let
  data Bool | Bool_match where
    True : Bool
    False : Bool
in
letrec
  !go : list data -> list data
    = \(xs : list data) ->
        (let
            r = list data
          in
          \(z : r) (f : data -> list data -> r) (xs : list data) ->
            chooseList
              {data}
              {all dead. r}
              xs
              (/\dead -> z)
              (/\dead -> f (headList {data} xs) (tailList {data} xs))
              {r})
          []
          (\(h : data) (t : list data) ->
             Bool_match
               (ifThenElse {Bool} (lessThanInteger (unIData h) 8) False True)
               {all dead. list data}
               (/\dead -> mkCons {data} h (go t))
               (/\dead -> go t)
               {all dead. dead})
          xs
in
\(eta : (\a -> list data) integer) -> go eta