let
  data (Tuple3 :: * -> * -> * -> *) a b c | Tuple3_match where
    Tuple3 : a -> b -> c -> Tuple3 a b c
  data Bool | Bool_match where
    True : Bool
    False : Bool
  data (Either :: * -> * -> *) a b | Either_match where
    Left : a -> Either a b
    Right : b -> Either a b
  data (Maybe :: * -> *) a | Maybe_match where
    Just : a -> Maybe a
    Nothing : Maybe a
  !reconstructCaseError : string = "PT1"
  data Unit | Unit_match where
    Unit : Unit
  !traceError : all a. string -> a
    = /\a ->
        \(str : string) -> let !x : Unit = trace {Unit} str Unit in error {a}
  !unitval : unit = ()
  !d : data
    = (let
          b = Maybe (Tuple3 Bool integer Bool)
        in
        \(dToData : (\a -> a -> data) integer)
         (dToData : (\a -> a -> data) b)
         (ds : Either integer b) ->
          Either_match
            {integer}
            {b}
            ds
            {data}
            (\(arg : integer) ->
               constrData 0 (mkCons {data} (dToData arg) (mkNilData unitval)))
            (\(arg : b) ->
               constrData 1 (mkCons {data} (dToData arg) (mkNilData unitval))))
        (\(i : integer) -> iData i)
        ((let
             a = Tuple3 Bool integer Bool
           in
           \(dToData : (\a -> a -> data) a)
            (ds : Maybe a) ->
             Maybe_match
               {a}
               ds
               {all dead. data}
               (\(arg : a) ->
                  /\dead ->
                    constrData
                      0
                      (mkCons {data} (dToData arg) (mkNilData unitval)))
               (/\dead -> constrData 1 (mkNilData unitval))
               {all dead. dead})
           (\(ds : Tuple3 Bool integer Bool) ->
              Tuple3_match
                {Bool}
                {integer}
                {Bool}
                ds
                {data}
                (\(arg : Bool)
                  (arg : integer)
                  (arg : Bool) ->
                   constrData
                     0
                     (mkCons
                        {data}
                        (Bool_match
                           arg
                           {all dead. data}
                           (/\dead -> constrData 1 (mkNilData unitval))
                           (/\dead -> constrData 0 (mkNilData unitval))
                           {all dead. dead})
                        (mkCons
                           {data}
                           (iData arg)
                           (mkCons
                              {data}
                              (Bool_match
                                 arg
                                 {all dead. data}
                                 (/\dead -> constrData 1 (mkNilData unitval))
                                 (/\dead -> constrData 0 (mkNilData unitval))
                                 {all dead. dead})
                              (mkNilData unitval)))))))
        (Right
           {integer}
           {Maybe (Tuple3 Bool integer Bool)}
           (Just
              {Tuple3 Bool integer Bool}
              (Tuple3 {Bool} {integer} {Bool} True 1 False)))
in
(let
    b = Maybe (Tuple3 Bool integer Bool)
  in
  \(dUnsafeFromData : (\a -> data -> a) integer)
   (dUnsafeFromData : (\a -> data -> a) b)
   (d : data) ->
    let
      !tup : pair integer (list data) = unConstrData d
      !index : integer = fstPair {integer} {list data} tup
    in
    ifThenElse
      {unit -> Either integer b}
      (equalsInteger index 1)
      (\(ds : unit) ->
         let
           !t : list data = sndPair {integer} {list data} tup
           !arg : data = headList {data} t
         in
         Right {integer} {b} (dUnsafeFromData arg))
      (\(ds : unit) ->
         ifThenElse
           {unit -> Either integer b}
           (equalsInteger index 0)
           (\(ds : unit) ->
              let
                !t : list data = sndPair {integer} {list data} tup
                !arg : data = headList {data} t
              in
              Left {integer} {b} (dUnsafeFromData arg))
           (\(ds : unit) -> traceError {Either integer b} reconstructCaseError)
           unitval)
      unitval)
  unIData
  ((let
       a = Tuple3 Bool integer Bool
     in
     \(dUnsafeFromData : (\a -> data -> a) a)
      (d : data) ->
       let
         !tup : pair integer (list data) = unConstrData d
         !index : integer = fstPair {integer} {list data} tup
         !t : list data = sndPair {integer} {list data} tup
         !arg : data = headList {data} t
       in
       ifThenElse
         {unit -> Maybe a}
         (equalsInteger index 0)
         (\(ds : unit) -> Just {a} (dUnsafeFromData arg))
         (\(ds : unit) ->
            ifThenElse
              {unit -> Maybe a}
              (equalsInteger index 1)
              (\(ds : unit) -> Nothing {a})
              (\(ds : unit) -> traceError {Maybe a} reconstructCaseError)
              unitval)
         unitval)
     (\(d : data) ->
        let
          !tup : pair integer (list data) = unConstrData d
          !index : integer = fstPair {integer} {list data} tup
          !t : list data = sndPair {integer} {list data} tup
          !arg : data = headList {data} t
          !t : list data = tailList {data} t
          !arg : data = headList {data} t
          !t : list data = tailList {data} t
          !arg : data = headList {data} t
        in
        ifThenElse
          {unit -> Tuple3 Bool integer Bool}
          (equalsInteger index 0)
          (\(ds : unit) ->
             Tuple3
               {Bool}
               {integer}
               {Bool}
               (let
                 !tup : pair integer (list data) = unConstrData arg
                 !index : integer = fstPair {integer} {list data} tup
                 !fallthrough : Bool
                   = ifThenElse
                       {unit -> Bool}
                       (equalsInteger index 0)
                       (\(ds : unit) -> False)
                       (\(ds : unit) -> traceError {Bool} reconstructCaseError)
                       unitval
               in
               ifThenElse
                 {unit -> Bool}
                 (equalsInteger index 1)
                 (\(ds : unit) -> True)
                 (\(ds : unit) -> fallthrough)
                 unitval)
               (unIData arg)
               (let
                 !tup : pair integer (list data) = unConstrData arg
                 !index : integer = fstPair {integer} {list data} tup
                 !fallthrough : Bool
                   = ifThenElse
                       {unit -> Bool}
                       (equalsInteger index 0)
                       (\(ds : unit) -> False)
                       (\(ds : unit) -> traceError {Bool} reconstructCaseError)
                       unitval
               in
               ifThenElse
                 {unit -> Bool}
                 (equalsInteger index 1)
                 (\(ds : unit) -> True)
                 (\(ds : unit) -> fallthrough)
                 unitval))
          (\(ds : unit) ->
             traceError {Tuple3 Bool integer Bool} reconstructCaseError)
          unitval))
  d