let
  data Bool | Bool_match where
    True : Bool
    False : Bool
in
letrec
  data (List :: * -> *) a | Nil_match where
    Nil : List a
    Cons : a -> List a -> List a
in
letrec
  !go : integer -> List integer
    = \(n : integer) ->
        Cons
          {integer}
          0
          (Bool_match
             (ifThenElse {Bool} (equalsInteger 1 n) True False)
             {all dead. List integer}
             (/\dead -> Nil {integer})
             (/\dead -> go (subtractInteger n 1))
             {all dead. dead})
in
let
  !n : integer = 1000
in
letrec
  !recursiveAll : all a. (a -> Bool) -> List a -> Bool
    = /\a ->
        \(ds : a -> Bool) (ds : List a) ->
          Nil_match
            {a}
            ds
            {all dead. Bool}
            (/\dead -> True)
            (\(x : a) (xs : List a) ->
               /\dead ->
                 Bool_match
                   (ds x)
                   {all dead. Bool}
                   (/\dead -> recursiveAll {a} ds xs)
                   (/\dead -> False)
                   {all dead. dead})
            {all dead. dead}
in
let
  !ls : List integer
    = Bool_match
        (ifThenElse {Bool} (lessThanEqualsInteger n 0) True False)
        {all dead. List integer}
        (/\dead -> Nil {integer})
        (/\dead -> go n)
        {all dead. dead}
in
recursiveAll
  {integer}
  (\(v : integer) -> ifThenElse {Bool} (lessThanEqualsInteger v 0) True False)
  ls