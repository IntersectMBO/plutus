letrec
  data (List :: * -> *) a | Nil_match where
    Nil : List a
    Cons : a -> List a -> List a
in
letrec
  !go : List integer -> integer
    = \(ds : List integer) ->
        Nil_match
          {integer}
          ds
          {all dead. integer}
          (/\dead -> 42)
          (\(x : integer) (xs : List integer) -> /\dead -> go xs)
          {all dead. dead}
in
let
  data Bool | Bool_match where
    True : Bool
    False : Bool
in
letrec
  !go : integer -> List integer
    = \(n : integer) ->
        Bool_match
          (ifThenElse {Bool} (equalsInteger 0 n) True False)
          {all dead. List integer}
          (/\dead -> Nil {integer})
          (/\dead -> Cons {integer} 1 (go (subtractInteger n 1)))
          {all dead. dead}
in
let
  !n : integer = 1000
  !ls : List integer
    = Bool_match
        (ifThenElse {Bool} (lessThanInteger n 0) True False)
        {all dead. List integer}
        (/\dead -> Nil {integer})
        (/\dead -> go n)
        {all dead. dead}
in
go ls