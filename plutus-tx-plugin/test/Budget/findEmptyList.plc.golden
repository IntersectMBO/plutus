let
  data Ordering | Ordering_match where
    EQ : Ordering
    GT : Ordering
    LT : Ordering
  data Bool | Bool_match where
    True : Bool
    False : Bool
  data (Ord :: * -> *) a | Ord_match where
    CConsOrd
      : (\a -> a -> a -> Bool) a -> (a -> a -> Ordering) -> (a -> a -> Bool) -> (a -> a -> Bool) -> (a -> a -> Bool) -> (a -> a -> Bool) -> (a -> a -> a) -> (a -> a -> a) -> Ord a
in
letrec
  data (List :: * -> *) a | Nil_match where
    Nil : List a
    Cons : a -> List a -> List a
in
let
  data (Maybe :: * -> *) a | Maybe_match where
    Just : a -> Maybe a
    Nothing : Maybe a
in
(let
    b = Maybe integer
  in
  \(f : integer -> b -> b)
   (z : b) ->
    letrec
      !go : List integer -> b
        = \(ds : List integer) ->
            Nil_match
              {integer}
              ds
              {all dead. b}
              (/\dead -> z)
              (\(x : integer) (xs : List integer) -> /\dead -> f x (go xs))
              {all dead. dead}
    in
    \(eta : List integer) -> go eta)
  (\(a : integer)
    (acc : Maybe integer) ->
     Bool_match
       ((let
            !v : Ord integer
              = CConsOrd
                  {integer}
                  (\(x : integer)
                    (y : integer) ->
                     ifThenElse {Bool} (equalsInteger x y) True False)
                  (\(eta : integer)
                    (eta : integer) ->
                     Bool_match
                       (ifThenElse {Bool} (equalsInteger eta eta) True False)
                       {all dead. Ordering}
                       (/\dead -> EQ)
                       (/\dead ->
                          Bool_match
                            (ifThenElse
                               {Bool}
                               (lessThanEqualsInteger eta eta)
                               True
                               False)
                            {all dead. Ordering}
                            (/\dead -> LT)
                            (/\dead -> GT)
                            {all dead. dead})
                       {all dead. dead})
                  (\(x : integer)
                    (y : integer) ->
                     ifThenElse {Bool} (lessThanInteger x y) True False)
                  (\(x : integer)
                    (y : integer) ->
                     ifThenElse {Bool} (lessThanEqualsInteger x y) True False)
                  (\(x : integer)
                    (y : integer) ->
                     ifThenElse {Bool} (lessThanEqualsInteger x y) False True)
                  (\(x : integer)
                    (y : integer) ->
                     ifThenElse {Bool} (lessThanInteger x y) False True)
                  (\(x : integer)
                    (y : integer) ->
                     Bool_match
                       (ifThenElse
                          {Bool}
                          (lessThanEqualsInteger x y)
                          True
                          False)
                       {all dead. integer}
                       (/\dead -> y)
                       (/\dead -> x)
                       {all dead. dead})
                  (\(x : integer)
                    (y : integer) ->
                     Bool_match
                       (ifThenElse
                          {Bool}
                          (lessThanEqualsInteger x y)
                          True
                          False)
                       {all dead. integer}
                       (/\dead -> x)
                       (/\dead -> y)
                       {all dead. dead})
          in
          Ord_match
            {integer}
            v
            {integer -> integer -> Bool}
            (\(v : (\a -> a -> a -> Bool) integer)
              (v : integer -> integer -> Ordering)
              (v : integer -> integer -> Bool)
              (v : integer -> integer -> Bool)
              (v : integer -> integer -> Bool)
              (v : integer -> integer -> Bool)
              (v : integer -> integer -> integer)
              (v : integer -> integer -> integer) ->
               v))
          1
          a)
       {all dead. Maybe integer}
       (/\dead -> Just {integer} a)
       (/\dead -> acc)
       {all dead. dead})
  (Nothing {integer})
  (Nil {integer})