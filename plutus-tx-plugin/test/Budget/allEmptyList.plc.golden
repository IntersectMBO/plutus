letrec data (List :: * -> *) a | Nil_match where
         Nil : List a
         Cons : a -> List a -> List a
in
let data (Monoid :: * -> *) a | Monoid_match where
      CConsMonoid : (\a -> a -> a -> a) a -> a -> Monoid a
in
letrec !fFoldableNil_cfoldMap
         : all m. all a. Monoid m -> (a -> m) -> List a -> m
         = /\m a ->
             \(dMonoid : Monoid m) (eta : a -> m) (eta : List a) ->
               Nil_match
                 {a} eta {all dead. m} (/\dead ->
                                          Monoid_match
                                            {m} dMonoid {m}
                                            (\(v : (\a -> a -> a -> a) m) (v
                                              : m) ->
                                               v))
                 (\(x : a) (xs : List a) ->
                    /\dead ->
                      Monoid_match
                        {m} dMonoid {(\a -> a -> a -> a) m}
                        (\(v : (\a -> a -> a -> a) m) (v : m) -> v) (eta x)
                        (fFoldableNil_cfoldMap {m} {a} dMonoid eta xs))
                 {all dead. dead}
in
let data Bool | Bool_match where
      True : Bool
      False : Bool
    data (MultiplicativeMonoid :: * -> *) a | MultiplicativeMonoid_match where
      CConsMultiplicativeMonoid
      : (\a -> a -> a -> a) a -> a -> MultiplicativeMonoid a
in fFoldableNil_cfoldMap
     {(\a -> a) Bool} {integer} (let !v : MultiplicativeMonoid Bool
                                       = CConsMultiplicativeMonoid
                                           {Bool} (\(l : Bool) (r : Bool) ->
                                                     Bool_match
                                                       l {all dead. Bool}
                                                       (/\dead -> r) (/\dead ->
                                                                        False)
                                                       {all dead. dead}) True
                                 in CConsMonoid
                                      {(\a -> a) Bool}
                                      (\(eta : (\a -> a) Bool) (eta
                                        : (\a -> a) Bool) ->
                                         MultiplicativeMonoid_match
                                           {Bool} v {(\a -> a -> a -> a) Bool}
                                           (\(v : (\a -> a -> a -> a) Bool) (v
                                             : Bool) ->
                                              v) eta eta)
                                      (MultiplicativeMonoid_match
                                         {Bool} v {Bool}
                                         (\(v : (\a -> a -> a -> a) Bool) (v
                                           : Bool) ->
                                            v))) (\(v : integer) ->
                                                    ifThenElse
                                                      {Bool}
                                                      (lessThanEqualsInteger
                                                         1 v) False True)
     (Nil {integer})