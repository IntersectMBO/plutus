letrec data (List :: * -> *) a | Nil_match where
         Nil : List a
         Cons : a -> List a -> List a
in
let data (Monoid :: * -> *) a | Monoid_match where
      CConsMonoid : (\a -> a -> a -> a) a -> a -> Monoid a
in
letrec !fFoldableNil_cfoldMap
         : all m. all a. Monoid m -> (a -> m) -> List a -> m
         = /\m a ->
             \(dMonoid : Monoid m) (eta : a -> m) (eta : List a) ->
               Nil_match
                 {a} eta {all dead. m} (/\dead ->
                                          Monoid_match
                                            {m} dMonoid {m}
                                            (\(v : (\a -> a -> a -> a) m) (v
                                              : m) ->
                                               v))
                 (\(x : a) (xs : List a) ->
                    /\dead ->
                      Monoid_match
                        {m} dMonoid {(\a -> a -> a -> a) m}
                        (\(v : (\a -> a -> a -> a) m) (v : m) -> v) (eta x)
                        (fFoldableNil_cfoldMap {m} {a} dMonoid eta xs))
                 {all dead. dead}
in
let data (AdditiveMonoid :: * -> *) a | AdditiveMonoid_match where
      CConsAdditiveMonoid : (\a -> a -> a -> a) a -> a -> AdditiveMonoid a
in (let !dAdditiveMonoid : AdditiveMonoid integer
          = CConsAdditiveMonoid
              {integer} (\(x : integer) (y : integer) -> addInteger x y) 0
    in fFoldableNil_cfoldMap
         {(\a -> a) integer} {integer} (CConsMonoid
                                          {(\a -> a) integer}
                                          (\(eta : (\a -> a) integer) (eta
                                            : (\a -> a) integer) ->
                                             AdditiveMonoid_match
                                               {integer} dAdditiveMonoid
                                               {(\a -> a -> a -> a) integer}
                                               (\(v
                                                 : (\a -> a -> a -> a) integer)
                                                 (v : integer) ->
                                                  v) eta eta)
                                          (AdditiveMonoid_match
                                             {integer} dAdditiveMonoid {integer}
                                             (\(v : (\a -> a -> a -> a) integer)
                                               (v : integer) ->
                                                v))) (\(ds : integer) -> ds))
     ((let a = List integer in \(c : integer -> a -> a) (n : a) ->
                                 c
                                   1 (c
                                        2 (c
                                             3 (c
                                                  4
                                                  (c
                                                     5
                                                     (c
                                                        6
                                                        (c
                                                           7
                                                           (c
                                                              8
                                                              (c
                                                                 9
                                                                 (c
                                                                    10
                                                                    n))))))))))
        (\(ds : integer) (ds : List integer) -> Cons {integer} ds ds)
        (Nil {integer}))