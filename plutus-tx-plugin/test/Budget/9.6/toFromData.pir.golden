let
  data (Tuple3 :: * -> * -> * -> *) a b c | Tuple3_match where
    Tuple3 : a -> b -> c -> Tuple3 a b c
  data (Either :: * -> * -> *) a b | Either_match where
    Left : a -> Either a b
    Right : b -> Either a b
  data (Maybe :: * -> *) a | Maybe_match where
    Just : a -> Maybe a
    Nothing : Maybe a
  data Unit | Unit_match where
    Unit : Unit
  !traceError : all a. string -> a
    = /\a ->
        \(str : string) -> let !x : Unit = trace {Unit} str Unit in error {a}
  !d : data
    = (let
          b = Maybe (Tuple3 bool integer bool)
        in
        \(`$dToData` : (\a -> a -> data) integer)
         (`$dToData` : (\a -> a -> data) b)
         (ds : Either integer b) ->
          Either_match
            {integer}
            {b}
            ds
            {data}
            (\(arg : integer) ->
               constrData 0 (mkCons {data} (`$dToData` arg) []))
            (\(arg : b) -> constrData 1 (mkCons {data} (`$dToData` arg) [])))
        (\(i : integer) -> iData i)
        ((let
             a = Tuple3 bool integer bool
           in
           \(`$dToData` : (\a -> a -> data) a) (ds : Maybe a) ->
             Maybe_match
               {a}
               ds
               {all dead. data}
               (\(arg : a) ->
                  /\dead -> constrData 0 (mkCons {data} (`$dToData` arg) []))
               (/\dead -> Constr 1 [])
               {all dead. dead})
           (\(ds : Tuple3 bool integer bool) ->
              Tuple3_match
                {bool}
                {integer}
                {bool}
                ds
                {data}
                (\(arg : bool) (arg : integer) (arg : bool) ->
                   constrData
                     0
                     (mkCons
                        {data}
                        (case
                           (all dead. data)
                           arg
                           [(/\dead -> Constr 0 []), (/\dead -> Constr 1 [])]
                           {all dead. dead})
                        (mkCons
                           {data}
                           (iData arg)
                           (mkCons
                              {data}
                              (case
                                 (all dead. data)
                                 arg
                                 [ (/\dead -> Constr 0 [])
                                 , (/\dead -> Constr 1 []) ]
                                 {all dead. dead})
                              []))))))
        (Right
           {integer}
           {Maybe (Tuple3 bool integer bool)}
           (Just
              {Tuple3 bool integer bool}
              (Tuple3 {bool} {integer} {bool} True 1 False)))
in
(let
    b = Maybe (Tuple3 bool integer bool)
  in
  \(`$dUnsafeFromData` : (\a -> data -> a) integer)
   (`$dUnsafeFromData` : (\a -> data -> a) b)
   (d : data) ->
    let
      !tup : pair integer (list data) = unConstrData d
      !index : integer = fstPair {integer} {list data} tup
      !args : list data = sndPair {integer} {list data} tup
    in
    case
      (all dead. Either integer b)
      (equalsInteger 0 index)
      [ (/\dead ->
           case
             (all dead. Either integer b)
             (equalsInteger 1 index)
             [ (/\dead -> traceError {Either integer b} "PT1")
             , (/\dead ->
                  Right
                    {integer}
                    {b}
                    (`$dUnsafeFromData` (headList {data} args))) ]
             {all dead. dead})
      , (/\dead ->
           Left {integer} {b} (`$dUnsafeFromData` (headList {data} args))) ]
      {all dead. dead})
  unIData
  ((let
       a = Tuple3 bool integer bool
     in
     \(`$dUnsafeFromData` : (\a -> data -> a) a) (d : data) ->
       let
         !tup : pair integer (list data) = unConstrData d
         !index : integer = fstPair {integer} {list data} tup
         !args : list data = sndPair {integer} {list data} tup
       in
       case
         (all dead. Maybe a)
         (equalsInteger 1 index)
         [ (/\dead ->
              case
                (all dead. Maybe a)
                (equalsInteger 0 index)
                [ (/\dead -> traceError {Maybe a} "PT1")
                , (/\dead ->
                     Just {a} (`$dUnsafeFromData` (headList {data} args))) ]
                {all dead. dead})
         , (/\dead -> Nothing {a}) ]
         {all dead. dead})
     (\(d : data) ->
        let
          !tup : pair integer (list data) = unConstrData d
          !index : integer = fstPair {integer} {list data} tup
          !args : list data = sndPair {integer} {list data} tup
        in
        case
          (all dead. Tuple3 bool integer bool)
          (equalsInteger 0 index)
          [ (/\dead -> traceError {Tuple3 bool integer bool} "PT1")
          , (/\dead ->
               let
                 !l : list data = tailList {data} args
               in
               Tuple3
                 {bool}
                 {integer}
                 {bool}
                 (let
                   !tup : pair integer (list data)
                     = unConstrData (headList {data} args)
                   !index : integer = fstPair {integer} {list data} tup
                   !args : list data = sndPair {integer} {list data} tup
                 in
                 case
                   (all dead. bool)
                   (equalsInteger 0 index)
                   [ (/\dead ->
                        case
                          (all dead. bool)
                          (equalsInteger 1 index)
                          [ (/\dead -> traceError {bool} "PT1")
                          , (/\dead -> True) ]
                          {all dead. dead})
                   , (/\dead -> False) ]
                   {all dead. dead})
                 (unIData (headList {data} l))
                 (let
                   !tup : pair integer (list data)
                     = unConstrData (headList {data} (tailList {data} l))
                   !index : integer = fstPair {integer} {list data} tup
                   !args : list data = sndPair {integer} {list data} tup
                 in
                 case
                   (all dead. bool)
                   (equalsInteger 0 index)
                   [ (/\dead ->
                        case
                          (all dead. bool)
                          (equalsInteger 1 index)
                          [ (/\dead -> traceError {bool} "PT1")
                          , (/\dead -> True) ]
                          {all dead. dead})
                   , (/\dead -> False) ]
                   {all dead. dead})) ]
          {all dead. dead}))
  d