(let
    data Unit | Unit_match where
      Unit : Unit
    data Bool | Bool_match where
      True : Bool
      False : Bool
    data (Tuple2 :: * -> * -> *) a b | Tuple2_match where
      Tuple2 : a -> b -> Tuple2 a b
  in
  \(ds : (\a -> data) integer) ->
    Tuple2_match
      {integer}
      {list data}
      ((let
           b = list data
         in
         \(tup : pair integer b) ->
           Tuple2
             {integer}
             {b}
             (case integer tup [(\(l : integer) (r : b) -> l)])
             (case b tup [(\(l : integer) (r : b) -> r)]))
         (unConstrData ds))
      {integer}
      (\(ds : integer) (ds : list data) ->
         Bool_match
           (case Bool (equalsInteger 0 ds) [False, True])
           {all dead. integer}
           (/\dead -> unIData (headList {data} ds))
           (/\dead ->
              Tuple2_match
                {integer}
                {list data}
                ((let
                     b = list data
                   in
                   \(tup : pair integer b) ->
                     Tuple2
                       {integer}
                       {b}
                       (case integer tup [(\(l : integer) (r : b) -> l)])
                       (case b tup [(\(l : integer) (r : b) -> r)]))
                   (unConstrData ds))
                {integer}
                (\(ds : integer) (ds : list data) ->
                   Bool_match
                     (case Bool (equalsInteger 1 ds) [False, True])
                     {all dead. integer}
                     (/\dead -> 1)
                     (/\dead ->
                        let
                          !defaultBody : integer = error {integer}
                        in
                        Unit_match (error {Unit}) {integer} defaultBody)
                     {all dead. dead}))
           {all dead. dead}))
  (Constr 0 [I 1])