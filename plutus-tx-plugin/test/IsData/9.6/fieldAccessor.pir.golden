let
  !mkI : integer -> data = iData
  ~`$fToDataInteger_$ctoBuiltinData` : integer -> data
    = \(i : integer) -> let !i : integer = i in mkI i
  ~`$fToDataInteger` : (\a -> a -> data) integer
    = `$fToDataInteger_$ctoBuiltinData`
  !equalsInteger : integer -> integer -> bool = equalsInteger
  !ifThenElse : all a. bool -> a -> a -> a = ifThenElse
  data Bool | Bool_match where
    True : Bool
    False : Bool
  ~equalsInteger : integer -> integer -> Bool
    = \(x : integer) ->
        let
          !x : integer = x
        in
        \(y : integer) ->
          let
            !y : integer = y
            !b : bool = equalsInteger x y
          in
          ifThenElse {Bool} b True False
  ~`$fEqInteger` : (\a -> a -> a -> Bool) integer = equalsInteger
  !unsafeDataAsI : data -> integer = unIData
  ~`$fUnsafeFromDataInteger` : (\a -> data -> a) integer = unsafeDataAsI
  data (Tuple2 :: * -> * -> *) a b | Tuple2_match where
    Tuple2 : a -> b -> Tuple2 a b
  ~`==` : all a. (\a -> a -> a -> Bool) a -> a -> a -> Bool
    = /\a -> \(v : (\a -> a -> a -> Bool) a) -> v
  data (Maybe :: * -> *) a | Maybe_match where
    Just : a -> Maybe a
    Nothing : Maybe a
  !fst : all a b. pair a b -> a = fstPair
  !head : all a. list a -> a = headList
  !snd : all a b. pair a b -> b = sndPair
  !tail : all a. list a -> list a = tailList
  !unsafeDataAsConstr : data -> pair integer (list data) = unConstrData
  ~unsafeFromBuiltinData : all a. (\a -> data -> a) a -> data -> a
    = /\a -> \(v : (\a -> data -> a) a) -> v
  ~matchOnRecordConstructor :
     all a. (\a -> data -> a) a -> (\a -> data) a -> Maybe (Tuple2 a integer)
    = /\a ->
        \(`$dUnsafeFromData` : (\a -> data -> a) a) (ds : (\a -> data) a) ->
          let
            !builtinData : data = ds
            !asConstr : pair integer (list data)
              = unsafeDataAsConstr builtinData
            !constrIx : integer = fst {integer} {list data} asConstr
            !constrArgs : list data = snd {integer} {list data} asConstr
            !field : a
              = unsafeFromBuiltinData
                  {a}
                  `$dUnsafeFromData`
                  (head {data} constrArgs)
            !rest : list data = tail {data} constrArgs
            !field : integer
              = unsafeFromBuiltinData
                  {integer}
                  `$fUnsafeFromDataInteger`
                  (head {data} rest)
          in
          Bool_match
            (`==` {integer} `$fEqInteger` constrIx 0)
            {all dead. Maybe (Tuple2 a integer)}
            (/\dead ->
               Just {Tuple2 a integer} (Tuple2 {a} {integer} field field))
            (/\dead -> Nothing {Tuple2 a integer})
            {all dead. dead}
  ~`$mRecordConstructor` :
     all r a.
       (\a -> a -> data) a ->
       (\a -> data -> a) a ->
       (\a -> data) a ->
       (a -> integer -> r) ->
       (unit -> r) ->
       r
    = /\r a ->
        \(`$dToData` : (\a -> a -> data) a)
         (`$dUnsafeFromData` : (\a -> data -> a) a)
         (scrut : (\a -> data) a) ->
          let
            !nt : data = scrut
          in
          \(cont : a -> integer -> r) ->
            let
              !cont : a -> integer -> r = cont
            in
            \(fail : unit -> r) ->
              let
                !fail : unit -> r = fail
              in
              Maybe_match
                {Tuple2 a integer}
                (matchOnRecordConstructor {a} `$dUnsafeFromData` nt)
                {all dead. r}
                (\(ds : Tuple2 a integer) ->
                   /\dead ->
                     Tuple2_match
                       {a}
                       {integer}
                       ds
                       {r}
                       (\(x : a) (y : integer) -> cont x y))
                (/\dead -> fail ())
                {all dead. dead}
  ~x : all a. (\a -> a -> data) a -> (\a -> data -> a) a -> (\a -> data) a -> a
    = /\a ->
        \(`$dToData` : (\a -> a -> data) a)
         (`$dUnsafeFromData` : (\a -> data -> a) a)
         (ds : (\a -> data) a) ->
          let
            !nt : data = ds
          in
          `$mRecordConstructor`
            {a}
            {a}
            `$dToData`
            `$dUnsafeFromData`
            nt
            (\(ds : a) (ds : integer) -> ds)
            (\(void : unit) -> (/\e -> error {e}) {a})
in
\(r : (\a -> data) integer) ->
  let
    !nt : data = r
  in
  x {integer} `$fToDataInteger` `$fUnsafeFromDataInteger` nt