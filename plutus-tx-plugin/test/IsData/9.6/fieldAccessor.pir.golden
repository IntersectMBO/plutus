let
  !unsafeDataAsI : data -> integer = unIData
  ~`$fUnsafeFromDataInteger` : (\a -> data -> a) integer = unsafeDataAsI
  data Bool | Bool_match where
    True : Bool
    False : Bool
  !equalsInteger : integer -> integer -> bool = equalsInteger
  !error : all a. unit -> a = /\a -> \(thunk : unit) -> error {a}
  !fst : all a b. pair a b -> a = fstPair
  !head : all a. list a -> a = headList
  !ifThenElse : all a. bool -> a -> a -> a = ifThenElse
  !snd : all a b. pair a b -> b = sndPair
  !unitval : unit = ()
  !unsafeDataAsConstr : data -> pair integer (list data) = unConstrData
  ~x : all a. (\a -> data -> a) a -> (\a -> data) a -> a
    = /\a ->
        \(`$dUnsafeFromData` : (\a -> data -> a) a) (ds : (\a -> data) a) ->
          let
            !inp : data = ds
            !tup : pair integer (list data) = unsafeDataAsConstr inp
            !idx : integer = fst {integer} {list data} tup
            !ds : list data = snd {integer} {list data} tup
            !d : data = head {data} ds
          in
          Bool_match
            (let
              !b : bool = equalsInteger idx 0
            in
            ifThenElse {Bool} b True False)
            {all dead. a}
            (/\dead -> `$dUnsafeFromData` d)
            (/\dead -> error {a} unitval)
            {all dead. dead}
in
\(r : (\a -> data) integer) ->
  let
    !nt : data = r
  in
  x {integer} `$fUnsafeFromDataInteger` nt