let
  ~defaultBody : data = (/\e -> error {e}) {data}
  ~`$` : all a b. (a -> b) -> a -> b = /\a b -> \(f : a -> b) (x : a) -> f x
  data Unit | Unit_match where
    Unit : Unit
  !mkConstr : integer -> list data -> data = constrData
  !mkNilData : unit -> list data = mkNilData
  !unitval : unit = ()
  ~`$fToDataUnit_$ctoBuiltinData` : Unit -> data
    = \(ds : Unit) -> mkConstr 0 (mkNilData unitval)
  ~`$fToDataUnit` : (\a -> a -> data) Unit = `$fToDataUnit_$ctoBuiltinData`
  !mkCons : all a. a -> list a -> list a = mkCons
  ~toBuiltinData : all a. (\a -> a -> data) a -> a -> data
    = /\a -> \(v : (\a -> a -> data) a) -> v
  ~`$bFirstC` : Unit -> data
    = \(arg0_ : Unit) ->
        let
          !arg0_ : Unit = arg0_
        in
        mkConstr
          0
          (mkCons
             {data}
             (toBuiltinData {Unit} `$fToDataUnit` arg0_)
             (mkNilData unitval))
  ~id : all a. a -> a = /\a -> \(x : a) -> x
  ~`$fToDataBuiltinData` : (\a -> a -> data) data = id {data}
  ~`$ctoBuiltinData` : data -> data = toBuiltinData {data} `$fToDataBuiltinData`
  ~`$fToDataSecretlyData` : (\a -> a -> data) data = `$ctoBuiltinData`
  ~`$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData` : data -> data
    = \(d : data) -> d
  ~`$fUnsafeFromDataBuiltinData` : (\a -> data -> a) data
    = `$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData`
  ~unsafeFromBuiltinData : all a. (\a -> data -> a) a -> data -> a
    = /\a -> \(v : (\a -> data -> a) a) -> v
  ~`$cunsafeFromBuiltinData` : data -> data
    = unsafeFromBuiltinData {data} `$fUnsafeFromDataBuiltinData`
  ~`$fUnsafeFromDataSecretlyData` : (\a -> data -> a) data
    = `$cunsafeFromBuiltinData`
  data (Solo :: * -> *) a | Solo_match where
    MkSolo : a -> Solo a
  !head : all a. list a -> a = headList
  !equalsInteger : integer -> integer -> bool = equalsInteger
  !ifThenElse : all a. bool -> a -> a -> a = ifThenElse
  data Bool | Bool_match where
    True : Bool
    False : Bool
  ~equalsInteger : integer -> integer -> Bool
    = \(x : integer) ->
        let
          !x : integer = x
        in
        \(y : integer) ->
          let
            !y : integer = y
            !b : bool = equalsInteger x y
          in
          ifThenElse {Bool} b True False
  ~`$fEqInteger` : (\a -> a -> a -> Bool) integer = equalsInteger
  ~`==` : all a. (\a -> a -> a -> Bool) a -> a -> a -> Bool
    = /\a -> \(v : (\a -> a -> a -> Bool) a) -> v
  data (Maybe :: * -> *) a | Maybe_match where
    Just : a -> Maybe a
    Nothing : Maybe a
  !fst : all a b. pair a b -> a = fstPair
  !snd : all a b. pair a b -> b = sndPair
  !unsafeDataAsConstr : data -> pair integer (list data) = unConstrData
  ~matchOnJustD : all a. (\a -> data -> a) a -> (\a -> data) a -> Maybe (Solo a)
    = /\a ->
        \(`$dUnsafeFromData` : (\a -> data -> a) a) (ds : (\a -> data) a) ->
          let
            !builtinData : data = ds
            !asConstr : pair integer (list data)
              = unsafeDataAsConstr builtinData
            !constrIx : integer = fst {integer} {list data} asConstr
            !constrArgs : list data = snd {integer} {list data} asConstr
            !field : a
              = unsafeFromBuiltinData
                  {a}
                  `$dUnsafeFromData`
                  (head {data} constrArgs)
          in
          Bool_match
            (`==` {integer} `$fEqInteger` constrIx 0)
            {all dead. Maybe (Solo a)}
            (/\dead -> Just {Solo a} (MkSolo {a} field))
            (/\dead -> Nothing {Solo a})
            {all dead. dead}
  ~`$mJustD` :
     all r a.
       (\a -> a -> data) a ->
       (\a -> data -> a) a ->
       (\a -> data) a ->
       (a -> r) ->
       (unit -> r) ->
       r
    = /\r a ->
        \(`$dToData` : (\a -> a -> data) a)
         (`$dUnsafeFromData` : (\a -> data -> a) a)
         (scrut : (\a -> data) a) ->
          let
            !nt : data = scrut
          in
          \(cont : a -> r) ->
            let
              !cont : a -> r = cont
            in
            \(fail : unit -> r) ->
              let
                !fail : unit -> r = fail
              in
              Maybe_match
                {Solo a}
                (matchOnJustD {a} `$dUnsafeFromData` nt)
                {all dead. r}
                (\(ds : Solo a) ->
                   /\dead -> Solo_match {a} ds {r} (\(arg : a) -> cont arg))
                (/\dead -> fail ())
                {all dead. dead}
  ~matchOnNothingD : all a. (\a -> data) a -> Maybe Unit
    = /\a ->
        \(ds : (\a -> data) a) ->
          let
            !builtinData : data = ds
            !asConstr : pair integer (list data)
              = unsafeDataAsConstr builtinData
            !constrIx : integer = fst {integer} {list data} asConstr
          in
          Bool_match
            (`==` {integer} `$fEqInteger` constrIx 1)
            {all dead. Maybe Unit}
            (/\dead -> Just {Unit} Unit)
            (/\dead -> Nothing {Unit})
            {all dead. dead}
  ~`$mNothingD` : all r a. (\a -> data) a -> (unit -> r) -> (unit -> r) -> r
    = /\r a ->
        \(scrut : (\a -> data) a) ->
          let
            !nt : data = scrut
          in
          \(cont : unit -> r) ->
            let
              !cont : unit -> r = cont
            in
            \(fail : unit -> r) ->
              let
                !fail : unit -> r = fail
              in
              Maybe_match
                {Unit}
                (matchOnNothingD {a} nt)
                {all dead. r}
                (\(ds : Unit) -> /\dead -> cont ())
                (/\dead -> fail ())
                {all dead. dead}
  !trace : all a. string -> a -> a = trace
  ~trace : all a. string -> a -> a = trace
in
\(ds : (\a -> data) data) ->
  let
    !nt : data = ds
  in
  `$mJustD`
    {data}
    {data}
    `$fToDataSecretlyData`
    `$fUnsafeFromDataSecretlyData`
    nt
    (\(a : data) -> trace {data} "Just a" a)
    (\(void : unit) ->
       `$mNothingD`
         {data}
         {data}
         nt
         (\(void : unit) ->
            `$` {data} {data} (trace {data} "Nothing") (`$bFirstC` Unit))
         (\(void : unit) ->
            Unit_match ((/\e -> error {e}) {Unit}) {data} defaultBody))