let
  data Unit | Unit_match where
    Unit : Unit
  data (Tuple2 :: * -> * -> *) a b | Tuple2_match where
    Tuple2 : a -> b -> Tuple2 a b
  !equalsInteger : integer -> integer -> bool = equalsInteger
  !error : all a. unit -> a = /\a -> \(thunk : unit) -> error {a}
  !fst : all a b. pair a b -> a = fstPair
  !head : all a. list a -> a = headList
  !ifThenElse : all a. bool -> a -> a -> a = ifThenElse
  ~reconstructCaseError : string = "PT1"
  !snd : all a b. pair a b -> b = sndPair
  !tail : all a. list a -> list a = tailList
  !trace : all a. string -> a -> a = trace
  !unitval : unit = ()
  !unsafeDataAsConstr : data -> pair integer (list data) = unConstrData
  ~`$fUnsafeFromDataTuple2_$cunsafeFromBuiltinData` :
     all a b. (\a -> data -> a) a -> (\a -> data -> a) b -> data -> Tuple2 a b
    = /\a b ->
        let
          ~x : Tuple2 a b
            = let
              !str : string = reconstructCaseError
              !x : Unit = trace {Unit} str Unit
            in
            error {Tuple2 a b} unitval
        in
        \(`$dUnsafeFromData` : (\a -> data -> a) a)
         (`$dUnsafeFromData` : (\a -> data -> a) b)
         (d : data) ->
          let
            !d : data = d
            !tup : pair integer (list data) = unsafeDataAsConstr d
            ~x : Tuple2 a b
              = let
                !t : list data = snd {integer} {list data} tup
                !arg : data = head {data} t
                !t : list data = tail {data} t
                !arg : data = head {data} t
              in
              Tuple2 {a} {b} (`$dUnsafeFromData` arg) (`$dUnsafeFromData` arg)
            !index : integer = fst {integer} {list data} tup
          in
          ifThenElse
            {unit -> Tuple2 a b}
            (equalsInteger index 0)
            (\(ds : unit) -> x)
            (\(ds : unit) -> x)
            unitval
  ~`$fUnsafeFromDataTuple2` :
     all a b.
       (\a -> data -> a) a ->
       (\a -> data -> a) b ->
       (\a -> data -> a) (Tuple2 a b)
    = `$fUnsafeFromDataTuple2_$cunsafeFromBuiltinData`
  !unsafeDataAsI : data -> integer = unIData
  ~`$fUnsafeFromDataInteger` : (\a -> data -> a) integer = unsafeDataAsI
  ~`$dUnsafeFromData` : (\a -> data -> a) (Tuple2 integer integer)
    = `$fUnsafeFromDataTuple2`
        {integer}
        {integer}
        `$fUnsafeFromDataInteger`
        `$fUnsafeFromDataInteger`
  data (Maybe :: * -> *) a | Maybe_match where
    Just : a -> Maybe a
    Nothing : Maybe a
  ~`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData` :
     all a. (\a -> data -> a) a -> data -> Maybe a
    = /\a ->
        let
          ~x : Maybe a
            = let
              !str : string = reconstructCaseError
              !x : Unit = trace {Unit} str Unit
            in
            error {Maybe a} unitval
        in
        \(`$dUnsafeFromData` : (\a -> data -> a) a) (d : data) ->
          let
            !d : data = d
            !tup : pair integer (list data) = unsafeDataAsConstr d
            ~x : Maybe a
              = let
                !t : list data = snd {integer} {list data} tup
                !arg : data = head {data} t
              in
              Just {a} (`$dUnsafeFromData` arg)
            !index : integer = fst {integer} {list data} tup
            ~x : Maybe a
              = ifThenElse
                  {unit -> Maybe a}
                  (equalsInteger index 1)
                  (\(ds : unit) -> Nothing {a})
                  (\(ds : unit) -> x)
                  unitval
          in
          ifThenElse
            {unit -> Maybe a}
            (equalsInteger index 0)
            (\(ds : unit) -> x)
            (\(ds : unit) -> x)
            unitval
  ~`$fUnsafeFromDataMaybe` :
     all a. (\a -> data -> a) a -> (\a -> data -> a) (Maybe a)
    = `$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
  ~`$dUnsafeFromData` : (\a -> data -> a) (Maybe (Tuple2 integer integer))
    = `$fUnsafeFromDataMaybe` {Tuple2 integer integer} `$dUnsafeFromData`
  ~unsafeFromBuiltinData : all a. (\a -> data -> a) a -> data -> a
    = /\a -> \(v : (\a -> data -> a) a) -> v
in
\(ds : data) ->
  let
    !ds : data = ds
  in
  unsafeFromBuiltinData {Maybe (Tuple2 integer integer)} `$dUnsafeFromData` ds