(program
  1.1.0
  (let
    (nonrec)
    (datatypebind
      (datatype
        (tyvardecl Maybe (fun (type) (type)))
        (tyvardecl a (type))
        Maybe_match
        (vardecl Just (fun a [ Maybe a ])) (vardecl Nothing [ Maybe a ])
      )
    )
    (termbind
      (strict)
      (vardecl
        fApplicativeMaybe_c
        (all
          a
          (type)
          (all b (type) (fun [ Maybe (fun a b) ] (fun [ Maybe a ] [ Maybe b ])))
        )
      )
      (abs
        a
        (type)
        (abs
          b
          (type)
          (lam
            ds
            [ Maybe (fun a b) ]
            (lam
              ds
              [ Maybe a ]
              {
                [
                  [
                    {
                      [ { Maybe_match (fun a b) } ds ]
                      (all dead (type) [ Maybe b ])
                    }
                    (lam
                      ipv
                      (fun a b)
                      (abs
                        dead
                        (type)
                        {
                          [
                            [
                              {
                                [ { Maybe_match a } ds ]
                                (all dead (type) [ Maybe b ])
                              }
                              (lam
                                ipv
                                a
                                (abs dead (type) [ { Just b } [ ipv ipv ] ])
                              )
                            ]
                            (abs dead (type) { Nothing b })
                          ]
                          (all dead (type) dead)
                        }
                      )
                    )
                  ]
                  (abs dead (type) { Nothing b })
                ]
                (all dead (type) dead)
              }
            )
          )
        )
      )
    )
    (termbind
      (strict)
      (vardecl fApplicativeMaybe_cpure (all a (type) (fun a [ Maybe a ])))
      (abs a (type) (lam ds a [ { Just a } ds ]))
    )
    (termbind
      (strict)
      (vardecl
        fFunctorMaybe_cfmap
        (all
          a (type) (all b (type) (fun (fun a b) (fun [ Maybe a ] [ Maybe b ])))
        )
      )
      (abs
        a
        (type)
        (abs
          b
          (type)
          (lam
            f
            (fun a b)
            (lam
              ds
              [ Maybe a ]
              {
                [
                  [
                    { [ { Maybe_match a } ds ] (all dead (type) [ Maybe b ]) }
                    (lam a a (abs dead (type) [ { Just b } [ f a ] ]))
                  ]
                  (abs dead (type) { Nothing b })
                ]
                (all dead (type) dead)
              }
            )
          )
        )
      )
    )
    (datatypebind
      (datatype
        (tyvardecl Applicative (fun (fun (type) (type)) (type)))
        (tyvardecl f (fun (type) (type)))
        Applicative_match
        (vardecl
          CConsApplicative
          (fun
            [
              (lam
                f
                (fun (type) (type))
                (all
                  a (type) (all b (type) (fun (fun a b) (fun [ f a ] [ f b ])))
                )
              )
              f
            ]
            (fun
              (all a (type) (fun a [ f a ]))
              (fun
                (all
                  a
                  (type)
                  (all b (type) (fun [ f (fun a b) ] (fun [ f a ] [ f b ])))
                )
                [ Applicative f ]
              )
            )
          )
        )
      )
    )
    (termbind
      (nonstrict)
      (vardecl fApplicativeMaybe [ Applicative Maybe ])
      [
        [
          [ { CConsApplicative Maybe } fFunctorMaybe_cfmap ]
          fApplicativeMaybe_cpure
        ]
        fApplicativeMaybe_c
      ]
    )
    (termbind
      (strict)
      (vardecl
        fApplicativeMaybe_c
        (all
          a
          (type)
          (all b (type) (fun [ Maybe a ] (fun [ Maybe b ] [ Maybe a ])))
        )
      )
      (abs
        a
        (type)
        (abs
          b
          (type)
          (lam
            ds
            [ Maybe a ]
            (lam
              ds
              [ Maybe b ]
              {
                [
                  [
                    { [ { Maybe_match a } ds ] (all dead (type) [ Maybe a ]) }
                    (lam
                      x
                      a
                      (abs
                        dead
                        (type)
                        {
                          [
                            [
                              {
                                [ { Maybe_match b } ds ]
                                (all dead (type) [ Maybe a ])
                              }
                              (lam y b (abs dead (type) [ { Just a } x ]))
                            ]
                            (abs dead (type) { Nothing a })
                          ]
                          (all dead (type) dead)
                        }
                      )
                    )
                  ]
                  (abs dead (type) { Nothing a })
                ]
                (all dead (type) dead)
              }
            )
          )
        )
      )
    )
    (termbind
      (strict)
      (vardecl
        fApplicativeMaybe_cfmap
        (all
          a (type) (all b (type) (fun (fun a b) (fun [ Maybe a ] [ Maybe b ])))
        )
      )
      (abs
        a
        (type)
        (abs
          b
          (type)
          (lam
            ds
            (fun a b)
            (lam
              ds
              [ Maybe a ]
              {
                [
                  [
                    { [ { Maybe_match a } ds ] (all dead (type) [ Maybe b ]) }
                    (lam a a (abs dead (type) [ { Just b } [ ds a ] ]))
                  ]
                  (abs dead (type) { Nothing b })
                ]
                (all dead (type) dead)
              }
            )
          )
        )
      )
    )
    (termbind
      (strict)
      (vardecl
        fApplicativeMaybe_c
        (all
          a
          (type)
          (all b (type) (fun [ Maybe (fun a b) ] (fun [ Maybe a ] [ Maybe b ])))
        )
      )
      (abs
        a
        (type)
        (abs
          b
          (type)
          (lam
            ds
            [ Maybe (fun a b) ]
            (lam
              m
              [ Maybe a ]
              {
                [
                  [
                    {
                      [ { Maybe_match (fun a b) } ds ]
                      (all dead (type) [ Maybe b ])
                    }
                    (lam
                      f
                      (fun a b)
                      (abs
                        dead
                        (type)
                        [ [ { { fApplicativeMaybe_cfmap a } b } f ] m ]
                      )
                    )
                  ]
                  (abs dead (type) { Nothing b })
                ]
                (all dead (type) dead)
              }
            )
          )
        )
      )
    )
    (termbind
      (strict)
      (vardecl
        fApplicativeMaybe_cliftA
        (all
          a
          (type)
          (all
            b
            (type)
            (all
              c
              (type)
              (fun
                (fun a (fun b c))
                (fun [ Maybe a ] (fun [ Maybe b ] [ Maybe c ]))
              )
            )
          )
        )
      )
      (abs
        a
        (type)
        (abs
          b
          (type)
          (abs
            c
            (type)
            (lam
              f
              (fun a (fun b c))
              (lam
                ds
                [ Maybe a ]
                (lam
                  ds
                  [ Maybe b ]
                  {
                    [
                      [
                        {
                          [ { Maybe_match a } ds ] (all dead (type) [ Maybe c ])
                        }
                        (lam
                          x
                          a
                          (abs
                            dead
                            (type)
                            {
                              [
                                [
                                  {
                                    [ { Maybe_match b } ds ]
                                    (all dead (type) [ Maybe c ])
                                  }
                                  (lam
                                    y
                                    b
                                    (abs
                                      dead (type) [ { Just c } [ [ f x ] y ] ]
                                    )
                                  )
                                ]
                                (abs dead (type) { Nothing c })
                              ]
                              (all dead (type) dead)
                            }
                          )
                        )
                      ]
                      (abs dead (type) { Nothing c })
                    ]
                    (all dead (type) dead)
                  }
                )
              )
            )
          )
        )
      )
    )
    (termbind
      (strict)
      (vardecl
        fFunctorMaybe_c
        (all a (type) (all b (type) (fun a (fun [ Maybe b ] [ Maybe a ]))))
      )
      (abs
        a
        (type)
        (abs
          b
          (type)
          (lam
            eta
            a
            (lam
              eta
              [ Maybe b ]
              {
                [
                  [
                    { [ { Maybe_match b } eta ] (all dead (type) [ Maybe a ]) }
                    (lam a b (abs dead (type) [ { Just a } eta ]))
                  ]
                  (abs dead (type) { Nothing a })
                ]
                (all dead (type) dead)
              }
            )
          )
        )
      )
    )
    (datatypebind
      (datatype
        (tyvardecl Functor (fun (fun (type) (type)) (type)))
        (tyvardecl f (fun (type) (type)))
        Functor_match
        (vardecl
          CConsFunctor
          (fun
            (all a (type) (all b (type) (fun (fun a b) (fun [ f a ] [ f b ]))))
            (fun
              (all a (type) (all b (type) (fun a (fun [ f b ] [ f a ]))))
              [ Functor f ]
            )
          )
        )
      )
    )
    (termbind
      (nonstrict)
      (vardecl fFunctorMaybe [ Functor Maybe ])
      [ [ { CConsFunctor Maybe } fApplicativeMaybe_cfmap ] fFunctorMaybe_c ]
    )
    (termbind
      (strict)
      (vardecl
        fApplicativeMaybe_c
        (all
          a
          (type)
          (all b (type) (fun [ Maybe a ] (fun [ Maybe b ] [ Maybe b ])))
        )
      )
      (abs
        a
        (type)
        (abs
          b
          (type)
          (lam
            ds
            [ Maybe a ]
            (lam
              m
              [ Maybe b ]
              {
                [
                  [
                    { [ { Maybe_match a } ds ] (all dead (type) [ Maybe b ]) }
                    (lam m a (abs dead (type) m))
                  ]
                  (abs dead (type) { Nothing b })
                ]
                (all dead (type) dead)
              }
            )
          )
        )
      )
    )
    (termbind
      (strict)
      (vardecl fApplicativeMaybe_cpure (all a (type) (fun a [ Maybe a ])))
      (abs a (type) (lam ds a [ { Just a } ds ]))
    )
    (datatypebind
      (datatype
        (tyvardecl Applicative (fun (fun (type) (type)) (type)))
        (tyvardecl f (fun (type) (type)))
        Applicative_match
        (vardecl
          CConsApplicative
          (fun
            [ Functor f ]
            (fun
              (all a (type) (fun a [ f a ]))
              (fun
                (all
                  a
                  (type)
                  (all b (type) (fun [ f (fun a b) ] (fun [ f a ] [ f b ])))
                )
                (fun
                  (all
                    a
                    (type)
                    (all
                      b
                      (type)
                      (all
                        c
                        (type)
                        (fun
                          (fun a (fun b c)) (fun [ f a ] (fun [ f b ] [ f c ]))
                        )
                      )
                    )
                  )
                  (fun
                    (all
                      a
                      (type)
                      (all b (type) (fun [ f a ] (fun [ f b ] [ f b ])))
                    )
                    (fun
                      (all
                        a
                        (type)
                        (all b (type) (fun [ f a ] (fun [ f b ] [ f a ])))
                      )
                      [ Applicative f ]
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
    (termbind
      (nonstrict)
      (vardecl fApplicativeMaybe [ Applicative Maybe ])
      [
        [
          [
            [
              [
                [ { CConsApplicative Maybe } fFunctorMaybe ]
                fApplicativeMaybe_cpure
              ]
              fApplicativeMaybe_c
            ]
            fApplicativeMaybe_cliftA
          ]
          fApplicativeMaybe_c
        ]
        fApplicativeMaybe_c
      ]
    )
    (termbind
      (strict)
      (vardecl
        fMonadMaybe_c
        (all
          a
          (type)
          (all b (type) (fun [ Maybe a ] (fun (fun a [ Maybe b ]) [ Maybe b ])))
        )
      )
      (abs
        a
        (type)
        (abs
          b
          (type)
          (lam
            ds
            [ Maybe a ]
            (lam
              k
              (fun a [ Maybe b ])
              {
                [
                  [
                    { [ { Maybe_match a } ds ] (all dead (type) [ Maybe b ]) }
                    (lam x a (abs dead (type) [ k x ]))
                  ]
                  (abs dead (type) { Nothing b })
                ]
                (all dead (type) dead)
              }
            )
          )
        )
      )
    )
    (datatypebind
      (datatype
        (tyvardecl Monad (fun (fun (type) (type)) (type)))
        (tyvardecl m (fun (type) (type)))
        Monad_match
        (vardecl
          CConsMonad
          (fun
            [ Applicative m ]
            (fun
              (all
                a
                (type)
                (all b (type) (fun [ m a ] (fun (fun a [ m b ]) [ m b ])))
              )
              (fun
                (all
                  a (type) (all b (type) (fun [ m a ] (fun [ m b ] [ m b ])))
                )
                (fun (all a (type) (fun a [ m a ])) [ Monad m ])
              )
            )
          )
        )
      )
    )
    (termbind
      (nonstrict)
      (vardecl fMonadMaybe [ Monad Maybe ])
      [
        [
          [ [ { CConsMonad Maybe } fApplicativeMaybe ] fMonadMaybe_c ]
          fApplicativeMaybe_c
        ]
        fApplicativeMaybe_cpure
      ]
    )
    (datatypebind
      (datatype
        (tyvardecl Tuple2 (fun (type) (fun (type) (type))))
        (tyvardecl a (type)) (tyvardecl b (type))
        Tuple2_match
        (vardecl Tuple2 (fun a (fun b [ [ Tuple2 a ] b ])))
      )
    )
    (termbind
      (strict)
      (vardecl
        bad_name
        (all
          m
          (fun (type) (type))
          (fun
            [ Monad m ]
            (all
              a
              (type)
              (all b (type) (fun [ m a ] (fun (fun a [ m b ]) [ m b ])))
            )
          )
        )
      )
      (abs
        m
        (fun (type) (type))
        (lam
          v
          [ Monad m ]
          [
            {
              [ { Monad_match m } v ]
              (all
                a
                (type)
                (all b (type) (fun [ m a ] (fun (fun a [ m b ]) [ m b ])))
              )
            }
            (lam
              v
              [ Applicative m ]
              (lam
                v
                (all
                  a
                  (type)
                  (all b (type) (fun [ m a ] (fun (fun a [ m b ]) [ m b ])))
                )
                (lam
                  v
                  (all
                    a (type) (all b (type) (fun [ m a ] (fun [ m b ] [ m b ])))
                  )
                  (lam v (all a (type) (fun a [ m a ])) v)
                )
              )
            )
          ]
        )
      )
    )
    (termbind
      (strict)
      (vardecl addInteger (fun (con integer) (fun (con integer) (con integer))))
      (builtin addInteger)
    )
    (termbind
      (strict)
      (vardecl addInteger (fun (con integer) (fun (con integer) (con integer))))
      (lam x (con integer) (lam y (con integer) [ [ addInteger x ] y ]))
    )
    (termbind
      (strict)
      (vardecl
        pure
        (all
          f
          (fun (type) (type))
          (fun [ Applicative f ] (all a (type) (fun a [ f a ])))
        )
      )
      (abs
        f
        (fun (type) (type))
        (lam
          v
          [ Applicative f ]
          [
            { [ { Applicative_match f } v ] (all a (type) (fun a [ f a ])) }
            (lam
              v
              [
                (lam
                  f
                  (fun (type) (type))
                  (all
                    a
                    (type)
                    (all b (type) (fun (fun a b) (fun [ f a ] [ f b ])))
                  )
                )
                f
              ]
              (lam
                v
                (all a (type) (fun a [ f a ]))
                (lam
                  v
                  (all
                    a
                    (type)
                    (all b (type) (fun [ f (fun a b) ] (fun [ f a ] [ f b ])))
                  )
                  v
                )
              )
            )
          ]
        )
      )
    )
    (lam
      ds
      [ Maybe [ [ Tuple2 (con integer) ] (con integer) ] ]
      (lam
        ds
        [ Maybe (con integer) ]
        [
          [
            {
              {
                [ { bad_name Maybe } fMonadMaybe ]
                [ [ Tuple2 (con integer) ] (con integer) ]
              }
              (con integer)
            }
            ds
          ]
          (lam
            ds
            [ [ Tuple2 (con integer) ] (con integer) ]
            [
              {
                [ { { Tuple2_match (con integer) } (con integer) } ds ]
                [ Maybe (con integer) ]
              }
              (lam
                x
                (con integer)
                (lam
                  x
                  (con integer)
                  [
                    [
                      {
                        { [ { bad_name Maybe } fMonadMaybe ] (con integer) }
                        (con integer)
                      }
                      ds
                    ]
                    (lam
                      y
                      (con integer)
                      [
                        { [ { pure Maybe } fApplicativeMaybe ] (con integer) }
                        [ [ addInteger [ [ addInteger x ] x ] ] y ]
                      ]
                    )
                  ]
                )
              )
            ]
          )
        ]
      )
    )
  )
)