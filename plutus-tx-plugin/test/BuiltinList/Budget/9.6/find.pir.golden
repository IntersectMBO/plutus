let
  data (Tuple2 :: * -> * -> *) a b | Tuple2_match where
    Tuple2 : a -> b -> Tuple2 a b
  data (Maybe :: * -> *) a | Maybe_match where
    Just : a -> Maybe a
    Nothing : Maybe a
  data Bool | Bool_match where
    True : Bool
    False : Bool
  !find : all a. (a -> Bool) -> list a -> Maybe a
    = /\a ->
        \(p : a -> Bool) ->
          letrec
            !go : list a -> Maybe a
              = (let
                    r = Maybe a
                  in
                  \(z : r) (f : a -> list a -> r) (xs : list a) ->
                    chooseList
                      {a}
                      {all dead. r}
                      xs
                      (/\dead -> z)
                      (/\dead -> f (headList {a} xs) (tailList {a} xs))
                      {r})
                  (Nothing {a})
                  (\(x : a) (xs : list a) ->
                     Bool_match
                       (p x)
                       {all dead. Maybe a}
                       (/\dead -> Just {a} x)
                       (/\dead -> go xs)
                       {all dead. dead})
          in
          go
in
\(xs : list integer) ->
  Tuple2
    {Maybe integer}
    {Maybe integer}
    (find
       {integer}
       (\(v : integer) -> case Bool (lessThanInteger v 8) [True, False])
       xs)
    (find
       {integer}
       (\(v : integer) -> case Bool (lessThanInteger v 12) [True, False])
       xs)