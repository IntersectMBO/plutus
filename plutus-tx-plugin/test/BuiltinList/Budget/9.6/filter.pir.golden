let
  data Bool | Bool_match where
    True : Bool
    False : Bool
in
\(xs : list integer) ->
  (letrec
      !go : list integer -> list integer
        = (let
              r = list integer
            in
            \(z : r) (f : integer -> list integer -> r) (xs : list integer) ->
              chooseList
                {integer}
                {all dead. r}
                xs
                (/\dead -> z)
                (/\dead -> f (headList {integer} xs) (tailList {integer} xs))
                {r})
            []
            (\(x : integer) (xs : list integer) ->
               let
                 !xs : list integer = go xs
               in
               Bool_match
                 (ifThenElse
                    {Bool}
                    (equalsInteger 0 (modInteger x 2))
                    True
                    False)
                 {all dead. list integer}
                 (/\dead -> mkCons {integer} x xs)
                 (/\dead -> xs)
                 {all dead. dead})
    in
    go)
    xs