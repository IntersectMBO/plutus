let
  data (Maybe :: * -> *) a | Maybe_match where
    Just : a -> Maybe a
    Nothing : Maybe a
  data Bool | Bool_match where
    True : Bool
    False : Bool
in
\(xs : list integer) ->
  (letrec
      !go : list integer -> list integer
        = (let
              r = list integer
            in
            \(z : r) (f : integer -> list integer -> r) (xs : list integer) ->
              chooseList
                {integer}
                {all dead. r}
                xs
                (/\dead -> z)
                (/\dead -> f (headList {integer} xs) (tailList {integer} xs))
                {r})
            []
            (\(x : integer) (xs : list integer) ->
               Maybe_match
                 {integer}
                 (Bool_match
                    (Bool_match
                       (ifThenElse
                          {Bool}
                          (equalsInteger 0 (modInteger x 2))
                          True
                          False)
                       {all dead. Bool}
                       (/\dead -> False)
                       (/\dead -> True)
                       {all dead. dead})
                    {all dead. Maybe integer}
                    (/\dead -> Just {integer} x)
                    (/\dead -> Nothing {integer})
                    {all dead. dead})
                 {all dead. list integer}
                 (\(y : integer) -> /\dead -> mkCons {integer} y (go xs))
                 (/\dead -> go xs)
                 {all dead. dead})
    in
    go)
    xs