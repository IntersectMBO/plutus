let
  data Unit | Unit_match where
    Unit : Unit
  data (Tuple3 :: * -> * -> * -> *) a b c | Tuple3_match where
    Tuple3 : a -> b -> c -> Tuple3 a b c
  data Bool | Bool_match where
    True : Bool
    False : Bool
  data (Solo :: * -> *) a | Solo_match where
    MkSolo : a -> Solo a
in
\(ds : (\a -> data) integer) ->
  Tuple3_match
    {Bool}
    {integer}
    {integer}
    (let
      !asConstr : pair integer (list data) = unConstrData ds
      !constrIx : integer = fstPair {integer} {list data} asConstr
      !constrArgs : list data = sndPair {integer} {list data} asConstr
      !field : integer = unIData (headList {data} constrArgs)
      !field : integer = unIData (headList {data} (tailList {data} constrArgs))
    in
    Tuple3
      {Bool}
      {integer}
      {integer}
      (ifThenElse {Bool} (equalsInteger 0 constrIx) True False)
      field
      field)
    {integer}
    (\(ds : Bool) (arg : integer) (arg : integer) ->
       Bool_match
         ds
         {all dead. integer}
         (/\dead -> arg)
         (/\dead ->
            Bool_match
              (ifThenElse
                 {Bool}
                 (equalsInteger
                    1
                    (fstPair {integer} {list data} (unConstrData ds)))
                 True
                 False)
              {all dead. integer}
              (/\dead -> 1)
              (/\dead -> Unit_match (error {Unit}) {integer} (error {integer}))
              {all dead. dead})
         {all dead. dead})