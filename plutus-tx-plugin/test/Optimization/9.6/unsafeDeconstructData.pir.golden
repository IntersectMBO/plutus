let
  data (Tuple2 :: * -> * -> *) a b | Tuple2_match where
    Tuple2 : a -> b -> Tuple2 a b
  data (Maybe :: * -> *) a | Maybe_match where
    Just : a -> Maybe a
    Nothing : Maybe a
in
\(ds : data) ->
  (let
      a = Tuple2 integer integer
    in
    \(`$dUnsafeFromData` : (\a -> data -> a) a) (d : data) ->
      let
        !tup : pair integer (list data) = unConstrData d
        !index : integer
          = case integer tup [(\(l : integer) (r : list data) -> l)]
        !args : list data
          = case (list data) tup [(\(l : integer) (r : list data) -> r)]
      in
      case
        (list data -> Maybe a)
        index
        [ (\(ds : list data) ->
             Just {a} (`$dUnsafeFromData` (headList {data} ds)))
        , (\(ds : list data) -> Nothing {a}) ]
        args)
    (\(d : data) ->
       let
         !tup : pair integer (list data) = unConstrData d
         !index : integer
           = case integer tup [(\(l : integer) (r : list data) -> l)]
         !args : list data
           = case (list data) tup [(\(l : integer) (r : list data) -> r)]
       in
       case
         (list data -> Tuple2 integer integer)
         index
         [ (\(ds : list data) ->
              Tuple2
                {integer}
                {integer}
                (unIData (headList {data} ds))
                (unIData (headList {data} (tailList {data} ds)))) ]
         args)
    ds