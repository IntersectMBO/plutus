let
  data (Tuple2 :: * -> * -> *) a b | Tuple2_match where
    Tuple2 : a -> b -> Tuple2 a b
  data (Maybe :: * -> *) a | Maybe_match where
    Just : a -> Maybe a
    Nothing : Maybe a
  data Unit | Unit_match where
    Unit : Unit
  !traceError : all a. string -> a
    = /\a ->
        \(str : string) -> let !x : Unit = trace {Unit} str Unit in error {a}
in
\(ds : data) ->
  (let
      a = Tuple2 integer integer
    in
    \(`$dUnsafeFromData` : (\a -> data -> a) a) (d : data) ->
      let
        !tup : pair integer (list data) = unConstrData d
        !index : integer = fstPair {integer} {list data} tup
        !args : list data = sndPair {integer} {list data} tup
      in
      case
        (all dead. Maybe a)
        (equalsInteger 1 index)
        [ (/\dead ->
             case
               (all dead. Maybe a)
               (equalsInteger 0 index)
               [ (/\dead -> traceError {Maybe a} "PT1")
               , (/\dead ->
                    Just {a} (`$dUnsafeFromData` (headList {data} args))) ]
               {all dead. dead})
        , (/\dead -> Nothing {a}) ]
        {all dead. dead})
    (\(d : data) ->
       let
         !tup : pair integer (list data) = unConstrData d
         !index : integer = fstPair {integer} {list data} tup
         !args : list data = sndPair {integer} {list data} tup
       in
       case
         (all dead. Tuple2 integer integer)
         (equalsInteger 0 index)
         [ (/\dead -> traceError {Tuple2 integer integer} "PT1")
         , (/\dead ->
              Tuple2
                {integer}
                {integer}
                (unIData (headList {data} args))
                (unIData (headList {data} (tailList {data} args)))) ]
         {all dead. dead})
    ds