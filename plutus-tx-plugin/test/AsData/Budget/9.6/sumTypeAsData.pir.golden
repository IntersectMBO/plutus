let
  ~defaultBody : data = (/\e -> error {e}) {data}
  data Unit | Unit_match where
    Unit : Unit
  !mkCons : all a. a -> list a -> list a = mkCons
  !mkConstr : integer -> list data -> data = constrData
  !mkNilData : unit -> list data = mkNilData
  !unitval : unit = ()
  ~`$bFirstC` : Unit -> data
    = \(arg0_ : Unit) ->
        mkConstr
          0
          (mkCons {data} (mkConstr 0 (mkNilData unitval)) (mkNilData unitval))
  ~id : all a. a -> a = /\a -> \(x : a) -> x
  ~`$fToDataSecretlyData` : (\a -> a -> data) data = id {data}
  ~`$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData` : data -> data
    = \(d : data) -> d
  ~`$fUnsafeFromDataSecretlyData` : (\a -> data -> a) data
    = `$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData`
  data Bool | Bool_match where
    True : Bool
    False : Bool
  !equalsInteger : integer -> integer -> bool = equalsInteger
  !fst : all a b. pair a b -> a = fstPair
  !head : all a. list a -> a = headList
  !ifThenElse : all a. bool -> a -> a -> a = ifThenElse
  !snd : all a b. pair a b -> b = sndPair
  !unsafeDataAsConstr : data -> pair integer (list data) = unConstrData
  ~`$mJustD` :
     all r a.
       (\a -> a -> data) a ->
       (\a -> data -> a) a ->
       (\a -> data) a ->
       (a -> r) ->
       (unit -> r) ->
       r
    = /\r a ->
        \(`$dToData` : (\a -> a -> data) a)
         (`$dUnsafeFromData` : (\a -> data -> a) a)
         (scrut : (\a -> data) a) ->
          let
            !nt : data = scrut
          in
          \(cont : a -> r) ->
            let
              !cont : a -> r = cont
            in
            \(fail : unit -> r) ->
              let
                !fail : unit -> r = fail
                !tup : pair integer (list data) = unsafeDataAsConstr nt
                !y : integer = fst {integer} {list data} tup
                !b : bool = equalsInteger 0 y
              in
              Bool_match
                (ifThenElse {Bool} b True False)
                {all dead. r}
                (/\dead ->
                   cont
                     (`$dUnsafeFromData`
                        (head {data} (snd {integer} {list data} tup))))
                (/\dead -> fail ())
                {all dead. dead}
  ~`$mNothingD` : all r a. (\a -> data) a -> (unit -> r) -> (unit -> r) -> r
    = /\r a ->
        \(scrut : (\a -> data) a) ->
          let
            !nt : data = scrut
          in
          \(cont : unit -> r) ->
            let
              !cont : unit -> r = cont
            in
            \(fail : unit -> r) ->
              let
                !fail : unit -> r = fail
                !tup : pair integer (list data) = unsafeDataAsConstr nt
                !y : integer = fst {integer} {list data} tup
                !b : bool = equalsInteger 1 y
              in
              Bool_match
                (ifThenElse {Bool} b True False)
                {all dead. r}
                (/\dead -> cont ())
                (/\dead -> fail ())
                {all dead. dead}
in
\(ds : (\a -> data) data) ->
  let
    !nt : data = ds
  in
  `$mJustD`
    {data}
    {data}
    `$fToDataSecretlyData`
    `$fUnsafeFromDataSecretlyData`
    nt
    (\(a : data) -> a)
    (\(void : unit) ->
       `$mNothingD`
         {data}
         {data}
         nt
         (\(void : unit) -> `$bFirstC` Unit)
         (\(void : unit) ->
            Unit_match ((/\e -> error {e}) {Unit}) {data} defaultBody))