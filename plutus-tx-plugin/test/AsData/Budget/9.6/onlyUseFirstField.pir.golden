let
  data (Tuple5 :: * -> * -> * -> * -> * -> *) a b c d e | Tuple5_match where
    Tuple5 : a -> b -> c -> d -> e -> Tuple5 a b c d e
  data Bool | Bool_match where
    True : Bool
    False : Bool
in
\(d : data) ->
  Tuple5_match
    {Bool}
    {integer}
    {integer}
    {integer}
    {integer}
    (let
      !asConstr : pair integer (list data) = unConstrData d
      !constrIx : integer = fstPair {integer} {list data} asConstr
      !constrArgs : list data = sndPair {integer} {list data} asConstr
      !field : integer = unIData (headList {data} constrArgs)
      !rest : list data = tailList {data} constrArgs
      !field : integer = unIData (headList {data} rest)
      !rest : list data = tailList {data} rest
      !field : integer = unIData (headList {data} rest)
      !field : integer = unIData (headList {data} (tailList {data} rest))
    in
    Tuple5
      {Bool}
      {integer}
      {integer}
      {integer}
      {integer}
      (ifThenElse {Bool} (equalsInteger 0 constrIx) True False)
      field
      field
      field
      field)
    {integer}
    (\(ds : Bool)
      (int : integer)
      (int : integer)
      (int : integer)
      (int : integer) ->
       Bool_match
         ds
         {all dead. integer}
         (/\dead -> int)
         (/\dead -> error {integer})
         {all dead. dead})