let
  data (Tuple4 :: * -> * -> * -> * -> *) a b c d | Tuple4_match where
    Tuple4 : a -> b -> c -> d -> Tuple4 a b c d
  data Bool | Bool_match where
    True : Bool
    False : Bool
  data (Maybe :: * -> *) a | Maybe_match where
    Just : a -> Maybe a
    Nothing : Maybe a
in
\(d : data) ->
  Maybe_match
    {Tuple4 integer integer integer integer}
    (let
      !asConstr : pair integer (list data) = unConstrData d
      !constrIx : integer = fstPair {integer} {list data} asConstr
      !constrArgs : list data = sndPair {integer} {list data} asConstr
      !field : integer = unIData (headList {data} constrArgs)
      !rest : list data = tailList {data} constrArgs
      !field : integer = unIData (headList {data} rest)
      !rest : list data = tailList {data} rest
      !field : integer = unIData (headList {data} rest)
      !field : integer = unIData (headList {data} (tailList {data} rest))
    in
    Bool_match
      (ifThenElse {Bool} (equalsInteger 0 constrIx) True False)
      {all dead. Maybe (Tuple4 integer integer integer integer)}
      (/\dead ->
         Just
           {Tuple4 integer integer integer integer}
           (Tuple4
              {integer}
              {integer}
              {integer}
              {integer}
              field
              field
              field
              field))
      (/\dead -> Nothing {Tuple4 integer integer integer integer})
      {all dead. dead})
    {all dead. integer}
    (\(ds : Tuple4 integer integer integer integer) ->
       /\dead ->
         Tuple4_match
           {integer}
           {integer}
           {integer}
           {integer}
           ds
           {integer}
           (\(int : integer) (int : integer) (int : integer) (int : integer) ->
              int))
    (/\dead -> error {integer})
    {all dead. dead}