= Writing off-chain code

Working with Plutus requires writing on-chain code and off-chain code,
with both parts working well together.

Let us start by looking at the off-chain part of this interplay,
code that will be executed by the wallet!

Such code is represented by a monadic computation in any monad
implementing `MonadWallet`:

[source,haskell]
----
type MonadWallet (m :: * -> *) = (WalletAPI m, WalletDiagnostics m) :: Constraint
----

By writing code independent of the specific choice of monad,
we make sure that it will run in different wallet implementations,
in particular the mock wallet of the Plutus Payground and
the actual Cardano wallet.

So what are those constraints `WalletAPI` and `WalletDiagnostics`?

[source,haskell]
----
class MonadError WalletAPIError m => WalletDiagnostics (m :: * -> *) where
  logMsg :: Text -> m ()
----

So this allows us to throw and catch errors (of type `WalletAPIError`)
and to log diagnostic messages.

Let us try this and write the "Hello, world!" of off-chain Plutus code:

include::hello.adoc[]

Pasting this code into the "Editor"-tab of the Playground and compiling it
will make function "hello" available in the "Simulation"-tab, so we can
add it as an action for one of the wallets.
After evaluation, we will see the expected message
in the "Logs"-section of the "Transactions"-tab.

Class `WalletAPI` is a bit more involved:

[source,haskell]
----
class WalletAPI (m :: * -> *) where
  submitTxn :: Tx -> m ()                                       -- <1>
  ownPubKey :: m PubKey                                         -- <2>
  sign :: ByteString -> m Signature                             -- <3>
  createPaymentWithChange :: Value -> m (Set TxIn, Maybe TxOut) -- <4>
  registerOnce :: EventTrigger -> EventHandler m -> m ()        -- <5>
  watchedAddresses :: m AddressMap                              -- <6>
  startWatching :: Address -> m ()                              -- <7>
  slot :: m Slot                                                -- <8>
----

<1> Submit a transaction.

<2> Get the public key belonging to the wallet.

<3> Cryptographically sign an arbitrary string.

<4> Create a set of transaction inputs and optionally a transaction output for change,
suitable to make a payment of the given value from the wallet.

<5> Register an event trigger, so that a specified action will be performed
as soon as the trigger condition becomes true.

<6> Get the addresses being watched by the wallet.

<7> Start watching an address for changes.

<8> Get the current time (slot).

Let us start exploring `WalletAPI` by reimplementing function `payToWallet_`
from the playground, which simply pays a certain amount of Ada to another
wallet!

include::payToWallet1.adoc[]

In contrast to our first `hello` example, function `myPayToWallet`
takes _arguments_. The user will be prompted to enter values for these in the
Playground when the function is added as an action to the simulation.

Note how we use `createPaymentWithChange` to help us build a transaction: Given
a value, this function will select suitable unspent transaction outputs
belonging to the wallet, which we can use as inputs.
It will also optionally create a
new transaction output, where the change can go to,
if the sum of the inputs exceeds the value we want to transfer.

Incidentally, paying some value to a public key
is so common that there are helper functions `payToPublicKey` and
`payToPublicKey_` for this (`payToPublicKey` returns the generated transaction,
`payToPublicKey_` does not).

[source,haskell]
----
payToPublicKey  :: (Monad m, WalletAPI m) => SlotRange -> Value -> PubKey -> m Tx
payToPublicKey_ :: (Monad m, WalletAPI m) => SlotRange -> Value -> PubKey -> m ()
----

Using `payToPublicKey_`, we can write `myPayToWallet` simpler as follows:

include::payToWallet2.adoc[]

Now that we have seen how to create and submit transactions,
let us use `registerOnce` to register a _trigger_.

.Triggers
[NOTE]
========
A wallet can register one or more triggers by specifying an `EventTrigger` and
an `EventHandler`.
The event trigger defines a condition, the event handler describes what to do
once the condition becomes true.

The following functions allow us to construct triggers:

[source,haskell]
----
neverT             :: EventTrigger                                 -- <1>
alwaysT            :: EventTrigger                                 -- <2>
notT               :: EventTrigger -> EventTrigger                 -- <3>
andT               :: EventTrigger -> EventTrigger -> EventTrigger -- <4>
orT                :: EventTrigger -> EventTrigger -> EventTrigger -- <5>
slotRangeT         :: SlotRange -> EventTrigger                    -- <6>
fundsAtAddressGeqT :: Address -> Value -> EventTrigger             -- <7>
fundsAtAddressGtT  :: Address -> Value -> EventTrigger             -- <8>
----

<1> This will never be true.
<2> This will always be true.
<3> Logical negation of the given trigger.
<4> Logical conjunction: True when _both_ triggers are true.
<5> Logical disjunction: True when _at least one_ of the triggers is true.
<6> Checks whether the current slot is in the given range.
<7> Is true if the funds at the address are _at least_ the specified value.
<8> Is true if the funds at the address are _greater than_ the specified value.

CAUTION: The triggers `fundsAtAddressGeqT` and `fundsAtAddressGtT` will only take those
unspent transaction outputs into account that are created _after_ the trigger
has been registered!

An event handler is defined with:

[source,haskell]
----
EventHandler :: (AnnotatedEventTrigger Bool -> m ()) -> EventHandler m
----

The argument of type `AnnotatedEventTrigger` allows the handler to inspect _which part_ of a
compound trigger (one built with `andT` and/or `orT`) has actually become true.
========

As an example, we can write a function that will wait for a specified slot
until performing a transaction:

include::trigger1.adoc[]

This is actually a somewhat silly example:
We do not really need a trigger to achieve this effect,
because we can simply use the transaction's _slot range_ instead:

include::trigger2.adoc[]

.Slot Ranges
[NOTE]
========
The _slot range_ of a transaction determines for which slots the transaction is
valid. We can construct slot ranges with the following functions:

[source,haskell]
----
always           :: SlotRange                                 -- <1>
defaultSlotRange :: SlotRange                                 -- <2>
singleton        :: Slot -> SlotRange                         -- <3>
interval         :: Slot -> Slot -> SlotRange                 -- <4>
intervalFrom     :: Slot -> SlotRange                         -- <5>
intervalTo       :: Slot -> SlotRange                         -- <6>
intersection     :: SlotRange -> SlotRange -> Maybe SlotRange -- <7>
hull             :: SlotRange -> SlotRange -> SlotRange       -- <8>
----

<1> The range of _all_ slots; a transaction using this range will always be
valid.

<2> The default slot range, a synonym for `always`.

<3> The range consisting exclusively of the specified slot.

<4> Given two slots `a` and `b`, `interval a b` is the range that starts at `a`
and ends _one slot before_ `b`, so the range contains `a`, but does not contain
`b`.

<5> The range starting at the given slot (which is included)
and never ending.

<6> The range ending _one slot before_ the given one, which is not included.

<7> The intersection of the two given ranges, provided they overlap.

<8> The smallest range containing _both_ given ranges.

Slot ranges can be inspected using these functions:

[source,haskell]
----
member   :: Slot -> SlotRange -> Bool      -- <1>
overlaps :: SlotRange -> SlotRange -> Bool -- <2>
contains :: SlotRange -> SlotRange -> Bool -- <3>
isEmpty  :: SlotRange -> Bool              -- <4>
before   :: Slot -> SlotRange -> Bool      -- <5>
after    :: Slot -> SlotRange -> Bool      -- <6>
----

<1> Checks whether the given slot is contained in the given range.

<2> Checks whether the two given ranges overlap, i.e. have at least one slot in
common.

<3> Checks whether the first range completely contains the second range, i.e.
whether all members of the second range are members of the first range.

<4> Is this range empty, i.e. does not contain any slots?

<5> Check if the given slot is _earlier_ than the beginning of the given range.

<6> Check if the given slot is _later_ than the end of the given range.
========

This concludes our short tour through the Wallet API.
We have seen how to log messages,
how to create and submit simple transactions,
how to use triggers to wait for a condition to become true before performing
a certain action
and how to create, inspect and use slot ranges.

In the next chapter,
we will dive into _on-chain_ code and create our first smart contract.
