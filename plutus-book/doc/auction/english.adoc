////
[source,haskell]
----
{-# LANGUAGE DataKinds                       #-}
{-# LANGUAGE DeriveAnyClass                  #-}
{-# LANGUAGE NoImplicitPrelude               #-}
{-# LANGUAGE ScopedTypeVariables             #-}
{-# LANGUAGE TemplateHaskell                 #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}

module Auction.English where

import           Prelude                        (Applicative (..))

import           Language.PlutusTx
import qualified Language.PlutusTx.Applicative  as PlutusTx
import           Language.PlutusTx.Prelude      hiding (Applicative (..))
import           Language.PlutusTx.StateMachine
import           Ledger
import           Ledger.Typed.Scripts           (wrapValidator)
import qualified Ledger.Ada                     as A
import qualified Ledger.Value                   as V
import           Playground.Contract
import           Wallet

import           Control.Monad (void, when)
import           Control.Monad.Except           (MonadError (..))
import qualified Data.ByteString.Lazy.Char8     as C
import           Data.List                      (find)
import           Data.Maybe                     (maybeToList)
import qualified Data.Map.Strict                as Map
import qualified Data.Set                       as Set
import qualified Data.Text                      as T

-- The admin token is parameterized by a transaction
-- output, which in turn is given by the hash of a
-- transaction and the output index.
type Admin = (TxHash, Integer)

-- Convert the reference to an output to a hash-index
-- pair.
mkAdmin :: TxOutRef -> Admin
mkAdmin (TxOutRefOf h i) = (plcTxHash h, i)

-- We need no data in data- and redeemer-scripts,
-- so both can be of unit type.
type AdminValidator = () -> () -> PendingTx -> Bool

validateAdmin :: Admin -> AdminValidator
validateAdmin (h, i) () () tx =
       spendsOutput tx h i
    && case pendingTxOutputs tx of
        (o : _) -> V.valueOf
            (pendingTxOutValue o)
            (ownCurrencySymbol tx)
            adminTokenName
            == 1
        []      -> False

adminRedeemer :: RedeemerScript
adminRedeemer = RedeemerScript $ toData ()

mkAdminValidator :: Admin -> ValidatorScript
mkAdminValidator = mkValidatorScript
                       . applyCode $$(compile [|| \a -> wrapValidator (validateAdmin a) ||])
                       . liftCode

adminAddress :: Admin -> Address
adminAddress = scriptAddress . mkAdminValidator

adminSymbol :: Admin -> CurrencySymbol
adminSymbol admin = case validatorScriptHash $ mkAdminValidator admin of
    ValidatorHash h -> V.currencySymbol h

adminTokenName :: TokenName
adminTokenName = TokenName emptyByteString

-- The value of the admin token.
adminValue :: Admin -> Value
adminValue admin = V.singleton (adminSymbol admin) adminTokenName 1

data NonFungible = NonFungible
    { issuer        :: PubKey
    , adminCurrency :: CurrencySymbol
    } deriving (Show, Generic, ToJSON, FromJSON, ToSchema)

makeLift ''NonFungible

type NonFungibleValidator =
       ()
    -> TokenName
    -> PendingTx
    -> Bool

validateNonFungible :: NonFungible -> NonFungibleValidator
validateNonFungible nf () name tx =
       txSignedBy tx (issuer nf)
    && case (pendingTxInputs tx, pendingTxOutputs tx) of
        ([i], os@(o : _)) ->
            let inValue = pendingTxInValue i
            in     foldMap pendingTxOutValue os
                    == (inValue + v2)
                && pendingTxOutValue o
                    == (inValue + v)
                && V.valueOf inValue s name == 0
                && V.valueOf
                    inValue
                    (adminCurrency nf)
                    adminTokenName
                   == 1
                && case pendingTxOutType o of
                    ScriptTxOut vh _ -> vh == ownHash tx
                    _                -> False
        _                 -> False
  where
    s :: CurrencySymbol
    s = ownCurrencySymbol tx

    v, v2 :: Value
    v  = V.singleton s name 1
    v2 = v + v

mkNonFungibleRedeemer :: String -> RedeemerScript
mkNonFungibleRedeemer name = RedeemerScript $ toData $ TokenName $ C.pack name

mkNonFungibleValidator :: NonFungible -> ValidatorScript
mkNonFungibleValidator = mkValidatorScript
                       . applyCode $$(compile [|| \nf -> wrapValidator (validateNonFungible nf) ||])
                       . liftCode

nonFungibleAddress :: NonFungible -> Address
nonFungibleAddress = scriptAddress . mkNonFungibleValidator

nonFungibleSymbol :: NonFungible -> CurrencySymbol
nonFungibleSymbol nf = case validatorScriptHash $ mkNonFungibleValidator nf of
    ValidatorHash h -> V.currencySymbol h

nonFungibleValue :: NonFungible -> String -> Value
nonFungibleValue nf name = V.singleton
    (nonFungibleSymbol nf)
    (TokenName $ C.pack name)
    1

mkNonFungibleTxOut :: NonFungible -> Value -> TxOut
mkNonFungibleTxOut nf v =
    scriptTxOut
        v
        (mkNonFungibleValidator nf)
        unitData

hasAdminToken :: CurrencySymbol -> (TxOutRef, TxOut) -> Bool
hasAdminToken s (_, o) =
    V.valueOf (txOutValue o) s adminTokenName == 1
----
////

[source,haskell]
----
data EnglishAuction = EnglishAuction
    { eaSymbol :: CurrencySymbol -- <1>
    , eaName   :: TokenName      -- <2>
    , eaOwner  :: PubKey         -- <3>
    , eaMinBid :: Ada            -- <4>
    , eaMinInc :: Ada            -- <5>
    , eaEndBid :: Slot           -- <6>
    , eaFinish :: Slot           -- <7>
    } deriving (Show, Generic, ToJSON, FromJSON, ToSchema)

makeLift ''EnglishAuction
----
<1> <<endmatter#currency-symbol,Currency symbol>> of the token.

<2> <<endmatter#token-name,Token name>> of the token. As discussed above,
    we assume that the token defined by the combination of `eaSymbol` and `eaName` is _unique_.

<3> Public key of the token owner.

<4> Minimal amount of the first bid. This is the minimal price the owner is
    willing to accept for his token.

<5> Minimal bid increase, i.e. the minimal increase amouunt of the new bid.

<6> Deadline for bids. Once the deadline has passed, no more bids can be placed,
    and the token owner can retrieve the highest bid (if there was one),
    or reclaim his token.

<7> Deadline for the token owner to retrieve the highest bid. Once _this_
    deadline has passed, the highest bidder can claim the token.

include::statemachine.adoc[]

What state do we need to keep track of for an auction? We will need to record
who made which bids, which suggests using a list `[(PubKey, Ada)]`
of key-ada pairs. When a new bid is
placed, we will add it to the front of the list, and when a bidder has been
outbid and reclaims her bid, we will remove the corresponding pair from the
list (which will never be at the head of the list, because the head of the list
contains the highest bid, which can not be reclaimed).

When the deadline has passed, and the token owner claims the highest bid,
we want to record this in an extra piece of state, a simple `Bool` indicating
whether the token owner has already made his claim.

This leads us to use:

[source,haskell]
----
type EAState = ([(PubKey, Ada)], Bool)

initialEAData :: DataScript
initialEAData = DataScript $ toData (([], False) :: EAState)
----
Script `initialEAData` describes the _initial_ state, before any bids have been
placed.

The type `i` of inputs is determined by the different actions
that can happen during an auction:

[source,haskell]
----
data EAAction =
      EABid PubKey Ada        -- <1>
    | EAClaimBid              -- <2>
    | EAClaimToken            -- <3>
    | EAReclaimBid PubKey Ada -- <4>
    | EAReclaimToken          -- <5>

makeIsData ''EAAction
makeLift ''EAAction
----
<1> Placing a bid. The arguments describe _who_ made the bid and how high it
    was.

<2> Claiming the highest bid after a successful auction. This should be done by
    the token owner.

<3> Claiming the token after a successful auction. This should be done by the
    highest bidder.

<4> Reclaiming a bid after the bidder has been outbid. The arguments describe do
    the bidder and how much she reclaims.

<5> Reclaiming the token after a failed auction. This should be done by the
    token owner.

During the duration of the auction, the token will be locked in an output
at the script address. Each transaction will have that output as input and
create a new output at that address containing the token (except at the very
end, when the highest bidder takes the token for herself).

Function `eaOutput` will give us the unique output at the script address,
given the pending transaction,
and it will simply log a message and do nothing if there is not exactly one such output.

[source,haskell]
----
eaOutput :: PendingTx -> PendingTxOut
eaOutput tx = case uniqueElement (findContinuingOutputs tx) of
    Nothing -> traceErrorH "exactly one output to the same script expected"
    Just i  -> pendingTxOutputs tx !! i
----

We find the highest bid (if there is one), by using the head of the list
in the first component of our state. This assumes, of course, that the highest
bid will always be at the head. We will make sure of this by rejecting bids that
are not sufficiently higher than the previous highest bid.

[source,haskell]
----
highestBid :: EAState -> Maybe (PubKey, Ada)
highestBid ([]   , _) = Nothing
highestBid (x : _, _) = Just x
----

Function `minNewBid` determines the minimal amount of a new bid,
which is the minimal bid if there has not yet been a bid
and the currently higest bid, increased by the minimal increment, if there has been a bid.

If the second component of the state is `True`, the auction is already over,
so no new bids are allowed, an exception occurs.

[source,haskell]
----
minNewBid :: EnglishAuction -> EAState -> Ada
minNewBid _  (_, True) = traceErrorH "bidding ended"
minNewBid ea s         = case highestBid s of
    Nothing        -> eaMinBid ea
    Just (_, ada') -> eaMinInc ea + ada'
----

When we validate transactions for an auction, we will often have to check
whether the _values_ of the unique auction script input and the unique auction
script output are correct. Function `valueCorrect` is a helper for that case.
It takes the pending transaction and a binary predicate on the two values as
input and then checks that predicate on the two relevant values.

[source,haskell]
----
valueCorrect :: PendingTx -> (Value -> Value -> Bool) -> Bool
valueCorrect tx cont =
    let iv = pendingTxInValue (pendingTxIn tx)
        ov = pendingTxOutValue (eaOutput tx)
    in  cont iv ov
----

Finally, it will be convenient to have a function `tokenValue` that computes the
_value_ of the auctioned token:

[source,haskell]
----
tokenValue :: EnglishAuction -> Value
tokenValue ea = V.singleton (eaSymbol ea) (eaName ea) 1
----

With these helpers under our belt, we write a function `eaTransit`,
which will be the transition function of our state machine.

[source,haskell]
----
eaTransit :: EnglishAuction -> EAState -> EAAction -> Maybe EAState
eaTransit ea s@(xs, _) (EABid pk ada)
    | ada >= minNewBid ea s = case xs of                                     -- <1>
        (pk', _) : _
            | pk' == pk -> traceH "already highest bidder" Nothing           -- <2>
        _               -> Just ((pk, ada) : xs, False)                      -- <3>
    | otherwise             = traceH "bid too low" Nothing

eaTransit _ (_,  True)  EAClaimBid = traceH "already claimed" Nothing
eaTransit _ ([], False) EAClaimBid = traceH "no bid to claim" Nothing
eaTransit _ (xs, False) EAClaimBid = Just (xs, True)

eaTransit _ ([], _) EAClaimToken = traceH "no bid made" Nothing
eaTransit _ s       EAClaimToken = Just s

eaTransit _ ([], _)     (EAReclaimBid _ _)    = traceH "no bid made" Nothing
eaTransit _ (y : ys, c) (EAReclaimBid pk ada) =
    fmapMaybe (\ys' -> (y : ys', c)) (go ys)                                 -- <4>
  where
    fmapMaybe :: (a -> b) -> Maybe a -> Maybe b
    fmapMaybe _ Nothing  = Nothing
    fmapMaybe f (Just a) = Just (f a)

    go []                = traceH "no such bid" Nothing
    go (z : zs)
        | z == (pk, ada) = Just zs
        | otherwise      = fmapMaybe (z :) (go zs)

eaTransit _ (_ : _, _) EAReclaimToken = traceH "bid made" Nothing
eaTransit _ ([], _)    EAReclaimToken = Just ([], False)
----

<1> We check whether the new bid is high enough.

<2> We prevent a bidder from bidding when she is _already_ the highest bidder.
    This is not necessary for security, but it prevents bidders from wasting
    money when they falsely assume their previous bid was rejected.

<3> We add the new bidder and bid to the list of bids.

<4> We use the local function `go` to delete the bid from the _tail_ of the list
    of bids. The _head_ contains the highest bid, which can not be reclaimed.

In addition to defining our state machine, we can also utilize `eaTransit`
to write a function that takes
the auction, the action, and the data script of the unique script input as
arguments and computes the correct data script for the unique script output:

// TODO: Replace with state machine lib

[source,haskell]
----
updateEAData :: EnglishAuction
             -> EAAction
             -> DataScript
             -> Maybe DataScript
updateEAData ea a (DataScript d) = case fromData d of
    Just state -> case eaTransit ea state a of
        Just state' -> Just $ DataScript $ toData state'
        Nothing -> Nothing
    Nothing -> Nothing
----

Next we write the checking part of our state machine.
Everything which only depends on the input
data script and the action is already contained in `eaTransit`
(via returning `Nothing`),
so in `eaCheck`, we have to check those conditions that additionally depend on the pending
transaction:

[source,haskell]
----
eaCheck :: EnglishAuction
        -> EAState
        -> EAAction
        -> PendingTx
        -> Bool
eaCheck ea _ (EABid _ ada) tx
    | not validBidTime = traceH "bid too late" False
    | not bidPaid      = traceH "wrong output value" False
    | otherwise        = True
  where
    validBidTime :: Bool                                    -- <1>
    validBidTime =
        intervalTo (eaEndBid ea)
            `contains` pendingTxValidRange tx

    bidPaid :: Bool
    bidPaid = valueCorrect tx (\iv ov ->                    -- <2>
        ov == (iv + A.toValue ada))
----

<1> Has the bid been made before the deadline?

<2> This is the first time we use our function `valueCorrect`
    from above. In this case, we check that the script output value equals the
    script input value, plus the bid.

Note that we do _not_ check whether the transaction has been signed by the
public key mentioned in the action. We do this on purpose: If the person making
the bid allows it to later be reclaimed by somebody else, then that is up to
her!

[source,haskell]
----
eaCheck ea s EAClaimBid tx = case highestBid s of
    Nothing                  -> traceH "no bid to claim" False
    Just (_, ada)
        | not bidClaimed     -> traceH "wrong value claimed" False
        | not validClaimTime -> traceH "claim too early" False
        | not byOwner        -> traceH "not claimed by owner" False
        | otherwise          -> True
      where
        bidClaimed :: Bool
        bidClaimed = valueCorrect tx (\iv ov ->                     -- <1>
            ov == (iv - A.toValue ada))

        validClaimTime :: Bool                                      -- <2>
        validClaimTime =
            intervalFrom (eaEndBid ea)
                `contains` pendingTxValidRange tx

        byOwner :: Bool                                             -- <3>
        byOwner = tx `txSignedBy` eaOwner ea
----

<1> We use `valueCorrect` again, this time to check that the output script value
    is the input script value minus the highest bid.

<2> Is bidding over?

<3> The highest bid must be claimed by the token owner.

[source,haskell]
----
eaCheck ea s EAClaimToken tx = case highestBid s of
    Nothing                   -> traceH "no bid made" False
    Just (pk, _)
        | not tokenClaimed    -> traceH "wrong value claimed" False
        | not validClaimTime  -> traceH "claim too early" False
        | not byHighestBidder -> traceH "not claimed by highest bidder" False
        | otherwise           -> True
      where
        tokenClaimed :: Bool
        tokenClaimed = valueCorrect tx (\iv ov ->                             -- <1>
            ov == (iv - tokenValue ea))

        validClaimTime :: Bool                                                -- <2>
        validClaimTime =
            intervalFrom (eaFinish ea)
                `contains` pendingTxValidRange tx

        byHighestBidder :: Bool                                               -- <3>
        byHighestBidder = tx `txSignedBy` pk
----

<1> This time we check that the output script value is the input script value
    minus the token.

<2> Claiming the token is the latest step in the auction and only allowed after
    `eaFinish ea` has been reached.

<3> The token belongs to the highest bidder now, so she must sign this
    transaction.

[source,haskell]
----
eaCheck _ _ (EAReclaimBid pk ada) tx
    | not byBidder = traceH "not reclaimed by bidder" False
    | not correct  = traceH "wrong value reclaimed" False
    | otherwise    = True
  where
    byBidder :: Bool
    byBidder = tx `txSignedBy` pk                           -- <1>

    correct :: Bool
    correct = valueCorrect tx (\iv ov ->                    -- <2>
        ov == (iv - A.toValue ada))
----

<1> The reclaim must be authorized by the public key associated with the bid.
    Note that we do not check to _where_ the reclaimed bid is sent, only that the
    transaction is signed by the right person.

<2> The output script value must be the input script value minus the bid that is
    being reclaimed.

Reclaiming a bid is always valid, so we do not have to check the time here.

[source,haskell]
----
eaCheck ea _ EAReclaimToken tx
    | not validReclaimTime = traceH "reclaim too early" False
    | otherwise            = True
  where
    validReclaimTime :: Bool
    validReclaimTime =
        intervalFrom (eaEndBid ea)
            `contains` pendingTxValidRange tx                 -- <1>
----

<1> The token can only be reclaimed once the bidding period is over.

We do not need to check any values here: Reclaiming is only valid if there have
been no bids, so the only value locked at the script address should be the
token.

Now it is easy to use `eaTransit` and `eaCheck` to define our state machine
and then the actual validator:

[source,haskell]
----
eaStateMachine :: EnglishAuction -> StateMachine EAState EAAction
eaStateMachine ea = StateMachine
    { smTransition = eaTransit ea
    , smCheck      = eaCheck ea
    , smFinal      = const False
    }

mkEAValidator :: EnglishAuction -> ValidatorScript
mkEAValidator ea = mkValidatorScript $ $$(compile [|| v ||]) `applyCode` liftCode ea
    where v ea' = wrapValidator (mkValidator (eaStateMachine ea'))

eaAddress :: EnglishAuction -> Address
eaAddress = scriptAddress . mkEAValidator
----

The redeemer is just the action.

[source,haskell]
----
mkEARedeemer :: EAAction -> RedeemerScript
mkEARedeemer a = RedeemerScript $ toData a
----

////
[source,haskell]
----
start' :: forall m. MonadWallet m => m CurrencySymbol
start' = do

    key  <- ownPubKey
    outs <- outputsAt $ pubKeyAddress key
    case Map.toList outs of
        []             -> throwError $
            OtherError $ T.pack "need at least one output"
        ((ref, o) : _) -> do
            let admin = mkAdmin ref
            startWatching $ adminAddress admin
            logMsg $ T.pack $
                "starting admin " ++ show admin
            void $ createTxAndSubmit
                defaultSlotRange
                Set.empty
                [scriptTxOut
                    zero
                    (mkAdminValidator admin)
                    unitData]
            go1 ref $ txOutValue o
            pure (adminSymbol admin)

  where
    go1 :: TxOutRef -> Value -> m ()
    go1 ref v = do
        t <- trigger
        registerOnce t $ handler1 ref v

    trigger :: m EventTrigger
    trigger = do
        sl <- slot
        return $ slotRangeT $ intervalFrom $ sl + 1

    handler1 :: TxOutRef -> Value -> EventHandler m
    handler1 ref v = EventHandler $ const $ do
        let admin = mkAdmin ref
        outs <- outputsAt $ adminAddress admin
        case Map.keys outs of
            []         -> go1 ref v
            (ref' : _) -> do
                key <- ownPubKey
                let i1 = pubKeyTxIn key ref
                    i2 = scriptTxIn
                            ref'
                            (mkAdminValidator admin)
                            unitRedeemer
                    o  = pubKeyTxOut
                            (v + adminValue admin)
                            key
                signTxAndSubmit_ Tx
                    { txInputs     = Set.fromList [i1, i2]
                    , txOutputs    = [o]
                    , txFee        = zero
                    , txForge      = adminValue admin
                    , txValidRange = defaultSlotRange
                    , txSignatures = Map.empty
                    }
                logMsg $ T.pack $
                    "forging admin token " ++
                    show (adminSymbol admin)

                go2 (adminSymbol admin)

    go2 :: CurrencySymbol -> m ()
    go2 s = do
        t <- trigger
        registerOnce t $ handler2 s

    handler2 :: CurrencySymbol -> EventHandler m
    handler2 s = EventHandler $ const $ do
        key  <- ownPubKey
        outs <- outputsAt $ pubKeyAddress key
        case find (hasAdminToken s) $ Map.toList outs of
            Nothing       -> go2 s
            Just (ref, o) -> do
                let nf = NonFungible
                            { issuer        = key
                            , adminCurrency = s
                            }
                logMsg $ T.pack $
                    "starting tokens " ++ show nf
                let v  = V.singleton s adminTokenName 1
                    i  = pubKeyTxIn key ref
                    o1 = scriptTxOut
                            v
                            (mkNonFungibleValidator nf)
                            unitData
                    o2 = pubKeyTxOut
                            (txOutValue o - v)
                            key
                void $ createTxAndSubmit
                    defaultSlotRange
                    (Set.singleton i)
                    [o1, o2]

start :: MonadWallet m => m ()
start = void start'

forge :: forall m. MonadWallet m
      => CurrencySymbol -- admin token symbol
      -> String         -- token name
      -> m ()
forge s n = do

    key <- ownPubKey
    let nf = NonFungible
                { issuer        = key
                , adminCurrency = s
                }
    logMsg $ T.pack $
        "forging " ++ n ++
        " (symbol " ++ show (nonFungibleSymbol nf) ++
        ") of " ++ show nf

    outs <- outputsAt $ nonFungibleAddress nf
    case findOut s $ Map.toList outs of
        Just (ref, o) -> do
            let v    = nonFungibleValue nf n
                v2   = v + v
                vIn  = txOutValue o
                vOut = vIn + v
            signTxAndSubmit_ Tx
                { txInputs     = Set.singleton $ scriptTxIn
                                    ref
                                    (mkNonFungibleValidator nf)
                                    (mkNonFungibleRedeemer n)
                , txOutputs    = [ mkNonFungibleTxOut nf vOut
                                 , pubKeyTxOut v key
                                 ]
                , txFee        = zero
                , txForge      = v2
                , txValidRange = defaultSlotRange
                , txSignatures = Map.empty
                }
        _         -> throwError $
                        OtherError $ T.pack "'start' has not run"
  where
    findOut :: CurrencySymbol
            -> [(TxOutRef, TxOut)]
            -> Maybe (TxOutRef, TxOut)
    findOut = find . hasAdminToken
----
////

The on-chain part is now complete, and we can turn our attention to the
wallet endpoints.

Before the token owner can start the auction, all potential bidders need to
_watch_ the auction address, so that their wallets will be aware of the (unique)
script output located there.

[source, haskell]
----
watchAuction :: MonadWallet m => EnglishAuction -> m ()
watchAuction ea = do
    logMsg $ T.pack $ "watching " ++ show ea
    startWatching $ eaAddress ea
----

The next endpoint, `startAuction`, will be used by the token owner to lock the
token in the auction contract with the initial data script and thereby _start_ the auction:

[source, haskell]
----
startAuction :: MonadWallet m
             => CurrencySymbol
             -> TokenName
             -> Ada
             -> Ada
             -> Slot
             -> Slot
             -> m ()
startAuction s n b inc e f = do
    pk <- ownPubKey
    let ea = EnglishAuction
                { eaSymbol = s
                , eaName   = n
                , eaOwner  = pk
                , eaMinBid = b
                , eaMinInc = inc
                , eaEndBid = e
                , eaFinish = f
                }
    logMsg $ T.pack $
        "starting auction " ++ show ea

    payToScript_
        defaultSlotRange
        (eaAddress ea)
        (tokenValue ea)
        initialEAData
----

After the unique script output containing the token has been created, all other
endpoints will first have to find that output, then use it as input for a
transaction that will change the auction state. In order to avoid duplication,
we therefore first write two helper functions that will make this easier:

[source, haskell]
----
withAuctionOutput' :: MonadWallet m
                   => EnglishAuction
                   -> m a                                        -- <1>
                   -> (TxOutRef -> TxOut -> DataScript -> m a)   -- <2>
                   -> m a
withAuctionOutput' ea notFound cont = do
    outs <- outputsAt $ eaAddress ea
    case find containsToken $ Map.toList outs of
        Nothing       -> do
            logMsg $ T.pack $ "auction output not found"         -- <3>
            notFound
        Just (ref, o) -> do
            logMsg $ T.pack $ "found auction output: " ++ show o
            case txOutType o of
                PayToScript ds -> cont ref o ds                  -- <4>
                _              -> do
                    logMsg $ T.pack $ "not a script output"      -- <5>
                    notFound
  where
    containsToken :: (TxOutRef, TxOut) -> Bool                   -- <6>
    containsToken (_, o) = txOutValue o `V.geq` tokenValue ea
----

<1> This will be the "exceptional" result if the unique output is not found.

<2> This argument represents the _continuation_, i.e. what we want to do next,
    given a reference to the output, the output itself and its data script.

<3> If we do not find the output containing the token,
    we return the "exceptional" result.

<4> Having found the output and its data script, we invoke our continuation.

<5> If the output is not a script output and thus does not have a data script,
    we return the "exceptional" result.

<6> We check that the output contains the token.

[source, haskell]
----
withAuctionOutput :: MonadWallet m
                  => EnglishAuction
                  -> (TxOutRef -> TxOut -> DataScript -> m ())
                  -> m ()
withAuctionOutput ea =
    withAuctionOutput' ea $ return ()
----

This is a variant of `withAuctionOutput'`,
which will do nothing if the output is not found.

Using this, it is relatively straightforward to implement the remaining
endpoints. We start with `bid` for placing a bid:

[source, haskell]
----
bid :: MonadWallet m
    => EnglishAuction
    -> Ada
    -> m ()
bid ea ada = do
    logMsg $ T.pack $ "bidding " ++ show ada ++ " in " ++ show ea
    pk <- ownPubKey
    let a = EABid pk ada
    withAuctionOutput ea $ \ref o ds -> case updateEAData ea a ds of -- <1> <3>
        Just ds' -> do
            (ins, mo) <- createPaymentWithChange (A.toValue ada) -- <2>
            let v   = mkEAValidator ea
                i   = scriptTxIn ref v $ mkEARedeemer a          -- <4>
                o'  = scriptTxOut (txOutValue o + A.toValue ada) v ds' -- <5>
            signTxAndSubmit_ Tx
                { txInputs     = Set.insert i ins
                , txOutputs    = o' : maybeToList mo
                , txForge      = zero
                , txFee        = zero
                , txValidRange = intervalTo $ eaEndBid ea        -- <6>
                , txSignatures = Map.empty
                }
        Nothing -> pure ()
----

<1> Here we put our `withAuctionOutput` helper to work.

<2> We find suitable outputs in our wallet to be able to pay the bid amount.

<3> We use `updateEAData` to compute the new data script.

<4> We consume the unique script output, attaching the appropriate redeemer
    script.

<5> The new unique script output will have the bid added to its value.

<6> We make sure to only place the bid before the deadline.

The next endpoint will be `claimBid`, used by the token owner after a successful
auction to claim the highest bid.

[source, haskell]
----
claimBid :: MonadWallet m
         => CurrencySymbol
         -> TokenName
         -> Ada
         -> Ada
         -> Slot
         -> Slot
         -> Ada                                         -- <1>
         -> m ()
claimBid s n b inc e f ada = do
    pk <- ownPubKey
    let ea = EnglishAuction
                { eaSymbol = s
                , eaName   = n
                , eaOwner  = pk
                , eaMinBid = b
                , eaMinInc = inc
                , eaEndBid = e
                , eaFinish = f
                }
        a = EAClaimBid
    logMsg $ T.pack $ "claiming bid in " ++ show ea
    withAuctionOutput ea $ \ref o ds -> case updateEAData ea a ds of
        Just ds' -> do
            let ada' = A.toValue ada
                v    = mkEAValidator ea
                i    = scriptTxIn ref v $ mkEARedeemer a
                o1   = scriptTxOut (txOutValue o - ada') v ds' -- <2>
                o2   = pubKeyTxOut ada' pk                     -- <3>
            signTxAndSubmit_ Tx
                { txInputs     = Set.singleton i
                , txOutputs    = [o1, o2]
                , txForge      = zero
                , txFee        = zero
                , txValidRange = intervalFrom $ eaEndBid ea -- <4>
                , txSignatures = Map.empty
                }
        Nothing -> pure ()
----

<1> The highest bid being claimed.

<2> The new unique script output will have its value reduced by the highest bid.

<3> The token owner takes the highest bid for himself.

<4> This is only valid after the deadline.

Endpoint `claimToken` will be used by the highest bidder to claim the token
after a successful auction.

[source, haskell]
----
claimToken :: MonadWallet m => EnglishAuction -> m ()
claimToken ea = do
    logMsg $ T.pack $ "claiming token in " ++ show ea
    let a = EAClaimToken
    withAuctionOutput ea $ \ref o ds -> case updateEAData ea a ds of
        Just ds' -> do
            pk <- ownPubKey
            let v   = mkEAValidator ea
                i   = scriptTxIn ref v $ mkEARedeemer a
                t   = tokenValue ea
                o1  = scriptTxOut (txOutValue o - t) v ds'     -- <1>
                o2  = pubKeyTxOut t pk                       -- <2>
            signTxAndSubmit_ Tx
                { txInputs     = Set.singleton i
                , txOutputs    = [o1, o2]
                , txForge      = zero
                , txFee        = zero
                , txValidRange = intervalFrom $ eaFinish ea  -- <3>
                , txSignatures = Map.empty
                }
        Nothing -> pure ()
----

<1> The token is taken out of the script.

<2> It is then payed to the highest bidder.

<3> This can only happen after the token owner has had time to claim the
    highest bid.

Endpoint `reclaimBid` will be used by bidders who have been outbid:

[source, haskell]
----
reclaimBid :: MonadWallet m
           => EnglishAuction
           -> Ada
           -> m ()
reclaimBid ea ada = do
    logMsg $ T.pack $
        "reclaiming " ++ show ada ++ " from " ++ show ea
    pk <- ownPubKey
    let a = EAReclaimBid pk ada
    withAuctionOutput ea $ \ref o ds -> case updateEAData ea a ds of
        Just ds' -> do
            let ada' = A.toValue ada
                v    = mkEAValidator ea
                i    = scriptTxIn ref v $ mkEARedeemer a
                o1   = scriptTxOut (txOutValue o - ada') v ds'  -- <1>
                o2   = pubKeyTxOut ada' pk                   -- <2>
            signTxAndSubmit_ Tx
                { txInputs     = Set.singleton i
                , txOutputs    = [o1, o2]
                , txForge      = zero
                , txFee        = zero
                , txValidRange = defaultSlotRange            -- <3>
                , txSignatures = Map.empty
                }
        Nothing -> pure ()
----

<1> The old bid is taken out of the script.

<2> It is then paid to the bidder.

<3> Such reclaims can in principle be done at any time. They will fail, however,
    if the auction winner has already taken the token out of the script, because
    there will no longer be a unique output.

The final endpoint, `reclaimToken`, will be used by the token owner in case of a
failed auction, an auction without any bids.

[source, haskell]
----
reclaimToken :: MonadWallet m
             => CurrencySymbol
             -> TokenName
             -> Ada
             -> Ada
             -> Slot
             -> Slot
             -> m ()
reclaimToken s n b inc e f = do
    pk <- ownPubKey
    let ea = EnglishAuction
                { eaSymbol = s
                , eaName   = n
                , eaOwner  = pk
                , eaMinBid = b
                , eaMinInc = inc
                , eaEndBid = e
                , eaFinish = f
                }
        a = EAReclaimToken
    logMsg $ T.pack $ "reclaiming token from " ++ show ea
    withAuctionOutput ea $ \ref o ds -> case updateEAData ea a ds of
        Just ds' -> do
            let v    = mkEAValidator ea
                i    = scriptTxIn ref v $ mkEARedeemer a
                o1   = scriptTxOut zero v ds'               -- <1>
                o2   = pubKeyTxOut (txOutValue o) pk          -- <2>
            signTxAndSubmit_ Tx
                { txInputs     = Set.singleton i
                , txOutputs    = [o1, o2]
                , txForge      = zero
                , txFee        = zero
                , txValidRange = intervalFrom $ eaEndBid ea   -- <3>
                , txSignatures = Map.empty
                }
        Nothing -> pure ()
----

<1> State machine contracts demand that there will always be exactly one new
    output to the state machine script, so we have to create one, even though its
    value will be zero.

<2> The owner takes the token out of the script.

<3> This is only valid after the deadline, when no bids can be placed anymore.

These endpoints together define a complete auction system: The token owner can
start the auction and either claim the highest bid in the end or get back the
token if there were no bids. Bidders can bid, reclaim their bids when they have
been outbid, and the highest bidder can claim the token in the end.

Unfortunately, there is a problem: How do the owner and the bidders know the
_state_ of the auction? How do bidders know whether they have been outbid? How
does the token owner know what highest bid he can claim?

All the information to answer these questions is contained in the data script of
the unique script output, but as mentioned before, in the present version of
Plutus, there is no `unlifted` analogue to `lifted` that would allow us to translate
scripts back into Haskell values.

So at the moment, all we can do is watch the unique script output and how its
value changes. If the value goes up, a new highest bid has been placed. If it
goes down, an outbid bidder has reclaimed her obsolete bid.

To simplify working with this idea, we write a helper function
that will allow us to execute a custom action at each slot after an auction starts,
where the action is allowed to depend on the current slot and the currently
highest bid:

[source,haskell]
----
trackAuction :: forall m s. MonadWallet m
             => EnglishAuction
             -> s                                     -- <1>
             -> (   Slot
                 -> Ada
                 -> DataScript
                 -> s
                 -> m (Maybe s))                      -- <2>
             -> m ()
trackAuction ea initS action = do
    sl <- slot
    wait sl 0 0 initS                                 -- <3>
  where
    wait :: Slot -> Ada -> Ada -> s -> m ()           -- <4>
    wait sl highest total s = do
        let sl' = sl + 1
        registerOnce
            (slotRangeT $ singleton sl')
            (EventHandler $ const $
                go sl' highest total s)

    go :: Slot -> Ada -> Ada -> s -> m ()
    go sl highest total s = withAuctionOutput'
        ea
        (wait sl highest total s) $                   -- <5>
        \_ o ds -> do                                 -- <6>
            let v        = txOutValue o
                total'   = A.fromValue v              -- <7>
                highest' = if total' > total
                                then total' - total
                                else highest          -- <8>

            logMsg $ T.pack $
                "highest bid " ++ show highest' ++
                " in auction " ++ show ea

            ms <- action sl highest' ds s             -- <9>
            case ms of
                Nothing -> return ()
                Just s' -> wait sl highest' total' s' -- <10>
----

<1> We allow our custom action to carry some custom state
    of type `s`, and this is the initial value of that
    piece of state.

<2> The action we want to perform at each slot. It takes the slot, the currently
    highest bid, the data script representing the current contract state
    and the custom state of type `s` as input
    and should return `Nothing` if tracking is done
    and `Just` the updated custom state
    if tracking should continue in the next slot.

<3> We start in slot `sl` with `highest` bid and `total` ada locked at the
    script both set to zero.

<4> We wait for the next slot while remembering the current slot,
    the current amounts of `highest` and `total`
    and the current value of the custom state.

<5> If the output can not be found, the auction probably has not started yet,
    and we simply wait for the next slot.

<6> We grab the unique script output.

<7> We then use it to update `total`.

<8> We also update `highest`.

<9> We perform our custom action with the current slot,
    the current value for `highest`,
    the current data script
    and the current custom state.

<10> If our custom action indicates that we are finished then we stop. Otherwise, we
     wait for the next slot and repeat the process.

Using this, we can provide a more convenient, "automated" endpoint
`runAuction` for the auction owner, which will start the auction,
keep track of the highest bid, and either claim the highest bid or
reclaim the token once the auction is over. We do not need custom
state for this, so we can use custom state type `()`.

[source, haskell]
----
runAuction :: forall m. MonadWallet m
           => CurrencySymbol
           -> TokenName
           -> Ada
           -> Ada
           -> Slot
           -> Slot
           -> m ()
runAuction s n b inc e f = do
    pk <- ownPubKey
    let ea = EnglishAuction
                { eaSymbol = s
                , eaName   = n
                , eaOwner  = pk
                , eaMinBid = b
                , eaMinInc = inc
                , eaEndBid = e
                , eaFinish = f
                }
    logMsg $ T.pack $
        "run auction " ++ show ea

    startAuction s n b inc e f

    trackAuction ea () $ \sl highest _ () -> do
        if sl == eaEndBid ea then do            -- <1>
            if highest > 0 then                 -- <2>
                claimBid s n b inc e f highest
            else                                -- <3>
                reclaimToken s n b inc e f
            return Nothing                      -- <4>

        else return $ Just ()                   -- <5>
----

<1> Is the auction over?

<2> If `highest` is greater than zero, the auction was successful, so we can
    call `reclaimBid`.

<3> If `highest` is still zero, the auction failed, and we call `reclaimToken`.

<4> In both cases, we are finished and return `True` to stop tracking.

<5> If bidding is still ongoing, we return `False` to keep tracking.

We would also like to automate the endpoints for the bidders.
A bidder should be able to simply state the auction she wants to bid in
and the highest bid she is willing to make
and let her wallet take care of the rest.

We can inspect the current state as follows:

[source,haskell]
----
isHighestBidder :: PubKey -> EAState -> Bool
isHighestBidder pk s = case highestBid s of
    Nothing       -> False
    Just (pk', _) -> pk == pk'

isHighestBidderM :: MonadWallet m
                 => DataScript
                 -> m Bool
isHighestBidderM (DataScript ds) = case fromData ds of
    Just s -> do
        pk <- ownPubKey
        return $ isHighestBidder pk s
    Nothing -> throwError $ OtherError $ T.pack "invalid state"
----

Function `isHighestBidderM` allows a wallet to
find out whether it is currently the highest bidder.

Using that and `trackAuction`, we are able to automate auctions for bidders
as well:

[source,haskell]
----
autoBid :: forall m. MonadWallet m
        => EnglishAuction
        -> Ada                                              -- <1>
        -> m ()
autoBid ea ada = do
    let m = eaMinBid ea
    return ()
    when (ada >= m) $ do                                    -- <2>

        logMsg $ T.pack $
            "bidding automatically in " ++ show ea ++
            " with highest bid " ++ show ada
        watchAuction ea

        trackAuction ea Nothing $ \sl highest ds mAda -> do -- <3>
            winning <- isHighestBidderM ds                  -- <4>
            logMsg $ T.pack $ show winning
            when (not winning && sl <= eaEndBid ea) $
                case mAda of
                    Just ada' -> reclaimBid ea ada'         -- <5>
                    Nothing   -> return ()
            case ( compare sl $ eaEndBid ea
                 , compare sl $ eaFinish ea) of             -- <6>
                 (GT, EQ) -> do                             -- <7>
                    claimToken ea
                    return Nothing
                 (EQ, LT)
                    | winning   -> return $ Just Nothing    -- <8>
                    | otherwise -> return Nothing           -- <9>
                 (GT, LT) -> return $ Just Nothing          -- <10>
                 _
                    | winning   -> return $ Just mAda       -- <11>
                    | otherwise -> do
                        let ada' = max
                                (eaMinBid ea)
                                (highest + eaMinInc ea)     -- <12>
                        if ada' > ada
                            then return Nothing             -- <13>
                            else do
                                bid ea ada'
                                return $ Just $ Just ada'   -- <14>
----

<1> The highest bid we are willing to place.

<2> Bidding only makes sense if we are willing to
    at least pay the minimal bid.

<3> This time we use a non-trivial custom state of type
    `Maybe Ada`, indicating the last bid (if any),
    we placed.

<4> We "unlift" the data script to see whether we are
    currently the highest bidder.

<5> If we are _not_ the highest bidder, and if we already
    placed a bid, we reclaim that bid.

<6> What we do next depends on which "era" of the auction we are in.

<7> If we waited till `eaFinish ea`, we have won the auction and can claim the token.

<8> If bidding is over and we won, we just have to wait.

<9> If bidding is over and we lost, we are finished.

<10> Again - if bidding is over and we won, we just have to wait.

<11> If bidding is still ongoing and we have the highest bid, we wait.

<12> If bidding is still ongoing and we do _not_ have the highest bid,
     we calculate the lowest possible higher bid.

<13> If we are not willing to place a bid that high, we are finished.

<14> Otherwise, we place the new bid and wait.

////
[source,haskell]
----
$(mkFunctions
    [ 'start, 'forge, 'startAuction, 'watchAuction
    , 'bid, 'claimBid, 'claimToken, 'reclaimBid
    , 'reclaimToken, 'runAuction, 'autoBid
    ])
----
////
