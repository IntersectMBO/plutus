[#09-extended]
= Extended UTxO Model

This chapter is geared towards the reader that wants to have a clearer picture
of just where Plutus fits in on Cardano Shelley
blockchain ledger. Here we present a high-level explanation of the extended
UTxO model and introduce the reader into the idea of using scripts as
tools for making smart contracts on the blockchain. In this chapter,
we use and build on concepts and notation from the <<03-UTxO#03-UTxO>> chapter.

In the basic UTxO model, the scheme for authorizing transactions
is reliable, but somewhat basic. It is also limited to strictly Ada accounting.
The extended UTxO model brings a significant portion of the expressiveness of
Ethereumâ€™s account-based scripting model to the UTxO-based Cardano blockchain,
including smart contract support.
The extension has two components:

. An extension to the data carried by
transactions and the corresponding processing scheme performed by the nodes
. An extension to the data stored on the chain UTxO
. An
extension to the wallet backend to facilitate off-chain code that coordinates
the execution of on-chain computations.
- Note that an extended UTxO wallet must have access to ledger data in
order to be able to watch (or to look up) outputs at specified addresses
at any time.

In this chapter, we focus on the first component.
In the extended UTxO model, additional on-chain computations must be done to
validate a transaction. Without scripts, the Shelley ledger UTxO state update
rule essentially consists of two steps (both of which are, of course, computations
performed by nodes, and are on-chain):

. Check that a transaction is valid, which includes verifying the following:
* it is live (the transactions time to live has not passed yet)
* the Ada values being spent are non-negative
* generalized accounting property holds
* the size of the transaction does not exceed the maximum
* the fee is being paid
* etc.

. Check that the every action the transaction is performing is witnessed
by the holder of the appropriate private key for
* the spending of every output (witnessed by the key holder for the address
from which the funds are being spent)
* claiming of rewards (witnessed by the holder of the staking key for
the reward address)
* the application of every certificate (witnessed by certificate author)
* genesis key delegations

For a detailed formal description of
this type of accounting, we refer the reader again to <<endmatter#deleg>>.
A major way to extend the functionality of the Cardano ledger is by adding
script capability to the second step.

== Scripts

Recall from the <<10-PlutusTx#10-PlutusTx>> chapter that
scripts (specifically, Plutus scripts) are Plutus Core expressions carried by
a transaction (or stored on the ledger). They are defined inside a specially-delimited
sections of a Haskell program, called Plutus Tx, which are then compiled into
Plutus Core.

Scripts are a way to add smart contract functionality
to the extended UTxO model.
Many of the subsequent chapters of this book discuss building scripts
that define specific smart contracts. In this section, however,
we discuss in general how scripts are used in the extended UTxO model.
For a draft of the formal specification of the extended UTxO model with
scripts, see <<endmatter#scripts>>.

Scripts, like witnesses, are another
tool to make sure a transaction is performing only authorized actions.
The purpose of witnessing for (non-script) spending of outputs is to verify
that the wallet spending the output has the private key associated with the address
in the corresponding UTxO entry (i.e. the address from which it is spending the
money) by checking that it was indeed signed (witnessed)
by that key.

A script `s {two-colons} Script` has its own address
`a {two-colons} Addr_script`, to which it
is possible to pay. This script address is the hash of the script.
Thus, for scripts, we want to check that a transaction (and the wallet that
generated it) has the original script of which this address is the hash.
The whole validator script itself is never stored on the ledger, only its hash,
and only as the address of the unspent UTxO entries belonging to that script.

The role of a script is not to generate additional inputs or outputs in
the current transaction (or make new transactions). Scripts are only used to
verify that if a given transaction is consuming an unspent
output, it is allowed to do so. This script locking approach is only
relevant to those outputs in the UTxO which are associated with a script
address, meaning that these outputs
belong to a script.

For example, recall the crowdfunding campaign scheme. If it is time for
the owner of the campaign to collect the contributions, his wallet
should produce a transaction with inputs which correspond to the contributions of the
funders (i.e. the entries in the ledger UTxO which have the script address of that
crowdfunding contract in the `Addr` field). The outputs of
this transaction must be totaling the same amount as the contributors'
inputs plus the transaction fee, presumably with the owner's own address in the
`Addr` field of each.
The purpose of the scripts carried by such a transaction would be to prove that
this consumption of UTxO entries is authorized, e.g. the campaign goal has
been reached and in this current interval of time, the owner is allowed to
collect the contributions.

The wallet is expected to compute the fees and either add them to the inputs, or
subtract them to the outputs if possible. The exact behaviour should be
configurable by the user. Note that changing the inputs and outputs affects the
transaction fees. Note also, however, that the fee can always be pre-computed
and paid in full, since a script-carrying transaction comes with all
the inputs, outputs, and other data that is needed to validate it. Thus,
there is never a problem of a transaction fee being insufficient.

Here we must note that several pieces of data
go into authorizing the spending of an output with
this script, including
the validator script, redeemer script, data script, and the datatype of the
contract, etc. These are very important features of Plutus and are the
tools that make it possible to perform contract state-dependent validation.
We will discuss the role of each of these in following section, as well as
explain the use of each in every example we present later on.

== Validator, Redeemer, and Data Scripts

A a term of type `Script` is a Plutus Core expression.
Validator scripts are Plutus Core functions that take several input
arguments (which are also scripts). In order to apply one script to
another, the Plutus Core application is wrapped in the map

`applyScript :: Script -> Script -> Script`

In the validation process, additionally, type checking the arguments is also done
before the application. Let us now look at the function of validator
scripts and their arguments on the blockchain.

. Validator script
* Carried by a transaction spending funds from a script address
* Not stored in full in the ledger UTxO
- only the hash is stored as the address of
the output to which the carrying transaction pays
* Is a function taking the following 3 types of scripts as parameters
- data script
- redeemer script
- transaction and ledger data
* returns a boolean, `False` if validation fails, `True` otherwise

. Data script
* Carried by a transaction which is paying to a script
* Contains state information about a given smart contract, e.g.
- the public key of the contributor of a crowdfunding campaign, or
- the hash of the word participants must guess to win money locked by the contract
* Stored in full in the UTxO
- each output belonging to a (validator) script address must have an associated data script
* Hash computed as part of transaction validation

[start=3]
. Redeemer script
* Carried by a transaction which is spending funds from a script address
* A piece of information the wallet must provide in order for a
transaction to spend from a
script address, and can be thought of as an action, such as a
- guessing a secret word (the guess can be verified using the _data_ script)
- an input command which is interpreted by the validator
as spending money from a script (this changes the data script of the contract)
* Validator evaluates to `True` if a suitable redeemer script is provided in
the context of other conditions being met by
- the data script, ledger state, and carrying transaction data
* Value is never stored on-chain, and only appears as part of transaction data
* Hash computed if and when it is necessary for script validation, not stored on-chain

There is one more argument that the validator data script takes which is put
together out of transaction and ledger data,

[start=4]
. A `PendingTx` value.
* Contains information about the current transaction
- inputs and outputs
- validity interval, etc.

The following function is used to perform the validation (i.e. apply the
validator to the relevant inputs) using the
scripts described above:

----
runScript
    :: (MonadError ScriptError m)
    => Checking
    -> ValidationData
    -- ^ contains the PendingTx data
    -> DataScripts
    -- ^ a list of data scripts that may be used in the validation computation
    -- ^ more on these in the note below
    -> ValidatorScript
    -- ^ the validator
    -> DataScript
    -- ^ the specific data script locking the input for which the validation is being performed
    -> RedeemerScript
    -- ^ the redeemer
    -> m [String]
----

We will explain the purpose of the argument of type `DataScripts` in the note below.
Now, let us look more closely at how these scripts fit into the extended model
transaction and UTxO structure.

Recall that in the classic model, UTxO entries are of the form
`(txid, ix) |-> (a,c)`. The pair `(a,c)` has type `TxOut` and is called an output,
where `a` is the address of the owner of the funds
(the paying or staking public key, usually), and `c` is the value of Ada in the output.

For the extended model, if `a` is a script
address (hash of the validator script), we must store additional data on the
ledger in the `TxOut` - the data script. It must be stored in full, not just the
hash, since it will be passed as an argument to the validator during
validation of a transaction which is trying to spend this output.
The extended `TxOut` for a script address contains

- an address `a`, which is the hash of the validator
- the value `c` of funds at this address
- the type of the output, and the data script, expressed as `PayToScript datascript`:

A `TxOut` which belongs to a public key address contains only the address and the value.
Thus, a term of the `TxOut` data structure type includes a term of the type:

`data TxOutType =`
`    PayToScript !DataScript -- A pay-to-script output with the given data script.`
`    | PayToPubKey !PubKey -- A pay-to-pubkey output.`

This is how the outputs are structured both inside the carrying transaction
and the UTxO. In the extended model, the position of an output in the outputs list
carried by a transaction is its reference index `ix`.
In the UTxO, the outputs are stored as a finite
map with the keys of the form `(txid, ix)`. Once a transaction is validated,
the update mechanism
of the UTxO is the same for both the the extended and classic model (with the
extended model storing the additional `TxOutType` data described above).
For a reminder, see the <<03-UTXO#03-UTXO>> chapter.

In the classic model, the inputs of a transaction are simply references to
the UTxO entries which the transaction is spending, so they are
of the form `(txid, ix)` - just like the keys of the UTxO finite map.
In the extended model, we call this pair
`TxOutRef` in the code, and it makes up only a part of the `TxIn`.
Additionally, for an `TxOutRef` which references a script address (i.e. is
spending from a script), the full validator and redeemer script must be included
in the `TxIn` data. So, in the `TxIn` data type, we add a term of the following
type:

`data TxInType =`
`      ConsumeScriptAddress !ValidatorScript !RedeemerScript `
`    -- ^ A transaction input that consumes a script address with the given validator and redeemer pair.`
`    | ConsumePublicKeyAddress !PubKey `
`    -- ^ A transaction input that consumes a public key address.`

To recap the paying and spending process in a different way,

. Paying to a script address
* Transaction contains an output `o` where the address in it is the hash of the
validator script
* `o` also contains the corresponding data script
* `o` becomes a value in the UTxO map once the carrying transaction is processed
* No validation occurs
- Neither the full validator nor the redeemer are part of this payment process

. Spending from a script address
* Transaction contains an input `i` which
- references the output in the UTxO it is spending
- contains the full validator and redeemer scripts
* The UTxO entry which `i` references is a script address, and thus has a
data script stored in the output
- the validator script `i` provides must hash to this script address
* Validation is done at this point for the spending of the specific output
`i` references
- we have the validator, redeemer and data script all available 
- if it succeeds, the transaction is allowed to spend the UTxO output `i` references

[NOTE]
====
. The Seal Mechanism

A transaction may be paying to a particular (validator) script address by creating
several different entries in the ledger UTxO associated this address, but each with
a different data script, which may also have arbitrary different types (since
these are Plutus Core programs).

In order to spend an output with a specific data script, the validator may need
to know the other data script values for this validator address. It may also
want the option to throw away the data scripts that validation does not care about.
To accommodate this, the `Sealed` mechanism is used.


Let's say your "actual" redeemer script (the one expected by the validator script)
has type r.
Now the type of the script that you use to create an input is no longer always r,
but depends on how many script outputs the pending transaction has!
If the pending tx has no script output, you still use r to create a script input.
If the pending tx has one script output with datascript type d1, you instead use
type Sealed (HashedDataScript d) -> r.
If the pending tx has two script outputs with datascript types d1, d2, you must
use Sealed (HashedDataScript d1) -> Sealed (HashedDataScript d2) -> r.
And so on...
So the system will take that script, apply it to the (hashed) datascripts of all
the script transaction output, get an r and then pass that r to the validator.
The Sealed thing is just something like a newtype-wrapper, so you have
seal :: a -> Seal a and unseal :: Seal a -> a, but there will be some security
restrictions, so not everybody can use both. No idea who can or can't. I think
in offchain code, when you construct the redeemer, you can not unseal, but the validator can.
Anyway, what your "pre-"-redeemer script (the funny function type) actually does
with the new arguments is up to you, the creator of the transaction. You can for
example simply ignore them.
The HashedDataScript thingie is more or less a pair of DataScript and its hash -
somehow that can be used by the validator to check that the HashedDataScript s it
gets (if it gets them, i.e. if the redeemer doesn't throw them away) are the "real"
ones from the pending transaction under scrutiny.

====



When we say an output is locked by a script, or belongs to a script address,
this means that the address of this UTxO entry is the hash of some validator
script (not redeemer, and not data script).
This address model of using a hash is not far off from
addresses in the classic UTxO model, which are a datatype
containing the paying and the staking (public, i.e. verification) keys.

As with regular addresses, there are really two things that can be done with
a script address. One can create UTxO entries associated with it (i.e.
pay to the script), and consume entries associated with that script. A transaction
which pays to a script must have an output
`ix |-> (a,c)`
such that the address `a` is the hash of the validator script to which it is paying
(computed off-chain by the wallet).
It must additionally carry
the data script associated with this index `ix`.
It may even carry several data scripts and pay into several different
states of the same contract (with distinct output, of course).
There is no need to perform
script validation using the validator that hashes to `a` here.
In fact, a node processing such a transaction does not need to see the original
validator here at all, unless this same transaction is also spending from the same
script address.

Now, in order to prove that a transaction `tx` is indeed authorized to spend outputs
locked by a validator script, the node doing the validation must apply
a `runScript` function to that validator script, and the three arguments above,
which effectively is the computation applying the validator to the three arguments.
It is necessary to use such a generic evaluator function here due to
the typing of the three scripts.
As pointed out in the <<10-PlutusTx#10-PlutusTx>> chapter, the data and redeemer scripts can be very different types
of Plutus Core expressions generated by template Haskell, so all that is known
to the generic `runScript` function is that these are the three types of
scripts. The validator itself, however, is expecting a term of the exact type it
must compute on, e.g. a public key-type term as the data script argument.

To summarize, the node computes



where

* the validator `vld` comes from the transaction data and
hashes to the value equal to the address of the ledger UTxO entry the transaction is spending
* the data script `dsc` is stored on the ledger and is associated
with the UTxO entry the transaction is spending (it can be looked up by this
entry as a key)
* the redeemer `rdm` is the choice of action the wallet (or its
owner) has made when generating the transaction, and comes directly from
transaction data

For the validation to be successful, the choice of action must be allowed by
the contract (validator) in the context of a given state. Note that,
in the spirit of UTxO style accounting, the contract state is never updated in
the UTxO entry. One can only spend that entry, and create a new one with a
different data script.

If this `runScript` computation returns true, the validation process proceeds.
Otherwise, the entire transaction is scrapped. Essentially, given the context
of the ledger state and carrying transaction data,
the validator is used to show that the provided action (redeemer), indeed
results in the correct state (data script), which means that the smart
contract functionality defined by the code in the validator allows the spending
of script-owned funds.

Note that with this model, as with the classic UTxO
model, a transaction which was not validated does not incur fees. Unlike
the classic model, however, the extended model allows for spending from script
addresses that do not belong to the wallet that generated the transaction.
This is because instead of a private key, a validator script must be
provided to spend from such an address, and scripts are publicly available.

The reader will also note later on, as we discuss writing a complete Plutus contract,
the off-chain function that returns a PlutusTx validator script takes a parameter.
This parameter is of a different type for each kind of contract. For example,
it will be a term of type `Campaign` for a crowdfunder contract:

`contributionScript {two-colons} Campaign -> ValidatorScript`

This parameter for any kind of contract is a
data structure containing necessary non-state, immutable data about the contract
(e.g. the public key of the owner of the campaign).
The values passed to the validator via this data structure parameter are not only used in
defining some of the contract's functions within
the validator, but they serve also a contract identification purpose.
Generally, it is a good idea to define the type of this state-less contract
structure parameter in such a way that it necessarily makes the resulting
contract unique, thus making its validator-hash address unique also.
Then the user is able to, for example, pay exactly to the instance of the
crowdfunder they intended, and not accidentally end up with top hat instead of
a Plutus textbook!

== Additional Extended Model Notes

=== Sharing Plutus Code

The off-chain code, explored in detail in
the next chapter, is run by the users' wallet (or, in the Playground simulation,
the mock wallet). The main goal of the off-chain code is to generate
the correct script at the correct time and to build a transaction carrying it.

Recall that Plutus Playground is a platform where one can write on- and off-chain code
to simulate smart contract functionality on
the mockchain. All the code written in the Playground
is shared by the mock wallets during the simulation, and can be used by
any of them.
In the real Cardano blockchain environment, on- and off-chain
contract code is meant to be used by all wallets participating in the contract,
distributed over the network. This means there needs to be another reliable way
to share Plutus code. The on-chain code is hashed, and the hash is stored in the
UTxO, giving the participants a way to verify that it is indeed the right code
for the right contract. The off-chain code is simply a way to generate
scripts and transactions, which then get validated and authenticated as
part of transaction processing. Thus, it is not necessary to use the blockchain to
provide additional guarantees of its authenticity - simply sharing such code
via a reliable code repository like GitHub will suffice.

However, similar to the case of legal know-how being necessary to write and
understand legal contracts, it is up to the creators and users of a smart contract
to have sufficient understanding of Plutus code to trust the contract is doing
what they expect it to do. Cryptographic security is powerless in this case -
this is where this book comes in!

=== Rollbacks and Other Extended UTxO Model Considerations

Given that blockchain events, such as the confirmation of a transaction, can
trigger the execution of off-chain coordination code, we need to carefully
consider the implications of needing to rollback any action that depends on a
rolled back transaction. We do not give the details of this functionality here.

There are other features of the extended UTxO system that are less relevant to
a Plutus user, which we will also not explain in detail in this chapter.

=== Adding Ledger Functionality Using Scripts

In the upcoming examples in this book we walk the reader through the process
of building, testing and using Plutus contracts. For examples of work on using
scripts to add specific functionality to the UTxO ledger, we would like to
point the reader to the following documents,

* Multi-currency on the UTxO Ledger, see <<endmatter#multicur>>
- An implementation of a script-based model for different types of
currency as well as non-fungible tokens on the mockchain
* A Formal Specification of a Multi-Signature Scheme Using Scripts, see <<endmatter#multisig>>
- A formal specification of enforcing a custom witnessing policy for spending
outputs
