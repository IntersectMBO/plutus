<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- Note [Cancelling interleaved Force-Delay pairs]
<span class="lineno">    2 </span>
<span class="lineno">    3 </span> The 'ForceDelay' optimisation pushes 'Force' inside its direct 'Apply' subterms,
<span class="lineno">    4 </span> removing any 'Delay' at the top of the body of the underlying lambda abstraction.
<span class="lineno">    5 </span> For example, @force [(\x -&gt; delay b) a]@ is transformed into @[(\x -&gt; b) a]@.
<span class="lineno">    6 </span> We also consider the case where the 'Force' is applied directly to the 'Delay' as
<span class="lineno">    7 </span> the base case, i.e. the case when the applications of lambdas is empty.
<span class="lineno">    8 </span> In such simple cases, the transformation is obviously correct, the question remains
<span class="lineno">    9 </span> if this approach can be generalised (note: see remark at the bottom).
<span class="lineno">   10 </span>
<span class="lineno">   11 </span> Since UPLC programs are created from erasing the types of TPLC programs (see
<span class="lineno">   12 </span> &quot;PlutusCore.Compiler.Erase&quot;) we will consider TPLC terms of the following structure,
<span class="lineno">   13 </span> in pseudo-code (@/\@ is (multi-)type abstraction and @\@ is (multi-)term abstraction):
<span class="lineno">   14 </span>
<span class="lineno">   15 </span> &gt; /\T1 -&gt; \X1 -&gt; /\T2 -&gt; \X2 -&gt; /\T3 -&gt; \X3 -&gt; ... -&gt; /\Tn -&gt; \Xn -&gt; body
<span class="lineno">   16 </span>
<span class="lineno">   17 </span> where @T1 ... Tn@ are lists of type variables (e.g. @T1@ could be @[t, q, p]@)
<span class="lineno">   18 </span> and @X1 ... Xn@ are lists of term variables. Of course, each @/\@ and @\@ here would
<span class="lineno">   19 </span> desugar to a sequence of type/term abstractions. Also @[ M P Q ]@ is iterated
<span class="lineno">   20 </span> term application, which, as usual, is left-associative.
<span class="lineno">   21 </span>
<span class="lineno">   22 </span> In order to reason about the proposed optimisation we need to consider such terms in
<span class="lineno">   23 </span> the context of them being applied to some sequence of terms.
<span class="lineno">   24 </span>
<span class="lineno">   25 </span> One important observation is that this transformation requires that the underlying
<span class="lineno">   26 </span> (term)-lambda abstraction will be exactly reduced by the applications.
<span class="lineno">   27 </span> For UPLC, this can happen only when the number of lambda abstracted variables is equal
<span class="lineno">   28 </span> to the number of terms to which it will be applied.
<span class="lineno">   29 </span> For example, @force (\\x -&gt; delay b) =&gt; (\\x -&gt; b)@ is invalid, since the former is @error@.
<span class="lineno">   30 </span> The other case, we can see that applying the optimisation modifies the end result:
<span class="lineno">   31 </span> &gt;  force [(\x -&gt; delay b) a1 a2] =&gt; [(\x -&gt; b) a1 a2] =&gt; b[x1:=a1] a2
<span class="lineno">   32 </span> &gt;
<span class="lineno">   33 </span> &gt;  vs.
<span class="lineno">   34 </span> &gt;
<span class="lineno">   35 </span> &gt;  force [(\x -&gt; delay b) a1 a2] =&gt; force [(delay b[x1:=a1]) a2] =&gt; error
<span class="lineno">   36 </span>
<span class="lineno">   37 </span> To generalise, we consider the family of terms above applied to a family of types and
<span class="lineno">   38 </span> terms:
<span class="lineno">   39 </span> &gt; [ (/\T1 -&gt; \X1 -&gt;  ... -&gt; /\Tn -&gt; \Xn -&gt; body)
<span class="lineno">   40 </span> &gt;     T1 X1 ... Tn Xn
<span class="lineno">   41 </span> &gt; ]
<span class="lineno">   42 </span>
<span class="lineno">   43 </span> For brevity, the types and the terms to which the lambda applies are named the same as the
<span class="lineno">   44 </span> bound variables, but of course this isn't necessary.
<span class="lineno">   45 </span> Also note that in general @|Ti| == |Xi|@ doesn't necessarily hold for any @i in [1, n]@.
<span class="lineno">   46 </span>
<span class="lineno">   47 </span> Translated to UPLC, the original term is:
<span class="lineno">   48 </span> &gt;  delay^|T1| (\X1 -&gt; delay^|T2| (\X2 -&gt; delay^|T3| (\X3 -&gt; ... -&gt; delay^|Tn| (\Xn -&gt; body))))
<span class="lineno">   49 </span> where @delay^|A|@ means &quot;apply delay |A| (the length of A) times&quot;.
<span class="lineno">   50 </span>
<span class="lineno">   51 </span> With the applications:
<span class="lineno">   52 </span> &gt; [force^|Tn| (... [force^|T3| ([force^|T2| ([force^|T1| (original) X1]) X2]) X3] ...) Xn]
<span class="lineno">   53 </span>
<span class="lineno">   54 </span> After inlining @original@ we get:
<span class="lineno">   55 </span> &gt;  [force^|Tn|
<span class="lineno">   56 </span> &gt;    (...
<span class="lineno">   57 </span> &gt;      ([force^|T3|
<span class="lineno">   58 </span> &gt;        ([force^|T2|
<span class="lineno">   59 </span> &gt;          ([force^|T1|
<span class="lineno">   60 </span> &gt;            (delay^|T1|
<span class="lineno">   61 </span> &gt;              (\X1 -&gt;
<span class="lineno">   62 </span> &gt;                 delay^|T2| (\X2 -&gt;
<span class="lineno">   63 </span> &gt;                   delay^|T3| (\X3 -&gt;
<span class="lineno">   64 </span> &gt;                     ... -&gt;
<span class="lineno">   65 </span> &gt;                       delay^|Tn| (\Xn -&gt; body)))))
<span class="lineno">   66 </span> &gt;           X1]) X2]) X3]) ...) Xn]
<span class="lineno">   67 </span>
<span class="lineno">   68 </span> In the end, after applying the base case optimisation:
<span class="lineno">   69 </span> &gt;  [force^|Tn|
<span class="lineno">   70 </span> &gt;    (...
<span class="lineno">   71 </span> &gt;      ([force^|T3|
<span class="lineno">   72 </span> &gt;        ([force^|T2|
<span class="lineno">   73 </span> &gt;          ([(\X1 -&gt;
<span class="lineno">   74 </span> &gt;            delay^|T2| (\X2 -&gt;
<span class="lineno">   75 </span> &gt;              delay^|T3| (\X3 -&gt;
<span class="lineno">   76 </span> &gt;                ... -&gt;
<span class="lineno">   77 </span> &gt;                  delay^|Tn| (\Xn -&gt; body))))
<span class="lineno">   78 </span> &gt;          X1]) X2]) X3]) ...) Xn]
<span class="lineno">   79 </span>
<span class="lineno">   80 </span> Notice that the next two reduction steps (applying @X1@ and reducing @force (delay ...)@)
<span class="lineno">   81 </span> produce an equivalent term to applying the transformation and then the reduction rule
<span class="lineno">   82 </span> for application.
<span class="lineno">   83 </span> This is easy to check, so we continue by showing what the &quot;optimised term&quot; looks like:
<span class="lineno">   84 </span> &gt;  [force^|Tn|
<span class="lineno">   85 </span> &gt;    (...
<span class="lineno">   86 </span> &gt;      [force^|T3|
<span class="lineno">   87 </span> &gt;        ([(\X1 -&gt; \X2 -&gt;
<span class="lineno">   88 </span> &gt;          delay^|T3| (\X3 -&gt;
<span class="lineno">   89 </span> &gt;            ... -&gt;
<span class="lineno">   90 </span> &gt;              delay^|Tn| (\Xn -&gt; body)))
<span class="lineno">   91 </span> &gt;         X1 X2]) X3] ...) Xn]
<span class="lineno">   92 </span>
<span class="lineno">   93 </span> The term can be optimised further by &quot;erasing&quot; the @force^|T3|@ and @delay^|T3|@ pair,
<span class="lineno">   94 </span> and so on until @Tn@.
<span class="lineno">   95 </span>
<span class="lineno">   96 </span> For examples of terms we can optimise, see the test cases in the
<span class="lineno">   97 </span> &quot;Transform.Simplify.forceDelay*&quot; module of the test suite.
<span class="lineno">   98 </span>
<span class="lineno">   99 </span> Remark:
<span class="lineno">  100 </span>
<span class="lineno">  101 </span> It has been observed that the transformation:
<span class="lineno">  102 </span> &gt; force([(\x -&gt; body) 5])
<span class="lineno">  103 </span> &gt; ==&gt;
<span class="lineno">  104 </span> &gt; [(\x -&gt; force(body))]
<span class="lineno">  105 </span> where @body@ isn't necessarily of the form @delay(...)@ is also valid.
<span class="lineno">  106 </span> The question arises, can we generalise the algorithm above given this observation?
<span class="lineno">  107 </span>
<span class="lineno">  108 </span> Let's consider a version of this algorithm which only &quot;pushes forces&quot; down under the
<span class="lineno">  109 </span> applications of lambdas, and the following term:
<span class="lineno">  110 </span> &gt; force (force ([(\x1 -&gt; delay [(\x2 -&gt; delay [(\x3 -&gt; body) 5]) 7]) 9]))
<span class="lineno">  111 </span> &gt; ==&gt; (push inner force)
<span class="lineno">  112 </span> &gt; force ([(\x1 -&gt; force (delay [(\x2 -&gt; delay [(\x3 -&gt; body) 5]) 7]) 9])
<span class="lineno">  113 </span> &gt; ==&gt; (push outer force)
<span class="lineno">  114 </span> &gt; [(\x1 -&gt; force (force (delay [(\x2 -&gt; delay [(\x3 -&gt; body) 5]) 7])) 9]
<span class="lineno">  115 </span>
<span class="lineno">  116 </span> The algorithm gets stuck because after this step the term doesn't contain a direct
<span class="lineno">  117 </span> application of a @force@ over a series of lambdas and applications.
<span class="lineno">  118 </span> To proceed, we need to introduce a separate pass which removes forces immediately
<span class="lineno">  119 </span> followed by delays. For our example above this results in:
<span class="lineno">  120 </span> &gt; [(\x1 -&gt; force ([(\x2 -&gt; delay [(\x3 -&gt; body) 5]) 7])) 9]
<span class="lineno">  121 </span>
<span class="lineno">  122 </span> As can be seen, to proceed with simplifying the term we need to run the &quot;push&quot; pass
<span class="lineno">  123 </span> again.
<span class="lineno">  124 </span>
<span class="lineno">  125 </span> For an arbitrary term to be fully reduced by such an algorithm, we would need to also do
<span class="lineno">  126 </span> an arbitrary number of traversals in this optimisation procedure. This increases the complexity
<span class="lineno">  127 </span> of the simplifier from both a computational perspective and a human-readability perspective.
<span class="lineno">  128 </span>
<span class="lineno">  129 </span> We can easily avoid this situation by removing the force-delay pairs in the same pass.
<span class="lineno">  130 </span> This means that we can fully reduce the term in a single traversal of the term, as described
<span class="lineno">  131 </span> in the original algorithm.
<span class="lineno">  132 </span>
<span class="lineno">  133 </span> We also turn
<span class="lineno">  134 </span>
<span class="lineno">  135 </span> &gt; (force [ (force (builtin ifThenElse)) b (delay x) (delay y) ] )
<span class="lineno">  136 </span>
<span class="lineno">  137 </span> into
<span class="lineno">  138 </span>
<span class="lineno">  139 </span> &gt; [ (force (builtin ifThenElse)) b x y ]
<span class="lineno">  140 </span>
<span class="lineno">  141 </span> if both @x@ and @y@ are pure and work-free.
<span class="lineno">  142 </span>-}
<span class="lineno">  143 </span>{-# LANGUAGE LambdaCase    #-}
<span class="lineno">  144 </span>{-# LANGUAGE TypeFamilies  #-}
<span class="lineno">  145 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">  146 </span>{-# LANGUAGE ViewPatterns  #-}
<span class="lineno">  147 </span>module UntypedPlutusCore.Transform.ForceDelay
<span class="lineno">  148 </span>    ( forceDelay
<span class="lineno">  149 </span>    ) where
<span class="lineno">  150 </span>
<span class="lineno">  151 </span>import PlutusCore.Builtin (BuiltinSemanticsVariant)
<span class="lineno">  152 </span>import PlutusCore.Default (DefaultFun (IfThenElse), DefaultUni)
<span class="lineno">  153 </span>import PlutusCore.MkPlc (mkIterApp)
<span class="lineno">  154 </span>import UntypedPlutusCore.Core
<span class="lineno">  155 </span>import UntypedPlutusCore.Purity (isPure, isWorkFree)
<span class="lineno">  156 </span>import UntypedPlutusCore.Transform.Simplifier (SimplifierStage (ForceDelay), SimplifierT,
<span class="lineno">  157 </span>                                               recordSimplification)
<span class="lineno">  158 </span>
<span class="lineno">  159 </span>import Control.Lens (transformOf)
<span class="lineno">  160 </span>import Control.Monad (guard)
<span class="lineno">  161 </span>import Data.Foldable as Foldable (foldl')
<span class="lineno">  162 </span>
<span class="lineno">  163 </span>{- | Traverses the term, for each node applying the optimisation
<span class="lineno">  164 </span> detailed above. For implementation details see 'optimisationProcedure'.
<span class="lineno">  165 </span>-}
<span class="lineno">  166 </span>forceDelay
<span class="lineno">  167 </span>    :: (uni ~ DefaultUni, fun ~ DefaultFun, Monad m)
<span class="lineno">  168 </span>    =&gt; BuiltinSemanticsVariant fun
<span class="lineno">  169 </span>    -&gt; Term name uni fun a
<span class="lineno">  170 </span>    -&gt; SimplifierT name uni fun a m (Term name uni fun a)
<span class="lineno">  171 </span><span class="decl"><span class="istickedoff">forceDelay semVar term = do</span>
<span class="lineno">  172 </span><span class="spaces">    </span><span class="istickedoff">let result = transformOf termSubterms (processTerm <span class="nottickedoff">semVar</span>) term</span>
<span class="lineno">  173 </span><span class="spaces">    </span><span class="istickedoff">recordSimplification term ForceDelay result</span>
<span class="lineno">  174 </span><span class="spaces">    </span><span class="istickedoff">return result</span></span>
<span class="lineno">  175 </span>
<span class="lineno">  176 </span>{- | Checks whether the term is of the right form, and &quot;pushes&quot;
<span class="lineno">  177 </span> the 'Force' down into the underlying lambda abstractions.
<span class="lineno">  178 </span>-}
<span class="lineno">  179 </span>processTerm
<span class="lineno">  180 </span>    :: (uni ~ DefaultUni, fun ~ DefaultFun)
<span class="lineno">  181 </span>    =&gt; BuiltinSemanticsVariant fun -&gt; Term name uni fun a -&gt; Term name uni fun a
<span class="lineno">  182 </span><span class="decl"><span class="istickedoff">processTerm semVar = \case</span>
<span class="lineno">  183 </span><span class="spaces">    </span><span class="istickedoff">Force _ (Delay _ t) -&gt; t</span>
<span class="lineno">  184 </span><span class="spaces">    </span><span class="istickedoff">-- Remove @Delay@s from @ifThenElse@ branches if the latter is @Force@d and the delayed term are</span>
<span class="lineno">  185 </span><span class="spaces">    </span><span class="istickedoff">-- pure and work-free anyway.</span>
<span class="lineno">  186 </span><span class="spaces">    </span><span class="istickedoff">Force _ (splitApplication -&gt;</span>
<span class="lineno">  187 </span><span class="spaces">        </span><span class="istickedoff">( forceIfThenElse@(Force _ (Builtin _ IfThenElse))</span>
<span class="lineno">  188 </span><span class="spaces">        </span><span class="istickedoff">, [cond, (trueAnn, (Delay _ trueAlt)), (falseAnn, (Delay _ falseAlt))]</span>
<span class="lineno">  189 </span><span class="spaces">        </span><span class="istickedoff">)) | <span class="nottickedoff">all (\alt -&gt; isPure semVar alt &amp;&amp; isWorkFree semVar alt) [trueAlt, falseAlt]</span> -&gt;</span>
<span class="lineno">  190 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">mkIterApp</span></span>
<span class="lineno">  191 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">forceIfThenElse</span></span>
<span class="lineno">  192 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">[cond, (trueAnn, trueAlt), (falseAnn, falseAlt)]</span></span>
<span class="lineno">  193 </span><span class="spaces">    </span><span class="istickedoff">original@(Force _ subTerm) -&gt;</span>
<span class="lineno">  194 </span><span class="spaces">        </span><span class="istickedoff">case optimisationProcedure subTerm of</span>
<span class="lineno">  195 </span><span class="spaces">            </span><span class="istickedoff">Just result -&gt; result</span>
<span class="lineno">  196 </span><span class="spaces">            </span><span class="istickedoff">Nothing     -&gt; original</span>
<span class="lineno">  197 </span><span class="spaces">    </span><span class="istickedoff">t -&gt; t</span></span>
<span class="lineno">  198 </span>
<span class="lineno">  199 </span>{- | Converts the subterm of a 'Force' into specialised types for representing
<span class="lineno">  200 </span> multiple applications on top of multiple abstractions. Checks whether the lambda
<span class="lineno">  201 </span> will eventually get &quot;exactly reduced&quot; and applies the optimisation.
<span class="lineno">  202 </span> Returns 'Nothing' if the optimisation cannot be applied.
<span class="lineno">  203 </span>-}
<span class="lineno">  204 </span>optimisationProcedure :: Term name uni fun a -&gt; Maybe (Term name uni fun a)
<span class="lineno">  205 </span><span class="decl"><span class="istickedoff">optimisationProcedure term = do</span>
<span class="lineno">  206 </span><span class="spaces">    </span><span class="istickedoff">asMultiApply &lt;- toMultiApply term</span>
<span class="lineno">  207 </span><span class="spaces">    </span><span class="istickedoff">innerMultiAbs &lt;- toMultiAbs . appHead $ asMultiApply</span>
<span class="lineno">  208 </span><span class="spaces">    </span><span class="istickedoff">guard $ length (appSpineRev asMultiApply) == length (absVars innerMultiAbs)</span>
<span class="lineno">  209 </span><span class="spaces">    </span><span class="istickedoff">case absRhs innerMultiAbs of</span>
<span class="lineno">  210 </span><span class="spaces">        </span><span class="istickedoff">Delay _ subTerm -&gt;</span>
<span class="lineno">  211 </span><span class="spaces">            </span><span class="istickedoff">let optimisedInnerMultiAbs = innerMultiAbs { absRhs = subTerm}</span>
<span class="lineno">  212 </span><span class="spaces">                </span><span class="istickedoff">optimisedMultiApply =</span>
<span class="lineno">  213 </span><span class="spaces">                    </span><span class="istickedoff">asMultiApply { appHead = fromMultiAbs optimisedInnerMultiAbs }</span>
<span class="lineno">  214 </span><span class="spaces">            </span><span class="istickedoff">in pure . fromMultiApply $ optimisedMultiApply</span>
<span class="lineno">  215 </span><span class="spaces">        </span><span class="istickedoff">_               -&gt; Nothing</span></span>
<span class="lineno">  216 </span>
<span class="lineno">  217 </span>data MultiApply name uni fun a = MultiApply
<span class="lineno">  218 </span>    { <span class="istickedoff"><span class="decl"><span class="istickedoff">appHead</span></span></span>     :: Term name uni fun a
<span class="lineno">  219 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">appSpineRev</span></span></span> :: [(a, Term name uni fun a)]
<span class="lineno">  220 </span>    }
<span class="lineno">  221 </span>
<span class="lineno">  222 </span>toMultiApply :: Term name uni fun a -&gt; Maybe (MultiApply name uni fun a)
<span class="lineno">  223 </span><span class="decl"><span class="istickedoff">toMultiApply term =</span>
<span class="lineno">  224 </span><span class="spaces">    </span><span class="istickedoff">case term of</span>
<span class="lineno">  225 </span><span class="spaces">        </span><span class="istickedoff">Apply _ _ _ -&gt; run [] term</span>
<span class="lineno">  226 </span><span class="spaces">        </span><span class="istickedoff">_           -&gt; Nothing</span>
<span class="lineno">  227 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  228 </span><span class="spaces">    </span><span class="istickedoff">run acc (Apply a t1 t2) =</span>
<span class="lineno">  229 </span><span class="spaces">        </span><span class="istickedoff">run ((a, t2) : acc) t1</span>
<span class="lineno">  230 </span><span class="spaces">    </span><span class="istickedoff">run acc t =</span>
<span class="lineno">  231 </span><span class="spaces">        </span><span class="istickedoff">pure $ MultiApply t acc</span></span>
<span class="lineno">  232 </span>
<span class="lineno">  233 </span>fromMultiApply :: MultiApply name uni fun a -&gt; Term name uni fun a
<span class="lineno">  234 </span><span class="decl"><span class="istickedoff">fromMultiApply (MultiApply term ts) =</span>
<span class="lineno">  235 </span><span class="spaces">    </span><span class="istickedoff">Foldable.foldl' (\acc (ann, arg) -&gt; Apply ann acc arg) term ts</span></span>
<span class="lineno">  236 </span>
<span class="lineno">  237 </span>data MultiAbs name uni fun a = MultiAbs
<span class="lineno">  238 </span>    { <span class="istickedoff"><span class="decl"><span class="istickedoff">absVars</span></span></span> :: [(a, name)]
<span class="lineno">  239 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">absRhs</span></span></span>  :: Term name uni fun a
<span class="lineno">  240 </span>    }
<span class="lineno">  241 </span>
<span class="lineno">  242 </span>toMultiAbs :: Term name uni fun a -&gt; Maybe (MultiAbs name uni fun a)
<span class="lineno">  243 </span><span class="decl"><span class="istickedoff">toMultiAbs term =</span>
<span class="lineno">  244 </span><span class="spaces">    </span><span class="istickedoff">case term of</span>
<span class="lineno">  245 </span><span class="spaces">        </span><span class="istickedoff">LamAbs _ _ _ -&gt; run [] term</span>
<span class="lineno">  246 </span><span class="spaces">        </span><span class="istickedoff">_            -&gt; Nothing</span>
<span class="lineno">  247 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  248 </span><span class="spaces">    </span><span class="istickedoff">run acc (LamAbs a name t) =</span>
<span class="lineno">  249 </span><span class="spaces">        </span><span class="istickedoff">run ((a, name) : acc) t</span>
<span class="lineno">  250 </span><span class="spaces">    </span><span class="istickedoff">run acc t =</span>
<span class="lineno">  251 </span><span class="spaces">        </span><span class="istickedoff">pure $ MultiAbs acc t</span></span>
<span class="lineno">  252 </span>
<span class="lineno">  253 </span>fromMultiAbs :: MultiAbs name uni fun a -&gt; Term name uni fun a
<span class="lineno">  254 </span><span class="decl"><span class="istickedoff">fromMultiAbs (MultiAbs vars term) =</span>
<span class="lineno">  255 </span><span class="spaces">    </span><span class="istickedoff">Foldable.foldl' (\acc (ann, name) -&gt; LamAbs ann name acc) term vars</span></span>

</pre>
</body>
</html>
