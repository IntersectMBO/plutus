<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>-- editorconfig-checker-disable-file
<span class="lineno">    2 </span>{-# LANGUAGE ConstraintKinds          #-}
<span class="lineno">    3 </span>{-# LANGUAGE DataKinds                #-}
<span class="lineno">    4 </span>{-# LANGUAGE FlexibleInstances        #-}
<span class="lineno">    5 </span>{-# LANGUAGE MultiParamTypeClasses    #-}
<span class="lineno">    6 </span>{-# LANGUAGE PolyKinds                #-}
<span class="lineno">    7 </span>{-# LANGUAGE StandaloneKindSignatures #-}
<span class="lineno">    8 </span>{-# LANGUAGE TypeFamilies             #-}
<span class="lineno">    9 </span>{-# LANGUAGE TypeOperators            #-}
<span class="lineno">   10 </span>{-# LANGUAGE UndecidableInstances     #-}
<span class="lineno">   11 </span>{-# LANGUAGE UndecidableSuperClasses  #-}
<span class="lineno">   12 </span>
<span class="lineno">   13 </span>module PlutusCore.Builtin.Polymorphism
<span class="lineno">   14 </span>    ( Opaque (..)
<span class="lineno">   15 </span>    , SomeConstant (..)
<span class="lineno">   16 </span>    , TyNameRep (..)
<span class="lineno">   17 </span>    , TyVarRep
<span class="lineno">   18 </span>    , TyAppRep
<span class="lineno">   19 </span>    , TyForallRep
<span class="lineno">   20 </span>    , BuiltinHead
<span class="lineno">   21 </span>    , LastArg
<span class="lineno">   22 </span>    , ElaborateBuiltin
<span class="lineno">   23 </span>    , AllElaboratedArgs
<span class="lineno">   24 </span>    , AllBuiltinArgs
<span class="lineno">   25 </span>    ) where
<span class="lineno">   26 </span>
<span class="lineno">   27 </span>import PlutusPrelude
<span class="lineno">   28 </span>
<span class="lineno">   29 </span>import PlutusCore.Builtin.HasConstant
<span class="lineno">   30 </span>import PlutusCore.Core
<span class="lineno">   31 </span>import PlutusCore.Evaluation.Machine.ExMemoryUsage
<span class="lineno">   32 </span>
<span class="lineno">   33 </span>import Data.Kind qualified as GHC
<span class="lineno">   34 </span>import GHC.Ix
<span class="lineno">   35 </span>import GHC.TypeLits
<span class="lineno">   36 </span>import Universe
<span class="lineno">   37 </span>
<span class="lineno">   38 </span>{- Note [Motivation for polymorphic built-in functions]
<span class="lineno">   39 </span>We need to support polymorphism for built-in functions for these reasons:
<span class="lineno">   40 </span>
<span class="lineno">   41 </span>1. @ifThenElse@ for 'Bool' (being a built-in type rather than a Scott-encoded one) has to be
<span class="lineno">   42 </span>polymorphic as its type signature is
<span class="lineno">   43 </span>
<span class="lineno">   44 </span>    ifThenElse : all a. Bool -&gt; a -&gt; a -&gt; a
<span class="lineno">   45 </span>
<span class="lineno">   46 </span>Previously we had 'Bool' as a Scott-encoded type, but this required plenty of supporting machinery,
<span class="lineno">   47 </span>because unlifting (aka Scott-decoding) a PLC 'Bool' to a Haskell 'Bool' is quite a non-trivial
<span class="lineno">   48 </span>thing. We got rid of it and now we have to pay for that by supporting polymorphic built-in functions
<span class="lineno">   49 </span>(but we added that support long ago anyway, 'cause it was easy to do).
<span class="lineno">   50 </span>
<span class="lineno">   51 </span>2. we have polymorphic built-in types such as lists and pairs and we need polymorphic built-in
<span class="lineno">   52 </span>functions to handle them
<span class="lineno">   53 </span>-}
<span class="lineno">   54 </span>
<span class="lineno">   55 </span>{- Note [Implementation of polymorphic built-in functions]
<span class="lineno">   56 </span>Encoding polymorphism in an AST in an intrinsically-typed manner is not a pleasant thing to do in
<span class="lineno">   57 </span>Haskell. It's not impossible, see &quot;Embedding F&quot;, Sam Lindley:
<span class="lineno">   58 </span>
<span class="lineno">   59 </span>    http://homepages.inf.ed.ac.uk/slindley/papers/embedding-f.pdf
<span class="lineno">   60 </span>
<span class="lineno">   61 </span>but it's extremely heavy and we don't need it, hence we avoid it.
<span class="lineno">   62 </span>
<span class="lineno">   63 </span>Instead, we pass type tags at runtime and ensure that a built-in function can be applied to an
<span class="lineno">   64 </span>argument by checking equality of the type tag that we get by looking at the signature of the
<span class="lineno">   65 </span>denotation of the builtin and the type tag that we get at runtime as a part of the argument.
<span class="lineno">   66 </span>
<span class="lineno">   67 </span>But we don't need to check equality of type tags when the denotation of the builtin is polymorphic
<span class="lineno">   68 </span>over the type of its argument, because then we can simply pass the AST directly through the builtin
<span class="lineno">   69 </span>without ever extracting anything from it.
<span class="lineno">   70 </span>
<span class="lineno">   71 </span>We do still need to type check such a builtin in Plutus though, hence we introduce a @newtype@
<span class="lineno">   72 </span>wrapper for attaching a Plutus type to the argument, so that the Plutus type checker can pick it up.
<span class="lineno">   73 </span>
<span class="lineno">   74 </span>In particular, an opaque value whose type is a PLC type variable `a_0` has the following type on
<span class="lineno">   75 </span>the Haskell side:
<span class="lineno">   76 </span>
<span class="lineno">   77 </span>    Opaque val (TyVarRep ('TyNameRep &quot;a&quot; 0))
<span class="lineno">   78 </span>
<span class="lineno">   79 </span>where that last argument is a direct counterpart of the term-level
<span class="lineno">   80 </span>
<span class="lineno">   81 </span>    TyVar () (TyName (Name &quot;a&quot; 0))
<span class="lineno">   82 </span>
<span class="lineno">   83 </span>@Opaque val rep@ can be used for passing any @val@ through the builtin application machinery,
<span class="lineno">   84 </span>not just one whose type is a bound variable. For example, you can define a new data type
<span class="lineno">   85 </span>
<span class="lineno">   86 </span>    data NatRep
<span class="lineno">   87 </span>
<span class="lineno">   88 </span>provide a 'KnownTypeAst' instance for it and define a (rather pointless) builtin like
<span class="lineno">   89 </span>@idNat : nat -&gt; nat@.
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>It's also possible to bind a type variable of a higher-kind, say, @f :: * -&gt; *@ and make a builtin
<span class="lineno">   92 </span>with the following signature:
<span class="lineno">   93 </span>
<span class="lineno">   94 </span>    idFInteger : all (f :: * -&gt; *). f integer -&gt; f integer
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>where the type application is handled with 'TyAppRep'. Note that the latter is defined as a
<span class="lineno">   97 </span>@data family@:
<span class="lineno">   98 </span>
<span class="lineno">   99 </span>    data family TyAppRep (fun :: dom -&gt; cod) (arg :: dom) :: cod
<span class="lineno">  100 </span>
<span class="lineno">  101 </span>We do that because a @data family@ can return a poly-kinded argument, which allows us to get an
<span class="lineno">  102 </span>intrinsically-kinded representation of PLC types. For example, an opaque @term@ whose type is an
<span class="lineno">  103 </span>application of a type variable @f@ to a type variable @a@ is represented like this:
<span class="lineno">  104 </span>
<span class="lineno">  105 </span>    Opaque val (TyAppRep (TyVarRep ('TyNameRep &quot;f&quot; 0)) (TyVarRep ('TyNameRep &quot;a&quot; 1 :: TyNameRep *)))
<span class="lineno">  106 </span>
<span class="lineno">  107 </span>Note the @TyNameRep *@ kind annotation. It tells us three things:
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>1. a type-level name has a kind associated with it. The reason for that is that we use names in
<span class="lineno">  110 </span>binders (for example, in the universal quantifier) and as variables and kinds are important in
<span class="lineno">  111 </span>both these cases due to us having an intrinsically-kinded representation of types, so it's
<span class="lineno">  112 </span>convenient to annotate type-level names with kinds. Another reason is that we do not attempt to do
<span class="lineno">  113 </span>any kind of static analysis on reflected type variables and associating kinds with them allows us
<span class="lineno">  114 </span>to catch errors like &quot;two variables with equal names and uniques, but different kinds&quot; earlier
<span class="lineno">  115 </span>2. the kind is not stored as an argument to the @TyNameRep@ constructor. Instead it's stored as
<span class="lineno">  116 </span>an index of the data type. The point of this is that if we stored the kind as an argument, we'd
<span class="lineno">  117 </span>have to provide it manually, but since the representation is intrinsically-kinded there's no point
<span class="lineno">  118 </span>in doing so as GHC can infer all the kinds itself
<span class="lineno">  119 </span>3. ... apart from cases where they're inherently ambiguous, like in the case above. If we don't
<span class="lineno">  120 </span>specify the kind of the @a_1@ type variable, then there's no way GHC could infer it as the variable
<span class="lineno">  121 </span>is passed as an argument to another variable with an unspecified kind (@f_0@)
<span class="lineno">  122 </span>4. finally, an opaque value can only be of a type of kind @*@. You can't construct a value whose
<span class="lineno">  123 </span>type is of some other kind. That's why we don't need to annotate the @f_0@ type variable: the domain
<span class="lineno">  124 </span>is inferred from the kind of the argument (where it's explicitly specified via @TyNameRep *@) and
<span class="lineno">  125 </span>the codomain is inferred from the fact that the whole type is passed to 'Opaque' and so it has to be
<span class="lineno">  126 </span>of kind @*@
<span class="lineno">  127 </span>
<span class="lineno">  128 </span>It would be nice if we didn't need to define that @*Rep@ stuff at the type level just to demote it
<span class="lineno">  129 </span>to the term level via a type class, but this hasn't been investigated yet. A plausible way would be
<span class="lineno">  130 </span>to ditch 'KnownTypeAst' (but keep 'ReadKnownIn' and 'MakeKnownIn') and provide PLC types
<span class="lineno">  131 </span>manually. But that doesn't seem to give rise to a terribly nice API. And we'd lose all the static
<span class="lineno">  132 </span>guarantees, which is not a big deal, but losing the automatic inference of type schemes would suck,
<span class="lineno">  133 </span>given that it's quite handy.
<span class="lineno">  134 </span>
<span class="lineno">  135 </span>Representing constructors as poly-kinded data families and handling those with open type families
<span class="lineno">  136 </span>and/or type classes is a way of solving the expression problem for indexed data types at the type
<span class="lineno">  137 </span>level, if you are into these things.
<span class="lineno">  138 </span>
<span class="lineno">  139 </span>See Note [Elaboration of polymorphism] for how this machinery is used in practice.
<span class="lineno">  140 </span>-}
<span class="lineno">  141 </span>
<span class="lineno">  142 </span>-- See Note [Motivation for polymorphic built-in functions].
<span class="lineno">  143 </span>-- See Note [Implementation of polymorphic built-in functions].
<span class="lineno">  144 </span>-- | The AST of a value with a Plutus type attached to it. The type is for the Plutus type checker
<span class="lineno">  145 </span>-- to look at. 'Opaque' can appear in the type of the denotation of a builtin.
<span class="lineno">  146 </span>newtype Opaque val (rep :: GHC.Type) = Opaque
<span class="lineno">  147 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unOpaque</span></span></span> :: val
<span class="lineno">  148 </span>    } deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">HasConstant</span></span></span></span>, <span class="decl"><span class="nottickedoff">ExMemoryUsage</span></span>)
<span class="lineno">  149 </span>-- Try not to add instances for this data type, so that we can throw more 'NoConstraintsErrMsg'
<span class="lineno">  150 </span>-- kind of type errors.
<span class="lineno">  151 </span>
<span class="lineno">  152 </span>type instance UniOf (Opaque val rep) = UniOf val
<span class="lineno">  153 </span>
<span class="lineno">  154 </span>-- | For unlifting from the 'Constant' constructor when the stored value is of a monomorphic
<span class="lineno">  155 </span>-- built-in type
<span class="lineno">  156 </span>--
<span class="lineno">  157 </span>-- The @rep@ parameter specifies how the type looks on the PLC side (i.e. just like with
<span class="lineno">  158 </span>-- @Opaque val rep@).
<span class="lineno">  159 </span>newtype SomeConstant uni (rep :: GHC.Type) = SomeConstant
<span class="lineno">  160 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unSomeConstant</span></span></span> :: Some (ValueOf uni)
<span class="lineno">  161 </span>    }
<span class="lineno">  162 </span>
<span class="lineno">  163 </span><span class="decl"><span class="istickedoff">deriving newtype instance (Everywhere uni ExMemoryUsage, Closed uni)</span>
<span class="lineno">  164 </span><span class="spaces">    </span><span class="istickedoff">=&gt; ExMemoryUsage (SomeConstant uni rep)</span></span>
<span class="lineno">  165 </span>
<span class="lineno">  166 </span>type instance UniOf (SomeConstant uni rep) = uni
<span class="lineno">  167 </span>
<span class="lineno">  168 </span>instance HasConstant (SomeConstant uni rep) where
<span class="lineno">  169 </span>    <span class="decl"><span class="nottickedoff">asConstant = coerceArg pure</span></span>
<span class="lineno">  170 </span>    {-# INLINE asConstant #-}
<span class="lineno">  171 </span>
<span class="lineno">  172 </span>    <span class="decl"><span class="istickedoff">fromConstant = coerce</span></span>
<span class="lineno">  173 </span>    {-# INLINE fromConstant #-}
<span class="lineno">  174 </span>
<span class="lineno">  175 </span>-- | Representation of a type variable: its name and unique and an implicit kind.
<span class="lineno">  176 </span>data TyNameRep (kind :: GHC.Type) = TyNameRep Symbol Nat
<span class="lineno">  177 </span>
<span class="lineno">  178 </span>-- | Representation of an intrinsically-kinded type variable: a name.
<span class="lineno">  179 </span>data family TyVarRep (name :: TyNameRep kind) :: kind
<span class="lineno">  180 </span>
<span class="lineno">  181 </span>-- | Representation of an intrinsically-kinded type application: a function and an argument.
<span class="lineno">  182 </span>data family TyAppRep (fun :: dom -&gt; cod) (arg :: dom) :: cod
<span class="lineno">  183 </span>
<span class="lineno">  184 </span>-- | Representation of of an intrinsically-kinded universal quantifier: a bound name and a body.
<span class="lineno">  185 </span>data family TyForallRep (name :: TyNameRep kind) (a :: GHC.Type) :: GHC.Type
<span class="lineno">  186 </span>
<span class="lineno">  187 </span>-- | For annotating an uninstantiated built-in type, so that it gets handled by the right instance
<span class="lineno">  188 </span>-- or type family.
<span class="lineno">  189 </span>type BuiltinHead :: forall a. a -&gt; a
<span class="lineno">  190 </span>data family BuiltinHead x
<span class="lineno">  191 </span>
<span class="lineno">  192 </span>-- | @LastArg x y@ is the same thing as @y@ in the signature of the denotation of a built-in
<span class="lineno">  193 </span>-- functions and this type is only used for referencing @x@ before @y@, so that the elaboration
<span class="lineno">  194 </span>-- machinery generates @x@ before @y@ in the @all@ part of the Plutus signature of the builtin.
<span class="lineno">  195 </span>-- This is a very hacky and indirect way of specifying the ordering of type variables in a Plutus
<span class="lineno">  196 </span>-- signature, in future we'll do it explicitly by introducing a 'Forall' binder for use in type
<span class="lineno">  197 </span>-- signatures of denotations of builtins.
<span class="lineno">  198 </span>type LastArg :: GHC.Type -&gt; GHC.Type -&gt; GHC.Type
<span class="lineno">  199 </span>data family LastArg x y
<span class="lineno">  200 </span>
<span class="lineno">  201 </span>-- | Take an iterated application of a built-in type and elaborate every function application
<span class="lineno">  202 </span>-- inside of it to 'TyAppRep' and annotate the head with 'BuiltinHead'.
<span class="lineno">  203 </span>--
<span class="lineno">  204 </span>-- The idea is that we don't need to process built-in types manually if we simply add some
<span class="lineno">  205 </span>-- annotations for instance resolution to look for. Think what we'd have to do manually for, say,
<span class="lineno">  206 </span>-- 'ToHoles': traverse the spine of the application and collect all the holes into a list, which is
<span class="lineno">  207 </span>-- troubling, because type applications are left-nested and lists are right-nested, so we'd have to
<span class="lineno">  208 </span>-- use accumulators or an explicit 'Reverse' type family. And then we also have 'KnownTypeAst' and
<span class="lineno">  209 </span>-- 'ToBinds', so handling built-in types in a special way for each of those would be a hassle,
<span class="lineno">  210 </span>-- especially given the fact that type-level Haskell is not exactly good at computing things.
<span class="lineno">  211 </span>-- With the 'ElaborateBuiltin' approach we get 'KnownTypeAst', 'ToHoles' and 'ToBinds' for free.
<span class="lineno">  212 </span>--
<span class="lineno">  213 </span>-- We make this an open type family, so that elaboration is customizable for each universe.
<span class="lineno">  214 </span>type ElaborateBuiltin :: forall a. (GHC.Type -&gt; GHC.Type) -&gt; a -&gt; a
<span class="lineno">  215 </span>type family ElaborateBuiltin uni x
<span class="lineno">  216 </span>
<span class="lineno">  217 </span>-- | Take a constraint and use it to constrain every argument of a possibly 0-ary elaborated
<span class="lineno">  218 </span>-- application of a built-in type.
<span class="lineno">  219 </span>type AllElaboratedArgs :: forall a. (GHC.Type -&gt; GHC.Constraint) -&gt; a -&gt; GHC.Constraint
<span class="lineno">  220 </span>type family AllElaboratedArgs constr x where
<span class="lineno">  221 </span>    AllElaboratedArgs constr (f `TyAppRep` x) = (constr x, AllElaboratedArgs constr f)
<span class="lineno">  222 </span>    AllElaboratedArgs _      (BuiltinHead _)  = ()
<span class="lineno">  223 </span>
<span class="lineno">  224 </span>-- | Take a constraint and use it to constrain every argument of a possibly 0-ary application of a
<span class="lineno">  225 </span>-- built-in type.
<span class="lineno">  226 </span>type AllBuiltinArgs
<span class="lineno">  227 </span>        :: forall a. (GHC.Type -&gt; GHC.Type) -&gt; (GHC.Type -&gt; GHC.Constraint) -&gt; a -&gt; GHC.Constraint
<span class="lineno">  228 </span>class    AllElaboratedArgs constr (ElaborateBuiltin uni x) =&gt; AllBuiltinArgs uni constr x
<span class="lineno">  229 </span>instance AllElaboratedArgs constr (ElaborateBuiltin uni x) =&gt; AllBuiltinArgs uni constr x
<span class="lineno">  230 </span>
<span class="lineno">  231 </span>-- Custom type errors to guide the programmer adding a new built-in function.
<span class="lineno">  232 </span>
<span class="lineno">  233 </span>-- We don't have @Unsatisfiable@ yet (https://github.com/ghc-proposals/ghc-proposals/pull/433).
<span class="lineno">  234 </span>-- | To be used when there's a 'TypeError' in the context. The condition is not checked as there's
<span class="lineno">  235 </span>-- no way we could do that.
<span class="lineno">  236 </span>underTypeError :: void
<span class="lineno">  237 </span><span class="decl"><span class="nottickedoff">underTypeError = error &quot;Panic: a 'TypeError' was bypassed&quot;</span></span>
<span class="lineno">  238 </span>
<span class="lineno">  239 </span>type NoStandalonePolymorphicDataErrMsg =
<span class="lineno">  240 </span>    'Text &quot;An unwrapped built-in type constructor can't be applied to a type variable&quot; ':$$:
<span class="lineno">  241 </span>    'Text &quot;Are you trying to define a polymorphic built-in function over a polymorphic type?&quot; ':$$:
<span class="lineno">  242 </span>    'Text &quot;In that case you need to wrap all polymorphic built-in types applied to type&quot; ':$$:
<span class="lineno">  243 </span>    'Text &quot; variables with either ‘SomeConstant’ or ‘Opaque’ depending on whether its the&quot; ':$$:
<span class="lineno">  244 </span>    'Text &quot; type of an argument or the type of the result, respectively&quot;
<span class="lineno">  245 </span>
<span class="lineno">  246 </span>instance TypeError NoStandalonePolymorphicDataErrMsg =&gt; uni `Contains` TyVarRep where
<span class="lineno">  247 </span>    <span class="decl"><span class="nottickedoff">knownUni = underTypeError</span></span>
<span class="lineno">  248 </span>
<span class="lineno">  249 </span>type NoConstraintsErrMsg =
<span class="lineno">  250 </span>    'Text &quot;Built-in functions are not allowed to have constraints&quot; ':$$:
<span class="lineno">  251 </span>    'Text &quot;To fix this error instantiate all constrained type variables&quot;
<span class="lineno">  252 </span>
<span class="lineno">  253 </span>instance <span class="decl"><span class="nottickedoff">TypeError NoConstraintsErrMsg =&gt; Eq (Opaque val rep)</span></span> where
<span class="lineno">  254 </span>    <span class="decl"><span class="nottickedoff">(==) = underTypeError</span></span>
<span class="lineno">  255 </span>
<span class="lineno">  256 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">TypeError NoConstraintsErrMsg =&gt; Ord (Opaque val rep)</span></span></span></span></span></span></span></span></span></span></span></span> where
<span class="lineno">  257 </span>    <span class="decl"><span class="nottickedoff">compare = underTypeError</span></span>
<span class="lineno">  258 </span>
<span class="lineno">  259 </span>instance <span class="decl"><span class="nottickedoff">TypeError NoConstraintsErrMsg =&gt; Num (Opaque val rep)</span></span> where
<span class="lineno">  260 </span>    <span class="decl"><span class="nottickedoff">(+)         = underTypeError</span></span>
<span class="lineno">  261 </span>    <span class="decl"><span class="nottickedoff">(*)         = underTypeError</span></span>
<span class="lineno">  262 </span>    <span class="decl"><span class="nottickedoff">abs         = underTypeError</span></span>
<span class="lineno">  263 </span>    <span class="decl"><span class="nottickedoff">signum      = underTypeError</span></span>
<span class="lineno">  264 </span>    <span class="decl"><span class="nottickedoff">fromInteger = underTypeError</span></span>
<span class="lineno">  265 </span>    <span class="decl"><span class="nottickedoff">negate      = underTypeError</span></span>
<span class="lineno">  266 </span>
<span class="lineno">  267 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">TypeError NoConstraintsErrMsg =&gt; Enum (Opaque val rep)</span></span></span></span></span></span></span></span></span></span></span></span> where
<span class="lineno">  268 </span>    <span class="decl"><span class="nottickedoff">toEnum   = underTypeError</span></span>
<span class="lineno">  269 </span>    <span class="decl"><span class="nottickedoff">fromEnum = underTypeError</span></span>
<span class="lineno">  270 </span>
<span class="lineno">  271 </span>instance TypeError NoConstraintsErrMsg =&gt; Real (Opaque val rep) where
<span class="lineno">  272 </span>    <span class="decl"><span class="nottickedoff">toRational = underTypeError</span></span>
<span class="lineno">  273 </span>
<span class="lineno">  274 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">TypeError NoConstraintsErrMsg =&gt; Integral (Opaque val rep)</span></span></span></span></span></span></span></span> where
<span class="lineno">  275 </span>    <span class="decl"><span class="nottickedoff">quotRem   = underTypeError</span></span>
<span class="lineno">  276 </span>    <span class="decl"><span class="nottickedoff">divMod    = underTypeError</span></span>
<span class="lineno">  277 </span>    <span class="decl"><span class="nottickedoff">toInteger = underTypeError</span></span>
<span class="lineno">  278 </span>
<span class="lineno">  279 </span>instance TypeError NoConstraintsErrMsg =&gt; Bounded (Opaque val rep) where
<span class="lineno">  280 </span>    <span class="decl"><span class="nottickedoff">minBound = underTypeError</span></span>
<span class="lineno">  281 </span>    <span class="decl"><span class="nottickedoff">maxBound = underTypeError</span></span>
<span class="lineno">  282 </span>
<span class="lineno">  283 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">TypeError NoConstraintsErrMsg =&gt; Ix (Opaque val rep)</span></span></span></span></span></span> where
<span class="lineno">  284 </span>    <span class="decl"><span class="nottickedoff">range   = underTypeError</span></span>
<span class="lineno">  285 </span>    <span class="decl"><span class="nottickedoff">index   = underTypeError</span></span>
<span class="lineno">  286 </span>    <span class="decl"><span class="nottickedoff">inRange = underTypeError</span></span>
<span class="lineno">  287 </span>
<span class="lineno">  288 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">TypeError NoConstraintsErrMsg =&gt; Semigroup (Opaque val rep)</span></span></span></span> where
<span class="lineno">  289 </span>    <span class="decl"><span class="nottickedoff">(&lt;&gt;) = underTypeError</span></span>
<span class="lineno">  290 </span>
<span class="lineno">  291 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">TypeError NoConstraintsErrMsg =&gt; Monoid (Opaque val rep)</span></span></span></span> where
<span class="lineno">  292 </span>    <span class="decl"><span class="nottickedoff">mempty = underTypeError</span></span>

</pre>
</body>
</html>
