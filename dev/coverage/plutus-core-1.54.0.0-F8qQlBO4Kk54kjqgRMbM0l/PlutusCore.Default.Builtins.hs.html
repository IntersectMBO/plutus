<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>-- editorconfig-checker-disable-file
<span class="lineno">    2 </span>{-# LANGUAGE BangPatterns          #-}
<span class="lineno">    3 </span>{-# LANGUAGE CPP                   #-}
<span class="lineno">    4 </span>{-# LANGUAGE DataKinds             #-}
<span class="lineno">    5 </span>{-# LANGUAGE DeriveAnyClass        #-}
<span class="lineno">    6 </span>{-# LANGUAGE FlexibleInstances     #-}
<span class="lineno">    7 </span>{-# LANGUAGE InstanceSigs          #-}
<span class="lineno">    8 </span>{-# LANGUAGE LambdaCase            #-}
<span class="lineno">    9 </span>{-# LANGUAGE MagicHash             #-}
<span class="lineno">   10 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">   11 </span>{-# LANGUAGE OverloadedStrings     #-}
<span class="lineno">   12 </span>{-# LANGUAGE ScopedTypeVariables   #-}
<span class="lineno">   13 </span>{-# LANGUAGE TypeFamilies          #-}
<span class="lineno">   14 </span>{-# LANGUAGE TypeOperators         #-}
<span class="lineno">   15 </span>{-# LANGUAGE UndecidableInstances  #-}
<span class="lineno">   16 </span>
<span class="lineno">   17 </span>module PlutusCore.Default.Builtins where
<span class="lineno">   18 </span>
<span class="lineno">   19 </span>import PlutusPrelude
<span class="lineno">   20 </span>
<span class="lineno">   21 </span>import PlutusCore.Builtin
<span class="lineno">   22 </span>import PlutusCore.Data (Data (..))
<span class="lineno">   23 </span>import PlutusCore.Default.Universe
<span class="lineno">   24 </span>import PlutusCore.Evaluation.Machine.BuiltinCostModel
<span class="lineno">   25 </span>import PlutusCore.Evaluation.Machine.ExBudgetStream (ExBudgetStream)
<span class="lineno">   26 </span>import PlutusCore.Evaluation.Machine.ExMemoryUsage (ExMemoryUsage, IntegerCostedLiterally (..),
<span class="lineno">   27 </span>                                                    NumBytesCostedAsNumWords (..), memoryUsage,
<span class="lineno">   28 </span>                                                    singletonRose)
<span class="lineno">   29 </span>import PlutusCore.Pretty (PrettyConfigPlc)
<span class="lineno">   30 </span>import PlutusCore.Value (Value)
<span class="lineno">   31 </span>import PlutusCore.Value qualified as Value
<span class="lineno">   32 </span>
<span class="lineno">   33 </span>import PlutusCore.Bitwise qualified as Bitwise
<span class="lineno">   34 </span>import PlutusCore.Crypto.BLS12_381.G1 qualified as BLS12_381.G1
<span class="lineno">   35 </span>import PlutusCore.Crypto.BLS12_381.G2 qualified as BLS12_381.G2
<span class="lineno">   36 </span>import PlutusCore.Crypto.BLS12_381.Pairing qualified as BLS12_381.Pairing
<span class="lineno">   37 </span>import PlutusCore.Crypto.Ed25519 (verifyEd25519Signature)
<span class="lineno">   38 </span>import PlutusCore.Crypto.ExpMod qualified as ExpMod
<span class="lineno">   39 </span>import PlutusCore.Crypto.Hash qualified as Hash
<span class="lineno">   40 </span>import PlutusCore.Crypto.Secp256k1 (verifyEcdsaSecp256k1Signature, verifySchnorrSecp256k1Signature)
<span class="lineno">   41 </span>
<span class="lineno">   42 </span>import Codec.Serialise (serialise)
<span class="lineno">   43 </span>import Control.Monad (unless)
<span class="lineno">   44 </span>import Control.Monad.Except (throwError)
<span class="lineno">   45 </span>import Data.ByteString (ByteString)
<span class="lineno">   46 </span>import Data.ByteString qualified as BS
<span class="lineno">   47 </span>import Data.ByteString.Lazy qualified as BSL
<span class="lineno">   48 </span>import Data.Ix (Ix)
<span class="lineno">   49 </span>import Data.Text (Text)
<span class="lineno">   50 </span>import Data.Text.Encoding (decodeUtf8', encodeUtf8)
<span class="lineno">   51 </span>import Data.Vector.Strict (Vector)
<span class="lineno">   52 </span>import Data.Vector.Strict qualified as Vector
<span class="lineno">   53 </span>import GHC.Natural (naturalFromInteger)
<span class="lineno">   54 </span>import GHC.Num.Integer (Integer (..))
<span class="lineno">   55 </span>import GHC.Types (Int (..))
<span class="lineno">   56 </span>import NoThunks.Class (NoThunks)
<span class="lineno">   57 </span>import PlutusCore.Flat hiding (from, to)
<span class="lineno">   58 </span>import PlutusCore.Flat.Decoder (Get, dBEBits8)
<span class="lineno">   59 </span>import PlutusCore.Flat.Encoder as Flat (Encoding, NumBits, eBits)
<span class="lineno">   60 </span>import Prettyprinter (viaShow)
<span class="lineno">   61 </span>
<span class="lineno">   62 </span>-- TODO: should we have the commonest built-in functions at the front to have more compact encoding?
<span class="lineno">   63 </span>-- | Default built-in functions.
<span class="lineno">   64 </span>--
<span class="lineno">   65 </span>-- When updating these, make sure to add them to the protocol version listing!
<span class="lineno">   66 </span>-- See Note [New builtins/language versions and protocol versions]
<span class="lineno">   67 </span>data DefaultFun
<span class="lineno">   68 </span>    -- Integers
<span class="lineno">   69 </span>    = AddInteger
<span class="lineno">   70 </span>    | SubtractInteger
<span class="lineno">   71 </span>    | MultiplyInteger
<span class="lineno">   72 </span>    | DivideInteger
<span class="lineno">   73 </span>    | QuotientInteger
<span class="lineno">   74 </span>    | RemainderInteger
<span class="lineno">   75 </span>    | ModInteger
<span class="lineno">   76 </span>    | EqualsInteger
<span class="lineno">   77 </span>    | LessThanInteger
<span class="lineno">   78 </span>    | LessThanEqualsInteger
<span class="lineno">   79 </span>    -- Bytestrings
<span class="lineno">   80 </span>    | AppendByteString
<span class="lineno">   81 </span>    | ConsByteString
<span class="lineno">   82 </span>    | SliceByteString
<span class="lineno">   83 </span>    | LengthOfByteString
<span class="lineno">   84 </span>    | IndexByteString
<span class="lineno">   85 </span>    | EqualsByteString
<span class="lineno">   86 </span>    | LessThanByteString
<span class="lineno">   87 </span>    | LessThanEqualsByteString
<span class="lineno">   88 </span>    -- Cryptography and hashes
<span class="lineno">   89 </span>    | Sha2_256
<span class="lineno">   90 </span>    | Sha3_256
<span class="lineno">   91 </span>    | Blake2b_256
<span class="lineno">   92 </span>    | VerifyEd25519Signature  -- formerly verifySignature
<span class="lineno">   93 </span>    | VerifyEcdsaSecp256k1Signature
<span class="lineno">   94 </span>    | VerifySchnorrSecp256k1Signature
<span class="lineno">   95 </span>    -- Strings
<span class="lineno">   96 </span>    | AppendString
<span class="lineno">   97 </span>    | EqualsString
<span class="lineno">   98 </span>    | EncodeUtf8
<span class="lineno">   99 </span>    | DecodeUtf8
<span class="lineno">  100 </span>    -- Bool
<span class="lineno">  101 </span>    | IfThenElse
<span class="lineno">  102 </span>    -- Unit
<span class="lineno">  103 </span>    | ChooseUnit
<span class="lineno">  104 </span>    -- Tracing
<span class="lineno">  105 </span>    | Trace
<span class="lineno">  106 </span>    -- Pairs
<span class="lineno">  107 </span>    | FstPair
<span class="lineno">  108 </span>    | SndPair
<span class="lineno">  109 </span>    -- Lists
<span class="lineno">  110 </span>    | ChooseList
<span class="lineno">  111 </span>    | MkCons
<span class="lineno">  112 </span>    | HeadList
<span class="lineno">  113 </span>    | TailList
<span class="lineno">  114 </span>    | NullList
<span class="lineno">  115 </span>    -- Data
<span class="lineno">  116 </span>    -- See Note [Legacy pattern matching on built-in types].
<span class="lineno">  117 </span>    -- It is convenient to have a &quot;choosing&quot; function for a data type that has more than two
<span class="lineno">  118 </span>    -- constructors to get pattern matching over it and we may end up having multiple such data
<span class="lineno">  119 </span>    -- types, hence we include the name of the data type as a suffix.
<span class="lineno">  120 </span>    | ChooseData
<span class="lineno">  121 </span>    | ConstrData
<span class="lineno">  122 </span>    | MapData
<span class="lineno">  123 </span>    | ListData
<span class="lineno">  124 </span>    | IData
<span class="lineno">  125 </span>    | BData
<span class="lineno">  126 </span>    | UnConstrData
<span class="lineno">  127 </span>    | UnMapData
<span class="lineno">  128 </span>    | UnListData
<span class="lineno">  129 </span>    | UnIData
<span class="lineno">  130 </span>    | UnBData
<span class="lineno">  131 </span>    | EqualsData
<span class="lineno">  132 </span>    | SerialiseData
<span class="lineno">  133 </span>    -- Misc monomorphized constructors.
<span class="lineno">  134 </span>    -- We could simply replace those with constants, but we use built-in functions for consistency
<span class="lineno">  135 </span>    -- with monomorphic built-in types. Polymorphic built-in constructors are generally problematic,
<span class="lineno">  136 </span>    -- See Note [Representable built-in functions over polymorphic built-in types].
<span class="lineno">  137 </span>    | MkPairData
<span class="lineno">  138 </span>    | MkNilData
<span class="lineno">  139 </span>    | MkNilPairData
<span class="lineno">  140 </span>    -- BLS12_381 operations
<span class="lineno">  141 </span>    -- G1
<span class="lineno">  142 </span>    | Bls12_381_G1_add
<span class="lineno">  143 </span>    | Bls12_381_G1_neg
<span class="lineno">  144 </span>    | Bls12_381_G1_scalarMul
<span class="lineno">  145 </span>    | Bls12_381_G1_equal
<span class="lineno">  146 </span>    | Bls12_381_G1_hashToGroup
<span class="lineno">  147 </span>    | Bls12_381_G1_compress
<span class="lineno">  148 </span>    | Bls12_381_G1_uncompress
<span class="lineno">  149 </span>    -- G2
<span class="lineno">  150 </span>    | Bls12_381_G2_add
<span class="lineno">  151 </span>    | Bls12_381_G2_neg
<span class="lineno">  152 </span>    | Bls12_381_G2_scalarMul
<span class="lineno">  153 </span>    | Bls12_381_G2_equal
<span class="lineno">  154 </span>    | Bls12_381_G2_hashToGroup
<span class="lineno">  155 </span>    | Bls12_381_G2_compress
<span class="lineno">  156 </span>    | Bls12_381_G2_uncompress
<span class="lineno">  157 </span>    -- Pairing
<span class="lineno">  158 </span>    | Bls12_381_millerLoop
<span class="lineno">  159 </span>    | Bls12_381_mulMlResult
<span class="lineno">  160 </span>    | Bls12_381_finalVerify
<span class="lineno">  161 </span>    -- Keccak_256, Blake2b_224
<span class="lineno">  162 </span>    | Keccak_256
<span class="lineno">  163 </span>    | Blake2b_224
<span class="lineno">  164 </span>    -- Conversions
<span class="lineno">  165 </span>    | IntegerToByteString
<span class="lineno">  166 </span>    | ByteStringToInteger
<span class="lineno">  167 </span>    -- Logical
<span class="lineno">  168 </span>    | AndByteString
<span class="lineno">  169 </span>    | OrByteString
<span class="lineno">  170 </span>    | XorByteString
<span class="lineno">  171 </span>    | ComplementByteString
<span class="lineno">  172 </span>    | ReadBit
<span class="lineno">  173 </span>    | WriteBits
<span class="lineno">  174 </span>    | ReplicateByte
<span class="lineno">  175 </span>    -- Bitwise
<span class="lineno">  176 </span>    | ShiftByteString
<span class="lineno">  177 </span>    | RotateByteString
<span class="lineno">  178 </span>    | CountSetBits
<span class="lineno">  179 </span>    | FindFirstSetBit
<span class="lineno">  180 </span>    -- Ripemd_160
<span class="lineno">  181 </span>    | Ripemd_160
<span class="lineno">  182 </span>    -- Batch 6
<span class="lineno">  183 </span>    | ExpModInteger
<span class="lineno">  184 </span>    | DropList
<span class="lineno">  185 </span>    -- Arrays
<span class="lineno">  186 </span>    | LengthOfArray
<span class="lineno">  187 </span>    | ListToArray
<span class="lineno">  188 </span>    | IndexArray
<span class="lineno">  189 </span>    -- BLS12_381 multi scalar multiplication
<span class="lineno">  190 </span>    | Bls12_381_G1_multiScalarMul
<span class="lineno">  191 </span>    | Bls12_381_G2_multiScalarMul
<span class="lineno">  192 </span>    -- Values
<span class="lineno">  193 </span>    | InsertCoin
<span class="lineno">  194 </span>    | LookupCoin
<span class="lineno">  195 </span>    | UnionValue
<span class="lineno">  196 </span>    | ValueContains
<span class="lineno">  197 </span>    | ValueData
<span class="lineno">  198 </span>    | UnValueData
<span class="lineno">  199 </span>    deriving stock (<span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Enum</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Bounded</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Ix</span></span></span></span></span></span></span></span></span></span></span></span>)
<span class="lineno">  200 </span>    deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Hashable</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">PrettyBy PrettyConfigPlc</span></span></span></span>)
<span class="lineno">  201 </span>
<span class="lineno">  202 </span>{- Note [Textual representation of names of built-in functions]. The plc parser
<span class="lineno">  203 </span> parses builtin names by looking at an enumeration of all of the built-in
<span class="lineno">  204 </span> functions and checking whether the given name matches the pretty-printed name,
<span class="lineno">  205 </span> obtained using the instance below.  Thus the definitive forms of the names of
<span class="lineno">  206 </span> the built-in functions are obtained by applying the function below to the
<span class="lineno">  207 </span> constructor names above. -}
<span class="lineno">  208 </span>instance <span class="decl"><span class="nottickedoff">Pretty DefaultFun</span></span> where
<span class="lineno">  209 </span>    <span class="decl"><span class="istickedoff">pretty fun = pretty $ lowerInitialChar $ show fun</span></span>
<span class="lineno">  210 </span>
<span class="lineno">  211 </span>instance ExMemoryUsage DefaultFun where
<span class="lineno">  212 </span>    <span class="decl"><span class="nottickedoff">memoryUsage _ = singletonRose 1</span></span>
<span class="lineno">  213 </span>    {-# INLINE memoryUsage #-}
<span class="lineno">  214 </span>
<span class="lineno">  215 </span>-- | Turn a function into another function that 'fail's when its second argument is @0@ or calls the
<span class="lineno">  216 </span>-- original function otherwise and wraps the result in 'pure'. Useful for correctly handling `div`,
<span class="lineno">  217 </span>-- `mod`, etc.
<span class="lineno">  218 </span>nonZeroSecondArg
<span class="lineno">  219 </span>    :: (Integer -&gt; Integer -&gt; Integer) -&gt; Integer -&gt; Integer -&gt; BuiltinResult Integer
<span class="lineno">  220 </span>-- If we match against @IS 0#@ instead of @0@, GHC will generate tidier Core for some reason. It
<span class="lineno">  221 </span>-- probably doesn't really matter performance-wise, but would be easier to read. We don't do it out
<span class="lineno">  222 </span>-- of paranoia and because it requires importing the 'IS' constructor, which is in different
<span class="lineno">  223 </span>-- packages depending on the GHC version, so requires a bunch of irritating CPP.
<span class="lineno">  224 </span>--
<span class="lineno">  225 </span>-- We could also replace 'div' with 'integerDiv' (and do the same for other division builtins) at
<span class="lineno">  226 </span>-- the call site of this function in order to avoid double matching against @0@, but that also
<span class="lineno">  227 </span>-- requires CPP. Perhaps we can afford one additional pattern match for division builtins for the
<span class="lineno">  228 </span>-- time being, since those aren't particularly fast anyway.
<span class="lineno">  229 </span>--
<span class="lineno">  230 </span>-- The bang is to communicate to GHC that the function is strict in both the arguments just in case
<span class="lineno">  231 </span>-- it'd want to allocate a thunk for the first argument otherwise.
<span class="lineno">  232 </span><span class="decl"><span class="istickedoff">nonZeroSecondArg _ !_ 0 =</span>
<span class="lineno">  233 </span><span class="spaces">    </span><span class="istickedoff">-- See Note [Structural vs operational errors within builtins].</span>
<span class="lineno">  234 </span><span class="spaces">    </span><span class="istickedoff">fail &quot;Cannot divide by zero&quot;</span>
<span class="lineno">  235 </span><span class="spaces"></span><span class="istickedoff">nonZeroSecondArg f  x y = pure $ f x y</span></span>
<span class="lineno">  236 </span>{-# INLINE nonZeroSecondArg #-}
<span class="lineno">  237 </span>
<span class="lineno">  238 </span>-- | Turn a function returning 'Either' into another function that 'fail's in the 'Left' case and
<span class="lineno">  239 </span>-- wraps the result in 'pure' in the 'Right' case.
<span class="lineno">  240 </span>eitherToBuiltinResult :: Show e =&gt; Either e r -&gt; BuiltinResult r
<span class="lineno">  241 </span><span class="decl"><span class="istickedoff">eitherToBuiltinResult = either (fail . <span class="nottickedoff">show</span>) pure</span></span>
<span class="lineno">  242 </span>{-# INLINE eitherToBuiltinResult #-}
<span class="lineno">  243 </span>
<span class="lineno">  244 </span>{- Note [Constants vs built-in functions]
<span class="lineno">  245 </span>A constant is any value of a built-in type. For example, 'Integer' is a built-in type, so anything
<span class="lineno">  246 </span>of type 'Integer' is a constant.
<span class="lineno">  247 </span>
<span class="lineno">  248 </span>On the contrary a built-in function can't be of a built-in type, because the type of a built-in
<span class="lineno">  249 </span>function is always of either the @all a. b@ form or the @a -&gt; b@ one, none of which is a built-in
<span class="lineno">  250 </span>type. This is checked by the machinery, so if the user tries to add a built-in function that is not
<span class="lineno">  251 </span>of one of these forms, they'll get a nice custom type error.
<span class="lineno">  252 </span>
<span class="lineno">  253 </span>A built-in function is associated with its Haskell implementation: there can be many built-in
<span class="lineno">  254 </span>functions of the same type, all doing different things, and there can be infinitely more _definable_
<span class="lineno">  255 </span>built-in functions of the same type that are not built-in functions nonetheless, because we didn't
<span class="lineno">  256 </span>register them as such by providing a Haskell implementation for each of them. This is the difference
<span class="lineno">  257 </span>between constants and built-in functions: the set of constants (infinite in our case) depends solely
<span class="lineno">  258 </span>on the set of available built-in types (also infinite in our case, because we have @Integer@,
<span class="lineno">  259 </span>@[Integer]@, @[[Integer]]@ etc), while the set of built-in functions is defined by explicitly
<span class="lineno">  260 </span>assigning each member a specific name and an associated with it Haskell implementation. It is
<span class="lineno">  261 </span>theoretically possible to have an infinite set of built-in functions, but we neither do that nor
<span class="lineno">  262 </span>need it, hence our set of built-in functions is finite.
<span class="lineno">  263 </span>
<span class="lineno">  264 </span>The rule of thumb is: constants are raw data and built-in functions are, well, functions.
<span class="lineno">  265 </span>
<span class="lineno">  266 </span>@(:)@ works as follows: it takes two constants wrapped as values, extracts an integer from the first
<span class="lineno">  267 </span>constant and a list of integers from the second one, prepends the former to the latter and wraps the
<span class="lineno">  268 </span>resulting list back into a constant, which gets wrapped into a value.
<span class="lineno">  269 </span>
<span class="lineno">  270 </span>Why does @(:)@ have to be a built-in function? Because its type is
<span class="lineno">  271 </span>
<span class="lineno">  272 </span>    all a. a -&gt; list a -&gt; list a
<span class="lineno">  273 </span>
<span class="lineno">  274 </span>and if we tried to make @(:)@ a constant we'd have to somehow make this type a built-in type and
<span class="lineno">  275 </span>promise that every value (i.e. every definable function) of this type can be used as a Plutus term,
<span class="lineno">  276 </span>which doesn't make any sense. Only the particular Haskell implementation that prepends an element to
<span class="lineno">  277 </span>a list is what we're interested in.
<span class="lineno">  278 </span>
<span class="lineno">  279 </span>Why may @[]@ not be a built-in function? If its type is hardcoded to @[Integer]@, then that's a
<span class="lineno">  280 </span>built-in type and we know that anything of a built-in type can be embedded into a term as a
<span class="lineno">  281 </span>constant. I.e. @[] :: [Integer]@ is perfectly fine as a constant and does not need to be a built-in
<span class="lineno">  282 </span>function.
<span class="lineno">  283 </span>
<span class="lineno">  284 </span>Why may @[]@ be a built-in function? If it's polymorphic over the type of the elements, then its
<span class="lineno">  285 </span>Plutus Core type is @all a. list a@ and that is not a built-in type, hence we have to make that a
<span class="lineno">  286 </span>built-in function.
<span class="lineno">  287 </span>-}
<span class="lineno">  288 </span>
<span class="lineno">  289 </span>{- Note [How to add a built-in function: simple cases]
<span class="lineno">  290 </span>This Note explains how to add a built-in function and how to read definitions of existing built-in
<span class="lineno">  291 </span>functions. It does not attempt to explain why things the way they are, that is explained in comments
<span class="lineno">  292 </span>in relevant modules, check out the following for an overview of the module structure:
<span class="lineno">  293 </span>https://github.com/IntersectMBO/plutus/blob/97c2b2c6975e41ce25ee5efa1dff0f1bd891a589/plutus-core/docs/BuiltinsOverview.md
<span class="lineno">  294 </span>
<span class="lineno">  295 </span>In order to add a new built-in function one needs to add a constructor to 'DefaultFun' and handle
<span class="lineno">  296 </span>it within the @ToBuiltinMeaning uni DefaultFun@ instance. The general pattern is
<span class="lineno">  297 </span>
<span class="lineno">  298 </span>    toBuiltinMeaning semvar &lt;BuiltinName&gt; =
<span class="lineno">  299 </span>        let &lt;builtinNameDenotation&gt; :: BS.ByteString -&gt; BS.ByteString
<span class="lineno">  300 </span>            &lt;builtinNameDenotation&gt; = &lt;denotation&gt;
<span class="lineno">  301 </span>            {-# INLINE &lt;builtinNameDenotation&gt; #-}
<span class="lineno">  302 </span>        in makeBuiltinMeaning
<span class="lineno">  303 </span>            &lt;builtinNameDenotation&gt;
<span class="lineno">  304 </span>            &lt;costingFunction&gt;
<span class="lineno">  305 </span>
<span class="lineno">  306 </span>Here's a specific example:
<span class="lineno">  307 </span>
<span class="lineno">  308 </span>    toBuiltinMeaning _ AddInteger =
<span class="lineno">  309 </span>        let addIntegerDenotation :: Integer -&gt; Integer -&gt; Integer
<span class="lineno">  310 </span>            addIntegerDenotation = (+)
<span class="lineno">  311 </span>            {-# INLINE addIntegerDenotation #-}
<span class="lineno">  312 </span>        in makeBuiltinMeaning
<span class="lineno">  313 </span>            addIntegerDenotation
<span class="lineno">  314 </span>            (runCostingFunTwoArguments . paramAddInteger)
<span class="lineno">  315 </span>
<span class="lineno">  316 </span>'makeBuiltinMeaning' creates a Plutus builtin out of its denotation (i.e. Haskell implementation)
<span class="lineno">  317 </span>and a costing function for it. Once a builtin is added, its Plutus type is kind-checked and printed
<span class="lineno">  318 </span>to a golden file automatically (consult @git status@). 'toBuiltinMeaning' also takes a
<span class="lineno">  319 </span>'BuiltinSemanticsVariant' argument which allows a particular builtin name to have multiple
<span class="lineno">  320 </span>associated denotations (see Note [Builtin semantics variants]), but for simplicity we assume in the
<span class="lineno">  321 </span>examples below that all builtins have only one variant rendering the @semvar@ argument irrelevant.
<span class="lineno">  322 </span>
<span class="lineno">  323 </span>See Note [Builtin semantics variants] for how @semvar@ enables us to customize the behavior of a
<span class="lineno">  324 </span>built-in function. For the purpose of these docs we're going to ignore that and use @_@ instead of
<span class="lineno">  325 </span>@semvar@.
<span class="lineno">  326 </span>
<span class="lineno">  327 </span>Note that it's very important for the denotation to have an explicit type signature for several
<span class="lineno">  328 </span>reasons:
<span class="lineno">  329 </span>
<span class="lineno">  330 </span>1. makes it easier to review the code and make sure it makes sense
<span class="lineno">  331 </span>2. makes it easier to search for builtins associated with certain types -- just @grep@ for the type
<span class="lineno">  332 </span>3. most importantly, if we let GHC infer the types, there's a small but very real chance that
<span class="lineno">  333 </span>   updating a library to a newer version will change the type of some definition used within the
<span class="lineno">  334 </span>   denotation of a builtin and that may get reflected in the type signature of the builtin without
<span class="lineno">  335 </span>   us noticing, since the builtins machinery will gladly swallow the change. And since the type
<span class="lineno">  336 </span>   signature of a builtin determines its behavior via ad hoc polymorphism a change in the type
<span class="lineno">  337 </span>   signature can cause a sudden hardfork, which would be very bad
<span class="lineno">  338 </span>
<span class="lineno">  339 </span>hence we specify the type signature for the denotation of each builtin explicitly and always create
<span class="lineno">  340 </span>a @let@ binding for consistency. We add an @INLINE@ pragma to the @let@ binding to make sure that
<span class="lineno">  341 </span>the binding doesn't get in the way of performance.
<span class="lineno">  342 </span>
<span class="lineno">  343 </span>Below we will enumerate what kind of denotations are accepted by 'makeBuiltinMeaning' without
<span class="lineno">  344 </span>touching any costing stuff.
<span class="lineno">  345 </span>
<span class="lineno">  346 </span>1. The simplest example of an accepted denotation is a monomorphic function that takes values of
<span class="lineno">  347 </span>built-in types and returns a value of a built-in type as well. For example
<span class="lineno">  348 </span>
<span class="lineno">  349 </span>    encodeUtf8 :: Text -&gt; BS.ByteString
<span class="lineno">  350 </span>
<span class="lineno">  351 </span>You can feed 'encodeUtf8' directly to 'makeBuiltinMeaning' without specifying any types:
<span class="lineno">  352 </span>
<span class="lineno">  353 </span>    toBuiltinMeaning _ EncodeUtf8 =
<span class="lineno">  354 </span>        let encodeUtf8Denotation :: Text -&gt; BS.ByteString
<span class="lineno">  355 </span>            encodeUtf8Denotation = encodeUtf8
<span class="lineno">  356 </span>            {-# INLINE encodeUtf8Denotation #-}
<span class="lineno">  357 </span>        in makeBuiltinMeaning
<span class="lineno">  358 </span>            encodeUtf8Denotation
<span class="lineno">  359 </span>            &lt;costingFunction&gt;
<span class="lineno">  360 </span>
<span class="lineno">  361 </span>This will add the builtin, the only two things that remain are implementing costing for this
<span class="lineno">  362 </span>builtin (out of the scope of this Note) and handling it within the @Flat DefaultFun@ instance
<span class="lineno">  363 </span>(see Note [Stable encoding of TPLC]).
<span class="lineno">  364 </span>
<span class="lineno">  365 </span>2. Unconstrained type variables are fine, you don't need to instantiate them. For example
<span class="lineno">  366 </span>
<span class="lineno">  367 </span>    toBuiltinMeaning _ IfThenElse =
<span class="lineno">  368 </span>        let ifThenElseDenotation :: Bool -&gt; a -&gt; a -&gt; a
<span class="lineno">  369 </span>            ifThenElseDenotation b x y = if b then x else y
<span class="lineno">  370 </span>            {-# INLINE ifThenElseDenotation #-}
<span class="lineno">  371 </span>        in makeBuiltinMeaning
<span class="lineno">  372 </span>            ifThenElseDenotation
<span class="lineno">  373 </span>            &lt;costingFunction&gt;
<span class="lineno">  374 </span>
<span class="lineno">  375 </span>works alright. The Haskell type of the denotation is
<span class="lineno">  376 </span>
<span class="lineno">  377 </span>    forall a. Bool -&gt; a -&gt; a -&gt; a
<span class="lineno">  378 </span>
<span class="lineno">  379 </span>whose counterpart in Plutus is
<span class="lineno">  380 </span>
<span class="lineno">  381 </span>    all a. bool -&gt; a -&gt; a -&gt; a
<span class="lineno">  382 </span>
<span class="lineno">  383 </span>and unsurprisingly it's the exact Plutus type of the added builtin.
<span class="lineno">  384 </span>
<span class="lineno">  385 </span>It may seem like getting the latter from the former is entirely trivial, however
<span class="lineno">  386 </span>'makeBuiltinMeaning' jumps through quite a few hoops to achieve that and below we'll consider those
<span class="lineno">  387 </span>of them that are important to know to be able to use 'makeBuiltinMeaning' in cases that are more
<span class="lineno">  388 </span>complicated than a simple monomorphic or polymorphic function. But for now let's talk about a few
<span class="lineno">  389 </span>more simple cases.
<span class="lineno">  390 </span>
<span class="lineno">  391 </span>3. Certain types are not built-in, but can be represented via built-in ones. For example, we don't
<span class="lineno">  392 </span>have 'Int' built-in, but we have 'Integer' and we can represent the former in terms of the
<span class="lineno">  393 </span>latter. The conversions between the two types are handled by 'makeBuiltinMeaning', so that the user
<span class="lineno">  394 </span>doesn't need to write them themselves and can just write
<span class="lineno">  395 </span>
<span class="lineno">  396 </span>    toBuiltinMeaning _ LengthOfByteString =
<span class="lineno">  397 </span>        let lengthOfByteStringDenotation :: BS.ByteString -&gt; Int
<span class="lineno">  398 </span>            lengthOfByteStringDenotation = BS.length
<span class="lineno">  399 </span>            {-# INLINE lengthOfByteStringDenotation #-}
<span class="lineno">  400 </span>        in makeBuiltinMeaning
<span class="lineno">  401 </span>            lengthOfByteStringDenotation
<span class="lineno">  402 </span>            &lt;costingFunction&gt;
<span class="lineno">  403 </span>
<span class="lineno">  404 </span>directly (where @BS.length :: BS.ByteString -&gt; Int@).
<span class="lineno">  405 </span>
<span class="lineno">  406 </span>Note however that while it's always safe to convert an 'Int' to an 'Integer', doing the opposite is
<span class="lineno">  407 </span>not safe in general, because an 'Integer' may not fit into the range of 'Int'. For this reason
<span class="lineno">  408 </span>
<span class="lineno">  409 </span>    YOU MUST NEVER USE 'fromIntegral' AND SIMILAR FUNCTIONS THAT CAN SILENTLY UNDER- OR OVERFLOW
<span class="lineno">  410 </span>    WHEN DEFINING A BUILT-IN FUNCTION
<span class="lineno">  411 </span>
<span class="lineno">  412 </span>For example defining a builtin that takes an 'Integer' and converts it to an 'Int' using
<span class="lineno">  413 </span>'fromIntegral' is not allowed under any circumstances and can be a huge vulnerability.
<span class="lineno">  414 </span>
<span class="lineno">  415 </span>It's completely fine to define a builtin that takes an 'Int' directly, though. How so? That's due
<span class="lineno">  416 </span>to the fact that the builtin application machinery checks that an 'Integer' is in the bounds of
<span class="lineno">  417 </span>'Int' before doing the conversion. If the bounds check succeeds, then the 'Integer' gets converted
<span class="lineno">  418 </span>to the corresponding 'Int', and if it doesn't, then the builtin application fails.
<span class="lineno">  419 </span>
<span class="lineno">  420 </span>For the list of types that can be converted to/from built-in ones look into the file with the
<span class="lineno">  421 </span>default universe. If you need to add a new such type, just copy-paste what's done for an existing
<span class="lineno">  422 </span>one and adjust.
<span class="lineno">  423 </span>
<span class="lineno">  424 </span>Speaking of builtin application failing:
<span class="lineno">  425 </span>
<span class="lineno">  426 </span>4. A built-in function can fail. Whenever a builtin fails, evaluation of the whole program fails.
<span class="lineno">  427 </span>There's a number of ways a builtin can fail:
<span class="lineno">  428 </span>
<span class="lineno">  429 </span>- as we've just seen a type conversion can fail due to an unsuccessful bounds check
<span class="lineno">  430 </span>- if the builtin expects, say, a 'Text' argument, but gets fed an 'Integer' argument
<span class="lineno">  431 </span>- if the builtin expects any constant, but gets fed a non-constant
<span class="lineno">  432 </span>- if its denotation runs in the 'BuiltinResult' monad and an 'evaluationFailure' gets returned
<span class="lineno">  433 </span>
<span class="lineno">  434 </span>Most of these are not a concern to the user defining a built-in function (conversions are handled
<span class="lineno">  435 </span>within the builtin application machinery, type mismatches are on the type checker and the person
<span class="lineno">  436 </span>writing the program etc), however explicitly returning 'evaluationFailure' from a builtin is
<span class="lineno">  437 </span>something that happens commonly.
<span class="lineno">  438 </span>
<span class="lineno">  439 </span>One simple example is a monomorphic function matching on a certain constructor and failing in all
<span class="lineno">  440 </span>other cases:
<span class="lineno">  441 </span>
<span class="lineno">  442 </span>    toBuiltinMeaning _ UnIData =
<span class="lineno">  443 </span>        let unIDataDenotation :: Data -&gt; BuiltinResult Integer
<span class="lineno">  444 </span>            unIDataDenotation = \case
<span class="lineno">  445 </span>                I i -&gt; pure i
<span class="lineno">  446 </span>                _   -&gt; evaluationFailure
<span class="lineno">  447 </span>            {-# INLINE unIDataDenotation #-}
<span class="lineno">  448 </span>        in makeBuiltinMeaning
<span class="lineno">  449 </span>            unIDataDenotation
<span class="lineno">  450 </span>            &lt;costingFunction&gt;
<span class="lineno">  451 </span>
<span class="lineno">  452 </span>The type of the denotation is
<span class="lineno">  453 </span>
<span class="lineno">  454 </span>    Data -&gt; BuiltinResult Integer
<span class="lineno">  455 </span>
<span class="lineno">  456 </span>and the Plutus type of the builtin is
<span class="lineno">  457 </span>
<span class="lineno">  458 </span>    data -&gt; integer
<span class="lineno">  459 </span>
<span class="lineno">  460 </span>because the error effect is implicit in Plutus.
<span class="lineno">  461 </span>
<span class="lineno">  462 </span>Returning @BuiltinResult a@ for a type variable @a@ is also fine, i.e. it doesn't matter whether
<span class="lineno">  463 </span>the denotation is monomorphic or polymorphic w.r.t. failing.
<span class="lineno">  464 </span>
<span class="lineno">  465 </span>But note that
<span class="lineno">  466 </span>
<span class="lineno">  467 </span>    'BuiltinResult' MUST BE EXPLICITLY USED FOR ANY FAILING BUILTIN AND THROWING AN EXCEPTION
<span class="lineno">  468 </span>    VIA 'error' OR 'throw' OR ELSE IS NOT ALLOWED AND CAN BE A HUGE VULNERABILITY. MAKE SURE THAT
<span class="lineno">  469 </span>    NONE OF THE FUNCTIONS THAT YOU USE TO DEFINE A BUILTIN THROW EXCEPTIONS
<span class="lineno">  470 </span>
<span class="lineno">  471 </span>An argument of a builtin can't have 'BuiltinResult' in its type -- only the result.
<span class="lineno">  472 </span>
<span class="lineno">  473 </span>5. A builtin can emit log messages. For that its denotation needs to run in the 'BuiltinResult' as
<span class="lineno">  474 </span>in case of failing. The ergonomics are the same. For example:
<span class="lineno">  475 </span>
<span class="lineno">  476 </span>    toBuiltinMeaning _ Trace =
<span class="lineno">  477 </span>        let traceDenotation :: Text -&gt; a -&gt; BuiltinResult a
<span class="lineno">  478 </span>            traceDenotation text a = a &lt;$ emit text
<span class="lineno">  479 </span>            {-# INLINE traceDenotation #-}
<span class="lineno">  480 </span>        in makeBuiltinMeaning
<span class="lineno">  481 </span>            traceDenotation
<span class="lineno">  482 </span>            &lt;costingFunction&gt;
<span class="lineno">  483 </span>
<span class="lineno">  484 </span>The type of the denotation is
<span class="lineno">  485 </span>
<span class="lineno">  486 </span>    forall a. Text -&gt; a -&gt; Builtin a
<span class="lineno">  487 </span>
<span class="lineno">  488 </span>and the Plutus type of the builtin is
<span class="lineno">  489 </span>
<span class="lineno">  490 </span>    all a. text -&gt; a -&gt; a
<span class="lineno">  491 </span>
<span class="lineno">  492 </span>because just like with the error effect, whether a function logs anything or not is not reflected
<span class="lineno">  493 </span>in its type.
<span class="lineno">  494 </span>
<span class="lineno">  495 </span>This concludes the list of simple cases. Before we jump to the hard ones, we need to talk about how
<span class="lineno">  496 </span>polymorphism gets elaborated, so read Note [Elaboration of polymorphism] next.
<span class="lineno">  497 </span>-}
<span class="lineno">  498 </span>
<span class="lineno">  499 </span>{- Note [Elaboration of polymorphism]
<span class="lineno">  500 </span>In Note [How to add a built-in function: simple cases] we defined the following builtin:
<span class="lineno">  501 </span>
<span class="lineno">  502 </span>    toBuiltinMeaning _ IfThenElse =
<span class="lineno">  503 </span>        let ifThenElseDenotation :: Bool -&gt; a -&gt; a -&gt; a
<span class="lineno">  504 </span>            ifThenElseDenotation b x y = if b then x else y
<span class="lineno">  505 </span>            {-# INLINE ifThenElseDenotation #-}
<span class="lineno">  506 </span>        in makeBuiltinMeaning
<span class="lineno">  507 </span>            ifThenElseDenotation
<span class="lineno">  508 </span>            &lt;costingFunction&gt;
<span class="lineno">  509 </span>
<span class="lineno">  510 </span>whose Haskell type is
<span class="lineno">  511 </span>
<span class="lineno">  512 </span>    forall a. Bool -&gt; a -&gt; a -&gt; a
<span class="lineno">  513 </span>
<span class="lineno">  514 </span>The way 'makeBuiltinMeaning' handles such a type is by traversing it and instantiating every type
<span class="lineno">  515 </span>variable. What a type variable gets instantiated to depends on where it appears. When the entire
<span class="lineno">  516 </span>type of an argument is a single type variable, it gets instantiated to @Opaque val VarN@ where
<span class="lineno">  517 </span>@VarN@ is pseudocode for &quot;a Haskell type representing a Plutus type variable with 'Unique' N&quot;
<span class="lineno">  518 </span>For the purpose of this explanation it doesn't matter what @VarN@ actually is and the representation
<span class="lineno">  519 </span>is subject to change anyway (see Note [Implementation of polymorphic built-in functions] if you want
<span class="lineno">  520 </span>to know the details). 'Opaque' however is more fundamental and so we need to talk about it.
<span class="lineno">  521 </span>Here's how it's defined:
<span class="lineno">  522 </span>
<span class="lineno">  523 </span>    newtype Opaque val (rep :: GHC.Type) = Opaque
<span class="lineno">  524 </span>        { unOpaque :: val
<span class="lineno">  525 </span>        }
<span class="lineno">  526 </span>
<span class="lineno">  527 </span>I.e. @Opaque val rep@ is a wrapper around @val@, which stands for the type of value that an
<span class="lineno">  528 </span>evaluator uses (the builtins machinery is designed to work with any evaluator and different
<span class="lineno">  529 </span>evaluators define their type of values differently, for example 'CkValue' if the type of value for
<span class="lineno">  530 </span>the CK machine). The idea is simple: in order to apply the denotation of a builtin expecting, say,
<span class="lineno">  531 </span>an 'Integer' constant we need to actually extract that 'Integer' from the AST of the given value,
<span class="lineno">  532 </span>but if the denotation is polymorphic over the type of its argument, then we don't need to extract
<span class="lineno">  533 </span>anything, we can just pass the AST of the value directly to the denotation (which means the value
<span class="lineno">  534 </span>doesn't have to be a 'Constant', it can be completely arbitrary). I.e. in order for a polymorphic
<span class="lineno">  535 </span>function to become a monomorphic denotation (denotations are always monomorpic) all type variables
<span class="lineno">  536 </span>in the type of that function need to be instantiated at the type of value that a given evaluator
<span class="lineno">  537 </span>uses.
<span class="lineno">  538 </span>
<span class="lineno">  539 </span>If we used just @val@ rather than @Opaque val rep@, we'd specialize
<span class="lineno">  540 </span>
<span class="lineno">  541 </span>    forall a. Bool -&gt; a -&gt; a -&gt; a
<span class="lineno">  542 </span>
<span class="lineno">  543 </span>to
<span class="lineno">  544 </span>
<span class="lineno">  545 </span>    Bool -&gt; val -&gt; val -&gt; val
<span class="lineno">  546 </span>
<span class="lineno">  547 </span>however then we'd need to separately specify the Plutus type of this builtin, since we can't infer
<span class="lineno">  548 </span>it from all these @val@s in the general case, for example does
<span class="lineno">  549 </span>
<span class="lineno">  550 </span>    val -&gt; val -&gt; val
<span class="lineno">  551 </span>
<span class="lineno">  552 </span>stand for
<span class="lineno">  553 </span>
<span class="lineno">  554 </span>    all a. a -&gt; a -&gt; a
<span class="lineno">  555 </span>
<span class="lineno">  556 </span>or
<span class="lineno">  557 </span>
<span class="lineno">  558 </span>    all a b. a -&gt; b -&gt; a
<span class="lineno">  559 </span>
<span class="lineno">  560 </span>or something else?
<span class="lineno">  561 </span>
<span class="lineno">  562 </span>So we use the @Opaque val rep@ wrapper, which is basically a @val@ with a @rep@ attached to it where
<span class="lineno">  563 </span>@rep@ represents the Plutus type of the argument/result, which is how we arrive at
<span class="lineno">  564 </span>
<span class="lineno">  565 </span>    Bool -&gt; Opaque val Var0 -&gt; Opaque val Var0 -&gt; Opaque val Var0
<span class="lineno">  566 </span>
<span class="lineno">  567 </span>This encoding allows us to specify both the Haskell and the Plutus types of the builtin
<span class="lineno">  568 </span>simultaneously.
<span class="lineno">  569 </span>
<span class="lineno">  570 </span>If we wanted to we could add explicit 'Opaque' while still having explicit polymorphism (leaving out
<span class="lineno">  571 </span>the @Var0@ thing for the elaboration machinery to figure out):
<span class="lineno">  572 </span>
<span class="lineno">  573 </span>    toBuiltinMeaning _ IfThenElse =
<span class="lineno">  574 </span>        let ifThenElseDenotation :: Bool -&gt; Opaque val a -&gt; Opaque val a -&gt; Opaque val a
<span class="lineno">  575 </span>            ifThenElseDenotation b x y = if b then x else y
<span class="lineno">  576 </span>            {-# INLINE ifThenElseDenotation #-}
<span class="lineno">  577 </span>        in makeBuiltinMeaning
<span class="lineno">  578 </span>            ifThenElseDenotation
<span class="lineno">  579 </span>            &lt;costingFunction&gt;
<span class="lineno">  580 </span>
<span class="lineno">  581 </span>and it would be equivalent to the original definition, but note how @a@ is now an argument to
<span class="lineno">  582 </span>'Opaque' rather than the entire type of an argument. In order for this definition to elaborate to
<span class="lineno">  583 </span>the same type as before @a@ needs to be instantiated to just @Var0@, as opposed to @Opaque val
<span class="lineno">  584 </span>Var0@, because the 'Opaque' part is already there, so this is what the elaboration machinery does.
<span class="lineno">  585 </span>
<span class="lineno">  586 </span>So regardless of which method of defining 'IfThenElse' we choose, the type of its denotation gets
<span class="lineno">  587 </span>elaborated to the same
<span class="lineno">  588 </span>
<span class="lineno">  589 </span>    Bool -&gt; Opaque val Var0 -&gt; Opaque val Var0 -&gt; Opaque val Var0
<span class="lineno">  590 </span>
<span class="lineno">  591 </span>which then gets digested, so that we can compute what Plutus type it corresponds to. The procedure
<span class="lineno">  592 </span>is simple: collect all distinct type variables, @all@-bind them and replace the usages with the
<span class="lineno">  593 </span>bound variables. This turns the type above into
<span class="lineno">  594 </span>
<span class="lineno">  595 </span>    all a. bool -&gt; a -&gt; a -&gt; a
<span class="lineno">  596 </span>
<span class="lineno">  597 </span>which is the Plutus type of the 'IfThenElse' builtin.
<span class="lineno">  598 </span>
<span class="lineno">  599 </span>It's of course allowed to have multiple type variables, e.g. in the following snippet:
<span class="lineno">  600 </span>
<span class="lineno">  601 </span>    toBuiltinMeaning _ Const =
<span class="lineno">  602 </span>        let constDenotation :: a -&gt; b -&gt; a
<span class="lineno">  603 </span>            constDenotation = Prelude.const
<span class="lineno">  604 </span>            {-# INLINE constDenotation #-}
<span class="lineno">  605 </span>        in makeBuiltinMeaning
<span class="lineno">  606 </span>            constDenotation
<span class="lineno">  607 </span>            &lt;costingFunction&gt;
<span class="lineno">  608 </span>
<span class="lineno">  609 </span>the Haskell type of 'const' is
<span class="lineno">  610 </span>
<span class="lineno">  611 </span>    forall a b. a -&gt; b -&gt; a
<span class="lineno">  612 </span>
<span class="lineno">  613 </span>which the elaboration machinery turns into
<span class="lineno">  614 </span>
<span class="lineno">  615 </span>    Opaque val Var0 -&gt; Opaque val Var1 -&gt; Opaque val Var0
<span class="lineno">  616 </span>
<span class="lineno">  617 </span>The elaboration machinery respects the explicitly specified parts of the type and does not attempt
<span class="lineno">  618 </span>to argue with them. For example if the user insisted that the instantiated type of 'const' had
<span class="lineno">  619 </span>@Var0@ and @Var1@ swapped:
<span class="lineno">  620 </span>
<span class="lineno">  621 </span>    Opaque val Var1 -&gt; Opaque val Var0 -&gt; Opaque val Var1
<span class="lineno">  622 </span>
<span class="lineno">  623 </span>the elaboration machinery wouldn't make a fuss about that.
<span class="lineno">  624 </span>
<span class="lineno">  625 </span>As a final simple example, consider
<span class="lineno">  626 </span>
<span class="lineno">  627 </span>    toBuiltinMeaning _ Trace =
<span class="lineno">  628 </span>        let traceDenotation :: Text -&gt; a -&gt; BuiltinResult a
<span class="lineno">  629 </span>            traceDenotation text a = a &lt;$ emit text
<span class="lineno">  630 </span>            {-# INLINE traceDenotation #-}
<span class="lineno">  631 </span>        in makeBuiltinMeaning
<span class="lineno">  632 </span>            traceDenotation
<span class="lineno">  633 </span>            &lt;costingFunction&gt;
<span class="lineno">  634 </span>
<span class="lineno">  635 </span>from [How to add a built-in function: simple cases]. The type of the denotation is
<span class="lineno">  636 </span>
<span class="lineno">  637 </span>    forall a. Text -&gt; a -&gt; BuiltinResult a
<span class="lineno">  638 </span>
<span class="lineno">  639 </span>which elaborates to
<span class="lineno">  640 </span>
<span class="lineno">  641 </span>    Text -&gt; Opaque val Var0 -&gt; BuiltinResult (Opaque val Var0)
<span class="lineno">  642 </span>
<span class="lineno">  643 </span>Elaboration machinery is able to look under 'BuiltinResult' even if there's a type variable inside
<span class="lineno">  644 </span>that does not appear anywhere else in the type signature, for example the type of the denotation in
<span class="lineno">  645 </span>
<span class="lineno">  646 </span>    toBuiltinMeaning _ ErrorPrime =
<span class="lineno">  647 </span>        let errorPrimeDenotation :: BuiltinResult a
<span class="lineno">  648 </span>            errorPrimeDenotation = evaluationFailure
<span class="lineno">  649 </span>            {-# INLINE errorPrimeDenotation #-}
<span class="lineno">  650 </span>        in makeBuiltinMeaning
<span class="lineno">  651 </span>            errorPrimeDenotation
<span class="lineno">  652 </span>            &lt;costingFunction&gt;
<span class="lineno">  653 </span>
<span class="lineno">  654 </span>is
<span class="lineno">  655 </span>
<span class="lineno">  656 </span>    forall a. BuiltinResult a
<span class="lineno">  657 </span>
<span class="lineno">  658 </span>which gets elaborated to
<span class="lineno">  659 </span>
<span class="lineno">  660 </span>    BuiltinResult (Opaque val Var0)
<span class="lineno">  661 </span>
<span class="lineno">  662 </span>from which the final Plutus type of the builtin is computed:
<span class="lineno">  663 </span>
<span class="lineno">  664 </span>    all a. a
<span class="lineno">  665 </span>
<span class="lineno">  666 </span>Read Note [How to add a built-in function: complicated cases] next.
<span class="lineno">  667 </span>-}
<span class="lineno">  668 </span>
<span class="lineno">  669 </span>{- Note [How to add a built-in function: complicated cases]
<span class="lineno">  670 </span>Now let's talk about more complicated built-in functions.
<span class="lineno">  671 </span>
<span class="lineno">  672 </span>1. In Note [Elaboration of polymorphism] we saw how a Haskell type variable gets elaborated to an
<span class="lineno">  673 </span>@Opaque val VarN@ and we learned that this type can be used directly as opposed to being inferred.
<span class="lineno">  674 </span>However there exist more ways to use 'Opaque' explicitly. Here's a simple example:
<span class="lineno">  675 </span>
<span class="lineno">  676 </span>    toBuiltinMeaning _ IdAssumeBool =
<span class="lineno">  677 </span>        let idAssumeBoolDenotation :: Opaque val Bool -&gt; Opaque val Bool
<span class="lineno">  678 </span>            idAssumeBoolDenotation = Prelude.id
<span class="lineno">  679 </span>            {-# INLINE idAssumeBoolDenotation #-}
<span class="lineno">  680 </span>        in makeBuiltinMeaning
<span class="lineno">  681 </span>            idAssumeBoolDenotation
<span class="lineno">  682 </span>            &lt;costingFunction&gt;
<span class="lineno">  683 </span>
<span class="lineno">  684 </span>This creates a built-in function whose Plutus type is
<span class="lineno">  685 </span>
<span class="lineno">  686 </span>    id : bool -&gt; bool
<span class="lineno">  687 </span>
<span class="lineno">  688 </span>i.e. the Plutus type signature of the built-in function is the same as with
<span class="lineno">  689 </span>
<span class="lineno">  690 </span>    toBuiltinMeaning _ IdBool =
<span class="lineno">  691 </span>        let idBoolDenotation :: Bool -&gt; Bool
<span class="lineno">  692 </span>            idBoolDenotation = Prelude.id
<span class="lineno">  693 </span>            {-# INLINE idBoolDenotation #-}
<span class="lineno">  694 </span>        in makeBuiltinMeaning
<span class="lineno">  695 </span>            idBoolDenotation
<span class="lineno">  696 </span>            &lt;costingFunction&gt;
<span class="lineno">  697 </span>
<span class="lineno">  698 </span>but the two evaluate differently: the former takes a value and returns it right away while the
<span class="lineno">  699 </span>latter takes a value, extracts a 'Bool' constant out of it and then lifts that constant back into
<span class="lineno">  700 </span>@val@. The difference is not only in performance (obviously returning something right away is
<span class="lineno">  701 </span>cheaper than unlifting-then-lifting-back), but also in semantics: the former returns its argument
<span class="lineno">  702 </span>during evaluation regardless of what that argument is, so if someone generates Untyped Plutus Core
<span class="lineno">  703 </span>directly, they can apply @IdAssumeBool@ to a term that doesn't evaluate to a 'Bool' constant or
<span class="lineno">  704 </span>even a constant at all and that won't be a runtime error, while the latter has to be applied to
<span class="lineno">  705 </span>a term evaluating to a 'Bool' constant in order not to fail at runtime.
<span class="lineno">  706 </span>
<span class="lineno">  707 </span>2. @val@ in @Opaque val rep@ is not completely arbitrary, it has to implement 'HasConstant', which
<span class="lineno">  708 </span>makes it possible to unlift @val@ as a constant or lift a constant back into @val@. There's a
<span class="lineno">  709 </span>'HasConstant' instance for @Opaque val rep@ whenever there's one for @val@, so if we, for some
<span class="lineno">  710 </span>reason, wanted to have 'Opaque' in the type signature of the denotation, but still unlift the
<span class="lineno">  711 </span>argument as a 'Bool', we could do that:
<span class="lineno">  712 </span>
<span class="lineno">  713 </span>    toBuiltinMeaning _ IdAssumeCheckBool =
<span class="lineno">  714 </span>        let idAssumeCheckBoolDenotation :: Opaque val Bool -&gt; BuiltinResult Bool
<span class="lineno">  715 </span>            idAssumeCheckBoolDenotation val = asConstant val of
<span class="lineno">  716 </span>                Right (Some (ValueOf DefaultUniBool b)) -&gt; pure b
<span class="lineno">  717 </span>                _                                       -&gt; evaluationFailure
<span class="lineno">  718 </span>            {-# INLINE idAssumeCheckBoolDenotation #-}
<span class="lineno">  719 </span>        in makeBuiltinMeaning
<span class="lineno">  720 </span>            idAssumeCheckBoolDenotation
<span class="lineno">  721 </span>            &lt;costingFunction&gt;
<span class="lineno">  722 </span>
<span class="lineno">  723 </span>Here in the denotation we unlift the given value as a constant, check that its type tag is
<span class="lineno">  724 </span>'DefaultUniBool' and return the unlifted 'Bool'. If any of that fails, we return an explicit
<span class="lineno">  725 </span>'evaluationFailure'.
<span class="lineno">  726 </span>
<span class="lineno">  727 </span>This achieves almost the same as 'IdBool', which keeps all the bookkeeping behind the scenes, but
<span class="lineno">  728 </span>there is a minor difference: in case of error its message is ignored. It would be easy to allow for
<span class="lineno">  729 </span>returning an unlifting error from a builtin explicitly, but we don't need that for anything, hence
<span class="lineno">  730 </span>it's not implemented.
<span class="lineno">  731 </span>
<span class="lineno">  732 </span>We call this style of manually calling 'asConstant' and matching on the type tag &quot;manual unlifting&quot;.
<span class="lineno">  733 </span>As opposed to &quot;automatic unlifting&quot; that we were using before where 'Bool' in the type of the
<span class="lineno">  734 </span>denotation of a builtin causes the builtins machinery to convert the given argument to a 'Bool'
<span class="lineno">  735 </span>constant automatically behind the scenes.
<span class="lineno">  736 </span>
<span class="lineno">  737 </span>3. There's a middle ground between automatic and manual unlifting to 'Bool', one can unlift a value
<span class="lineno">  738 </span>automatically as a constant and then unlift the result manually to 'Bool' using the 'SomeConstant'
<span class="lineno">  739 </span>wrapper:
<span class="lineno">  740 </span>
<span class="lineno">  741 </span>    newtype SomeConstant uni (rep :: GHC.Type) = SomeConstant
<span class="lineno">  742 </span>        { unSomeConstant :: Some (ValueOf uni)
<span class="lineno">  743 </span>        }
<span class="lineno">  744 </span>
<span class="lineno">  745 </span>'SomeConstant' is similar to 'Opaque' in that it has a @rep@ representing a Plutus type.
<span class="lineno">  746 </span>The difference is that 'Opaque' is a wrapper around an arbitrary value and 'SomeConstant' is a
<span class="lineno">  747 </span>wrapper around a constant. 'SomeConstant' allows one to automatically unlift an argument of a
<span class="lineno">  748 </span>built-in function as a constant with all 'asConstant' business kept behind the scenes, for example:
<span class="lineno">  749 </span>
<span class="lineno">  750 </span>    toBuiltinMeaning _ IdSomeConstantBool =
<span class="lineno">  751 </span>        let idSomeConstantBoolDenotation :: SomeConstant uni Bool -&gt; BuiltinResult Bool
<span class="lineno">  752 </span>            idSomeConstantBoolDenotation = \case
<span class="lineno">  753 </span>                SomeConstant (Some (ValueOf DefaultUniBool b)) -&gt; pure b
<span class="lineno">  754 </span>                _                                              -&gt; evaluationFailure
<span class="lineno">  755 </span>            {-# INLINE idSomeConstantBoolDenotation #-}
<span class="lineno">  756 </span>        in makeBuiltinMeaning
<span class="lineno">  757 </span>            idSomeConstantBoolDenotation
<span class="lineno">  758 </span>            &lt;costingFunction&gt;
<span class="lineno">  759 </span>
<span class="lineno">  760 </span>Note how we no longer call 'asConstant' manually, but still manually match on 'DefaultUniBool'.
<span class="lineno">  761 </span>
<span class="lineno">  762 </span>So there's a whole range of how &quot;low-level&quot; one can choose to be when defining a built-in function.
<span class="lineno">  763 </span>However it's not always possible to use automatic unlifting, see next.
<span class="lineno">  764 </span>
<span class="lineno">  765 </span>4. If we try to define the following built-in function:
<span class="lineno">  766 </span>
<span class="lineno">  767 </span>    toBuiltinMeaning _ NullList =
<span class="lineno">  768 </span>        let nullListDenotation :: [a] -&gt; Bool
<span class="lineno">  769 </span>            nullListDenotation = null
<span class="lineno">  770 </span>            {-# INLINE nullListDenotation #-}
<span class="lineno">  771 </span>        in makeBuiltinMeaning
<span class="lineno">  772 </span>            nullListDenotation
<span class="lineno">  773 </span>            &lt;costingFunction&gt;
<span class="lineno">  774 </span>
<span class="lineno">  775 </span>we'll get an error, saying that a polymorphic built-in type can't be applied to a type variable.
<span class="lineno">  776 </span>It's not impossible to make it work, see Note [Unlifting a term as a value of a built-in type], but
<span class="lineno">  777 </span>not in the general case, plus it has to be very inefficient.
<span class="lineno">  778 </span>
<span class="lineno">  779 </span>Instead we have to use 'SomeConstant' to automatically unlift the argument as a constant and then
<span class="lineno">  780 </span>check that the value inside of it is a list (by matching on the type tag):
<span class="lineno">  781 </span>
<span class="lineno">  782 </span>    toBuiltinMeaning _ NullList =
<span class="lineno">  783 </span>        let nullListDenotation :: SomeConstant uni [a] -&gt; BuiltinResult Bool
<span class="lineno">  784 </span>            nullListDenotation (SomeConstant (Some (ValueOf uniListA xs))) = do
<span class="lineno">  785 </span>                case uniListA of
<span class="lineno">  786 </span>                    DefaultUniList _ -&gt; pure $ null xs
<span class="lineno">  787 </span>                    _ -&gt; throwError $ structuralUnliftingError &quot;Expected a list but got something else&quot;
<span class="lineno">  788 </span>            {-# INLINE nullListDenotation #-}
<span class="lineno">  789 </span>        in makeBuiltinMeaning
<span class="lineno">  790 </span>            nullListDenotation
<span class="lineno">  791 </span>            &lt;costingFunction&gt;
<span class="lineno">  792 </span>
<span class="lineno">  793 </span>As before, we have to match on the type tag, because there's no relation between @rep@ from
<span class="lineno">  794 </span>@SomeConstant uni rep@ and the constant that the built-in function actually receives at runtime
<span class="lineno">  795 </span>(someone could generate Untyped Plutus Core directly and apply 'nullPlc' to an 'Integer' or
<span class="lineno">  796 </span>whatever). @rep@ is only for the Plutus type checker to look at, it doesn't influence evaluation
<span class="lineno">  797 </span>in any way.
<span class="lineno">  798 </span>
<span class="lineno">  799 </span>Here's a similar built-in function:
<span class="lineno">  800 </span>
<span class="lineno">  801 </span>    toBuiltinMeaning _ FstPair =
<span class="lineno">  802 </span>        let fstPairDenotation :: SomeConstant uni (a, b) -&gt; BuiltinResult (Opaque val a)
<span class="lineno">  803 </span>            fstPairDenotation (SomeConstant (Some (ValueOf uniPairAB xy))) = do
<span class="lineno">  804 </span>                case uniPairAB of
<span class="lineno">  805 </span>                    DefaultUniPair uniA _ -&gt;              -- [1]
<span class="lineno">  806 </span>                        pure . fromValueOf uniA $ fst xy  -- [2]
<span class="lineno">  807 </span>                    _ -&gt;
<span class="lineno">  808 </span>                        throwError $ structuralUnliftingError &quot;Expected a pair but got something else&quot;
<span class="lineno">  809 </span>            {-# INLINE fstPairDenotation #-}
<span class="lineno">  810 </span>        in makeBuiltinMeaning
<span class="lineno">  811 </span>            fstPairDenotation
<span class="lineno">  812 </span>            &lt;costingFunction&gt;
<span class="lineno">  813 </span>
<span class="lineno">  814 </span>In this definition we extract the first element of a pair by checking that the given constant is
<span class="lineno">  815 </span>indeed a pair [1] and lifting its first element into @val@ using the type tag for the first
<span class="lineno">  816 </span>element [2] (extracted from the type tag for the whole pair constant [1]).
<span class="lineno">  817 </span>
<span class="lineno">  818 </span>Note that it's fine to mix automatic unlifting for polymorphism not related to built-in types and
<span class="lineno">  819 </span>manual unlifting for arguments having non-monomorphized polymorphic built-in types, for example:
<span class="lineno">  820 </span>
<span class="lineno">  821 </span>    toBuiltinMeaning _ ChooseList =
<span class="lineno">  822 </span>        let chooseListDenotation :: SomeConstant uni [a] -&gt; b -&gt; b -&gt; BuiltinResult b
<span class="lineno">  823 </span>            chooseListDenotation (SomeConstant (Some (ValueOf uniListA xs))) a b = do
<span class="lineno">  824 </span>                case uniListA of
<span class="lineno">  825 </span>                    DefaultUniList _ -&gt; pure $ case xs of
<span class="lineno">  826 </span>                        []    -&gt; a
<span class="lineno">  827 </span>                        _ : _ -&gt; b
<span class="lineno">  828 </span>                    _ -&gt; throwError $ structuralUnliftingError &quot;Expected a list but got something else&quot;
<span class="lineno">  829 </span>            {-# INLINE chooseListDenotation #-}
<span class="lineno">  830 </span>        in makeBuiltinMeaning
<span class="lineno">  831 </span>            chooseListDenotation
<span class="lineno">  832 </span>            (runCostingFunThreeArguments . paramChooseList)
<span class="lineno">  833 </span>            &lt;costingFunction&gt;
<span class="lineno">  834 </span>
<span class="lineno">  835 </span>Here @a@ appears inside @[]@, which is a polymorphic built-in type, and so we have to use
<span class="lineno">  836 </span>'SomeConstant' and check that the given constant is indeed a list, while @b@ doesn't appear inside
<span class="lineno">  837 </span>of any built-in type and so we don't need to instantiate it to 'Opaque' manually, the elaboration
<span class="lineno">  838 </span>machinery will do it for us.
<span class="lineno">  839 </span>
<span class="lineno">  840 </span>Our final example is this:
<span class="lineno">  841 </span>
<span class="lineno">  842 </span>    toBuiltinMeaning _ MkCons =
<span class="lineno">  843 </span>        let mkConsDenotation
<span class="lineno">  844 </span>                :: SomeConstant uni a -&gt; SomeConstant uni [a] -&gt; BuiltinResult (Opaque val [a])
<span class="lineno">  845 </span>            mkConsDenotation
<span class="lineno">  846 </span>              (SomeConstant (Some (ValueOf uniA x)))
<span class="lineno">  847 </span>              (SomeConstant (Some (ValueOf uniListA xs))) = do
<span class="lineno">  848 </span>                case uniListA of
<span class="lineno">  849 </span>                    DefaultUniList uniA' -&gt; case uniA `geq` uniA' of       -- [1]
<span class="lineno">  850 </span>                        Just Refl -&gt;                                       -- [2]
<span class="lineno">  851 </span>                            pure . fromValueOf uniListA $ x : xs           -- [3]
<span class="lineno">  852 </span>                        _ -&gt; throwError $ structuralUnliftingError
<span class="lineno">  853 </span>                            &quot;The type of the value does not match the type of elements in the list&quot;
<span class="lineno">  854 </span>                    _ -&gt; throwError $ structuralUnliftingError &quot;Expected a list but got something else&quot;
<span class="lineno">  855 </span>            {-# INLINE mkConsDenotation #-}
<span class="lineno">  856 </span>        in makeBuiltinMeaning
<span class="lineno">  857 </span>            mkConsDenotation
<span class="lineno">  858 </span>            &lt;costingFunction&gt;
<span class="lineno">  859 </span>
<span class="lineno">  860 </span>Here we prepend an element to a list [3] after checking that the second argument is indeed a
<span class="lineno">  861 </span>list [1] and that the type tag of the element being prepended equals the type tag for elements of
<span class="lineno">  862 </span>the list [2] (extracted from the type tag for the whole list constant [1]).
<span class="lineno">  863 </span>-}
<span class="lineno">  864 </span>
<span class="lineno">  865 </span>{- Note [Builtins and Plutus type checking]
<span class="lineno">  866 </span>There's a direct correspondence between the Haskell type of the denotation of a builtin and the
<span class="lineno">  867 </span>Plutus type of the builtin:
<span class="lineno">  868 </span>
<span class="lineno">  869 </span>1. elaboration turns a Haskell type variable into a concrete Haskell type representing a Plutus type
<span class="lineno">  870 </span>   variable, which later becomes demoted (in the regular @singletons@ sense via 'KnownSymbol' etc)
<span class="lineno">  871 </span>   to a regular Haskell value representing a Plutus type variable (as a part of the AST)
<span class="lineno">  872 </span>2. a builtin head (i.e. a completely uninstantiated built-in type such as @Bool@ and @[]@) is
<span class="lineno">  873 </span>   considered abstract by the Plutus type checker. All the type checker cares about is being able to
<span class="lineno">  874 </span>   get the (Plutus) kind of a builtin head and check two builtin heads for equality
<span class="lineno">  875 </span>3. Plutus type normalization tears partially or fully instantiated built-in types (such as
<span class="lineno">  876 </span>   @[Integer]@) apart and creates a Plutus type application for each Haskell type application
<span class="lineno">  877 </span>4. 'BuiltinResult' does not appear on the Plutus side, since the logging and failure effects are
<span class="lineno">  878 </span>   implicit in Plutus as was discussed above
<span class="lineno">  879 </span>5. 'Opaque' and 'SomeConstant' both carry a Haskell @rep@ type argument representing some Plutus
<span class="lineno">  880 </span>   type to be used for Plutus type checking
<span class="lineno">  881 </span>
<span class="lineno">  882 </span>This last part means that one can attach any (legal) @rep@ to an 'Opaque' or 'SomeConstant' and
<span class="lineno">  883 </span>it'll be used by the Plutus type checker completely regardless of what the built-in function
<span class="lineno">  884 </span>actually does. Let's look at some examples.
<span class="lineno">  885 </span>
<span class="lineno">  886 </span>1. The following built-in function unlifts to 'Bool' and lifts the result back:
<span class="lineno">  887 </span>
<span class="lineno">  888 </span>    toBuiltinMeaning _ IdIntegerAsBool =
<span class="lineno">  889 </span>        let idIntegerAsBoolDenotation
<span class="lineno">  890 </span>                :: SomeConstant uni Integer -&gt; BuiltinResult (SomeConstant uni Integer)
<span class="lineno">  891 </span>            idIntegerAsBoolDenotation = \case
<span class="lineno">  892 </span>                con@(SomeConstant (Some (ValueOf DefaultUniBool _))) -&gt; pure con
<span class="lineno">  893 </span>                _                                                    -&gt; evaluationFailure
<span class="lineno">  894 </span>            {-# INLINE idIntegerAsBoolDenotation #-}
<span class="lineno">  895 </span>        in makeBuiltinMeaning
<span class="lineno">  896 </span>            idIntegerAsBoolDenotation
<span class="lineno">  897 </span>            &lt;costingFunction&gt;
<span class="lineno">  898 </span>
<span class="lineno">  899 </span>but on the Plutus side its type is
<span class="lineno">  900 </span>
<span class="lineno">  901 </span>    integer -&gt; integer
<span class="lineno">  902 </span>
<span class="lineno">  903 </span>because the @rep@ that 'SomeConstant' carries is 'Integer' in both the cases (in the type of the
<span class="lineno">  904 </span>argument, as well as in the type of the result).
<span class="lineno">  905 </span>
<span class="lineno">  906 </span>This means that for this built-in function the Plutus type checker will accept a program that fails
<span class="lineno">  907 </span>at runtime due to a type mismatch and will reject a program that runs successfully. Other built-in
<span class="lineno">  908 </span>functions also can fail, e.g. the type of @ifThenElse@ says that the builtin expects a @Bool@ and
<span class="lineno">  909 </span>feeding it something else will result in evaluation failure, but 'idIntegerAsBool' is different:
<span class="lineno">  910 </span>it's respecting its type signature is what causes a failure, not disrespecting it.
<span class="lineno">  911 </span>
<span class="lineno">  912 </span>2. Another example of an unsafe built-in function is this one that checks whether an argument is a
<span class="lineno">  913 </span>constant or not:
<span class="lineno">  914 </span>
<span class="lineno">  915 </span>    toBuiltinMeaning _ IsConstant =
<span class="lineno">  916 </span>        let isConstantDenotation :: Opaque val a -&gt; Bool
<span class="lineno">  917 </span>            isConstantDenotation = isRight . asConstant
<span class="lineno">  918 </span>            {-# INLINE isConstantDenotation #-}
<span class="lineno">  919 </span>        in makeBuiltinMeaning
<span class="lineno">  920 </span>            isConstantDenotation
<span class="lineno">  921 </span>            &lt;costingFunction&gt;
<span class="lineno">  922 </span>
<span class="lineno">  923 </span>Its type on the Plutus side is
<span class="lineno">  924 </span>
<span class="lineno">  925 </span>    all a. a -&gt; bool
<span class="lineno">  926 </span>
<span class="lineno">  927 </span>By parametricity any inhabitant of this type has to be either bottom or a function ignoring its
<span class="lineno">  928 </span>argument, but @IsConstant@ actually uses the argument and so we break parametricity with this
<span class="lineno">  929 </span>built-in function.
<span class="lineno">  930 </span>
<span class="lineno">  931 </span>3. Finally, we can have a Plutus version of @unsafeCoerce@:
<span class="lineno">  932 </span>
<span class="lineno">  933 </span>    toBuiltinMeaning _ UnsafeCoerce =
<span class="lineno">  934 </span>        let unsafeCoerceDenotation :: Opaque val a -&gt; Opaque val b
<span class="lineno">  935 </span>            unsafeCoerceDenotation = Opaque . unOpaque
<span class="lineno">  936 </span>            {-# INLINE unsafeCoerceDenotation #-}
<span class="lineno">  937 </span>        in makeBuiltinMeaning
<span class="lineno">  938 </span>            unsafeCoerceDenotation
<span class="lineno">  939 </span>            &lt;costingFunction&gt;
<span class="lineno">  940 </span>
<span class="lineno">  941 </span>Its type on the Plutus side is
<span class="lineno">  942 </span>
<span class="lineno">  943 </span>    all a b. a -&gt; b
<span class="lineno">  944 </span>
<span class="lineno">  945 </span>and thus this built-in function allows for viewing any Plutus expression as having an arbitrary
<span class="lineno">  946 </span>type. Which is of course not nearly as bad as @unsafeCoerce@ in Haskell, because in Plutus a
<span class="lineno">  947 </span>blob of memory representing an @Integer@ is not going to be viewed as a @[Bool]@ and an attempt to
<span class="lineno">  948 </span>actually extract that @[Bool]@ will result in evaluation failure, but this built-in function is
<span class="lineno">  949 </span>still not a good citizen of the Plutus type system.
<span class="lineno">  950 </span>
<span class="lineno">  951 </span>One could of course simply wrap Haskell's @unsafeCoerce@ as a built-in function in Plutus, but it
<span class="lineno">  952 </span>goes without saying that this is not supposed to be done.
<span class="lineno">  953 </span>
<span class="lineno">  954 </span>So overall one needs to be very careful when defining built-in functions that have explicit
<span class="lineno">  955 </span>'Opaque' and 'SomeConstant' arguments. Expressiveness doesn't come for free.
<span class="lineno">  956 </span>-}
<span class="lineno">  957 </span>
<span class="lineno">  958 </span>{- Note [Representable built-in functions over polymorphic built-in types]
<span class="lineno">  959 </span>Note [Legacy pattern matching on built-in types] discusses how general higher-order polymorphic
<span class="lineno">  960 </span>built-in functions are troubling, but polymorphic built-in functions can be troubling even in
<span class="lineno">  961 </span>the first-order case. In a Plutus program we always pair constants of built-in types with their
<span class="lineno">  962 </span>tags from the universe, which means that in order to produce a constant embedded into a program
<span class="lineno">  963 </span>we need the tag of the type of that constant. We can't get that tag from a Plutus type -- those
<span class="lineno">  964 </span>are gone at runtime, so the only place we can get a type tag from during evaluation is some already
<span class="lineno">  965 </span>existing constant. I.e. the following built-in function is representable:
<span class="lineno">  966 </span>
<span class="lineno">  967 </span>    tail : all a. [a] -&gt; [a]
<span class="lineno">  968 </span>
<span class="lineno">  969 </span>because for constructing the result we need a type tag for @[a]@, but we have a value of that type
<span class="lineno">  970 </span>as an argument and so we can extract the type tag from it. Same applies to
<span class="lineno">  971 </span>
<span class="lineno">  972 </span>    swap : all a b. (a, b) -&gt; (b, a)
<span class="lineno">  973 </span>
<span class="lineno">  974 </span>since 'SomeConstantOf' always contains a type tag for each type that a polymorphic built-in type is
<span class="lineno">  975 </span>instantiated with and so constructing a type tag for @(b, a)@ given type tags for @a@ and @b@ is
<span class="lineno">  976 </span>unproblematic.
<span class="lineno">  977 </span>
<span class="lineno">  978 </span>And so neither
<span class="lineno">  979 </span>
<span class="lineno">  980 </span>    cons : all a. a -&gt; [a] -&gt; [a]
<span class="lineno">  981 </span>
<span class="lineno">  982 </span>is troubling (even though that ones requires checking at runtime that the element to be prepended
<span class="lineno">  983 </span>is of the same type as the type of the elements of the list as it's impossible to enforce this kind
<span class="lineno">  984 </span>of type safety in Haskell over possibly untyped PLC).
<span class="lineno">  985 </span>
<span class="lineno">  986 </span>However consider the following imaginary builtin:
<span class="lineno">  987 </span>
<span class="lineno">  988 </span>    nil : all a. [a]
<span class="lineno">  989 </span>
<span class="lineno">  990 </span>we can't represent it for two reasons:
<span class="lineno">  991 </span>
<span class="lineno">  992 </span>1. we don't have any argument providing us a type tag for @a@ and hence we can't construct a type
<span class="lineno">  993 </span>   tag for @[a]@
<span class="lineno">  994 </span>2. it would be a very unsound builtin to have. We can only instantiate built-in types with other
<span class="lineno">  995 </span>   built-in types and so allowing @nil {some_non_built_in_type}@ would be a lie that couldn't reduce
<span class="lineno">  996 </span>   to anything since it's not even possible to represent a built-in list with non-built-in elements
<span class="lineno">  997 </span>   (even if there's zero of them)
<span class="lineno">  998 </span>
<span class="lineno">  999 </span>&quot;Wait, but wouldn't @cons {some_non_built_in_type}@ be a lie as well?&quot; -- No! Since @cons@ does not
<span class="lineno"> 1000 </span>just construct a list filled with elements of a non-built-in type but also expects one as an
<span class="lineno"> 1001 </span>argument and providing such an argument is impossible, 'cause it's pretty much the same thing as
<span class="lineno"> 1002 </span>populating 'Void' -- both values are equally unrepresentable. And so @cons {some_non_built_in_type}@
<span class="lineno"> 1003 </span>is a way to say @absurd@, which is perfectly fine to have.
<span class="lineno"> 1004 </span>
<span class="lineno"> 1005 </span>Finally,
<span class="lineno"> 1006 </span>
<span class="lineno"> 1007 </span>    comma :: all a b. a -&gt; b -&gt; (a, b)
<span class="lineno"> 1008 </span>
<span class="lineno"> 1009 </span>is representable (because we can require arguments to be constants carrying universes with them,
<span class="lineno"> 1010 </span>which we can use to construct the resulting universe), but is still a lie, because instantiating
<span class="lineno"> 1011 </span>that builtin with non-built-in types is possible and so the PLC type checker won't throw on such
<span class="lineno"> 1012 </span>an instantiation, which will become 'evalutionFailure' at runtime the moment unlifting of a
<span class="lineno"> 1013 </span>non-constant is attempted when a constant is expected.
<span class="lineno"> 1014 </span>
<span class="lineno"> 1015 </span>So could we still get @nil@ or a safe version of @comma@ somehow? Well, we could have this
<span class="lineno"> 1016 </span>weirdness:
<span class="lineno"> 1017 </span>
<span class="lineno"> 1018 </span>    nilOfTypeOf : all a. [a] -&gt; [a]
<span class="lineno"> 1019 </span>
<span class="lineno"> 1020 </span>i.e. ask for an already existing list, but ignore the actual list and only use the type tag.
<span class="lineno"> 1021 </span>
<span class="lineno"> 1022 </span>But since we're ignoring the actual list, can't we just not pass it in the first place? And instead
<span class="lineno"> 1023 </span>pass around our good old friends, singletons. We should be able to do that, but it hasn't been
<span class="lineno"> 1024 </span>investigated. Perhaps something along the lines of adding the following constructor to 'DefaultUni':
<span class="lineno"> 1025 </span>
<span class="lineno"> 1026 </span>    DefaultUniProtoSing :: DefaultUni (Esc (Proxy @GHC.Type))
<span class="lineno"> 1027 </span>
<span class="lineno"> 1028 </span>and then defining
<span class="lineno"> 1029 </span>
<span class="lineno"> 1030 </span>    nil : all a. sing a -&gt; [a]
<span class="lineno"> 1031 </span>
<span class="lineno"> 1032 </span>and then the Plutus Tx compiler can provide a type class or something for constructing singletons
<span class="lineno"> 1033 </span>for built-in types.
<span class="lineno"> 1034 </span>
<span class="lineno"> 1035 </span>This was investigated in https://github.com/IntersectMBO/plutus/pull/4337 but we decided not to
<span class="lineno"> 1036 </span>do it quite yet, even though it worked (the Plutus Tx part wasn't implemented).
<span class="lineno"> 1037 </span>-}
<span class="lineno"> 1038 </span>
<span class="lineno"> 1039 </span>{- Note [Structural vs operational errors within builtins]
<span class="lineno"> 1040 </span>See the Haddock of 'EvaluationError' to understand why we sometimes use use @throwing
<span class="lineno"> 1041 </span>_StructuralUnliftingError@ (to throw a &quot;structural&quot; evaluation error) and sometimes use 'fail' (to
<span class="lineno"> 1042 </span>throw an &quot;operational&quot; evaluation error). Please respect the distinction when adding new built-in
<span class="lineno"> 1043 </span>functions.
<span class="lineno"> 1044 </span>-}
<span class="lineno"> 1045 </span>
<span class="lineno"> 1046 </span>instance uni ~ DefaultUni =&gt; ToBuiltinMeaning uni DefaultFun where
<span class="lineno"> 1047 </span>    type CostingPart uni DefaultFun = BuiltinCostModel
<span class="lineno"> 1048 </span>
<span class="lineno"> 1049 </span>    {- | Allow different variants of builtins with different implementations, and
<span class="lineno"> 1050 </span>       possibly different semantics.  Note that DefaultFunSemanticsVariantA,
<span class="lineno"> 1051 </span>       DefaultFunSemanticsVariantB etc. do not correspond directly to PlutusV1,
<span class="lineno"> 1052 </span>       PlutusV2 etc. in plutus-ledger-api: see Note [Builtin semantics variants]. -}
<span class="lineno"> 1053 </span>    data BuiltinSemanticsVariant DefaultFun
<span class="lineno"> 1054 </span>        = DefaultFunSemanticsVariantA
<span class="lineno"> 1055 </span>        | DefaultFunSemanticsVariantB
<span class="lineno"> 1056 </span>        | DefaultFunSemanticsVariantC
<span class="lineno"> 1057 </span>        deriving stock (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Enum</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Bounded</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>)
<span class="lineno"> 1058 </span>        deriving anyclass (<span class="decl"><span class="istickedoff">NFData</span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">NoThunks</span></span></span></span></span></span>)
<span class="lineno"> 1059 </span>
<span class="lineno"> 1060 </span>    -- Integers
<span class="lineno"> 1061 </span>    toBuiltinMeaning
<span class="lineno"> 1062 </span>        :: forall val. HasMeaningIn uni val
<span class="lineno"> 1063 </span>        =&gt; BuiltinSemanticsVariant DefaultFun
<span class="lineno"> 1064 </span>        -&gt; DefaultFun
<span class="lineno"> 1065 </span>        -&gt; BuiltinMeaning val BuiltinCostModel
<span class="lineno"> 1066 </span>
<span class="lineno"> 1067 </span>    <span class="decl"><span class="istickedoff">toBuiltinMeaning _semvar AddInteger =</span>
<span class="lineno"> 1068 </span><span class="spaces">        </span><span class="istickedoff">let addIntegerDenotation :: Integer -&gt; Integer -&gt; Integer</span>
<span class="lineno"> 1069 </span><span class="spaces">            </span><span class="istickedoff">addIntegerDenotation = (+)</span>
<span class="lineno"> 1070 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE addIntegerDenotation #-}</span>
<span class="lineno"> 1071 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1072 </span><span class="spaces">            </span><span class="istickedoff">addIntegerDenotation</span>
<span class="lineno"> 1073 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramAddInteger)</span>
<span class="lineno"> 1074 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1075 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar SubtractInteger =</span>
<span class="lineno"> 1076 </span><span class="spaces">        </span><span class="istickedoff">let subtractIntegerDenotation :: Integer -&gt; Integer -&gt; Integer</span>
<span class="lineno"> 1077 </span><span class="spaces">            </span><span class="istickedoff">subtractIntegerDenotation = (-)</span>
<span class="lineno"> 1078 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE subtractIntegerDenotation #-}</span>
<span class="lineno"> 1079 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1080 </span><span class="spaces">            </span><span class="istickedoff">subtractIntegerDenotation</span>
<span class="lineno"> 1081 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramSubtractInteger)</span>
<span class="lineno"> 1082 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1083 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar MultiplyInteger =</span>
<span class="lineno"> 1084 </span><span class="spaces">        </span><span class="istickedoff">let multiplyIntegerDenotation :: Integer -&gt; Integer -&gt; Integer</span>
<span class="lineno"> 1085 </span><span class="spaces">            </span><span class="istickedoff">multiplyIntegerDenotation = (*)</span>
<span class="lineno"> 1086 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE multiplyIntegerDenotation #-}</span>
<span class="lineno"> 1087 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1088 </span><span class="spaces">            </span><span class="istickedoff">multiplyIntegerDenotation</span>
<span class="lineno"> 1089 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramMultiplyInteger)</span>
<span class="lineno"> 1090 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1091 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar DivideInteger =</span>
<span class="lineno"> 1092 </span><span class="spaces">        </span><span class="istickedoff">let divideIntegerDenotation :: Integer -&gt; Integer -&gt; BuiltinResult Integer</span>
<span class="lineno"> 1093 </span><span class="spaces">            </span><span class="istickedoff">divideIntegerDenotation = nonZeroSecondArg div</span>
<span class="lineno"> 1094 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE divideIntegerDenotation #-}</span>
<span class="lineno"> 1095 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1096 </span><span class="spaces">            </span><span class="istickedoff">divideIntegerDenotation</span>
<span class="lineno"> 1097 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramDivideInteger)</span>
<span class="lineno"> 1098 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1099 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar QuotientInteger =</span>
<span class="lineno"> 1100 </span><span class="spaces">        </span><span class="istickedoff">let quotientIntegerDenotation :: Integer -&gt; Integer -&gt; BuiltinResult Integer</span>
<span class="lineno"> 1101 </span><span class="spaces">            </span><span class="istickedoff">quotientIntegerDenotation = nonZeroSecondArg quot</span>
<span class="lineno"> 1102 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE quotientIntegerDenotation #-}</span>
<span class="lineno"> 1103 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1104 </span><span class="spaces">            </span><span class="istickedoff">quotientIntegerDenotation</span>
<span class="lineno"> 1105 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramQuotientInteger)</span>
<span class="lineno"> 1106 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1107 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar RemainderInteger =</span>
<span class="lineno"> 1108 </span><span class="spaces">        </span><span class="istickedoff">let remainderIntegerDenotation :: Integer -&gt; Integer -&gt; BuiltinResult Integer</span>
<span class="lineno"> 1109 </span><span class="spaces">            </span><span class="istickedoff">remainderIntegerDenotation = nonZeroSecondArg rem</span>
<span class="lineno"> 1110 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE remainderIntegerDenotation #-}</span>
<span class="lineno"> 1111 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1112 </span><span class="spaces">            </span><span class="istickedoff">remainderIntegerDenotation</span>
<span class="lineno"> 1113 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramRemainderInteger)</span>
<span class="lineno"> 1114 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1115 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar ModInteger =</span>
<span class="lineno"> 1116 </span><span class="spaces">        </span><span class="istickedoff">let modIntegerDenotation :: Integer -&gt; Integer -&gt; BuiltinResult Integer</span>
<span class="lineno"> 1117 </span><span class="spaces">            </span><span class="istickedoff">modIntegerDenotation = nonZeroSecondArg mod</span>
<span class="lineno"> 1118 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE modIntegerDenotation #-}</span>
<span class="lineno"> 1119 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1120 </span><span class="spaces">            </span><span class="istickedoff">modIntegerDenotation</span>
<span class="lineno"> 1121 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramModInteger)</span>
<span class="lineno"> 1122 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1123 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar EqualsInteger =</span>
<span class="lineno"> 1124 </span><span class="spaces">        </span><span class="istickedoff">let equalsIntegerDenotation :: Integer -&gt; Integer -&gt; Bool</span>
<span class="lineno"> 1125 </span><span class="spaces">            </span><span class="istickedoff">equalsIntegerDenotation = (==)</span>
<span class="lineno"> 1126 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE equalsIntegerDenotation #-}</span>
<span class="lineno"> 1127 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1128 </span><span class="spaces">            </span><span class="istickedoff">equalsIntegerDenotation</span>
<span class="lineno"> 1129 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramEqualsInteger)</span>
<span class="lineno"> 1130 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1131 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar LessThanInteger =</span>
<span class="lineno"> 1132 </span><span class="spaces">        </span><span class="istickedoff">let lessThanIntegerDenotation :: Integer -&gt; Integer -&gt; Bool</span>
<span class="lineno"> 1133 </span><span class="spaces">            </span><span class="istickedoff">lessThanIntegerDenotation = (&lt;)</span>
<span class="lineno"> 1134 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE lessThanIntegerDenotation #-}</span>
<span class="lineno"> 1135 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1136 </span><span class="spaces">            </span><span class="istickedoff">lessThanIntegerDenotation</span>
<span class="lineno"> 1137 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramLessThanInteger)</span>
<span class="lineno"> 1138 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1139 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar LessThanEqualsInteger =</span>
<span class="lineno"> 1140 </span><span class="spaces">        </span><span class="istickedoff">let lessThanEqualsIntegerDenotation :: Integer -&gt; Integer -&gt; Bool</span>
<span class="lineno"> 1141 </span><span class="spaces">            </span><span class="istickedoff">lessThanEqualsIntegerDenotation = (&lt;=)</span>
<span class="lineno"> 1142 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE lessThanEqualsIntegerDenotation #-}</span>
<span class="lineno"> 1143 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1144 </span><span class="spaces">            </span><span class="istickedoff">lessThanEqualsIntegerDenotation</span>
<span class="lineno"> 1145 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramLessThanEqualsInteger)</span>
<span class="lineno"> 1146 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1147 </span><span class="spaces">    </span><span class="istickedoff">-- Bytestrings</span>
<span class="lineno"> 1148 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar AppendByteString =</span>
<span class="lineno"> 1149 </span><span class="spaces">        </span><span class="istickedoff">let appendByteStringDenotation :: BS.ByteString -&gt; BS.ByteString -&gt; BS.ByteString</span>
<span class="lineno"> 1150 </span><span class="spaces">            </span><span class="istickedoff">appendByteStringDenotation = BS.append</span>
<span class="lineno"> 1151 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE appendByteStringDenotation #-}</span>
<span class="lineno"> 1152 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1153 </span><span class="spaces">            </span><span class="istickedoff">appendByteStringDenotation</span>
<span class="lineno"> 1154 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramAppendByteString)</span>
<span class="lineno"> 1155 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1156 </span><span class="spaces">    </span><span class="istickedoff">-- See Note [Builtin semantics variants]</span>
<span class="lineno"> 1157 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning semvar ConsByteString =</span>
<span class="lineno"> 1158 </span><span class="spaces">        </span><span class="istickedoff">-- The costing function is the same for all variants of this builtin,</span>
<span class="lineno"> 1159 </span><span class="spaces">        </span><span class="istickedoff">-- but since the denotation of the builtin accepts constants of</span>
<span class="lineno"> 1160 </span><span class="spaces">        </span><span class="istickedoff">-- different types ('Integer' vs 'Word8'), the costing function needs to</span>
<span class="lineno"> 1161 </span><span class="spaces">        </span><span class="istickedoff">-- by polymorphic over the type of constant.</span>
<span class="lineno"> 1162 </span><span class="spaces">        </span><span class="istickedoff">let costingFun</span>
<span class="lineno"> 1163 </span><span class="spaces">                </span><span class="istickedoff">:: ExMemoryUsage a =&gt; BuiltinCostModel -&gt; a -&gt; BS.ByteString -&gt; ExBudgetStream</span>
<span class="lineno"> 1164 </span><span class="spaces">            </span><span class="istickedoff">costingFun = runCostingFunTwoArguments . paramConsByteString</span>
<span class="lineno"> 1165 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE costingFun #-}</span>
<span class="lineno"> 1166 </span><span class="spaces">            </span><span class="istickedoff">consByteStringMeaning_V1 =</span>
<span class="lineno"> 1167 </span><span class="spaces">                </span><span class="istickedoff">let consByteStringDenotation :: Integer -&gt; BS.ByteString -&gt; BS.ByteString</span>
<span class="lineno"> 1168 </span><span class="spaces">                    </span><span class="istickedoff">consByteStringDenotation n = BS.cons (fromIntegral n)</span>
<span class="lineno"> 1169 </span><span class="spaces">                    </span><span class="istickedoff">-- Earlier instructions say never to use `fromIntegral` in the definition of a</span>
<span class="lineno"> 1170 </span><span class="spaces">                    </span><span class="istickedoff">-- builtin; however in this case it reduces its argument modulo 256 to get a</span>
<span class="lineno"> 1171 </span><span class="spaces">                    </span><span class="istickedoff">-- `Word8`, which is exactly what we want.</span>
<span class="lineno"> 1172 </span><span class="spaces">                    </span><span class="istickedoff">{-# INLINE consByteStringDenotation #-}</span>
<span class="lineno"> 1173 </span><span class="spaces">                </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1174 </span><span class="spaces">                    </span><span class="istickedoff">consByteStringDenotation</span>
<span class="lineno"> 1175 </span><span class="spaces">                    </span><span class="istickedoff">costingFun</span>
<span class="lineno"> 1176 </span><span class="spaces">            </span><span class="istickedoff">-- For builtin semantics variants larger than 'DefaultFunSemanticsVariantA', the first</span>
<span class="lineno"> 1177 </span><span class="spaces">            </span><span class="istickedoff">-- input must be in range @[0..255]@.</span>
<span class="lineno"> 1178 </span><span class="spaces">            </span><span class="istickedoff">consByteStringMeaning_V2 =</span>
<span class="lineno"> 1179 </span><span class="spaces">                </span><span class="istickedoff">let consByteStringDenotation :: Word8 -&gt; BS.ByteString -&gt; BS.ByteString</span>
<span class="lineno"> 1180 </span><span class="spaces">                    </span><span class="istickedoff">consByteStringDenotation = BS.cons</span>
<span class="lineno"> 1181 </span><span class="spaces">                    </span><span class="istickedoff">{-# INLINE consByteStringDenotation #-}</span>
<span class="lineno"> 1182 </span><span class="spaces">                </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1183 </span><span class="spaces">                    </span><span class="istickedoff">consByteStringDenotation</span>
<span class="lineno"> 1184 </span><span class="spaces">                    </span><span class="istickedoff">costingFun</span>
<span class="lineno"> 1185 </span><span class="spaces">        </span><span class="istickedoff">in case semvar of</span>
<span class="lineno"> 1186 </span><span class="spaces">            </span><span class="istickedoff">DefaultFunSemanticsVariantA -&gt; consByteStringMeaning_V1</span>
<span class="lineno"> 1187 </span><span class="spaces">            </span><span class="istickedoff">DefaultFunSemanticsVariantB -&gt; consByteStringMeaning_V1</span>
<span class="lineno"> 1188 </span><span class="spaces">            </span><span class="istickedoff">DefaultFunSemanticsVariantC -&gt; consByteStringMeaning_V2</span>
<span class="lineno"> 1189 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1190 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar SliceByteString =</span>
<span class="lineno"> 1191 </span><span class="spaces">        </span><span class="istickedoff">let sliceByteStringDenotation :: Int -&gt; Int -&gt; BS.ByteString -&gt; BS.ByteString</span>
<span class="lineno"> 1192 </span><span class="spaces">            </span><span class="istickedoff">sliceByteStringDenotation start n xs = BS.take n (BS.drop start xs)</span>
<span class="lineno"> 1193 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE sliceByteStringDenotation #-}</span>
<span class="lineno"> 1194 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1195 </span><span class="spaces">            </span><span class="istickedoff">sliceByteStringDenotation</span>
<span class="lineno"> 1196 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunThreeArguments . paramSliceByteString)</span>
<span class="lineno"> 1197 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1198 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar LengthOfByteString =</span>
<span class="lineno"> 1199 </span><span class="spaces">        </span><span class="istickedoff">let lengthOfByteStringDenotation :: BS.ByteString -&gt; Int</span>
<span class="lineno"> 1200 </span><span class="spaces">            </span><span class="istickedoff">lengthOfByteStringDenotation = BS.length</span>
<span class="lineno"> 1201 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE lengthOfByteStringDenotation #-}</span>
<span class="lineno"> 1202 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1203 </span><span class="spaces">            </span><span class="istickedoff">lengthOfByteStringDenotation</span>
<span class="lineno"> 1204 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramLengthOfByteString)</span>
<span class="lineno"> 1205 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1206 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar IndexByteString =</span>
<span class="lineno"> 1207 </span><span class="spaces">        </span><span class="istickedoff">let indexByteStringDenotation :: BS.ByteString -&gt; Int -&gt; BuiltinResult Word8</span>
<span class="lineno"> 1208 </span><span class="spaces">            </span><span class="istickedoff">indexByteStringDenotation xs n = do</span>
<span class="lineno"> 1209 </span><span class="spaces">                </span><span class="istickedoff">unless (n &gt;= 0 &amp;&amp; n &lt; BS.length xs) $</span>
<span class="lineno"> 1210 </span><span class="spaces">                    </span><span class="istickedoff">-- See Note [Structural vs operational errors within builtins].</span>
<span class="lineno"> 1211 </span><span class="spaces">                    </span><span class="istickedoff">-- The arguments are going to be printed in the &quot;cause&quot; part of the error</span>
<span class="lineno"> 1212 </span><span class="spaces">                    </span><span class="istickedoff">-- message, so we don't need to repeat them here.</span>
<span class="lineno"> 1213 </span><span class="spaces">                    </span><span class="istickedoff">fail &quot;Index out of bounds&quot;</span>
<span class="lineno"> 1214 </span><span class="spaces">                </span><span class="istickedoff">pure $ BS.index xs n</span>
<span class="lineno"> 1215 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE indexByteStringDenotation #-}</span>
<span class="lineno"> 1216 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1217 </span><span class="spaces">            </span><span class="istickedoff">indexByteStringDenotation</span>
<span class="lineno"> 1218 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramIndexByteString)</span>
<span class="lineno"> 1219 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1220 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar EqualsByteString =</span>
<span class="lineno"> 1221 </span><span class="spaces">        </span><span class="istickedoff">let equalsByteStringDenotation :: BS.ByteString -&gt; BS.ByteString -&gt; Bool</span>
<span class="lineno"> 1222 </span><span class="spaces">            </span><span class="istickedoff">equalsByteStringDenotation = (==)</span>
<span class="lineno"> 1223 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE equalsByteStringDenotation #-}</span>
<span class="lineno"> 1224 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1225 </span><span class="spaces">            </span><span class="istickedoff">equalsByteStringDenotation</span>
<span class="lineno"> 1226 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramEqualsByteString)</span>
<span class="lineno"> 1227 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1228 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar LessThanByteString =</span>
<span class="lineno"> 1229 </span><span class="spaces">        </span><span class="istickedoff">let lessThanByteStringDenotation :: BS.ByteString -&gt; BS.ByteString -&gt; Bool</span>
<span class="lineno"> 1230 </span><span class="spaces">            </span><span class="istickedoff">lessThanByteStringDenotation = (&lt;)</span>
<span class="lineno"> 1231 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE lessThanByteStringDenotation #-}</span>
<span class="lineno"> 1232 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1233 </span><span class="spaces">            </span><span class="istickedoff">lessThanByteStringDenotation</span>
<span class="lineno"> 1234 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramLessThanByteString)</span>
<span class="lineno"> 1235 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1236 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar LessThanEqualsByteString =</span>
<span class="lineno"> 1237 </span><span class="spaces">        </span><span class="istickedoff">let lessThanEqualsByteStringDenotation :: BS.ByteString -&gt; BS.ByteString -&gt; Bool</span>
<span class="lineno"> 1238 </span><span class="spaces">            </span><span class="istickedoff">lessThanEqualsByteStringDenotation = (&lt;=)</span>
<span class="lineno"> 1239 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE lessThanEqualsByteStringDenotation #-}</span>
<span class="lineno"> 1240 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1241 </span><span class="spaces">            </span><span class="istickedoff">lessThanEqualsByteStringDenotation</span>
<span class="lineno"> 1242 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramLessThanEqualsByteString)</span>
<span class="lineno"> 1243 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1244 </span><span class="spaces">    </span><span class="istickedoff">-- Cryptography and hashes</span>
<span class="lineno"> 1245 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Sha2_256 =</span>
<span class="lineno"> 1246 </span><span class="spaces">        </span><span class="istickedoff">let sha2_256Denotation :: BS.ByteString -&gt; BS.ByteString</span>
<span class="lineno"> 1247 </span><span class="spaces">            </span><span class="istickedoff">sha2_256Denotation = Hash.sha2_256</span>
<span class="lineno"> 1248 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE sha2_256Denotation #-}</span>
<span class="lineno"> 1249 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1250 </span><span class="spaces">            </span><span class="istickedoff">sha2_256Denotation</span>
<span class="lineno"> 1251 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramSha2_256)</span>
<span class="lineno"> 1252 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1253 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Sha3_256 =</span>
<span class="lineno"> 1254 </span><span class="spaces">        </span><span class="istickedoff">let sha3_256Denotation :: BS.ByteString -&gt; BS.ByteString</span>
<span class="lineno"> 1255 </span><span class="spaces">            </span><span class="istickedoff">sha3_256Denotation = Hash.sha3_256</span>
<span class="lineno"> 1256 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE sha3_256Denotation #-}</span>
<span class="lineno"> 1257 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1258 </span><span class="spaces">            </span><span class="istickedoff">sha3_256Denotation</span>
<span class="lineno"> 1259 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramSha3_256)</span>
<span class="lineno"> 1260 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1261 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Blake2b_256 =</span>
<span class="lineno"> 1262 </span><span class="spaces">        </span><span class="istickedoff">let blake2b_256Denotation :: BS.ByteString -&gt; BS.ByteString</span>
<span class="lineno"> 1263 </span><span class="spaces">            </span><span class="istickedoff">blake2b_256Denotation = Hash.blake2b_256</span>
<span class="lineno"> 1264 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE blake2b_256Denotation #-}</span>
<span class="lineno"> 1265 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1266 </span><span class="spaces">            </span><span class="istickedoff">blake2b_256Denotation</span>
<span class="lineno"> 1267 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramBlake2b_256)</span>
<span class="lineno"> 1268 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1269 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar VerifyEd25519Signature =</span>
<span class="lineno"> 1270 </span><span class="spaces">        </span><span class="istickedoff">let verifyEd25519SignatureDenotation</span>
<span class="lineno"> 1271 </span><span class="spaces">                </span><span class="istickedoff">:: BS.ByteString -&gt; BS.ByteString -&gt; BS.ByteString -&gt; BuiltinResult Bool</span>
<span class="lineno"> 1272 </span><span class="spaces">            </span><span class="istickedoff">verifyEd25519SignatureDenotation = verifyEd25519Signature</span>
<span class="lineno"> 1273 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE verifyEd25519SignatureDenotation #-}</span>
<span class="lineno"> 1274 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1275 </span><span class="spaces">            </span><span class="istickedoff">verifyEd25519SignatureDenotation</span>
<span class="lineno"> 1276 </span><span class="spaces">            </span><span class="istickedoff">-- Benchmarks indicate that the two variants have very similar</span>
<span class="lineno"> 1277 </span><span class="spaces">            </span><span class="istickedoff">-- execution times, so it's safe to use the same costing function for</span>
<span class="lineno"> 1278 </span><span class="spaces">            </span><span class="istickedoff">-- both.</span>
<span class="lineno"> 1279 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunThreeArguments . paramVerifyEd25519Signature)</span>
<span class="lineno"> 1280 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1281 </span><span class="spaces">    </span><span class="istickedoff">{- Note [ECDSA secp256k1 signature verification].  An ECDSA signature</span>
<span class="lineno"> 1282 </span><span class="spaces">       </span><span class="istickedoff">consists of a pair of values (r,s), and for each value of r there are in</span>
<span class="lineno"> 1283 </span><span class="spaces">       </span><span class="istickedoff">fact two valid values of s, one effectively the negative of the other.</span>
<span class="lineno"> 1284 </span><span class="spaces">       </span><span class="istickedoff">The Bitcoin implementation that underlies `verifyEcdsaSecp256k1Signature`</span>
<span class="lineno"> 1285 </span><span class="spaces">       </span><span class="istickedoff">expects that the lower of the two possible values of the s component of</span>
<span class="lineno"> 1286 </span><span class="spaces">       </span><span class="istickedoff">the signature is used, returning `false` immediately if that's not the</span>
<span class="lineno"> 1287 </span><span class="spaces">       </span><span class="istickedoff">case.  It appears that this restriction is peculiar to Bitcoin, and ECDSA</span>
<span class="lineno"> 1288 </span><span class="spaces">       </span><span class="istickedoff">schemes in general don't require it.  Thus this function may be more</span>
<span class="lineno"> 1289 </span><span class="spaces">       </span><span class="istickedoff">restrictive than expected.  See</span>
<span class="lineno"> 1290 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1291 </span><span class="spaces">          </span><span class="istickedoff">https://github.com/bitcoin/bips/blob/master/bip-0146.mediawiki#LOW_S</span>
<span class="lineno"> 1292 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1293 </span><span class="spaces">       </span><span class="istickedoff">and the implementation of secp256k1_ecdsa_verify in</span>
<span class="lineno"> 1294 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1295 </span><span class="spaces">          </span><span class="istickedoff">https://github.com/bitcoin-core/secp256k1.</span>
<span class="lineno"> 1296 </span><span class="spaces">     </span><span class="istickedoff">-}</span>
<span class="lineno"> 1297 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar VerifyEcdsaSecp256k1Signature =</span>
<span class="lineno"> 1298 </span><span class="spaces">        </span><span class="istickedoff">let verifyEcdsaSecp256k1SignatureDenotation</span>
<span class="lineno"> 1299 </span><span class="spaces">                </span><span class="istickedoff">:: BS.ByteString -&gt; BS.ByteString -&gt; BS.ByteString -&gt; BuiltinResult Bool</span>
<span class="lineno"> 1300 </span><span class="spaces">            </span><span class="istickedoff">verifyEcdsaSecp256k1SignatureDenotation = verifyEcdsaSecp256k1Signature</span>
<span class="lineno"> 1301 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE verifyEcdsaSecp256k1SignatureDenotation #-}</span>
<span class="lineno"> 1302 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1303 </span><span class="spaces">            </span><span class="istickedoff">verifyEcdsaSecp256k1SignatureDenotation</span>
<span class="lineno"> 1304 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunThreeArguments . paramVerifyEcdsaSecp256k1Signature)</span>
<span class="lineno"> 1305 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1306 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar VerifySchnorrSecp256k1Signature =</span>
<span class="lineno"> 1307 </span><span class="spaces">        </span><span class="istickedoff">let verifySchnorrSecp256k1SignatureDenotation</span>
<span class="lineno"> 1308 </span><span class="spaces">                </span><span class="istickedoff">:: BS.ByteString -&gt; BS.ByteString -&gt; BS.ByteString -&gt; BuiltinResult Bool</span>
<span class="lineno"> 1309 </span><span class="spaces">            </span><span class="istickedoff">verifySchnorrSecp256k1SignatureDenotation = verifySchnorrSecp256k1Signature</span>
<span class="lineno"> 1310 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE verifySchnorrSecp256k1SignatureDenotation #-}</span>
<span class="lineno"> 1311 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1312 </span><span class="spaces">            </span><span class="istickedoff">verifySchnorrSecp256k1SignatureDenotation</span>
<span class="lineno"> 1313 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunThreeArguments . paramVerifySchnorrSecp256k1Signature)</span>
<span class="lineno"> 1314 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1315 </span><span class="spaces">    </span><span class="istickedoff">-- Strings</span>
<span class="lineno"> 1316 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar AppendString =</span>
<span class="lineno"> 1317 </span><span class="spaces">        </span><span class="istickedoff">let appendStringDenotation :: Text -&gt; Text -&gt; Text</span>
<span class="lineno"> 1318 </span><span class="spaces">            </span><span class="istickedoff">appendStringDenotation = (&lt;&gt;)</span>
<span class="lineno"> 1319 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE appendStringDenotation #-}</span>
<span class="lineno"> 1320 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1321 </span><span class="spaces">            </span><span class="istickedoff">appendStringDenotation</span>
<span class="lineno"> 1322 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramAppendString)</span>
<span class="lineno"> 1323 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1324 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar EqualsString =</span>
<span class="lineno"> 1325 </span><span class="spaces">        </span><span class="istickedoff">let equalsStringDenotation :: Text -&gt; Text -&gt; Bool</span>
<span class="lineno"> 1326 </span><span class="spaces">            </span><span class="istickedoff">equalsStringDenotation = (==)</span>
<span class="lineno"> 1327 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE equalsStringDenotation #-}</span>
<span class="lineno"> 1328 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1329 </span><span class="spaces">            </span><span class="istickedoff">equalsStringDenotation</span>
<span class="lineno"> 1330 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramEqualsString)</span>
<span class="lineno"> 1331 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1332 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar EncodeUtf8 =</span>
<span class="lineno"> 1333 </span><span class="spaces">        </span><span class="istickedoff">let encodeUtf8Denotation :: Text -&gt; BS.ByteString</span>
<span class="lineno"> 1334 </span><span class="spaces">            </span><span class="istickedoff">encodeUtf8Denotation = encodeUtf8</span>
<span class="lineno"> 1335 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE encodeUtf8Denotation #-}</span>
<span class="lineno"> 1336 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1337 </span><span class="spaces">            </span><span class="istickedoff">encodeUtf8Denotation</span>
<span class="lineno"> 1338 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramEncodeUtf8)</span>
<span class="lineno"> 1339 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1340 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar DecodeUtf8 =</span>
<span class="lineno"> 1341 </span><span class="spaces">        </span><span class="istickedoff">let decodeUtf8Denotation :: BS.ByteString -&gt; BuiltinResult Text</span>
<span class="lineno"> 1342 </span><span class="spaces">            </span><span class="istickedoff">decodeUtf8Denotation = eitherToBuiltinResult . decodeUtf8'</span>
<span class="lineno"> 1343 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE decodeUtf8Denotation #-}</span>
<span class="lineno"> 1344 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1345 </span><span class="spaces">            </span><span class="istickedoff">decodeUtf8Denotation</span>
<span class="lineno"> 1346 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramDecodeUtf8)</span>
<span class="lineno"> 1347 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1348 </span><span class="spaces">    </span><span class="istickedoff">-- Bool</span>
<span class="lineno"> 1349 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar IfThenElse =</span>
<span class="lineno"> 1350 </span><span class="spaces">        </span><span class="istickedoff">let ifThenElseDenotation :: Bool -&gt; a -&gt; a -&gt; a</span>
<span class="lineno"> 1351 </span><span class="spaces">            </span><span class="istickedoff">ifThenElseDenotation b x y = if b then x else y</span>
<span class="lineno"> 1352 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE ifThenElseDenotation #-}</span>
<span class="lineno"> 1353 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1354 </span><span class="spaces">            </span><span class="istickedoff">ifThenElseDenotation</span>
<span class="lineno"> 1355 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunThreeArguments . paramIfThenElse)</span>
<span class="lineno"> 1356 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1357 </span><span class="spaces">    </span><span class="istickedoff">-- Unit</span>
<span class="lineno"> 1358 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar ChooseUnit =</span>
<span class="lineno"> 1359 </span><span class="spaces">        </span><span class="istickedoff">let chooseUnitDenotation :: () -&gt; a -&gt; a</span>
<span class="lineno"> 1360 </span><span class="spaces">            </span><span class="istickedoff">chooseUnitDenotation () x = x</span>
<span class="lineno"> 1361 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE chooseUnitDenotation #-}</span>
<span class="lineno"> 1362 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1363 </span><span class="spaces">            </span><span class="istickedoff">chooseUnitDenotation</span>
<span class="lineno"> 1364 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramChooseUnit)</span>
<span class="lineno"> 1365 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1366 </span><span class="spaces">    </span><span class="istickedoff">-- Tracing</span>
<span class="lineno"> 1367 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Trace =</span>
<span class="lineno"> 1368 </span><span class="spaces">        </span><span class="istickedoff">let traceDenotation :: Text -&gt; a -&gt; BuiltinResult a</span>
<span class="lineno"> 1369 </span><span class="spaces">            </span><span class="istickedoff">traceDenotation text a = a &lt;$ emit text</span>
<span class="lineno"> 1370 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE traceDenotation #-}</span>
<span class="lineno"> 1371 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1372 </span><span class="spaces">            </span><span class="istickedoff">traceDenotation</span>
<span class="lineno"> 1373 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramTrace)</span>
<span class="lineno"> 1374 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1375 </span><span class="spaces">    </span><span class="istickedoff">-- Pairs</span>
<span class="lineno"> 1376 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar FstPair =</span>
<span class="lineno"> 1377 </span><span class="spaces">        </span><span class="istickedoff">let fstPairDenotation :: SomeConstant uni (a, b) -&gt; BuiltinResult (Opaque val a)</span>
<span class="lineno"> 1378 </span><span class="spaces">            </span><span class="istickedoff">fstPairDenotation (SomeConstant (Some (ValueOf uniPairAB xy))) =</span>
<span class="lineno"> 1379 </span><span class="spaces">                </span><span class="istickedoff">case uniPairAB of</span>
<span class="lineno"> 1380 </span><span class="spaces">                    </span><span class="istickedoff">DefaultUniPair uniA _ -&gt; pure . fromValueOf uniA $ fst xy</span>
<span class="lineno"> 1381 </span><span class="spaces">                    </span><span class="istickedoff">_                     -&gt;</span>
<span class="lineno"> 1382 </span><span class="spaces">                        </span><span class="istickedoff">-- See Note [Structural vs operational errors within builtins].</span>
<span class="lineno"> 1383 </span><span class="spaces">                        </span><span class="istickedoff">throwError $ structuralUnliftingError &quot;Expected a pair but got something else&quot;</span>
<span class="lineno"> 1384 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE fstPairDenotation #-}</span>
<span class="lineno"> 1385 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1386 </span><span class="spaces">            </span><span class="istickedoff">fstPairDenotation</span>
<span class="lineno"> 1387 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramFstPair)</span>
<span class="lineno"> 1388 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1389 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar SndPair =</span>
<span class="lineno"> 1390 </span><span class="spaces">        </span><span class="istickedoff">let sndPairDenotation :: SomeConstant uni (a, b) -&gt; BuiltinResult (Opaque val b)</span>
<span class="lineno"> 1391 </span><span class="spaces">            </span><span class="istickedoff">sndPairDenotation (SomeConstant (Some (ValueOf uniPairAB xy))) =</span>
<span class="lineno"> 1392 </span><span class="spaces">                </span><span class="istickedoff">case uniPairAB of</span>
<span class="lineno"> 1393 </span><span class="spaces">                    </span><span class="istickedoff">DefaultUniPair _ uniB -&gt; pure . fromValueOf uniB $ snd xy</span>
<span class="lineno"> 1394 </span><span class="spaces">                    </span><span class="istickedoff">_                     -&gt;</span>
<span class="lineno"> 1395 </span><span class="spaces">                        </span><span class="istickedoff">-- See Note [Structural vs operational errors within builtins].</span>
<span class="lineno"> 1396 </span><span class="spaces">                        </span><span class="istickedoff">throwError $ structuralUnliftingError &quot;Expected a pair but got something else&quot;</span>
<span class="lineno"> 1397 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE sndPairDenotation #-}</span>
<span class="lineno"> 1398 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1399 </span><span class="spaces">            </span><span class="istickedoff">sndPairDenotation</span>
<span class="lineno"> 1400 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramSndPair)</span>
<span class="lineno"> 1401 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1402 </span><span class="spaces">    </span><span class="istickedoff">-- Lists</span>
<span class="lineno"> 1403 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar ChooseList =</span>
<span class="lineno"> 1404 </span><span class="spaces">        </span><span class="istickedoff">let chooseListDenotation :: SomeConstant uni [a] -&gt; b -&gt; b -&gt; BuiltinResult b</span>
<span class="lineno"> 1405 </span><span class="spaces">            </span><span class="istickedoff">chooseListDenotation (SomeConstant (Some (ValueOf uniListA xs))) a b =</span>
<span class="lineno"> 1406 </span><span class="spaces">                </span><span class="istickedoff">case uniListA of</span>
<span class="lineno"> 1407 </span><span class="spaces">                    </span><span class="istickedoff">DefaultUniList _ -&gt; pure $ case xs of</span>
<span class="lineno"> 1408 </span><span class="spaces">                        </span><span class="istickedoff">[]    -&gt; a</span>
<span class="lineno"> 1409 </span><span class="spaces">                        </span><span class="istickedoff">_ : _ -&gt; b</span>
<span class="lineno"> 1410 </span><span class="spaces">                    </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1411 </span><span class="spaces">                        </span><span class="istickedoff">-- See Note [Structural vs operational errors within builtins].</span>
<span class="lineno"> 1412 </span><span class="spaces">                        </span><span class="istickedoff">throwError $ structuralUnliftingError &quot;Expected a list but got something else&quot;</span>
<span class="lineno"> 1413 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE chooseListDenotation #-}</span>
<span class="lineno"> 1414 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1415 </span><span class="spaces">            </span><span class="istickedoff">chooseListDenotation</span>
<span class="lineno"> 1416 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunThreeArguments . paramChooseList)</span>
<span class="lineno"> 1417 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1418 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar MkCons =</span>
<span class="lineno"> 1419 </span><span class="spaces">        </span><span class="istickedoff">let mkConsDenotation</span>
<span class="lineno"> 1420 </span><span class="spaces">                </span><span class="istickedoff">:: SomeConstant uni a -&gt; SomeConstant uni [a] -&gt; BuiltinResult (Opaque val [a])</span>
<span class="lineno"> 1421 </span><span class="spaces">            </span><span class="istickedoff">mkConsDenotation</span>
<span class="lineno"> 1422 </span><span class="spaces">              </span><span class="istickedoff">(SomeConstant (Some (ValueOf uniA x)))</span>
<span class="lineno"> 1423 </span><span class="spaces">              </span><span class="istickedoff">(SomeConstant (Some (ValueOf uniListA xs))) =</span>
<span class="lineno"> 1424 </span><span class="spaces">                </span><span class="istickedoff">-- See Note [Structural vs operational errors within builtins].</span>
<span class="lineno"> 1425 </span><span class="spaces">                </span><span class="istickedoff">case uniListA of</span>
<span class="lineno"> 1426 </span><span class="spaces">                    </span><span class="istickedoff">DefaultUniList uniA' -&gt; case uniA `geq` uniA' of</span>
<span class="lineno"> 1427 </span><span class="spaces">                        </span><span class="istickedoff">Just Refl -&gt; pure . fromValueOf uniListA $ x : xs</span>
<span class="lineno"> 1428 </span><span class="spaces">                        </span><span class="istickedoff">_         -&gt; throwError $ structuralUnliftingError</span>
<span class="lineno"> 1429 </span><span class="spaces">                            </span><span class="istickedoff">&quot;The type of the value does not match the type of elements in the list&quot;</span>
<span class="lineno"> 1430 </span><span class="spaces">                    </span><span class="istickedoff">_ -&gt; throwError $ structuralUnliftingError &quot;Expected a list but got something else&quot;</span>
<span class="lineno"> 1431 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE mkConsDenotation #-}</span>
<span class="lineno"> 1432 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1433 </span><span class="spaces">            </span><span class="istickedoff">mkConsDenotation</span>
<span class="lineno"> 1434 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramMkCons)</span>
<span class="lineno"> 1435 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1436 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar HeadList =</span>
<span class="lineno"> 1437 </span><span class="spaces">        </span><span class="istickedoff">let headListDenotation :: SomeConstant uni [a] -&gt; BuiltinResult (Opaque val a)</span>
<span class="lineno"> 1438 </span><span class="spaces">            </span><span class="istickedoff">headListDenotation (SomeConstant (Some (ValueOf uniListA xs))) =</span>
<span class="lineno"> 1439 </span><span class="spaces">                </span><span class="istickedoff">case uniListA of</span>
<span class="lineno"> 1440 </span><span class="spaces">                    </span><span class="istickedoff">DefaultUniList uniA -&gt; case xs of</span>
<span class="lineno"> 1441 </span><span class="spaces">                        </span><span class="istickedoff">[]    -&gt; fail &quot;Expected a non-empty list but got an empty one&quot;</span>
<span class="lineno"> 1442 </span><span class="spaces">                        </span><span class="istickedoff">x : _ -&gt; pure $ fromValueOf uniA x</span>
<span class="lineno"> 1443 </span><span class="spaces">                    </span><span class="istickedoff">_ -&gt; throwError $ structuralUnliftingError &quot;Expected a list but got something else&quot;</span>
<span class="lineno"> 1444 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE headListDenotation #-}</span>
<span class="lineno"> 1445 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1446 </span><span class="spaces">            </span><span class="istickedoff">headListDenotation</span>
<span class="lineno"> 1447 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramHeadList)</span>
<span class="lineno"> 1448 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1449 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar TailList =</span>
<span class="lineno"> 1450 </span><span class="spaces">        </span><span class="istickedoff">let tailListDenotation :: SomeConstant uni [a] -&gt; BuiltinResult (Opaque val [a])</span>
<span class="lineno"> 1451 </span><span class="spaces">            </span><span class="istickedoff">tailListDenotation (SomeConstant (Some (ValueOf uniListA xs))) =</span>
<span class="lineno"> 1452 </span><span class="spaces">                </span><span class="istickedoff">case uniListA of</span>
<span class="lineno"> 1453 </span><span class="spaces">                    </span><span class="istickedoff">DefaultUniList _argUni -&gt;</span>
<span class="lineno"> 1454 </span><span class="spaces">                      </span><span class="istickedoff">case xs of</span>
<span class="lineno"> 1455 </span><span class="spaces">                        </span><span class="istickedoff">[]      -&gt; fail &quot;Expected a non-empty list but got an empty one&quot;</span>
<span class="lineno"> 1456 </span><span class="spaces">                        </span><span class="istickedoff">_ : xs' -&gt; pure $ fromValueOf uniListA xs'</span>
<span class="lineno"> 1457 </span><span class="spaces">                    </span><span class="istickedoff">_ -&gt; throwError $ structuralUnliftingError &quot;Expected a list but got something else&quot;</span>
<span class="lineno"> 1458 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE tailListDenotation #-}</span>
<span class="lineno"> 1459 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1460 </span><span class="spaces">            </span><span class="istickedoff">tailListDenotation</span>
<span class="lineno"> 1461 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramTailList)</span>
<span class="lineno"> 1462 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1463 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar NullList =</span>
<span class="lineno"> 1464 </span><span class="spaces">        </span><span class="istickedoff">let nullListDenotation :: SomeConstant uni [a] -&gt; BuiltinResult Bool</span>
<span class="lineno"> 1465 </span><span class="spaces">            </span><span class="istickedoff">nullListDenotation (SomeConstant (Some (ValueOf uniListA xs))) =</span>
<span class="lineno"> 1466 </span><span class="spaces">                </span><span class="istickedoff">case uniListA of</span>
<span class="lineno"> 1467 </span><span class="spaces">                    </span><span class="istickedoff">DefaultUniList _uniA -&gt; pure $ null xs</span>
<span class="lineno"> 1468 </span><span class="spaces">                    </span><span class="istickedoff">_ -&gt; throwError $ structuralUnliftingError &quot;Expected a list but got something else&quot;</span>
<span class="lineno"> 1469 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE nullListDenotation #-}</span>
<span class="lineno"> 1470 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1471 </span><span class="spaces">            </span><span class="istickedoff">nullListDenotation</span>
<span class="lineno"> 1472 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramNullList)</span>
<span class="lineno"> 1473 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1474 </span><span class="spaces">    </span><span class="istickedoff">-- Data</span>
<span class="lineno"> 1475 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar ChooseData =</span>
<span class="lineno"> 1476 </span><span class="spaces">        </span><span class="istickedoff">let chooseDataDenotation :: Data -&gt; a -&gt; a -&gt; a -&gt; a -&gt; a -&gt; a</span>
<span class="lineno"> 1477 </span><span class="spaces">            </span><span class="istickedoff">chooseDataDenotation d xConstr xMap xList xI xB =</span>
<span class="lineno"> 1478 </span><span class="spaces">                </span><span class="istickedoff">case d of</span>
<span class="lineno"> 1479 </span><span class="spaces">                    </span><span class="istickedoff">Constr {} -&gt; xConstr</span>
<span class="lineno"> 1480 </span><span class="spaces">                    </span><span class="istickedoff">Map    {} -&gt; xMap</span>
<span class="lineno"> 1481 </span><span class="spaces">                    </span><span class="istickedoff">List   {} -&gt; xList</span>
<span class="lineno"> 1482 </span><span class="spaces">                    </span><span class="istickedoff">I      {} -&gt; xI</span>
<span class="lineno"> 1483 </span><span class="spaces">                    </span><span class="istickedoff">B      {} -&gt; xB</span>
<span class="lineno"> 1484 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE chooseDataDenotation #-}</span>
<span class="lineno"> 1485 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1486 </span><span class="spaces">            </span><span class="istickedoff">chooseDataDenotation</span>
<span class="lineno"> 1487 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunSixArguments . paramChooseData)</span>
<span class="lineno"> 1488 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1489 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar ConstrData =</span>
<span class="lineno"> 1490 </span><span class="spaces">        </span><span class="istickedoff">let constrDataDenotation :: Integer -&gt; [Data] -&gt; Data</span>
<span class="lineno"> 1491 </span><span class="spaces">            </span><span class="istickedoff">constrDataDenotation = Constr</span>
<span class="lineno"> 1492 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE constrDataDenotation #-}</span>
<span class="lineno"> 1493 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1494 </span><span class="spaces">            </span><span class="istickedoff">constrDataDenotation</span>
<span class="lineno"> 1495 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramConstrData)</span>
<span class="lineno"> 1496 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1497 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar MapData =</span>
<span class="lineno"> 1498 </span><span class="spaces">        </span><span class="istickedoff">let mapDataDenotation :: [(Data, Data)] -&gt; Data</span>
<span class="lineno"> 1499 </span><span class="spaces">            </span><span class="istickedoff">mapDataDenotation = Map</span>
<span class="lineno"> 1500 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE mapDataDenotation #-}</span>
<span class="lineno"> 1501 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1502 </span><span class="spaces">            </span><span class="istickedoff">mapDataDenotation</span>
<span class="lineno"> 1503 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramMapData)</span>
<span class="lineno"> 1504 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1505 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar ListData =</span>
<span class="lineno"> 1506 </span><span class="spaces">        </span><span class="istickedoff">let listDataDenotation :: [Data] -&gt; Data</span>
<span class="lineno"> 1507 </span><span class="spaces">            </span><span class="istickedoff">listDataDenotation = List</span>
<span class="lineno"> 1508 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE listDataDenotation #-}</span>
<span class="lineno"> 1509 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1510 </span><span class="spaces">            </span><span class="istickedoff">listDataDenotation</span>
<span class="lineno"> 1511 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramListData)</span>
<span class="lineno"> 1512 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1513 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar IData =</span>
<span class="lineno"> 1514 </span><span class="spaces">        </span><span class="istickedoff">let iDataDenotation :: Integer -&gt; Data</span>
<span class="lineno"> 1515 </span><span class="spaces">            </span><span class="istickedoff">iDataDenotation = I</span>
<span class="lineno"> 1516 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE iDataDenotation #-}</span>
<span class="lineno"> 1517 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1518 </span><span class="spaces">            </span><span class="istickedoff">iDataDenotation</span>
<span class="lineno"> 1519 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramIData)</span>
<span class="lineno"> 1520 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1521 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar BData =</span>
<span class="lineno"> 1522 </span><span class="spaces">        </span><span class="istickedoff">let bDataDenotation :: BS.ByteString -&gt; Data</span>
<span class="lineno"> 1523 </span><span class="spaces">            </span><span class="istickedoff">bDataDenotation = B</span>
<span class="lineno"> 1524 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE bDataDenotation #-}</span>
<span class="lineno"> 1525 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1526 </span><span class="spaces">            </span><span class="istickedoff">bDataDenotation</span>
<span class="lineno"> 1527 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramBData)</span>
<span class="lineno"> 1528 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1529 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar UnConstrData =</span>
<span class="lineno"> 1530 </span><span class="spaces">        </span><span class="istickedoff">let unConstrDataDenotation :: Data -&gt; BuiltinResult (Integer, [Data])</span>
<span class="lineno"> 1531 </span><span class="spaces">            </span><span class="istickedoff">unConstrDataDenotation = \case</span>
<span class="lineno"> 1532 </span><span class="spaces">                </span><span class="istickedoff">Constr i ds -&gt; pure (i, ds)</span>
<span class="lineno"> 1533 </span><span class="spaces">                </span><span class="istickedoff">_           -&gt;</span>
<span class="lineno"> 1534 </span><span class="spaces">                    </span><span class="istickedoff">-- See Note [Structural vs operational errors within builtins].</span>
<span class="lineno"> 1535 </span><span class="spaces">                    </span><span class="istickedoff">fail <span class="nottickedoff">&quot;Expected the Constr constructor but got a different one&quot;</span></span>
<span class="lineno"> 1536 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE unConstrDataDenotation #-}</span>
<span class="lineno"> 1537 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1538 </span><span class="spaces">            </span><span class="istickedoff">unConstrDataDenotation</span>
<span class="lineno"> 1539 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramUnConstrData)</span>
<span class="lineno"> 1540 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1541 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar UnMapData =</span>
<span class="lineno"> 1542 </span><span class="spaces">        </span><span class="istickedoff">let unMapDataDenotation :: Data -&gt; BuiltinResult [(Data, Data)]</span>
<span class="lineno"> 1543 </span><span class="spaces">            </span><span class="istickedoff">unMapDataDenotation = \case</span>
<span class="lineno"> 1544 </span><span class="spaces">                </span><span class="istickedoff">Map es -&gt; pure es</span>
<span class="lineno"> 1545 </span><span class="spaces">                </span><span class="istickedoff">_      -&gt;</span>
<span class="lineno"> 1546 </span><span class="spaces">                    </span><span class="istickedoff">-- See Note [Structural vs operational errors within builtins].</span>
<span class="lineno"> 1547 </span><span class="spaces">                    </span><span class="istickedoff">fail <span class="nottickedoff">&quot;Expected the Map constructor but got a different one&quot;</span></span>
<span class="lineno"> 1548 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE unMapDataDenotation #-}</span>
<span class="lineno"> 1549 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1550 </span><span class="spaces">            </span><span class="istickedoff">unMapDataDenotation</span>
<span class="lineno"> 1551 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramUnMapData)</span>
<span class="lineno"> 1552 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1553 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar UnListData =</span>
<span class="lineno"> 1554 </span><span class="spaces">        </span><span class="istickedoff">let unListDataDenotation :: Data -&gt; BuiltinResult [Data]</span>
<span class="lineno"> 1555 </span><span class="spaces">            </span><span class="istickedoff">unListDataDenotation = \case</span>
<span class="lineno"> 1556 </span><span class="spaces">                </span><span class="istickedoff">List ds -&gt; pure ds</span>
<span class="lineno"> 1557 </span><span class="spaces">                </span><span class="istickedoff">_       -&gt;</span>
<span class="lineno"> 1558 </span><span class="spaces">                    </span><span class="istickedoff">-- See Note [Structural vs operational errors within builtins].</span>
<span class="lineno"> 1559 </span><span class="spaces">                    </span><span class="istickedoff">fail <span class="nottickedoff">&quot;Expected the List constructor but got a different one&quot;</span></span>
<span class="lineno"> 1560 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE unListDataDenotation #-}</span>
<span class="lineno"> 1561 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1562 </span><span class="spaces">            </span><span class="istickedoff">unListDataDenotation</span>
<span class="lineno"> 1563 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramUnListData)</span>
<span class="lineno"> 1564 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1565 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar UnIData =</span>
<span class="lineno"> 1566 </span><span class="spaces">        </span><span class="istickedoff">let unIDataDenotation :: Data -&gt; BuiltinResult Integer</span>
<span class="lineno"> 1567 </span><span class="spaces">            </span><span class="istickedoff">unIDataDenotation = \case</span>
<span class="lineno"> 1568 </span><span class="spaces">                </span><span class="istickedoff">I i -&gt; pure i</span>
<span class="lineno"> 1569 </span><span class="spaces">                </span><span class="istickedoff">_   -&gt;</span>
<span class="lineno"> 1570 </span><span class="spaces">                    </span><span class="istickedoff">-- See Note [Structural vs operational errors within builtins].</span>
<span class="lineno"> 1571 </span><span class="spaces">                    </span><span class="istickedoff">fail <span class="nottickedoff">&quot;Expected the I constructor but got a different one&quot;</span></span>
<span class="lineno"> 1572 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE unIDataDenotation #-}</span>
<span class="lineno"> 1573 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1574 </span><span class="spaces">            </span><span class="istickedoff">unIDataDenotation</span>
<span class="lineno"> 1575 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramUnIData)</span>
<span class="lineno"> 1576 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1577 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar UnBData =</span>
<span class="lineno"> 1578 </span><span class="spaces">        </span><span class="istickedoff">let unBDataDenotation :: Data -&gt; BuiltinResult BS.ByteString</span>
<span class="lineno"> 1579 </span><span class="spaces">            </span><span class="istickedoff">unBDataDenotation = \case</span>
<span class="lineno"> 1580 </span><span class="spaces">                </span><span class="istickedoff">B b -&gt; pure b</span>
<span class="lineno"> 1581 </span><span class="spaces">                </span><span class="istickedoff">_   -&gt;</span>
<span class="lineno"> 1582 </span><span class="spaces">                    </span><span class="istickedoff">-- See Note [Structural vs operational errors within builtins].</span>
<span class="lineno"> 1583 </span><span class="spaces">                    </span><span class="istickedoff">fail <span class="nottickedoff">&quot;Expected the B constructor but got a different one&quot;</span></span>
<span class="lineno"> 1584 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE unBDataDenotation #-}</span>
<span class="lineno"> 1585 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1586 </span><span class="spaces">            </span><span class="istickedoff">unBDataDenotation</span>
<span class="lineno"> 1587 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramUnBData)</span>
<span class="lineno"> 1588 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1589 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar EqualsData =</span>
<span class="lineno"> 1590 </span><span class="spaces">        </span><span class="istickedoff">let equalsDataDenotation :: Data -&gt; Data -&gt; Bool</span>
<span class="lineno"> 1591 </span><span class="spaces">            </span><span class="istickedoff">equalsDataDenotation = (==)</span>
<span class="lineno"> 1592 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE equalsDataDenotation #-}</span>
<span class="lineno"> 1593 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1594 </span><span class="spaces">            </span><span class="istickedoff">equalsDataDenotation</span>
<span class="lineno"> 1595 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramEqualsData)</span>
<span class="lineno"> 1596 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1597 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar SerialiseData =</span>
<span class="lineno"> 1598 </span><span class="spaces">        </span><span class="istickedoff">let serialiseDataDenotation :: Data -&gt; BS.ByteString</span>
<span class="lineno"> 1599 </span><span class="spaces">            </span><span class="istickedoff">serialiseDataDenotation = BSL.toStrict . serialise</span>
<span class="lineno"> 1600 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE serialiseDataDenotation #-}</span>
<span class="lineno"> 1601 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1602 </span><span class="spaces">            </span><span class="istickedoff">serialiseDataDenotation</span>
<span class="lineno"> 1603 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramSerialiseData)</span>
<span class="lineno"> 1604 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1605 </span><span class="spaces">    </span><span class="istickedoff">-- Misc constructors</span>
<span class="lineno"> 1606 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar MkPairData =</span>
<span class="lineno"> 1607 </span><span class="spaces">        </span><span class="istickedoff">let mkPairDataDenotation :: Data -&gt; Data -&gt; (Data, Data)</span>
<span class="lineno"> 1608 </span><span class="spaces">            </span><span class="istickedoff">mkPairDataDenotation = (,)</span>
<span class="lineno"> 1609 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE mkPairDataDenotation #-}</span>
<span class="lineno"> 1610 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1611 </span><span class="spaces">            </span><span class="istickedoff">mkPairDataDenotation</span>
<span class="lineno"> 1612 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramMkPairData)</span>
<span class="lineno"> 1613 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1614 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar MkNilData =</span>
<span class="lineno"> 1615 </span><span class="spaces">        </span><span class="istickedoff">-- Nullary built-in functions don't work, so we need a unit argument.</span>
<span class="lineno"> 1616 </span><span class="spaces">        </span><span class="istickedoff">-- We don't really need this built-in function, see Note [Constants vs built-in functions],</span>
<span class="lineno"> 1617 </span><span class="spaces">        </span><span class="istickedoff">-- but we keep it around for historical reasons and convenience.</span>
<span class="lineno"> 1618 </span><span class="spaces">        </span><span class="istickedoff">let mkNilDataDenotation :: () -&gt; [Data]</span>
<span class="lineno"> 1619 </span><span class="spaces">            </span><span class="istickedoff">mkNilDataDenotation () = []</span>
<span class="lineno"> 1620 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE mkNilDataDenotation #-}</span>
<span class="lineno"> 1621 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1622 </span><span class="spaces">            </span><span class="istickedoff">mkNilDataDenotation</span>
<span class="lineno"> 1623 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramMkNilData)</span>
<span class="lineno"> 1624 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1625 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar MkNilPairData =</span>
<span class="lineno"> 1626 </span><span class="spaces">        </span><span class="istickedoff">-- Nullary built-in functions don't work, so we need a unit argument.</span>
<span class="lineno"> 1627 </span><span class="spaces">        </span><span class="istickedoff">-- We don't really need this built-in function, see Note [Constants vs built-in functions],</span>
<span class="lineno"> 1628 </span><span class="spaces">        </span><span class="istickedoff">-- but we keep it around for historical reasons and convenience.</span>
<span class="lineno"> 1629 </span><span class="spaces">        </span><span class="istickedoff">let mkNilPairDataDenotation :: () -&gt; [(Data, Data)]</span>
<span class="lineno"> 1630 </span><span class="spaces">            </span><span class="istickedoff">mkNilPairDataDenotation () = []</span>
<span class="lineno"> 1631 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE mkNilPairDataDenotation #-}</span>
<span class="lineno"> 1632 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1633 </span><span class="spaces">            </span><span class="istickedoff">mkNilPairDataDenotation</span>
<span class="lineno"> 1634 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramMkNilPairData)</span>
<span class="lineno"> 1635 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1636 </span><span class="spaces">    </span><span class="istickedoff">-- BLS12_381.G1</span>
<span class="lineno"> 1637 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Bls12_381_G1_add =</span>
<span class="lineno"> 1638 </span><span class="spaces">        </span><span class="istickedoff">let bls12_381_G1_addDenotation</span>
<span class="lineno"> 1639 </span><span class="spaces">                </span><span class="istickedoff">:: BLS12_381.G1.Element -&gt; BLS12_381.G1.Element -&gt; BLS12_381.G1.Element</span>
<span class="lineno"> 1640 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G1_addDenotation = BLS12_381.G1.add</span>
<span class="lineno"> 1641 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE bls12_381_G1_addDenotation #-}</span>
<span class="lineno"> 1642 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1643 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G1_addDenotation</span>
<span class="lineno"> 1644 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramBls12_381_G1_add)</span>
<span class="lineno"> 1645 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1646 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Bls12_381_G1_neg =</span>
<span class="lineno"> 1647 </span><span class="spaces">        </span><span class="istickedoff">let bls12_381_G1_negDenotation :: BLS12_381.G1.Element -&gt; BLS12_381.G1.Element</span>
<span class="lineno"> 1648 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G1_negDenotation = BLS12_381.G1.neg</span>
<span class="lineno"> 1649 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE bls12_381_G1_negDenotation #-}</span>
<span class="lineno"> 1650 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1651 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G1_negDenotation</span>
<span class="lineno"> 1652 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramBls12_381_G1_neg)</span>
<span class="lineno"> 1653 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1654 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Bls12_381_G1_scalarMul =</span>
<span class="lineno"> 1655 </span><span class="spaces">        </span><span class="istickedoff">let bls12_381_G1_scalarMulDenotation</span>
<span class="lineno"> 1656 </span><span class="spaces">                </span><span class="istickedoff">:: Integer -&gt; BLS12_381.G1.Element -&gt; BLS12_381.G1.Element</span>
<span class="lineno"> 1657 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G1_scalarMulDenotation = BLS12_381.G1.scalarMul</span>
<span class="lineno"> 1658 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE bls12_381_G1_scalarMulDenotation #-}</span>
<span class="lineno"> 1659 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1660 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G1_scalarMulDenotation</span>
<span class="lineno"> 1661 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramBls12_381_G1_scalarMul)</span>
<span class="lineno"> 1662 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1663 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Bls12_381_G1_compress =</span>
<span class="lineno"> 1664 </span><span class="spaces">        </span><span class="istickedoff">let bls12_381_G1_compressDenotation :: BLS12_381.G1.Element -&gt; BS.ByteString</span>
<span class="lineno"> 1665 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G1_compressDenotation = BLS12_381.G1.compress</span>
<span class="lineno"> 1666 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE bls12_381_G1_compressDenotation #-}</span>
<span class="lineno"> 1667 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1668 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G1_compressDenotation</span>
<span class="lineno"> 1669 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramBls12_381_G1_compress)</span>
<span class="lineno"> 1670 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1671 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Bls12_381_G1_uncompress =</span>
<span class="lineno"> 1672 </span><span class="spaces">        </span><span class="istickedoff">let bls12_381_G1_uncompressDenotation</span>
<span class="lineno"> 1673 </span><span class="spaces">                </span><span class="istickedoff">:: BS.ByteString -&gt; BuiltinResult BLS12_381.G1.Element</span>
<span class="lineno"> 1674 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G1_uncompressDenotation = eitherToBuiltinResult . BLS12_381.G1.uncompress</span>
<span class="lineno"> 1675 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE bls12_381_G1_uncompressDenotation #-}</span>
<span class="lineno"> 1676 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1677 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G1_uncompressDenotation</span>
<span class="lineno"> 1678 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramBls12_381_G1_uncompress)</span>
<span class="lineno"> 1679 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1680 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Bls12_381_G1_hashToGroup =</span>
<span class="lineno"> 1681 </span><span class="spaces">        </span><span class="istickedoff">let bls12_381_G1_hashToGroupDenotation</span>
<span class="lineno"> 1682 </span><span class="spaces">                </span><span class="istickedoff">:: BS.ByteString -&gt; BS.ByteString -&gt; BuiltinResult BLS12_381.G1.Element</span>
<span class="lineno"> 1683 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G1_hashToGroupDenotation = eitherToBuiltinResult .* BLS12_381.G1.hashToGroup</span>
<span class="lineno"> 1684 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE bls12_381_G1_hashToGroupDenotation #-}</span>
<span class="lineno"> 1685 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1686 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G1_hashToGroupDenotation</span>
<span class="lineno"> 1687 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramBls12_381_G1_hashToGroup)</span>
<span class="lineno"> 1688 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1689 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Bls12_381_G1_equal =</span>
<span class="lineno"> 1690 </span><span class="spaces">        </span><span class="istickedoff">let bls12_381_G1_equalDenotation :: BLS12_381.G1.Element -&gt; BLS12_381.G1.Element -&gt; Bool</span>
<span class="lineno"> 1691 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G1_equalDenotation = (==)</span>
<span class="lineno"> 1692 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE bls12_381_G1_equalDenotation #-}</span>
<span class="lineno"> 1693 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1694 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G1_equalDenotation</span>
<span class="lineno"> 1695 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramBls12_381_G1_equal)</span>
<span class="lineno"> 1696 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1697 </span><span class="spaces">    </span><span class="istickedoff">-- BLS12_381.G2</span>
<span class="lineno"> 1698 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Bls12_381_G2_add =</span>
<span class="lineno"> 1699 </span><span class="spaces">        </span><span class="istickedoff">let bls12_381_G2_addDenotation</span>
<span class="lineno"> 1700 </span><span class="spaces">                </span><span class="istickedoff">:: BLS12_381.G2.Element -&gt; BLS12_381.G2.Element -&gt; BLS12_381.G2.Element</span>
<span class="lineno"> 1701 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G2_addDenotation = BLS12_381.G2.add</span>
<span class="lineno"> 1702 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE bls12_381_G2_addDenotation #-}</span>
<span class="lineno"> 1703 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1704 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G2_addDenotation</span>
<span class="lineno"> 1705 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramBls12_381_G2_add)</span>
<span class="lineno"> 1706 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1707 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Bls12_381_G2_neg =</span>
<span class="lineno"> 1708 </span><span class="spaces">        </span><span class="istickedoff">let bls12_381_G2_negDenotation :: BLS12_381.G2.Element -&gt; BLS12_381.G2.Element</span>
<span class="lineno"> 1709 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G2_negDenotation = BLS12_381.G2.neg</span>
<span class="lineno"> 1710 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE bls12_381_G2_negDenotation #-}</span>
<span class="lineno"> 1711 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1712 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G2_negDenotation</span>
<span class="lineno"> 1713 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramBls12_381_G2_neg)</span>
<span class="lineno"> 1714 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1715 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Bls12_381_G2_scalarMul =</span>
<span class="lineno"> 1716 </span><span class="spaces">        </span><span class="istickedoff">let bls12_381_G2_scalarMulDenotation</span>
<span class="lineno"> 1717 </span><span class="spaces">                </span><span class="istickedoff">:: Integer -&gt; BLS12_381.G2.Element -&gt; BLS12_381.G2.Element</span>
<span class="lineno"> 1718 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G2_scalarMulDenotation = BLS12_381.G2.scalarMul</span>
<span class="lineno"> 1719 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE bls12_381_G2_scalarMulDenotation #-}</span>
<span class="lineno"> 1720 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1721 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G2_scalarMulDenotation</span>
<span class="lineno"> 1722 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramBls12_381_G2_scalarMul)</span>
<span class="lineno"> 1723 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1724 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Bls12_381_G2_compress =</span>
<span class="lineno"> 1725 </span><span class="spaces">        </span><span class="istickedoff">let bls12_381_G2_compressDenotation :: BLS12_381.G2.Element -&gt; BS.ByteString</span>
<span class="lineno"> 1726 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G2_compressDenotation = BLS12_381.G2.compress</span>
<span class="lineno"> 1727 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE bls12_381_G2_compressDenotation #-}</span>
<span class="lineno"> 1728 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1729 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G2_compressDenotation</span>
<span class="lineno"> 1730 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramBls12_381_G2_compress)</span>
<span class="lineno"> 1731 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1732 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Bls12_381_G2_uncompress =</span>
<span class="lineno"> 1733 </span><span class="spaces">        </span><span class="istickedoff">let bls12_381_G2_uncompressDenotation</span>
<span class="lineno"> 1734 </span><span class="spaces">                </span><span class="istickedoff">:: BS.ByteString -&gt; BuiltinResult BLS12_381.G2.Element</span>
<span class="lineno"> 1735 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G2_uncompressDenotation = eitherToBuiltinResult . BLS12_381.G2.uncompress</span>
<span class="lineno"> 1736 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE bls12_381_G2_uncompressDenotation #-}</span>
<span class="lineno"> 1737 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1738 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G2_uncompressDenotation</span>
<span class="lineno"> 1739 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramBls12_381_G2_uncompress)</span>
<span class="lineno"> 1740 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1741 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Bls12_381_G2_hashToGroup =</span>
<span class="lineno"> 1742 </span><span class="spaces">        </span><span class="istickedoff">let bls12_381_G2_hashToGroupDenotation</span>
<span class="lineno"> 1743 </span><span class="spaces">                </span><span class="istickedoff">:: BS.ByteString -&gt; BS.ByteString -&gt; BuiltinResult BLS12_381.G2.Element</span>
<span class="lineno"> 1744 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G2_hashToGroupDenotation = eitherToBuiltinResult .* BLS12_381.G2.hashToGroup</span>
<span class="lineno"> 1745 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE bls12_381_G2_hashToGroupDenotation #-}</span>
<span class="lineno"> 1746 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1747 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G2_hashToGroupDenotation</span>
<span class="lineno"> 1748 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramBls12_381_G2_hashToGroup)</span>
<span class="lineno"> 1749 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1750 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Bls12_381_G2_equal =</span>
<span class="lineno"> 1751 </span><span class="spaces">        </span><span class="istickedoff">let bls12_381_G2_equalDenotation :: BLS12_381.G2.Element -&gt; BLS12_381.G2.Element -&gt; Bool</span>
<span class="lineno"> 1752 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G2_equalDenotation = (==)</span>
<span class="lineno"> 1753 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE bls12_381_G2_equalDenotation #-}</span>
<span class="lineno"> 1754 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1755 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G2_equalDenotation</span>
<span class="lineno"> 1756 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramBls12_381_G2_equal)</span>
<span class="lineno"> 1757 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1758 </span><span class="spaces">    </span><span class="istickedoff">-- BLS12_381.Pairing</span>
<span class="lineno"> 1759 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Bls12_381_millerLoop =</span>
<span class="lineno"> 1760 </span><span class="spaces">        </span><span class="istickedoff">let bls12_381_millerLoopDenotation</span>
<span class="lineno"> 1761 </span><span class="spaces">                </span><span class="istickedoff">:: BLS12_381.G1.Element -&gt; BLS12_381.G2.Element -&gt; BLS12_381.Pairing.MlResult</span>
<span class="lineno"> 1762 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_millerLoopDenotation = BLS12_381.Pairing.millerLoop</span>
<span class="lineno"> 1763 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE bls12_381_millerLoopDenotation #-}</span>
<span class="lineno"> 1764 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1765 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_millerLoopDenotation</span>
<span class="lineno"> 1766 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramBls12_381_millerLoop)</span>
<span class="lineno"> 1767 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1768 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Bls12_381_mulMlResult =</span>
<span class="lineno"> 1769 </span><span class="spaces">        </span><span class="istickedoff">let bls12_381_mulMlResultDenotation</span>
<span class="lineno"> 1770 </span><span class="spaces">                </span><span class="istickedoff">:: BLS12_381.Pairing.MlResult</span>
<span class="lineno"> 1771 </span><span class="spaces">                </span><span class="istickedoff">-&gt; BLS12_381.Pairing.MlResult</span>
<span class="lineno"> 1772 </span><span class="spaces">                </span><span class="istickedoff">-&gt; BLS12_381.Pairing.MlResult</span>
<span class="lineno"> 1773 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_mulMlResultDenotation = BLS12_381.Pairing.mulMlResult</span>
<span class="lineno"> 1774 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE bls12_381_mulMlResultDenotation #-}</span>
<span class="lineno"> 1775 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1776 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_mulMlResultDenotation</span>
<span class="lineno"> 1777 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramBls12_381_mulMlResult)</span>
<span class="lineno"> 1778 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1779 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Bls12_381_finalVerify =</span>
<span class="lineno"> 1780 </span><span class="spaces">        </span><span class="istickedoff">let bls12_381_finalVerifyDenotation</span>
<span class="lineno"> 1781 </span><span class="spaces">                </span><span class="istickedoff">:: BLS12_381.Pairing.MlResult -&gt; BLS12_381.Pairing.MlResult -&gt; Bool</span>
<span class="lineno"> 1782 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_finalVerifyDenotation = BLS12_381.Pairing.finalVerify</span>
<span class="lineno"> 1783 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE bls12_381_finalVerifyDenotation #-}</span>
<span class="lineno"> 1784 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1785 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_finalVerifyDenotation</span>
<span class="lineno"> 1786 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramBls12_381_finalVerify)</span>
<span class="lineno"> 1787 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1788 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Keccak_256 =</span>
<span class="lineno"> 1789 </span><span class="spaces">        </span><span class="istickedoff">let keccak_256Denotation :: BS.ByteString -&gt; BS.ByteString</span>
<span class="lineno"> 1790 </span><span class="spaces">            </span><span class="istickedoff">keccak_256Denotation = Hash.keccak_256</span>
<span class="lineno"> 1791 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE keccak_256Denotation #-}</span>
<span class="lineno"> 1792 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1793 </span><span class="spaces">            </span><span class="istickedoff">keccak_256Denotation</span>
<span class="lineno"> 1794 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramKeccak_256)</span>
<span class="lineno"> 1795 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1796 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Blake2b_224 =</span>
<span class="lineno"> 1797 </span><span class="spaces">        </span><span class="istickedoff">let blake2b_224Denotation :: BS.ByteString -&gt; BS.ByteString</span>
<span class="lineno"> 1798 </span><span class="spaces">            </span><span class="istickedoff">blake2b_224Denotation = Hash.blake2b_224</span>
<span class="lineno"> 1799 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE blake2b_224Denotation #-}</span>
<span class="lineno"> 1800 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1801 </span><span class="spaces">            </span><span class="istickedoff">blake2b_224Denotation</span>
<span class="lineno"> 1802 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramBlake2b_224)</span>
<span class="lineno"> 1803 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1804 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1805 </span><span class="spaces">    </span><span class="istickedoff">-- Extra bytestring operations</span>
<span class="lineno"> 1806 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1807 </span><span class="spaces">    </span><span class="istickedoff">-- Conversions</span>
<span class="lineno"> 1808 </span><span class="spaces">    </span><span class="istickedoff">{- See Note [Input length limitation for IntegerToByteString] -}</span>
<span class="lineno"> 1809 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar IntegerToByteString =</span>
<span class="lineno"> 1810 </span><span class="spaces">        </span><span class="istickedoff">let integerToByteStringDenotation :: Bool -&gt; NumBytesCostedAsNumWords -&gt; Integer -&gt; BuiltinResult BS.ByteString</span>
<span class="lineno"> 1811 </span><span class="spaces">            </span><span class="istickedoff">{- The second argument is wrapped in a NumBytesCostedAsNumWords to allow us to</span>
<span class="lineno"> 1812 </span><span class="spaces">               </span><span class="istickedoff">interpret it as a size during costing. -}</span>
<span class="lineno"> 1813 </span><span class="spaces">            </span><span class="istickedoff">integerToByteStringDenotation b (NumBytesCostedAsNumWords w) = Bitwise.integerToByteString b w</span>
<span class="lineno"> 1814 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE integerToByteStringDenotation #-}</span>
<span class="lineno"> 1815 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1816 </span><span class="spaces">            </span><span class="istickedoff">integerToByteStringDenotation</span>
<span class="lineno"> 1817 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunThreeArguments . paramIntegerToByteString)</span>
<span class="lineno"> 1818 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1819 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar ByteStringToInteger =</span>
<span class="lineno"> 1820 </span><span class="spaces">        </span><span class="istickedoff">let byteStringToIntegerDenotation :: Bool -&gt; BS.ByteString -&gt; Integer</span>
<span class="lineno"> 1821 </span><span class="spaces">            </span><span class="istickedoff">byteStringToIntegerDenotation = Bitwise.byteStringToInteger</span>
<span class="lineno"> 1822 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE byteStringToIntegerDenotation #-}</span>
<span class="lineno"> 1823 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1824 </span><span class="spaces">            </span><span class="istickedoff">byteStringToIntegerDenotation</span>
<span class="lineno"> 1825 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramByteStringToInteger)</span>
<span class="lineno"> 1826 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1827 </span><span class="spaces">    </span><span class="istickedoff">-- Logical</span>
<span class="lineno"> 1828 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar AndByteString =</span>
<span class="lineno"> 1829 </span><span class="spaces">        </span><span class="istickedoff">let andByteStringDenotation :: Bool -&gt; BS.ByteString -&gt; BS.ByteString -&gt; BS.ByteString</span>
<span class="lineno"> 1830 </span><span class="spaces">            </span><span class="istickedoff">andByteStringDenotation = Bitwise.andByteString</span>
<span class="lineno"> 1831 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE andByteStringDenotation #-}</span>
<span class="lineno"> 1832 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1833 </span><span class="spaces">            </span><span class="istickedoff">andByteStringDenotation</span>
<span class="lineno"> 1834 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunThreeArguments . paramAndByteString)</span>
<span class="lineno"> 1835 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1836 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar OrByteString =</span>
<span class="lineno"> 1837 </span><span class="spaces">        </span><span class="istickedoff">let orByteStringDenotation :: Bool -&gt; BS.ByteString -&gt; BS.ByteString -&gt; BS.ByteString</span>
<span class="lineno"> 1838 </span><span class="spaces">            </span><span class="istickedoff">orByteStringDenotation = Bitwise.orByteString</span>
<span class="lineno"> 1839 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE orByteStringDenotation #-}</span>
<span class="lineno"> 1840 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1841 </span><span class="spaces">            </span><span class="istickedoff">orByteStringDenotation</span>
<span class="lineno"> 1842 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunThreeArguments . paramOrByteString)</span>
<span class="lineno"> 1843 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1844 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar XorByteString =</span>
<span class="lineno"> 1845 </span><span class="spaces">        </span><span class="istickedoff">let xorByteStringDenotation :: Bool -&gt; BS.ByteString -&gt; BS.ByteString -&gt; BS.ByteString</span>
<span class="lineno"> 1846 </span><span class="spaces">            </span><span class="istickedoff">xorByteStringDenotation = Bitwise.xorByteString</span>
<span class="lineno"> 1847 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE xorByteStringDenotation #-}</span>
<span class="lineno"> 1848 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1849 </span><span class="spaces">            </span><span class="istickedoff">xorByteStringDenotation</span>
<span class="lineno"> 1850 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunThreeArguments . paramXorByteString)</span>
<span class="lineno"> 1851 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1852 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar ComplementByteString =</span>
<span class="lineno"> 1853 </span><span class="spaces">        </span><span class="istickedoff">let complementByteStringDenotation :: BS.ByteString -&gt; BS.ByteString</span>
<span class="lineno"> 1854 </span><span class="spaces">            </span><span class="istickedoff">complementByteStringDenotation = Bitwise.complementByteString</span>
<span class="lineno"> 1855 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE complementByteStringDenotation #-}</span>
<span class="lineno"> 1856 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1857 </span><span class="spaces">            </span><span class="istickedoff">complementByteStringDenotation</span>
<span class="lineno"> 1858 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramComplementByteString)</span>
<span class="lineno"> 1859 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1860 </span><span class="spaces">    </span><span class="istickedoff">-- Bitwise operations</span>
<span class="lineno"> 1861 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1862 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar ReadBit =</span>
<span class="lineno"> 1863 </span><span class="spaces">        </span><span class="istickedoff">let readBitDenotation :: BS.ByteString -&gt; Int -&gt; BuiltinResult Bool</span>
<span class="lineno"> 1864 </span><span class="spaces">            </span><span class="istickedoff">readBitDenotation = Bitwise.readBit</span>
<span class="lineno"> 1865 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE readBitDenotation #-}</span>
<span class="lineno"> 1866 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1867 </span><span class="spaces">            </span><span class="istickedoff">readBitDenotation</span>
<span class="lineno"> 1868 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramReadBit)</span>
<span class="lineno"> 1869 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1870 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar WriteBits =</span>
<span class="lineno"> 1871 </span><span class="spaces">        </span><span class="istickedoff">let writeBitsDenotation</span>
<span class="lineno"> 1872 </span><span class="spaces">              </span><span class="istickedoff">:: BS.ByteString</span>
<span class="lineno"> 1873 </span><span class="spaces">              </span><span class="istickedoff">-&gt; [Integer]</span>
<span class="lineno"> 1874 </span><span class="spaces">              </span><span class="istickedoff">-&gt; Bool</span>
<span class="lineno"> 1875 </span><span class="spaces">              </span><span class="istickedoff">-&gt; BuiltinResult BS.ByteString</span>
<span class="lineno"> 1876 </span><span class="spaces">            </span><span class="istickedoff">writeBitsDenotation s ixs = Bitwise.writeBits s ixs</span>
<span class="lineno"> 1877 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE writeBitsDenotation #-}</span>
<span class="lineno"> 1878 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1879 </span><span class="spaces">            </span><span class="istickedoff">writeBitsDenotation</span>
<span class="lineno"> 1880 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunThreeArguments . paramWriteBits)</span>
<span class="lineno"> 1881 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1882 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar ReplicateByte =</span>
<span class="lineno"> 1883 </span><span class="spaces">        </span><span class="istickedoff">let replicateByteDenotation :: NumBytesCostedAsNumWords -&gt; Word8 -&gt; BuiltinResult BS.ByteString</span>
<span class="lineno"> 1884 </span><span class="spaces">            </span><span class="istickedoff">replicateByteDenotation (NumBytesCostedAsNumWords n) = Bitwise.replicateByte n</span>
<span class="lineno"> 1885 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE replicateByteDenotation #-}</span>
<span class="lineno"> 1886 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1887 </span><span class="spaces">            </span><span class="istickedoff">replicateByteDenotation</span>
<span class="lineno"> 1888 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramReplicateByte)</span>
<span class="lineno"> 1889 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1890 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar ShiftByteString =</span>
<span class="lineno"> 1891 </span><span class="spaces">        </span><span class="istickedoff">let shiftByteStringDenotation :: BS.ByteString -&gt; IntegerCostedLiterally -&gt; BS.ByteString</span>
<span class="lineno"> 1892 </span><span class="spaces">            </span><span class="istickedoff">shiftByteStringDenotation s (IntegerCostedLiterally n) = Bitwise.shiftByteString s n</span>
<span class="lineno"> 1893 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE shiftByteStringDenotation #-}</span>
<span class="lineno"> 1894 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1895 </span><span class="spaces">            </span><span class="istickedoff">shiftByteStringDenotation</span>
<span class="lineno"> 1896 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramShiftByteString)</span>
<span class="lineno"> 1897 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1898 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar RotateByteString =</span>
<span class="lineno"> 1899 </span><span class="spaces">        </span><span class="istickedoff">let rotateByteStringDenotation :: BS.ByteString -&gt; IntegerCostedLiterally -&gt; BS.ByteString</span>
<span class="lineno"> 1900 </span><span class="spaces">            </span><span class="istickedoff">rotateByteStringDenotation s (IntegerCostedLiterally n) = Bitwise.rotateByteString s n</span>
<span class="lineno"> 1901 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE rotateByteStringDenotation #-}</span>
<span class="lineno"> 1902 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1903 </span><span class="spaces">            </span><span class="istickedoff">rotateByteStringDenotation</span>
<span class="lineno"> 1904 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramRotateByteString)</span>
<span class="lineno"> 1905 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1906 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar CountSetBits =</span>
<span class="lineno"> 1907 </span><span class="spaces">        </span><span class="istickedoff">let countSetBitsDenotation :: BS.ByteString -&gt; Int</span>
<span class="lineno"> 1908 </span><span class="spaces">            </span><span class="istickedoff">countSetBitsDenotation = Bitwise.countSetBits</span>
<span class="lineno"> 1909 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE countSetBitsDenotation #-}</span>
<span class="lineno"> 1910 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1911 </span><span class="spaces">            </span><span class="istickedoff">countSetBitsDenotation</span>
<span class="lineno"> 1912 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramCountSetBits)</span>
<span class="lineno"> 1913 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1914 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar FindFirstSetBit =</span>
<span class="lineno"> 1915 </span><span class="spaces">        </span><span class="istickedoff">let findFirstSetBitDenotation :: BS.ByteString -&gt; Int</span>
<span class="lineno"> 1916 </span><span class="spaces">            </span><span class="istickedoff">findFirstSetBitDenotation = Bitwise.findFirstSetBit</span>
<span class="lineno"> 1917 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE findFirstSetBitDenotation #-}</span>
<span class="lineno"> 1918 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1919 </span><span class="spaces">            </span><span class="istickedoff">findFirstSetBitDenotation</span>
<span class="lineno"> 1920 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramFindFirstSetBit)</span>
<span class="lineno"> 1921 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1922 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Ripemd_160 =</span>
<span class="lineno"> 1923 </span><span class="spaces">        </span><span class="istickedoff">let ripemd_160Denotation :: BS.ByteString -&gt; BS.ByteString</span>
<span class="lineno"> 1924 </span><span class="spaces">            </span><span class="istickedoff">ripemd_160Denotation = Hash.ripemd_160</span>
<span class="lineno"> 1925 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE ripemd_160Denotation #-}</span>
<span class="lineno"> 1926 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1927 </span><span class="spaces">            </span><span class="istickedoff">ripemd_160Denotation</span>
<span class="lineno"> 1928 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . paramRipemd_160)</span>
<span class="lineno"> 1929 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1930 </span><span class="spaces">    </span><span class="istickedoff">-- Batch 6</span>
<span class="lineno"> 1931 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1932 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar ExpModInteger =</span>
<span class="lineno"> 1933 </span><span class="spaces">        </span><span class="istickedoff">let expModIntegerDenotation</span>
<span class="lineno"> 1934 </span><span class="spaces">              </span><span class="istickedoff">:: Integer</span>
<span class="lineno"> 1935 </span><span class="spaces">              </span><span class="istickedoff">-&gt; Integer</span>
<span class="lineno"> 1936 </span><span class="spaces">              </span><span class="istickedoff">-&gt; Integer</span>
<span class="lineno"> 1937 </span><span class="spaces">              </span><span class="istickedoff">-&gt; BuiltinResult Natural</span>
<span class="lineno"> 1938 </span><span class="spaces">            </span><span class="istickedoff">expModIntegerDenotation a b m =</span>
<span class="lineno"> 1939 </span><span class="spaces">              </span><span class="istickedoff">if m &lt; 0</span>
<span class="lineno"> 1940 </span><span class="spaces">              </span><span class="istickedoff">then fail &quot;expModInteger: negative modulus&quot;</span>
<span class="lineno"> 1941 </span><span class="spaces">              </span><span class="istickedoff">else ExpMod.expMod a b (naturalFromInteger m)</span>
<span class="lineno"> 1942 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE expModIntegerDenotation #-}</span>
<span class="lineno"> 1943 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1944 </span><span class="spaces">            </span><span class="istickedoff">expModIntegerDenotation</span>
<span class="lineno"> 1945 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunThreeArguments . paramExpModInteger)</span>
<span class="lineno"> 1946 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1947 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar DropList =</span>
<span class="lineno"> 1948 </span><span class="spaces">        </span><span class="istickedoff">let dropListDenotation</span>
<span class="lineno"> 1949 </span><span class="spaces">                </span><span class="istickedoff">:: IntegerCostedLiterally -&gt; SomeConstant uni [a] -&gt; BuiltinResult (Opaque val [a])</span>
<span class="lineno"> 1950 </span><span class="spaces">            </span><span class="istickedoff">dropListDenotation i (SomeConstant (Some (ValueOf uniListA xs))) = do</span>
<span class="lineno"> 1951 </span><span class="spaces">                </span><span class="istickedoff">-- See Note [Operational vs structural errors within builtins].</span>
<span class="lineno"> 1952 </span><span class="spaces">                </span><span class="istickedoff">case uniListA of</span>
<span class="lineno"> 1953 </span><span class="spaces">                    </span><span class="istickedoff">DefaultUniList _ -&gt;</span>
<span class="lineno"> 1954 </span><span class="spaces">                        </span><span class="istickedoff">-- The fastest way of dropping elements from a list is by operating on</span>
<span class="lineno"> 1955 </span><span class="spaces">                        </span><span class="istickedoff">-- an unboxed int (i.e. an 'Int#'). We could implement that manually, but</span>
<span class="lineno"> 1956 </span><span class="spaces">                        </span><span class="istickedoff">-- 'drop' in @Prelude@ already does that under the hood, so we just need to</span>
<span class="lineno"> 1957 </span><span class="spaces">                        </span><span class="istickedoff">-- convert the given 'Integer' to an 'Int' and call 'drop' over that.</span>
<span class="lineno"> 1958 </span><span class="spaces">                        </span><span class="istickedoff">fromValueOf uniListA &lt;$&gt; case unIntegerCostedLiterally i of</span>
<span class="lineno"> 1959 </span><span class="spaces">                            </span><span class="istickedoff">IS i# -&gt; pure $ drop (I# i#) xs</span>
<span class="lineno"> 1960 </span><span class="spaces">                            </span><span class="istickedoff">IN _ -&gt; pure xs</span>
<span class="lineno"> 1961 </span><span class="spaces">                            </span><span class="istickedoff">-- If the given 'Integer' is higher than @maxBound :: Int@, then we</span>
<span class="lineno"> 1962 </span><span class="spaces">                            </span><span class="istickedoff">-- call 'drop' over the latter instead to get the same performance as in</span>
<span class="lineno"> 1963 </span><span class="spaces">                            </span><span class="istickedoff">-- the previous case. This will produce a different result when the</span>
<span class="lineno"> 1964 </span><span class="spaces">                            </span><span class="istickedoff">-- list is longer than @maxBound :: Int@, but in practice not only is</span>
<span class="lineno"> 1965 </span><span class="spaces">                            </span><span class="istickedoff">-- the budget going to get exhausted long before a @maxBound@ number of</span>
<span class="lineno"> 1966 </span><span class="spaces">                            </span><span class="istickedoff">-- elements is skipped, it's not even feasible to skip so many elements</span>
<span class="lineno"> 1967 </span><span class="spaces">                            </span><span class="istickedoff">-- for 'Int64' (and we enforce @Int = Int64@ in the @Universe@ module)</span>
<span class="lineno"> 1968 </span><span class="spaces">                            </span><span class="istickedoff">-- as that'll take ~3000 years assuming it takes a second to skip</span>
<span class="lineno"> 1969 </span><span class="spaces">                            </span><span class="istickedoff">-- @10^8@ elements.</span>
<span class="lineno"> 1970 </span><span class="spaces">                            </span><span class="istickedoff">--</span>
<span class="lineno"> 1971 </span><span class="spaces">                            </span><span class="istickedoff">-- We could &quot;optimistically&quot; return '[]' directly without doing any</span>
<span class="lineno"> 1972 </span><span class="spaces">                            </span><span class="istickedoff">-- skipping at all, but then we'd be occasionally returning the wrong</span>
<span class="lineno"> 1973 </span><span class="spaces">                            </span><span class="istickedoff">-- answer immediately rather than in 3000 years and that doesn't sound</span>
<span class="lineno"> 1974 </span><span class="spaces">                            </span><span class="istickedoff">-- like a good idea. Particularly given that costing for this builtin is</span>
<span class="lineno"> 1975 </span><span class="spaces">                            </span><span class="istickedoff">-- oblivious to such implementation details anyway, so we wouldn't even</span>
<span class="lineno"> 1976 </span><span class="spaces">                            </span><span class="istickedoff">-- be able to capitalize on the fast and loose approach.</span>
<span class="lineno"> 1977 </span><span class="spaces">                            </span><span class="istickedoff">--</span>
<span class="lineno"> 1978 </span><span class="spaces">                            </span><span class="istickedoff">-- Instead of using 'drop' we could've made it something like</span>
<span class="lineno"> 1979 </span><span class="spaces">                            </span><span class="istickedoff">-- @foldl' const []@, which would be a tad faster while taking even more</span>
<span class="lineno"> 1980 </span><span class="spaces">                            </span><span class="istickedoff">-- than 3000 years to return the wrong result, but with the current</span>
<span class="lineno"> 1981 </span><span class="spaces">                            </span><span class="istickedoff">-- approach the wrong result is an error, while with the foldl-based one</span>
<span class="lineno"> 1982 </span><span class="spaces">                            </span><span class="istickedoff">-- it'd be an actual incorrect value. Plus, it's best not to rely on</span>
<span class="lineno"> 1983 </span><span class="spaces">                            </span><span class="istickedoff">-- GHC not optimizing such an expression away to just '[]' (it really</span>
<span class="lineno"> 1984 </span><span class="spaces">                            </span><span class="istickedoff">-- shouldn't, but not taking chances with GHC is the best approach). And</span>
<span class="lineno"> 1985 </span><span class="spaces">                            </span><span class="istickedoff">-- again, we wouldn't be able to capitalize on such a speedup anyway.</span>
<span class="lineno"> 1986 </span><span class="spaces">                            </span><span class="istickedoff">IP _ -&gt; case drop maxBound xs of</span>
<span class="lineno"> 1987 </span><span class="spaces">                               </span><span class="istickedoff">[] -&gt; pure []</span>
<span class="lineno"> 1988 </span><span class="spaces">                               </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1989 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">throwError $ structuralUnliftingError</span></span>
<span class="lineno"> 1990 </span><span class="spaces">                                       </span><span class="istickedoff"><span class="nottickedoff">&quot;Panic: unreachable clause executed&quot;</span></span>
<span class="lineno"> 1991 </span><span class="spaces">                    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">throwError $ structuralUnliftingError &quot;Expected a list but got something else&quot;</span></span>
<span class="lineno"> 1992 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE dropListDenotation #-}</span>
<span class="lineno"> 1993 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 1994 </span><span class="spaces">            </span><span class="istickedoff">dropListDenotation</span>
<span class="lineno"> 1995 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramDropList)</span>
<span class="lineno"> 1996 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1997 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar LengthOfArray =</span>
<span class="lineno"> 1998 </span><span class="spaces">      </span><span class="istickedoff">let lengthOfArrayDenotation :: SomeConstant uni (Vector a) -&gt; BuiltinResult Int</span>
<span class="lineno"> 1999 </span><span class="spaces">          </span><span class="istickedoff">lengthOfArrayDenotation (SomeConstant (Some (ValueOf uni vec))) =</span>
<span class="lineno"> 2000 </span><span class="spaces">            </span><span class="istickedoff">case uni of</span>
<span class="lineno"> 2001 </span><span class="spaces">              </span><span class="istickedoff">DefaultUniArray _uniA -&gt; pure $ Vector.length vec</span>
<span class="lineno"> 2002 </span><span class="spaces">              </span><span class="istickedoff">_ -&gt; throwError $ structuralUnliftingError &quot;Expected an array but got something else&quot;</span>
<span class="lineno"> 2003 </span><span class="spaces">          </span><span class="istickedoff">{-# INLINE lengthOfArrayDenotation #-}</span>
<span class="lineno"> 2004 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning lengthOfArrayDenotation (runCostingFunOneArgument . paramLengthOfArray)</span>
<span class="lineno"> 2005 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2006 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar ListToArray =</span>
<span class="lineno"> 2007 </span><span class="spaces">      </span><span class="istickedoff">let listToArrayDenotation :: SomeConstant uni [a] -&gt; BuiltinResult (Opaque val (Vector a))</span>
<span class="lineno"> 2008 </span><span class="spaces">          </span><span class="istickedoff">listToArrayDenotation (SomeConstant (Some (ValueOf uniListA xs))) =</span>
<span class="lineno"> 2009 </span><span class="spaces">            </span><span class="istickedoff">case uniListA of</span>
<span class="lineno"> 2010 </span><span class="spaces">              </span><span class="istickedoff">DefaultUniList uniA -&gt; pure $ fromValueOf (DefaultUniArray uniA) $ Vector.fromList xs</span>
<span class="lineno"> 2011 </span><span class="spaces">              </span><span class="istickedoff">_ -&gt; throwError $ structuralUnliftingError  &quot;Expected a list but got something else&quot;</span>
<span class="lineno"> 2012 </span><span class="spaces">          </span><span class="istickedoff">{-# INLINE listToArrayDenotation #-}</span>
<span class="lineno"> 2013 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning listToArrayDenotation (runCostingFunOneArgument . paramListToArray)</span>
<span class="lineno"> 2014 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2015 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar IndexArray =</span>
<span class="lineno"> 2016 </span><span class="spaces">      </span><span class="istickedoff">let indexArrayDenotation :: SomeConstant uni (Vector a) -&gt; Int -&gt; BuiltinResult (Opaque val a)</span>
<span class="lineno"> 2017 </span><span class="spaces">          </span><span class="istickedoff">indexArrayDenotation (SomeConstant (Some (ValueOf uni vec))) n =</span>
<span class="lineno"> 2018 </span><span class="spaces">            </span><span class="istickedoff">case uni of</span>
<span class="lineno"> 2019 </span><span class="spaces">              </span><span class="istickedoff">DefaultUniArray arg -&gt; do</span>
<span class="lineno"> 2020 </span><span class="spaces">                </span><span class="istickedoff">case vec Vector.!? n of</span>
<span class="lineno"> 2021 </span><span class="spaces">                  </span><span class="istickedoff">Nothing -&gt; fail <span class="nottickedoff">&quot;Array index out of bounds&quot;</span></span>
<span class="lineno"> 2022 </span><span class="spaces">                  </span><span class="istickedoff">Just el -&gt; pure $ fromValueOf arg el</span>
<span class="lineno"> 2023 </span><span class="spaces">              </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 2024 </span><span class="spaces">                    </span><span class="istickedoff">-- See Note [Structural vs operational errors within builtins].</span>
<span class="lineno"> 2025 </span><span class="spaces">                    </span><span class="istickedoff">-- The arguments are going to be printed in the &quot;cause&quot; part of the error</span>
<span class="lineno"> 2026 </span><span class="spaces">                    </span><span class="istickedoff">-- message, so we don't need to repeat them here.</span>
<span class="lineno"> 2027 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">throwError $ structuralUnliftingError &quot;Expected an array but got something else&quot;</span></span>
<span class="lineno"> 2028 </span><span class="spaces">          </span><span class="istickedoff">{-# INLINE indexArrayDenotation #-}</span>
<span class="lineno"> 2029 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning indexArrayDenotation (runCostingFunTwoArguments . paramIndexArray)</span>
<span class="lineno"> 2030 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2031 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Bls12_381_G1_multiScalarMul =</span>
<span class="lineno"> 2032 </span><span class="spaces">        </span><span class="istickedoff">let bls12_381_G1_multiScalarMulDenotation</span>
<span class="lineno"> 2033 </span><span class="spaces">                </span><span class="istickedoff">:: [Integer] -&gt; [BLS12_381.G1.Element] -&gt; BLS12_381.G1.Element</span>
<span class="lineno"> 2034 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G1_multiScalarMulDenotation = BLS12_381.G1.multiScalarMul</span>
<span class="lineno"> 2035 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE bls12_381_G1_multiScalarMulDenotation #-}</span>
<span class="lineno"> 2036 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 2037 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G1_multiScalarMulDenotation</span>
<span class="lineno"> 2038 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramBls12_381_G1_multiScalarMul)</span>
<span class="lineno"> 2039 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2040 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar Bls12_381_G2_multiScalarMul =</span>
<span class="lineno"> 2041 </span><span class="spaces">        </span><span class="istickedoff">let bls12_381_G2_multiScalarMulDenotation</span>
<span class="lineno"> 2042 </span><span class="spaces">                </span><span class="istickedoff">:: [Integer] -&gt; [BLS12_381.G2.Element] -&gt; BLS12_381.G2.Element</span>
<span class="lineno"> 2043 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G2_multiScalarMulDenotation = BLS12_381.G2.multiScalarMul</span>
<span class="lineno"> 2044 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE bls12_381_G2_multiScalarMulDenotation #-}</span>
<span class="lineno"> 2045 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 2046 </span><span class="spaces">            </span><span class="istickedoff">bls12_381_G2_multiScalarMulDenotation</span>
<span class="lineno"> 2047 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . paramBls12_381_G2_multiScalarMul)</span>
<span class="lineno"> 2048 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2049 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar InsertCoin =</span>
<span class="lineno"> 2050 </span><span class="spaces">      </span><span class="istickedoff">let insertCoinDenotation :: ByteString -&gt; ByteString -&gt; Integer -&gt; Value -&gt; BuiltinResult Value</span>
<span class="lineno"> 2051 </span><span class="spaces">          </span><span class="istickedoff">insertCoinDenotation = Value.insertCoin</span>
<span class="lineno"> 2052 </span><span class="spaces">          </span><span class="istickedoff">{-# INLINE insertCoinDenotation #-}</span>
<span class="lineno"> 2053 </span><span class="spaces">       </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 2054 </span><span class="spaces">            </span><span class="istickedoff">insertCoinDenotation</span>
<span class="lineno"> 2055 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunFourArguments . unimplementedCostingFun)</span>
<span class="lineno"> 2056 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2057 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar LookupCoin =</span>
<span class="lineno"> 2058 </span><span class="spaces">      </span><span class="istickedoff">let lookupCoinDenotation :: ByteString -&gt; ByteString -&gt; Value -&gt; Integer</span>
<span class="lineno"> 2059 </span><span class="spaces">          </span><span class="istickedoff">lookupCoinDenotation = Value.lookupCoin</span>
<span class="lineno"> 2060 </span><span class="spaces">          </span><span class="istickedoff">{-# INLINE lookupCoinDenotation #-}</span>
<span class="lineno"> 2061 </span><span class="spaces">       </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 2062 </span><span class="spaces">            </span><span class="istickedoff">lookupCoinDenotation</span>
<span class="lineno"> 2063 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunThreeArguments . unimplementedCostingFun)</span>
<span class="lineno"> 2064 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2065 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar UnionValue =</span>
<span class="lineno"> 2066 </span><span class="spaces">      </span><span class="istickedoff">let unionValueDenotation :: Value -&gt; Value -&gt; Value</span>
<span class="lineno"> 2067 </span><span class="spaces">          </span><span class="istickedoff">unionValueDenotation = Value.unionValue</span>
<span class="lineno"> 2068 </span><span class="spaces">          </span><span class="istickedoff">{-# INLINE unionValueDenotation #-}</span>
<span class="lineno"> 2069 </span><span class="spaces">       </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 2070 </span><span class="spaces">            </span><span class="istickedoff">unionValueDenotation</span>
<span class="lineno"> 2071 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . unimplementedCostingFun)</span>
<span class="lineno"> 2072 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2073 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar ValueContains =</span>
<span class="lineno"> 2074 </span><span class="spaces">      </span><span class="istickedoff">let valueContainsDenotation :: Value -&gt; Value -&gt; BuiltinResult Bool</span>
<span class="lineno"> 2075 </span><span class="spaces">          </span><span class="istickedoff">valueContainsDenotation = Value.valueContains</span>
<span class="lineno"> 2076 </span><span class="spaces">          </span><span class="istickedoff">{-# INLINE valueContainsDenotation #-}</span>
<span class="lineno"> 2077 </span><span class="spaces">       </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 2078 </span><span class="spaces">            </span><span class="istickedoff">valueContainsDenotation</span>
<span class="lineno"> 2079 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunTwoArguments . unimplementedCostingFun)</span>
<span class="lineno"> 2080 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2081 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar ValueData =</span>
<span class="lineno"> 2082 </span><span class="spaces">        </span><span class="istickedoff">let valueDataDenotation :: Value -&gt; Data</span>
<span class="lineno"> 2083 </span><span class="spaces">            </span><span class="istickedoff">valueDataDenotation = Value.valueData</span>
<span class="lineno"> 2084 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE valueDataDenotation #-}</span>
<span class="lineno"> 2085 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 2086 </span><span class="spaces">            </span><span class="istickedoff">valueDataDenotation</span>
<span class="lineno"> 2087 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . unimplementedCostingFun)</span>
<span class="lineno"> 2088 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2089 </span><span class="spaces">    </span><span class="istickedoff">toBuiltinMeaning _semvar UnValueData =</span>
<span class="lineno"> 2090 </span><span class="spaces">        </span><span class="istickedoff">let unValueDataDenotation :: Data -&gt; BuiltinResult Value</span>
<span class="lineno"> 2091 </span><span class="spaces">            </span><span class="istickedoff">unValueDataDenotation = Value.unValueData</span>
<span class="lineno"> 2092 </span><span class="spaces">            </span><span class="istickedoff">{-# INLINE unValueDataDenotation #-}</span>
<span class="lineno"> 2093 </span><span class="spaces">        </span><span class="istickedoff">in makeBuiltinMeaning</span>
<span class="lineno"> 2094 </span><span class="spaces">            </span><span class="istickedoff">unValueDataDenotation</span>
<span class="lineno"> 2095 </span><span class="spaces">            </span><span class="istickedoff">(runCostingFunOneArgument . unimplementedCostingFun)</span></span>
<span class="lineno"> 2096 </span>
<span class="lineno"> 2097 </span>    -- See Note [Inlining meanings of builtins].
<span class="lineno"> 2098 </span>    {-# INLINE toBuiltinMeaning #-}
<span class="lineno"> 2099 </span>
<span class="lineno"> 2100 </span>    {- *** IMPORTANT! *** When you're adding a new builtin above you typically won't
<span class="lineno"> 2101 </span>       be able to add a sensible costing function until the implementation is
<span class="lineno"> 2102 </span>       complete and you can benchmark it.  It's still necessary to supply
<span class="lineno"> 2103 </span>       `toBuiltinMeaning` with some costing function though: this **MUST** be
<span class="lineno"> 2104 </span>       `unimplementedCostingFun`: this will assign a very large cost to any
<span class="lineno"> 2105 </span>       invocation of the function, preventing it from being used in places where
<span class="lineno"> 2106 </span>       costs are important (for example on testnets) until the implementation is
<span class="lineno"> 2107 </span>       complete and a proper costing function has been defined.  Once the
<span class="lineno"> 2108 </span>       builtin is ready for general use replace `unimplementedCostingFun` with
<span class="lineno"> 2109 </span>       the appropriate `param&lt;BuiltinName&gt;` from BuiltinCostModelBase.
<span class="lineno"> 2110 </span>
<span class="lineno"> 2111 </span>       Please leave this comment immediately after the definition of the final
<span class="lineno"> 2112 </span>       builtin to maximise the chances of it being seen the next time someone
<span class="lineno"> 2113 </span>       implements a new builtin.
<span class="lineno"> 2114 </span>    -}
<span class="lineno"> 2115 </span>
<span class="lineno"> 2116 </span>instance Default (BuiltinSemanticsVariant DefaultFun) where
<span class="lineno"> 2117 </span>    <span class="decl"><span class="istickedoff">def = maxBound</span></span>
<span class="lineno"> 2118 </span>
<span class="lineno"> 2119 </span>instance <span class="decl"><span class="nottickedoff">Pretty (BuiltinSemanticsVariant DefaultFun)</span></span> where
<span class="lineno"> 2120 </span>    <span class="decl"><span class="istickedoff">pretty = viaShow</span></span>
<span class="lineno"> 2121 </span>
<span class="lineno"> 2122 </span>-- It's set deliberately to give us &quot;extra room&quot; in the binary format to add things without running
<span class="lineno"> 2123 </span>-- out of space for tags (expanding the space would change the binary format for people who're
<span class="lineno"> 2124 </span>-- implementing it manually). So we have to set it manually.
<span class="lineno"> 2125 </span>-- | Using 7 bits to encode builtin tags.
<span class="lineno"> 2126 </span>builtinTagWidth :: NumBits
<span class="lineno"> 2127 </span><span class="decl"><span class="istickedoff">builtinTagWidth = 7</span></span>
<span class="lineno"> 2128 </span>
<span class="lineno"> 2129 </span>encodeBuiltin :: Word8 -&gt; Flat.Encoding
<span class="lineno"> 2130 </span><span class="decl"><span class="istickedoff">encodeBuiltin = eBits builtinTagWidth</span></span>
<span class="lineno"> 2131 </span>
<span class="lineno"> 2132 </span>decodeBuiltin :: Get Word8
<span class="lineno"> 2133 </span><span class="decl"><span class="istickedoff">decodeBuiltin = dBEBits8 builtinTagWidth</span></span>
<span class="lineno"> 2134 </span>
<span class="lineno"> 2135 </span>-- See Note [Stable encoding of TPLC]
<span class="lineno"> 2136 </span>instance Flat DefaultFun where
<span class="lineno"> 2137 </span>    <span class="decl"><span class="istickedoff">encode = encodeBuiltin . \case</span>
<span class="lineno"> 2138 </span><span class="spaces">              </span><span class="istickedoff">AddInteger                      -&gt; 0</span>
<span class="lineno"> 2139 </span><span class="spaces">              </span><span class="istickedoff">SubtractInteger                 -&gt; 1</span>
<span class="lineno"> 2140 </span><span class="spaces">              </span><span class="istickedoff">MultiplyInteger                 -&gt; 2</span>
<span class="lineno"> 2141 </span><span class="spaces">              </span><span class="istickedoff">DivideInteger                   -&gt; 3</span>
<span class="lineno"> 2142 </span><span class="spaces">              </span><span class="istickedoff">QuotientInteger                 -&gt; 4</span>
<span class="lineno"> 2143 </span><span class="spaces">              </span><span class="istickedoff">RemainderInteger                -&gt; 5</span>
<span class="lineno"> 2144 </span><span class="spaces">              </span><span class="istickedoff">ModInteger                      -&gt; 6</span>
<span class="lineno"> 2145 </span><span class="spaces">              </span><span class="istickedoff">EqualsInteger                   -&gt; 7</span>
<span class="lineno"> 2146 </span><span class="spaces">              </span><span class="istickedoff">LessThanInteger                 -&gt; 8</span>
<span class="lineno"> 2147 </span><span class="spaces">              </span><span class="istickedoff">LessThanEqualsInteger           -&gt; 9</span>
<span class="lineno"> 2148 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2149 </span><span class="spaces">              </span><span class="istickedoff">AppendByteString                -&gt; 10</span>
<span class="lineno"> 2150 </span><span class="spaces">              </span><span class="istickedoff">ConsByteString                  -&gt; 11</span>
<span class="lineno"> 2151 </span><span class="spaces">              </span><span class="istickedoff">SliceByteString                 -&gt; 12</span>
<span class="lineno"> 2152 </span><span class="spaces">              </span><span class="istickedoff">LengthOfByteString              -&gt; 13</span>
<span class="lineno"> 2153 </span><span class="spaces">              </span><span class="istickedoff">IndexByteString                 -&gt; 14</span>
<span class="lineno"> 2154 </span><span class="spaces">              </span><span class="istickedoff">EqualsByteString                -&gt; 15</span>
<span class="lineno"> 2155 </span><span class="spaces">              </span><span class="istickedoff">LessThanByteString              -&gt; 16</span>
<span class="lineno"> 2156 </span><span class="spaces">              </span><span class="istickedoff">LessThanEqualsByteString        -&gt; 17</span>
<span class="lineno"> 2157 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2158 </span><span class="spaces">              </span><span class="istickedoff">Sha2_256                        -&gt; 18</span>
<span class="lineno"> 2159 </span><span class="spaces">              </span><span class="istickedoff">Sha3_256                        -&gt; 19</span>
<span class="lineno"> 2160 </span><span class="spaces">              </span><span class="istickedoff">Blake2b_256                     -&gt; 20</span>
<span class="lineno"> 2161 </span><span class="spaces">              </span><span class="istickedoff">VerifyEd25519Signature          -&gt; 21</span>
<span class="lineno"> 2162 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2163 </span><span class="spaces">              </span><span class="istickedoff">AppendString                    -&gt; 22</span>
<span class="lineno"> 2164 </span><span class="spaces">              </span><span class="istickedoff">EqualsString                    -&gt; 23</span>
<span class="lineno"> 2165 </span><span class="spaces">              </span><span class="istickedoff">EncodeUtf8                      -&gt; 24</span>
<span class="lineno"> 2166 </span><span class="spaces">              </span><span class="istickedoff">DecodeUtf8                      -&gt; 25</span>
<span class="lineno"> 2167 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2168 </span><span class="spaces">              </span><span class="istickedoff">IfThenElse                      -&gt; 26</span>
<span class="lineno"> 2169 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2170 </span><span class="spaces">              </span><span class="istickedoff">ChooseUnit                      -&gt; 27</span>
<span class="lineno"> 2171 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2172 </span><span class="spaces">              </span><span class="istickedoff">Trace                           -&gt; 28</span>
<span class="lineno"> 2173 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2174 </span><span class="spaces">              </span><span class="istickedoff">FstPair                         -&gt; 29</span>
<span class="lineno"> 2175 </span><span class="spaces">              </span><span class="istickedoff">SndPair                         -&gt; 30</span>
<span class="lineno"> 2176 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2177 </span><span class="spaces">              </span><span class="istickedoff">ChooseList                      -&gt; 31</span>
<span class="lineno"> 2178 </span><span class="spaces">              </span><span class="istickedoff">MkCons                          -&gt; 32</span>
<span class="lineno"> 2179 </span><span class="spaces">              </span><span class="istickedoff">HeadList                        -&gt; 33</span>
<span class="lineno"> 2180 </span><span class="spaces">              </span><span class="istickedoff">TailList                        -&gt; 34</span>
<span class="lineno"> 2181 </span><span class="spaces">              </span><span class="istickedoff">NullList                        -&gt; 35</span>
<span class="lineno"> 2182 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2183 </span><span class="spaces">              </span><span class="istickedoff">ChooseData                      -&gt; 36</span>
<span class="lineno"> 2184 </span><span class="spaces">              </span><span class="istickedoff">ConstrData                      -&gt; 37</span>
<span class="lineno"> 2185 </span><span class="spaces">              </span><span class="istickedoff">MapData                         -&gt; 38</span>
<span class="lineno"> 2186 </span><span class="spaces">              </span><span class="istickedoff">ListData                        -&gt; 39</span>
<span class="lineno"> 2187 </span><span class="spaces">              </span><span class="istickedoff">IData                           -&gt; 40</span>
<span class="lineno"> 2188 </span><span class="spaces">              </span><span class="istickedoff">BData                           -&gt; 41</span>
<span class="lineno"> 2189 </span><span class="spaces">              </span><span class="istickedoff">UnConstrData                    -&gt; 42</span>
<span class="lineno"> 2190 </span><span class="spaces">              </span><span class="istickedoff">UnMapData                       -&gt; 43</span>
<span class="lineno"> 2191 </span><span class="spaces">              </span><span class="istickedoff">UnListData                      -&gt; 44</span>
<span class="lineno"> 2192 </span><span class="spaces">              </span><span class="istickedoff">UnIData                         -&gt; 45</span>
<span class="lineno"> 2193 </span><span class="spaces">              </span><span class="istickedoff">UnBData                         -&gt; 46</span>
<span class="lineno"> 2194 </span><span class="spaces">              </span><span class="istickedoff">EqualsData                      -&gt; 47</span>
<span class="lineno"> 2195 </span><span class="spaces">              </span><span class="istickedoff">MkPairData                      -&gt; 48</span>
<span class="lineno"> 2196 </span><span class="spaces">              </span><span class="istickedoff">MkNilData                       -&gt; 49</span>
<span class="lineno"> 2197 </span><span class="spaces">              </span><span class="istickedoff">MkNilPairData                   -&gt; 50</span>
<span class="lineno"> 2198 </span><span class="spaces">              </span><span class="istickedoff">SerialiseData                   -&gt; 51</span>
<span class="lineno"> 2199 </span><span class="spaces">              </span><span class="istickedoff">VerifyEcdsaSecp256k1Signature   -&gt; 52</span>
<span class="lineno"> 2200 </span><span class="spaces">              </span><span class="istickedoff">VerifySchnorrSecp256k1Signature -&gt; 53</span>
<span class="lineno"> 2201 </span><span class="spaces">              </span><span class="istickedoff">Bls12_381_G1_add                -&gt; 54</span>
<span class="lineno"> 2202 </span><span class="spaces">              </span><span class="istickedoff">Bls12_381_G1_neg                -&gt; 55</span>
<span class="lineno"> 2203 </span><span class="spaces">              </span><span class="istickedoff">Bls12_381_G1_scalarMul          -&gt; 56</span>
<span class="lineno"> 2204 </span><span class="spaces">              </span><span class="istickedoff">Bls12_381_G1_equal              -&gt; 57</span>
<span class="lineno"> 2205 </span><span class="spaces">              </span><span class="istickedoff">Bls12_381_G1_compress           -&gt; 58</span>
<span class="lineno"> 2206 </span><span class="spaces">              </span><span class="istickedoff">Bls12_381_G1_uncompress         -&gt; 59</span>
<span class="lineno"> 2207 </span><span class="spaces">              </span><span class="istickedoff">Bls12_381_G1_hashToGroup        -&gt; 60</span>
<span class="lineno"> 2208 </span><span class="spaces">              </span><span class="istickedoff">Bls12_381_G2_add                -&gt; 61</span>
<span class="lineno"> 2209 </span><span class="spaces">              </span><span class="istickedoff">Bls12_381_G2_neg                -&gt; 62</span>
<span class="lineno"> 2210 </span><span class="spaces">              </span><span class="istickedoff">Bls12_381_G2_scalarMul          -&gt; 63</span>
<span class="lineno"> 2211 </span><span class="spaces">              </span><span class="istickedoff">Bls12_381_G2_equal              -&gt; 64</span>
<span class="lineno"> 2212 </span><span class="spaces">              </span><span class="istickedoff">Bls12_381_G2_compress           -&gt; 65</span>
<span class="lineno"> 2213 </span><span class="spaces">              </span><span class="istickedoff">Bls12_381_G2_uncompress         -&gt; 66</span>
<span class="lineno"> 2214 </span><span class="spaces">              </span><span class="istickedoff">Bls12_381_G2_hashToGroup        -&gt; 67</span>
<span class="lineno"> 2215 </span><span class="spaces">              </span><span class="istickedoff">Bls12_381_millerLoop            -&gt; 68</span>
<span class="lineno"> 2216 </span><span class="spaces">              </span><span class="istickedoff">Bls12_381_mulMlResult           -&gt; 69</span>
<span class="lineno"> 2217 </span><span class="spaces">              </span><span class="istickedoff">Bls12_381_finalVerify           -&gt; 70</span>
<span class="lineno"> 2218 </span><span class="spaces">              </span><span class="istickedoff">Keccak_256                      -&gt; 71</span>
<span class="lineno"> 2219 </span><span class="spaces">              </span><span class="istickedoff">Blake2b_224                     -&gt; 72</span>
<span class="lineno"> 2220 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2221 </span><span class="spaces">              </span><span class="istickedoff">IntegerToByteString             -&gt; 73</span>
<span class="lineno"> 2222 </span><span class="spaces">              </span><span class="istickedoff">ByteStringToInteger             -&gt; 74</span>
<span class="lineno"> 2223 </span><span class="spaces">              </span><span class="istickedoff">AndByteString                   -&gt; 75</span>
<span class="lineno"> 2224 </span><span class="spaces">              </span><span class="istickedoff">OrByteString                    -&gt; 76</span>
<span class="lineno"> 2225 </span><span class="spaces">              </span><span class="istickedoff">XorByteString                   -&gt; 77</span>
<span class="lineno"> 2226 </span><span class="spaces">              </span><span class="istickedoff">ComplementByteString            -&gt; 78</span>
<span class="lineno"> 2227 </span><span class="spaces">              </span><span class="istickedoff">ReadBit                         -&gt; 79</span>
<span class="lineno"> 2228 </span><span class="spaces">              </span><span class="istickedoff">WriteBits                       -&gt; 80</span>
<span class="lineno"> 2229 </span><span class="spaces">              </span><span class="istickedoff">ReplicateByte                   -&gt; 81</span>
<span class="lineno"> 2230 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2231 </span><span class="spaces">              </span><span class="istickedoff">ShiftByteString                 -&gt; 82</span>
<span class="lineno"> 2232 </span><span class="spaces">              </span><span class="istickedoff">RotateByteString                -&gt; 83</span>
<span class="lineno"> 2233 </span><span class="spaces">              </span><span class="istickedoff">CountSetBits                    -&gt; 84</span>
<span class="lineno"> 2234 </span><span class="spaces">              </span><span class="istickedoff">FindFirstSetBit                 -&gt; 85</span>
<span class="lineno"> 2235 </span><span class="spaces">              </span><span class="istickedoff">Ripemd_160                      -&gt; 86</span>
<span class="lineno"> 2236 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2237 </span><span class="spaces">              </span><span class="istickedoff">ExpModInteger                   -&gt; 87</span>
<span class="lineno"> 2238 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2239 </span><span class="spaces">              </span><span class="istickedoff">DropList                        -&gt; 88</span>
<span class="lineno"> 2240 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2241 </span><span class="spaces">              </span><span class="istickedoff">LengthOfArray                   -&gt; 89</span>
<span class="lineno"> 2242 </span><span class="spaces">              </span><span class="istickedoff">ListToArray                     -&gt; 90</span>
<span class="lineno"> 2243 </span><span class="spaces">              </span><span class="istickedoff">IndexArray                      -&gt; 91</span>
<span class="lineno"> 2244 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2245 </span><span class="spaces">              </span><span class="istickedoff">Bls12_381_G1_multiScalarMul     -&gt; 92</span>
<span class="lineno"> 2246 </span><span class="spaces">              </span><span class="istickedoff">Bls12_381_G2_multiScalarMul     -&gt; 93</span>
<span class="lineno"> 2247 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2248 </span><span class="spaces">              </span><span class="istickedoff">InsertCoin                      -&gt; 94</span>
<span class="lineno"> 2249 </span><span class="spaces">              </span><span class="istickedoff">LookupCoin                      -&gt; <span class="nottickedoff">95</span></span>
<span class="lineno"> 2250 </span><span class="spaces">              </span><span class="istickedoff">UnionValue                      -&gt; 96</span>
<span class="lineno"> 2251 </span><span class="spaces">              </span><span class="istickedoff">ValueContains                   -&gt; <span class="nottickedoff">97</span></span>
<span class="lineno"> 2252 </span><span class="spaces">              </span><span class="istickedoff">ValueData                       -&gt; 98</span>
<span class="lineno"> 2253 </span><span class="spaces">              </span><span class="istickedoff">UnValueData                     -&gt; <span class="nottickedoff">99</span></span></span>
<span class="lineno"> 2254 </span>
<span class="lineno"> 2255 </span>    <span class="decl"><span class="istickedoff">decode = go =&lt;&lt; decodeBuiltin</span>
<span class="lineno"> 2256 </span><span class="spaces">        </span><span class="istickedoff">where go 0  = pure AddInteger</span>
<span class="lineno"> 2257 </span><span class="spaces">              </span><span class="istickedoff">go 1  = pure SubtractInteger</span>
<span class="lineno"> 2258 </span><span class="spaces">              </span><span class="istickedoff">go 2  = pure MultiplyInteger</span>
<span class="lineno"> 2259 </span><span class="spaces">              </span><span class="istickedoff">go 3  = pure DivideInteger</span>
<span class="lineno"> 2260 </span><span class="spaces">              </span><span class="istickedoff">go 4  = pure QuotientInteger</span>
<span class="lineno"> 2261 </span><span class="spaces">              </span><span class="istickedoff">go 5  = pure RemainderInteger</span>
<span class="lineno"> 2262 </span><span class="spaces">              </span><span class="istickedoff">go 6  = pure ModInteger</span>
<span class="lineno"> 2263 </span><span class="spaces">              </span><span class="istickedoff">go 7  = pure EqualsInteger</span>
<span class="lineno"> 2264 </span><span class="spaces">              </span><span class="istickedoff">go 8  = pure LessThanInteger</span>
<span class="lineno"> 2265 </span><span class="spaces">              </span><span class="istickedoff">go 9  = pure LessThanEqualsInteger</span>
<span class="lineno"> 2266 </span><span class="spaces">              </span><span class="istickedoff">go 10 = pure AppendByteString</span>
<span class="lineno"> 2267 </span><span class="spaces">              </span><span class="istickedoff">go 11 = pure ConsByteString</span>
<span class="lineno"> 2268 </span><span class="spaces">              </span><span class="istickedoff">go 12 = pure SliceByteString</span>
<span class="lineno"> 2269 </span><span class="spaces">              </span><span class="istickedoff">go 13 = pure LengthOfByteString</span>
<span class="lineno"> 2270 </span><span class="spaces">              </span><span class="istickedoff">go 14 = pure IndexByteString</span>
<span class="lineno"> 2271 </span><span class="spaces">              </span><span class="istickedoff">go 15 = pure EqualsByteString</span>
<span class="lineno"> 2272 </span><span class="spaces">              </span><span class="istickedoff">go 16 = pure LessThanByteString</span>
<span class="lineno"> 2273 </span><span class="spaces">              </span><span class="istickedoff">go 17 = pure LessThanEqualsByteString</span>
<span class="lineno"> 2274 </span><span class="spaces">              </span><span class="istickedoff">go 18 = pure Sha2_256</span>
<span class="lineno"> 2275 </span><span class="spaces">              </span><span class="istickedoff">go 19 = pure Sha3_256</span>
<span class="lineno"> 2276 </span><span class="spaces">              </span><span class="istickedoff">go 20 = pure Blake2b_256</span>
<span class="lineno"> 2277 </span><span class="spaces">              </span><span class="istickedoff">go 21 = pure VerifyEd25519Signature</span>
<span class="lineno"> 2278 </span><span class="spaces">              </span><span class="istickedoff">go 22 = pure AppendString</span>
<span class="lineno"> 2279 </span><span class="spaces">              </span><span class="istickedoff">go 23 = pure EqualsString</span>
<span class="lineno"> 2280 </span><span class="spaces">              </span><span class="istickedoff">go 24 = pure EncodeUtf8</span>
<span class="lineno"> 2281 </span><span class="spaces">              </span><span class="istickedoff">go 25 = pure DecodeUtf8</span>
<span class="lineno"> 2282 </span><span class="spaces">              </span><span class="istickedoff">go 26 = pure IfThenElse</span>
<span class="lineno"> 2283 </span><span class="spaces">              </span><span class="istickedoff">go 27 = pure ChooseUnit</span>
<span class="lineno"> 2284 </span><span class="spaces">              </span><span class="istickedoff">go 28 = pure Trace</span>
<span class="lineno"> 2285 </span><span class="spaces">              </span><span class="istickedoff">go 29 = pure FstPair</span>
<span class="lineno"> 2286 </span><span class="spaces">              </span><span class="istickedoff">go 30 = pure SndPair</span>
<span class="lineno"> 2287 </span><span class="spaces">              </span><span class="istickedoff">go 31 = pure ChooseList</span>
<span class="lineno"> 2288 </span><span class="spaces">              </span><span class="istickedoff">go 32 = pure MkCons</span>
<span class="lineno"> 2289 </span><span class="spaces">              </span><span class="istickedoff">go 33 = pure HeadList</span>
<span class="lineno"> 2290 </span><span class="spaces">              </span><span class="istickedoff">go 34 = pure TailList</span>
<span class="lineno"> 2291 </span><span class="spaces">              </span><span class="istickedoff">go 35 = pure NullList</span>
<span class="lineno"> 2292 </span><span class="spaces">              </span><span class="istickedoff">go 36 = pure ChooseData</span>
<span class="lineno"> 2293 </span><span class="spaces">              </span><span class="istickedoff">go 37 = pure ConstrData</span>
<span class="lineno"> 2294 </span><span class="spaces">              </span><span class="istickedoff">go 38 = pure MapData</span>
<span class="lineno"> 2295 </span><span class="spaces">              </span><span class="istickedoff">go 39 = pure ListData</span>
<span class="lineno"> 2296 </span><span class="spaces">              </span><span class="istickedoff">go 40 = pure IData</span>
<span class="lineno"> 2297 </span><span class="spaces">              </span><span class="istickedoff">go 41 = pure BData</span>
<span class="lineno"> 2298 </span><span class="spaces">              </span><span class="istickedoff">go 42 = pure UnConstrData</span>
<span class="lineno"> 2299 </span><span class="spaces">              </span><span class="istickedoff">go 43 = pure UnMapData</span>
<span class="lineno"> 2300 </span><span class="spaces">              </span><span class="istickedoff">go 44 = pure UnListData</span>
<span class="lineno"> 2301 </span><span class="spaces">              </span><span class="istickedoff">go 45 = pure UnIData</span>
<span class="lineno"> 2302 </span><span class="spaces">              </span><span class="istickedoff">go 46 = pure UnBData</span>
<span class="lineno"> 2303 </span><span class="spaces">              </span><span class="istickedoff">go 47 = pure EqualsData</span>
<span class="lineno"> 2304 </span><span class="spaces">              </span><span class="istickedoff">go 48 = pure MkPairData</span>
<span class="lineno"> 2305 </span><span class="spaces">              </span><span class="istickedoff">go 49 = pure MkNilData</span>
<span class="lineno"> 2306 </span><span class="spaces">              </span><span class="istickedoff">go 50 = pure MkNilPairData</span>
<span class="lineno"> 2307 </span><span class="spaces">              </span><span class="istickedoff">go 51 = pure SerialiseData</span>
<span class="lineno"> 2308 </span><span class="spaces">              </span><span class="istickedoff">go 52 = pure VerifyEcdsaSecp256k1Signature</span>
<span class="lineno"> 2309 </span><span class="spaces">              </span><span class="istickedoff">go 53 = pure VerifySchnorrSecp256k1Signature</span>
<span class="lineno"> 2310 </span><span class="spaces">              </span><span class="istickedoff">go 54 = pure Bls12_381_G1_add</span>
<span class="lineno"> 2311 </span><span class="spaces">              </span><span class="istickedoff">go 55 = pure Bls12_381_G1_neg</span>
<span class="lineno"> 2312 </span><span class="spaces">              </span><span class="istickedoff">go 56 = pure Bls12_381_G1_scalarMul</span>
<span class="lineno"> 2313 </span><span class="spaces">              </span><span class="istickedoff">go 57 = pure Bls12_381_G1_equal</span>
<span class="lineno"> 2314 </span><span class="spaces">              </span><span class="istickedoff">go 58 = pure Bls12_381_G1_compress</span>
<span class="lineno"> 2315 </span><span class="spaces">              </span><span class="istickedoff">go 59 = pure Bls12_381_G1_uncompress</span>
<span class="lineno"> 2316 </span><span class="spaces">              </span><span class="istickedoff">go 60 = pure Bls12_381_G1_hashToGroup</span>
<span class="lineno"> 2317 </span><span class="spaces">              </span><span class="istickedoff">go 61 = pure Bls12_381_G2_add</span>
<span class="lineno"> 2318 </span><span class="spaces">              </span><span class="istickedoff">go 62 = pure Bls12_381_G2_neg</span>
<span class="lineno"> 2319 </span><span class="spaces">              </span><span class="istickedoff">go 63 = pure Bls12_381_G2_scalarMul</span>
<span class="lineno"> 2320 </span><span class="spaces">              </span><span class="istickedoff">go 64 = pure Bls12_381_G2_equal</span>
<span class="lineno"> 2321 </span><span class="spaces">              </span><span class="istickedoff">go 65 = pure Bls12_381_G2_compress</span>
<span class="lineno"> 2322 </span><span class="spaces">              </span><span class="istickedoff">go 66 = pure Bls12_381_G2_uncompress</span>
<span class="lineno"> 2323 </span><span class="spaces">              </span><span class="istickedoff">go 67 = pure Bls12_381_G2_hashToGroup</span>
<span class="lineno"> 2324 </span><span class="spaces">              </span><span class="istickedoff">go 68 = pure Bls12_381_millerLoop</span>
<span class="lineno"> 2325 </span><span class="spaces">              </span><span class="istickedoff">go 69 = pure Bls12_381_mulMlResult</span>
<span class="lineno"> 2326 </span><span class="spaces">              </span><span class="istickedoff">go 70 = pure Bls12_381_finalVerify</span>
<span class="lineno"> 2327 </span><span class="spaces">              </span><span class="istickedoff">go 71 = pure Keccak_256</span>
<span class="lineno"> 2328 </span><span class="spaces">              </span><span class="istickedoff">go 72 = pure Blake2b_224</span>
<span class="lineno"> 2329 </span><span class="spaces">              </span><span class="istickedoff">go 73 = pure IntegerToByteString</span>
<span class="lineno"> 2330 </span><span class="spaces">              </span><span class="istickedoff">go 74 = pure ByteStringToInteger</span>
<span class="lineno"> 2331 </span><span class="spaces">              </span><span class="istickedoff">go 75 = pure AndByteString</span>
<span class="lineno"> 2332 </span><span class="spaces">              </span><span class="istickedoff">go 76 = pure OrByteString</span>
<span class="lineno"> 2333 </span><span class="spaces">              </span><span class="istickedoff">go 77 = pure XorByteString</span>
<span class="lineno"> 2334 </span><span class="spaces">              </span><span class="istickedoff">go 78 = pure ComplementByteString</span>
<span class="lineno"> 2335 </span><span class="spaces">              </span><span class="istickedoff">go 79 = pure ReadBit</span>
<span class="lineno"> 2336 </span><span class="spaces">              </span><span class="istickedoff">go 80 = pure WriteBits</span>
<span class="lineno"> 2337 </span><span class="spaces">              </span><span class="istickedoff">go 81 = pure ReplicateByte</span>
<span class="lineno"> 2338 </span><span class="spaces">              </span><span class="istickedoff">go 82 = pure ShiftByteString</span>
<span class="lineno"> 2339 </span><span class="spaces">              </span><span class="istickedoff">go 83 = pure RotateByteString</span>
<span class="lineno"> 2340 </span><span class="spaces">              </span><span class="istickedoff">go 84 = pure CountSetBits</span>
<span class="lineno"> 2341 </span><span class="spaces">              </span><span class="istickedoff">go 85 = pure FindFirstSetBit</span>
<span class="lineno"> 2342 </span><span class="spaces">              </span><span class="istickedoff">go 86 = pure Ripemd_160</span>
<span class="lineno"> 2343 </span><span class="spaces">              </span><span class="istickedoff">go 87 = pure ExpModInteger</span>
<span class="lineno"> 2344 </span><span class="spaces">              </span><span class="istickedoff">go 88 = pure DropList</span>
<span class="lineno"> 2345 </span><span class="spaces">              </span><span class="istickedoff">go 89 = pure LengthOfArray</span>
<span class="lineno"> 2346 </span><span class="spaces">              </span><span class="istickedoff">go 90 = pure ListToArray</span>
<span class="lineno"> 2347 </span><span class="spaces">              </span><span class="istickedoff">go 91 = pure IndexArray</span>
<span class="lineno"> 2348 </span><span class="spaces">              </span><span class="istickedoff">go 92 = pure Bls12_381_G1_multiScalarMul</span>
<span class="lineno"> 2349 </span><span class="spaces">              </span><span class="istickedoff">go 93 = pure Bls12_381_G2_multiScalarMul</span>
<span class="lineno"> 2350 </span><span class="spaces">              </span><span class="istickedoff">go 94 = pure InsertCoin</span>
<span class="lineno"> 2351 </span><span class="spaces">              </span><span class="istickedoff">go 95 = <span class="nottickedoff">pure LookupCoin</span></span>
<span class="lineno"> 2352 </span><span class="spaces">              </span><span class="istickedoff">go 96 = pure UnionValue</span>
<span class="lineno"> 2353 </span><span class="spaces">              </span><span class="istickedoff">go 97 = <span class="nottickedoff">pure ValueContains</span></span>
<span class="lineno"> 2354 </span><span class="spaces">              </span><span class="istickedoff">go 98 = pure ValueData</span>
<span class="lineno"> 2355 </span><span class="spaces">              </span><span class="istickedoff">go 99 = <span class="nottickedoff">pure UnValueData</span></span>
<span class="lineno"> 2356 </span><span class="spaces">              </span><span class="istickedoff">go t  = <span class="nottickedoff">fail $ &quot;Failed to decode builtin tag, got: &quot; ++ show t</span></span></span>
<span class="lineno"> 2357 </span>
<span class="lineno"> 2358 </span>    <span class="decl"><span class="istickedoff">size _ n = n + builtinTagWidth</span></span>
<span class="lineno"> 2359 </span>
<span class="lineno"> 2360 </span>{- Note [Legacy pattern matching on built-in types]
<span class="lineno"> 2361 </span>We used to only support direct pattern matching on enumeration types: 'Void', 'Unit', 'Bool'
<span class="lineno"> 2362 </span>etc. This is because it was impossible to 'Case' on a value of a built-in type.
<span class="lineno"> 2363 </span>
<span class="lineno"> 2364 </span>So e.g. if we wanted to add the following data type:
<span class="lineno"> 2365 </span>
<span class="lineno"> 2366 </span>    newtype AnInt = AnInt Int
<span class="lineno"> 2367 </span>
<span class="lineno"> 2368 </span>as a built-in type, we wouldn't be able to add the following function as its pattern matcher:
<span class="lineno"> 2369 </span>
<span class="lineno"> 2370 </span>    matchAnInt :: AnInt -&gt; (Int -&gt; r) -&gt; r
<span class="lineno"> 2371 </span>    matchAnInt (AnInt i) f = f i
<span class="lineno"> 2372 </span>
<span class="lineno"> 2373 </span>because we could not express the @f i@ part using the builtins machinery.
<span class="lineno"> 2374 </span>
<span class="lineno"> 2375 </span>But it still was possible to have @AnInt@ as a built-in type, it's just that instead of trying to
<span class="lineno"> 2376 </span>make its pattern matcher into a builtin we could have the following builtin:
<span class="lineno"> 2377 </span>
<span class="lineno"> 2378 </span>    anIntToInt :: AnInt -&gt; Int
<span class="lineno"> 2379 </span>    anIntToInt (AnInt i) = i
<span class="lineno"> 2380 </span>
<span class="lineno"> 2381 </span>Although that was an annoyance for more complex data types. For tuples we needed to provide two
<span class="lineno"> 2382 </span>projection functions ('fst' and 'snd') instead of a single pattern matcher, which is not too bad,
<span class="lineno"> 2383 </span>but to get pattern matching on lists we needed a more complicated setup. For example originally we
<span class="lineno"> 2384 </span>would define three built-in functions: @null@, @head@ and @tail@, plus require `Bool` to be in the
<span class="lineno"> 2385 </span>universe, so that we can define an equivalent of
<span class="lineno"> 2386 </span>
<span class="lineno"> 2387 </span>    matchList :: [a] -&gt; r -&gt; (a -&gt; [a] -&gt; r) -&gt; r
<span class="lineno"> 2388 </span>    matchList xs z f = if null xs then z else f (head xs) (tail xs)
<span class="lineno"> 2389 </span>
<span class="lineno"> 2390 </span>If a constructor stores more than one value, the corresponding projection function would pack them
<span class="lineno"> 2391 </span>into a (possibly nested) pair, for example for
<span class="lineno"> 2392 </span>
<span class="lineno"> 2393 </span>    data Data
<span class="lineno"> 2394 </span>        = Constr Integer [Data]
<span class="lineno"> 2395 </span>        | &lt;...&gt;
<span class="lineno"> 2396 </span>
<span class="lineno"> 2397 </span>we had (pseudocode):
<span class="lineno"> 2398 </span>
<span class="lineno"> 2399 </span>    unConstrData (Constr i ds) = (i, ds)
<span class="lineno"> 2400 </span>
<span class="lineno"> 2401 </span>and we still have that built-in function for backwards compatibility reasons.
<span class="lineno"> 2402 </span>
<span class="lineno"> 2403 </span>In order to get pattern matching over 'Data' we needed a projection function per constructor as well
<span class="lineno"> 2404 </span>as with lists, but writing (where the @Data@ suffix indicates that a function is a builtin that
<span class="lineno"> 2405 </span>somehow corresponds to a constructor of 'Data')
<span class="lineno"> 2406 </span>
<span class="lineno"> 2407 </span>    if isConstrData d
<span class="lineno"> 2408 </span>        then uncurry fConstr $ unConstrData d
<span class="lineno"> 2409 </span>        else if isMapData d
<span class="lineno"> 2410 </span>            then fMap $ unMapData d
<span class="lineno"> 2411 </span>            else if isListData d
<span class="lineno"> 2412 </span>                then fList $ unListData d
<span class="lineno"> 2413 </span>                else &lt;...&gt;
<span class="lineno"> 2414 </span>
<span class="lineno"> 2415 </span>is tedious and inefficient and so instead we introduced a single @chooseData@ builtin that matches
<span class="lineno"> 2416 </span>on its @Data@ argument and chooses the appropriate branch (type instantiations and strictness
<span class="lineno"> 2417 </span>concerns are omitted for clarity):
<span class="lineno"> 2418 </span>
<span class="lineno"> 2419 </span>     chooseData
<span class="lineno"> 2420 </span>        (uncurry fConstr $ unConstrData d)
<span class="lineno"> 2421 </span>        (fMap $ unMapData d)
<span class="lineno"> 2422 </span>        (fList $ unListData d)
<span class="lineno"> 2423 </span>        &lt;...&gt;
<span class="lineno"> 2424 </span>        d
<span class="lineno"> 2425 </span>
<span class="lineno"> 2426 </span>which, for example, evaluates to @fMap es@ when @d@ is @Map es@
<span class="lineno"> 2427 </span>
<span class="lineno"> 2428 </span>We decided to handle lists the same way by using @chooseList@ rather than @null@ for consistency,
<span class="lineno"> 2429 </span>before introduction of casing on values of built-in types.
<span class="lineno"> 2430 </span>-}

</pre>
</body>
</html>
