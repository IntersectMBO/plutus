<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE GADTs             #-}
<span class="lineno">    2 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    3 </span>
<span class="lineno">    4 </span>module PlutusCore.Parser.Builtin where
<span class="lineno">    5 </span>
<span class="lineno">    6 </span>import PlutusPrelude (Word8, reoption, void)
<span class="lineno">    7 </span>
<span class="lineno">    8 </span>import PlutusCore.Crypto.BLS12_381.G1 qualified as BLS12_381.G1
<span class="lineno">    9 </span>import PlutusCore.Crypto.BLS12_381.G2 qualified as BLS12_381.G2
<span class="lineno">   10 </span>import PlutusCore.Data
<span class="lineno">   11 </span>import PlutusCore.Default
<span class="lineno">   12 </span>import PlutusCore.Error (ParserError (UnknownBuiltinFunction))
<span class="lineno">   13 </span>import PlutusCore.Name.Unique
<span class="lineno">   14 </span>import PlutusCore.Parser.ParserCommon
<span class="lineno">   15 </span>import PlutusCore.Parser.Type (defaultUni)
<span class="lineno">   16 </span>import PlutusCore.Pretty (display)
<span class="lineno">   17 </span>import PlutusCore.Value qualified as PLC (Value)
<span class="lineno">   18 </span>import PlutusCore.Value qualified as Value
<span class="lineno">   19 </span>
<span class="lineno">   20 </span>import Control.Monad.Combinators
<span class="lineno">   21 </span>import Data.ByteString (ByteString, pack, unpack)
<span class="lineno">   22 </span>import Data.Map.Strict qualified as Map
<span class="lineno">   23 </span>import Data.Text qualified as T
<span class="lineno">   24 </span>import Data.Text.Internal.Read (hexDigitToInt)
<span class="lineno">   25 </span>import Data.Vector.Strict (Vector)
<span class="lineno">   26 </span>import Data.Vector.Strict qualified as Vector
<span class="lineno">   27 </span>import Text.Megaparsec (customFailure, getSourcePos, takeWhileP)
<span class="lineno">   28 </span>import Text.Megaparsec.Char (char, hexDigitChar, string)
<span class="lineno">   29 </span>import Text.Megaparsec.Char.Lexer qualified as Lex
<span class="lineno">   30 </span>
<span class="lineno">   31 </span>cachedBuiltin :: Map.Map T.Text DefaultFun
<span class="lineno">   32 </span><span class="decl"><span class="istickedoff">cachedBuiltin = Map.fromList [(display fn, fn) | fn &lt;- [minBound .. maxBound]]</span></span>
<span class="lineno">   33 </span>
<span class="lineno">   34 </span>-- | Parser for builtin functions. Atm the parser can only parse `DefaultFun`.
<span class="lineno">   35 </span>builtinFunction :: Parser DefaultFun
<span class="lineno">   36 </span><span class="decl"><span class="istickedoff">builtinFunction = lexeme $ do</span>
<span class="lineno">   37 </span><span class="spaces">  </span><span class="istickedoff">txt &lt;- takeWhileP <span class="nottickedoff">(Just &quot;builtin function identifier&quot;)</span> isIdentifierChar</span>
<span class="lineno">   38 </span><span class="spaces">  </span><span class="istickedoff">case Map.lookup txt cachedBuiltin of</span>
<span class="lineno">   39 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">   40 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">let lBuiltin = fmap fst $ Map.toList cachedBuiltin</span></span>
<span class="lineno">   41 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">pos &lt;- getSourcePos</span></span>
<span class="lineno">   42 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">customFailure $ UnknownBuiltinFunction txt pos lBuiltin</span></span>
<span class="lineno">   43 </span><span class="spaces">    </span><span class="istickedoff">Just builtin -&gt; pure builtin</span></span>
<span class="lineno">   44 </span>
<span class="lineno">   45 </span>-- | Parser for integer constants.
<span class="lineno">   46 </span>conInteger :: Parser Integer
<span class="lineno">   47 </span><span class="decl"><span class="istickedoff">conInteger = Lex.signed whitespace (lexeme Lex.decimal)</span></span>
<span class="lineno">   48 </span>
<span class="lineno">   49 </span>-- | Parser for a pair of hex digits to a Word8.
<span class="lineno">   50 </span>hexByte :: Parser Word8
<span class="lineno">   51 </span><span class="decl"><span class="istickedoff">hexByte = do</span>
<span class="lineno">   52 </span><span class="spaces">  </span><span class="istickedoff">high &lt;- hexDigitChar</span>
<span class="lineno">   53 </span><span class="spaces">  </span><span class="istickedoff">low &lt;- hexDigitChar</span>
<span class="lineno">   54 </span><span class="spaces">  </span><span class="istickedoff">pure $ fromIntegral (hexDigitToInt high * 16 + hexDigitToInt low)</span></span>
<span class="lineno">   55 </span>
<span class="lineno">   56 </span>-- | Parser for bytestring constants. They start with &quot;#&quot;.
<span class="lineno">   57 </span>conBS :: Parser ByteString
<span class="lineno">   58 </span><span class="decl"><span class="istickedoff">conBS = lexeme . fmap pack $ char '#' *&gt; many hexByte</span></span>
<span class="lineno">   59 </span>
<span class="lineno">   60 </span>{- | Parser for string constants (wrapped in double quotes).  Note that
<span class="lineno">   61 </span> Data.Text.pack &quot;performs replacement on invalid scalar values&quot;, which means
<span class="lineno">   62 </span> that Unicode surrogate code points (corresponding to integers in the range
<span class="lineno">   63 </span> 0xD800-0xDFFF) are converted to the Unicode replacement character U+FFFD
<span class="lineno">   64 </span> (decimal 65533).  Thus `(con string &quot;X\xD800Z&quot;)` parses to a `Text` object
<span class="lineno">   65 </span> whose second character is U+FFFD.
<span class="lineno">   66 </span>-}
<span class="lineno">   67 </span>conText :: Parser T.Text
<span class="lineno">   68 </span><span class="decl"><span class="istickedoff">conText = lexeme . fmap T.pack $ char '\&quot;' *&gt; manyTill Lex.charLiteral (char '\&quot;')</span></span>
<span class="lineno">   69 </span>
<span class="lineno">   70 </span>-- | Parser for unit.
<span class="lineno">   71 </span>conUnit :: Parser ()
<span class="lineno">   72 </span><span class="decl"><span class="istickedoff">conUnit = void (symbol &quot;(&quot; *&gt; symbol &quot;)&quot;)</span></span>
<span class="lineno">   73 </span>
<span class="lineno">   74 </span>-- | Parser for bool.
<span class="lineno">   75 </span>conBool :: Parser Bool
<span class="lineno">   76 </span><span class="decl"><span class="istickedoff">conBool =</span>
<span class="lineno">   77 </span><span class="spaces">  </span><span class="istickedoff">choice</span>
<span class="lineno">   78 </span><span class="spaces">    </span><span class="istickedoff">[ True &lt;$ symbol &quot;True&quot;</span>
<span class="lineno">   79 </span><span class="spaces">    </span><span class="istickedoff">, False &lt;$ symbol &quot;False&quot;</span>
<span class="lineno">   80 </span><span class="spaces">    </span><span class="istickedoff">]</span></span>
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>-- | Parser for lists.
<span class="lineno">   83 </span>conList :: DefaultUni (Esc a) -&gt; Parser [a]
<span class="lineno">   84 </span><span class="decl"><span class="istickedoff">conList uniA = trailingWhitespace . inBrackets $</span>
<span class="lineno">   85 </span><span class="spaces">  </span><span class="istickedoff">constantOf ExpectParensNo uniA `sepBy` symbol &quot;,&quot;</span></span>
<span class="lineno">   86 </span>
<span class="lineno">   87 </span>-- | Parser for arrays.
<span class="lineno">   88 </span>conArray :: DefaultUni (Esc a) -&gt; Parser (Vector a)
<span class="lineno">   89 </span><span class="decl"><span class="istickedoff">conArray uniA = Vector.fromList &lt;$&gt; conList uniA</span></span>
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>-- | Parser for values.
<span class="lineno">   92 </span>conValue :: Parser PLC.Value
<span class="lineno">   93 </span><span class="decl"><span class="istickedoff">conValue = do</span>
<span class="lineno">   94 </span><span class="spaces">  </span><span class="istickedoff">Value.fromList &lt;$&gt; (traverse validateKeys =&lt;&lt; conList knownUni)</span>
<span class="lineno">   95 </span><span class="spaces"> </span><span class="istickedoff">where</span>
<span class="lineno">   96 </span><span class="spaces">  </span><span class="istickedoff">validateToken (token, amt) = do</span>
<span class="lineno">   97 </span><span class="spaces">    </span><span class="istickedoff">tk &lt;- maybe (fail $ <span class="nottickedoff">&quot;Invalid token: &quot; &lt;&gt; show (unpack token)</span>) pure (Value.k token)</span>
<span class="lineno">   98 </span><span class="spaces">    </span><span class="istickedoff">pure (tk, amt)</span>
<span class="lineno">   99 </span><span class="spaces">  </span><span class="istickedoff">validateKeys (currency, tokens) = do</span>
<span class="lineno">  100 </span><span class="spaces">    </span><span class="istickedoff">ck &lt;- maybe (fail $ <span class="nottickedoff">&quot;Invalid currency: &quot; &lt;&gt; show (unpack currency)</span>) pure (Value.k currency)</span>
<span class="lineno">  101 </span><span class="spaces">    </span><span class="istickedoff">tks &lt;- traverse validateToken tokens</span>
<span class="lineno">  102 </span><span class="spaces">    </span><span class="istickedoff">pure (ck, tks)</span></span>
<span class="lineno">  103 </span>
<span class="lineno">  104 </span>-- | Parser for pairs.
<span class="lineno">  105 </span>conPair :: DefaultUni (Esc a) -&gt; DefaultUni (Esc b) -&gt; Parser (a, b)
<span class="lineno">  106 </span><span class="decl"><span class="istickedoff">conPair uniA uniB = trailingWhitespace . inParens $ do</span>
<span class="lineno">  107 </span><span class="spaces">  </span><span class="istickedoff">a &lt;- constantOf ExpectParensNo uniA</span>
<span class="lineno">  108 </span><span class="spaces">  </span><span class="istickedoff">_ &lt;- symbol &quot;,&quot;</span>
<span class="lineno">  109 </span><span class="spaces">  </span><span class="istickedoff">b &lt;- constantOf ExpectParensNo uniB</span>
<span class="lineno">  110 </span><span class="spaces">  </span><span class="istickedoff">pure (a, b)</span></span>
<span class="lineno">  111 </span>
<span class="lineno">  112 </span>conDataNoParens :: Parser Data
<span class="lineno">  113 </span><span class="decl"><span class="istickedoff">conDataNoParens =</span>
<span class="lineno">  114 </span><span class="spaces">    </span><span class="istickedoff">choice</span>
<span class="lineno">  115 </span><span class="spaces">        </span><span class="istickedoff">[ symbol &quot;Constr&quot; *&gt; (Constr &lt;$&gt; conInteger &lt;*&gt; conList knownUni)</span>
<span class="lineno">  116 </span><span class="spaces">        </span><span class="istickedoff">, symbol &quot;Map&quot; *&gt; (Map &lt;$&gt; conList knownUni)</span>
<span class="lineno">  117 </span><span class="spaces">        </span><span class="istickedoff">, symbol &quot;List&quot; *&gt; (List &lt;$&gt; conList knownUni)</span>
<span class="lineno">  118 </span><span class="spaces">        </span><span class="istickedoff">, symbol &quot;I&quot; *&gt; (I &lt;$&gt; conInteger)</span>
<span class="lineno">  119 </span><span class="spaces">        </span><span class="istickedoff">, symbol &quot;B&quot; *&gt; (B &lt;$&gt; conBS)</span>
<span class="lineno">  120 </span><span class="spaces">        </span><span class="istickedoff">]</span></span>
<span class="lineno">  121 </span>
<span class="lineno">  122 </span>conData :: ExpectParens -&gt; Parser Data
<span class="lineno">  123 </span><span class="decl"><span class="istickedoff">conData ExpectParensYes = trailingWhitespace $ inParens conDataNoParens</span>
<span class="lineno">  124 </span><span class="spaces"></span><span class="istickedoff">conData ExpectParensNo  = conDataNoParens</span></span>
<span class="lineno">  125 </span>
<span class="lineno">  126 </span>-- Serialised BLS12_381 elements are &quot;0x&quot; followed by a hex string of even
<span class="lineno">  127 </span>-- length.  Maybe we should just use the usual bytestring syntax.
<span class="lineno">  128 </span>con0xBS :: Parser ByteString
<span class="lineno">  129 </span><span class="decl"><span class="istickedoff">con0xBS = lexeme . fmap pack $ string &quot;0x&quot; *&gt; many hexByte</span></span>
<span class="lineno">  130 </span>
<span class="lineno">  131 </span>conBLS12_381_G1_Element :: Parser BLS12_381.G1.Element
<span class="lineno">  132 </span><span class="decl"><span class="istickedoff">conBLS12_381_G1_Element = do</span>
<span class="lineno">  133 </span><span class="spaces">    </span><span class="istickedoff">s &lt;- con0xBS</span>
<span class="lineno">  134 </span><span class="spaces">    </span><span class="istickedoff">case BLS12_381.G1.uncompress s of</span>
<span class="lineno">  135 </span><span class="spaces">      </span><span class="istickedoff">Left err -&gt; fail $ <span class="nottickedoff">&quot;Failed to decode value of type bls12_381_G1_element: &quot; ++ show err</span></span>
<span class="lineno">  136 </span><span class="spaces">      </span><span class="istickedoff">Right e  -&gt; pure e</span></span>
<span class="lineno">  137 </span>
<span class="lineno">  138 </span>conBLS12_381_G2_Element :: Parser BLS12_381.G2.Element
<span class="lineno">  139 </span><span class="decl"><span class="istickedoff">conBLS12_381_G2_Element = do</span>
<span class="lineno">  140 </span><span class="spaces">    </span><span class="istickedoff">s &lt;- con0xBS</span>
<span class="lineno">  141 </span><span class="spaces">    </span><span class="istickedoff">case BLS12_381.G2.uncompress s of</span>
<span class="lineno">  142 </span><span class="spaces">      </span><span class="istickedoff">Left err -&gt; fail $ <span class="nottickedoff">&quot;Failed to decode value of type bls12_381_G2_element: &quot; ++ show err</span></span>
<span class="lineno">  143 </span><span class="spaces">      </span><span class="istickedoff">Right e  -&gt; pure e</span></span>
<span class="lineno">  144 </span>
<span class="lineno">  145 </span>-- | Parser for constants of the given type.
<span class="lineno">  146 </span>constantOf :: ExpectParens -&gt; DefaultUni (Esc a) -&gt; Parser a
<span class="lineno">  147 </span><span class="decl"><span class="istickedoff">constantOf expectParens uni =</span>
<span class="lineno">  148 </span><span class="spaces">  </span><span class="istickedoff">case uni of</span>
<span class="lineno">  149 </span><span class="spaces">    </span><span class="istickedoff">DefaultUniInteger                                                 -&gt; conInteger</span>
<span class="lineno">  150 </span><span class="spaces">    </span><span class="istickedoff">DefaultUniByteString                                              -&gt; conBS</span>
<span class="lineno">  151 </span><span class="spaces">    </span><span class="istickedoff">DefaultUniString                                                  -&gt; conText</span>
<span class="lineno">  152 </span><span class="spaces">    </span><span class="istickedoff">DefaultUniUnit                                                    -&gt; conUnit</span>
<span class="lineno">  153 </span><span class="spaces">    </span><span class="istickedoff">DefaultUniBool                                                    -&gt; conBool</span>
<span class="lineno">  154 </span><span class="spaces">    </span><span class="istickedoff">DefaultUniValue                                                   -&gt; conValue</span>
<span class="lineno">  155 </span><span class="spaces">    </span><span class="istickedoff">DefaultUniProtoList `DefaultUniApply` uniA                        -&gt; conList uniA</span>
<span class="lineno">  156 </span><span class="spaces">    </span><span class="istickedoff">DefaultUniProtoArray `DefaultUniApply` uniA                       -&gt; conArray uniA</span>
<span class="lineno">  157 </span><span class="spaces">    </span><span class="istickedoff">DefaultUniProtoPair `DefaultUniApply` uniA `DefaultUniApply` uniB -&gt; conPair uniA uniB</span>
<span class="lineno">  158 </span><span class="spaces">    </span><span class="istickedoff">f `DefaultUniApply` _ `DefaultUniApply` _ `DefaultUniApply` _     -&gt; <span class="nottickedoff">noMoreTypeFunctions f</span></span>
<span class="lineno">  159 </span><span class="spaces">    </span><span class="istickedoff">DefaultUniData                                                    -&gt; conData expectParens</span>
<span class="lineno">  160 </span><span class="spaces">    </span><span class="istickedoff">DefaultUniBLS12_381_G1_Element                                    -&gt; conBLS12_381_G1_Element</span>
<span class="lineno">  161 </span><span class="spaces">    </span><span class="istickedoff">DefaultUniBLS12_381_G2_Element                                    -&gt; conBLS12_381_G2_Element</span>
<span class="lineno">  162 </span><span class="spaces">    </span><span class="istickedoff">DefaultUniBLS12_381_MlResult</span>
<span class="lineno">  163 </span><span class="spaces">        </span><span class="istickedoff">-&gt; <span class="nottickedoff">fail &quot;Constants of type bls12_381_mlresult are not supported&quot;</span></span></span>
<span class="lineno">  164 </span>
<span class="lineno">  165 </span>-- | Parser of constants whose type is in 'DefaultUni'.
<span class="lineno">  166 </span>constant :: Parser (Some (ValueOf DefaultUni))
<span class="lineno">  167 </span><span class="decl"><span class="istickedoff">constant = do</span>
<span class="lineno">  168 </span><span class="spaces">  </span><span class="istickedoff">-- Parse the type tag.</span>
<span class="lineno">  169 </span><span class="spaces">  </span><span class="istickedoff">SomeTypeIn (Kinded uni) &lt;- defaultUni</span>
<span class="lineno">  170 </span><span class="spaces">  </span><span class="istickedoff">-- Check it's of kind @*@, because a constant that we're about to parse can only be of type of</span>
<span class="lineno">  171 </span><span class="spaces">  </span><span class="istickedoff">-- kind @*@.</span>
<span class="lineno">  172 </span><span class="spaces">  </span><span class="istickedoff">Refl &lt;- reoption $ checkStar <span class="nottickedoff">uni</span></span>
<span class="lineno">  173 </span><span class="spaces">  </span><span class="istickedoff">-- Parse the constant of the type represented by the type tag.</span>
<span class="lineno">  174 </span><span class="spaces">  </span><span class="istickedoff">someValueOf uni &lt;$&gt; constantOf ExpectParensYes uni</span></span>
<span class="lineno">  175 </span>
<span class="lineno">  176 </span>data ExpectParens
<span class="lineno">  177 </span>  = ExpectParensYes
<span class="lineno">  178 </span>  | ExpectParensNo

</pre>
</body>
</html>
