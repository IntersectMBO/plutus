<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>-- editorconfig-checker-disable-file
<span class="lineno">    2 </span>{-# LANGUAGE BangPatterns          #-}
<span class="lineno">    3 </span>{-# LANGUAGE DeriveAnyClass        #-}
<span class="lineno">    4 </span>{-# LANGUAGE FlexibleInstances     #-}
<span class="lineno">    5 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">    6 </span>{-# LANGUAGE NumericUnderscores    #-}
<span class="lineno">    7 </span>{-# LANGUAGE TypeFamilies          #-}
<span class="lineno">    8 </span>{-# LANGUAGE TypeOperators         #-}
<span class="lineno">    9 </span>{-# LANGUAGE UndecidableInstances  #-}
<span class="lineno">   10 </span>
<span class="lineno">   11 </span>{-# LANGUAGE StrictData            #-}
<span class="lineno">   12 </span>module PlutusCore.Evaluation.Machine.CostingFun.Core
<span class="lineno">   13 </span>    ( CostingFun(..)
<span class="lineno">   14 </span>    , UnimplementedCostingFun(..)
<span class="lineno">   15 </span>    , Intercept(..)
<span class="lineno">   16 </span>    , Slope(..)
<span class="lineno">   17 </span>    , Coefficient0(..)
<span class="lineno">   18 </span>    , Coefficient1(..)
<span class="lineno">   19 </span>    , Coefficient2(..)
<span class="lineno">   20 </span>    , Coefficient00(..)
<span class="lineno">   21 </span>    , Coefficient10(..)
<span class="lineno">   22 </span>    , Coefficient01(..)
<span class="lineno">   23 </span>    , Coefficient20(..)
<span class="lineno">   24 </span>    , Coefficient11(..)
<span class="lineno">   25 </span>    , Coefficient02(..)
<span class="lineno">   26 </span>    , Coefficient12(..)
<span class="lineno">   27 </span>    , OneVariableLinearFunction(..)
<span class="lineno">   28 </span>    , OneVariableQuadraticFunction(..)
<span class="lineno">   29 </span>    , TwoVariableLinearFunction(..)
<span class="lineno">   30 </span>    , TwoVariableQuadraticFunction(..)
<span class="lineno">   31 </span>    , ExpModCostingFunction(..)
<span class="lineno">   32 </span>    , ModelSubtractedSizes(..)
<span class="lineno">   33 </span>    , ModelConstantOrLinear(..)  -- Deprecated: see below.
<span class="lineno">   34 </span>    , ModelConstantOrOneArgument(..)
<span class="lineno">   35 </span>    , ModelConstantOrTwoArguments(..)
<span class="lineno">   36 </span>    , ModelOneArgument(..)
<span class="lineno">   37 </span>    , ModelTwoArguments(..)
<span class="lineno">   38 </span>    , ModelThreeArguments(..)
<span class="lineno">   39 </span>    , ModelFourArguments(..)
<span class="lineno">   40 </span>    , ModelFiveArguments(..)
<span class="lineno">   41 </span>    , ModelSixArguments(..)
<span class="lineno">   42 </span>    , runCostingFunOneArgument
<span class="lineno">   43 </span>    , runCostingFunTwoArguments
<span class="lineno">   44 </span>    , runCostingFunThreeArguments
<span class="lineno">   45 </span>    , runCostingFunFourArguments
<span class="lineno">   46 </span>    , runCostingFunFiveArguments
<span class="lineno">   47 </span>    , runCostingFunSixArguments
<span class="lineno">   48 </span>    , Hashable
<span class="lineno">   49 </span>    )
<span class="lineno">   50 </span>where
<span class="lineno">   51 </span>
<span class="lineno">   52 </span>import PlutusCore.Evaluation.Machine.CostStream
<span class="lineno">   53 </span>import PlutusCore.Evaluation.Machine.ExBudgetStream
<span class="lineno">   54 </span>import PlutusCore.Evaluation.Machine.ExMemory
<span class="lineno">   55 </span>import PlutusCore.Evaluation.Machine.ExMemoryUsage
<span class="lineno">   56 </span>
<span class="lineno">   57 </span>import Control.DeepSeq
<span class="lineno">   58 </span>import Data.Default.Class
<span class="lineno">   59 </span>import Data.Hashable
<span class="lineno">   60 </span>import Deriving.Aeson
<span class="lineno">   61 </span>import GHC.Exts
<span class="lineno">   62 </span>import Language.Haskell.TH.Syntax hiding (Name, newName)
<span class="lineno">   63 </span>
<span class="lineno">   64 </span>-- | A class used for convenience in this module, don't export it.
<span class="lineno">   65 </span>class OnMemoryUsages c a where
<span class="lineno">   66 </span>    -- | Turn
<span class="lineno">   67 </span>    --
<span class="lineno">   68 </span>    -- &gt; \mem1 ... memN -&gt; f mem1 ... memN
<span class="lineno">   69 </span>    --
<span class="lineno">   70 </span>    -- into
<span class="lineno">   71 </span>    --
<span class="lineno">   72 </span>    -- &gt; \arg1 ... argN -&gt; f (memoryUsage arg1) ... (memoryUsage argN)
<span class="lineno">   73 </span>    --
<span class="lineno">   74 </span>    -- so that we don't need to repeat those 'memoryUsage' calls at every use site, which would also
<span class="lineno">   75 </span>    -- require binding @arg*@ explicitly, i.e. require even more boilerplate.
<span class="lineno">   76 </span>    onMemoryUsages :: c -&gt; a
<span class="lineno">   77 </span>
<span class="lineno">   78 </span>instance (ab ~ (a -&gt; b), ExMemoryUsage a, OnMemoryUsages c b) =&gt;
<span class="lineno">   79 </span>        OnMemoryUsages (CostStream -&gt; c) ab where
<span class="lineno">   80 </span>    -- 'inline' is for making sure that 'memoryUsage' does get inlined.
<span class="lineno">   81 </span>    <span class="decl"><span class="istickedoff">onMemoryUsages f = onMemoryUsages . f . flattenCostRose . inline memoryUsage</span></span>
<span class="lineno">   82 </span>    {-# INLINE onMemoryUsages #-}
<span class="lineno">   83 </span>
<span class="lineno">   84 </span>instance ab ~ ExBudgetStream =&gt; OnMemoryUsages ExBudgetStream ab where
<span class="lineno">   85 </span>    <span class="decl"><span class="istickedoff">onMemoryUsages = id</span></span>
<span class="lineno">   86 </span>    {-# INLINE onMemoryUsages #-}
<span class="lineno">   87 </span>
<span class="lineno">   88 </span>{- | A type of costing functions parametric over a model type.  In practice the we
<span class="lineno">   89 </span>have one model type `Model&lt;N&gt;Arguments` for every N, where N is the arity of the
<span class="lineno">   90 </span>builtin whose costs we want to model.  Each model type has a number of
<span class="lineno">   91 </span>constructors defining different &quot;shapes&quot; of N-parameter functions which
<span class="lineno">   92 </span>calculate a cost given the sizes of the builtin's arguments. -}
<span class="lineno">   93 </span>data CostingFun model = CostingFun
<span class="lineno">   94 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">costingFunCpu</span></span></span>    :: model
<span class="lineno">   95 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">costingFunMemory</span></span></span> :: model
<span class="lineno">   96 </span>    }
<span class="lineno">   97 </span>    deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">   98 </span>    deriving anyclass (<span class="decl"><span class="istickedoff">Default</span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">   99 </span>
<span class="lineno">  100 </span>{- | In the initial stages of implementing a new builtin it is necessary to
<span class="lineno">  101 </span>   provide a temporary costing function which is used until the builtin has been
<span class="lineno">  102 </span>   properly costed: `see CostModelGeneration.md`.  Each `Model&lt;N&gt;Arguments` type
<span class="lineno">  103 </span>   defines an instance of this class where `unimplementedCostingFun` is a
<span class="lineno">  104 </span>   constant costing function which returns a very high cost for all inputs.
<span class="lineno">  105 </span>   This prevents new functions from being used in situations where costs are
<span class="lineno">  106 </span>   important until a sensible costing function has been implemented. -}
<span class="lineno">  107 </span>class UnimplementedCostingFun a where
<span class="lineno">  108 </span>  unimplementedCostingFun :: b -&gt; CostingFun a
<span class="lineno">  109 </span>
<span class="lineno">  110 </span>{- | Make a very expensive pair of CPU and memory costing functions.  The name is
<span class="lineno">  111 </span>   slightly misleading because it actually makes a function which returns such a
<span class="lineno">  112 </span>   pair, which is what is required at the use site in `PlutusCore.Default.Builtins`,
<span class="lineno">  113 </span>   where properly implemented costing functions are constructed from a
<span class="lineno">  114 </span>   BuiltinCostModel object.  We can't use maxBound :: CostingInteger because then the
<span class="lineno">  115 </span>   evaluator always fails; instead we assign a cost of 100,000,000,000, which is well
<span class="lineno">  116 </span>   beyond the current on-chain CPU and memory limits (10,000,000,000 and 14,000,000
<span class="lineno">  117 </span>   respectively) but still allows over 92,000,000 evaluations before the maximum
<span class="lineno">  118 </span>   CostingInteger is reached.  This allows us to use an &quot;uncosted&quot; builtin for
<span class="lineno">  119 </span>   testing and for running costing benchmarks, but will prevent it from being used
<span class="lineno">  120 </span>   when the Plutus Core evaluator is invoked by the ledger.
<span class="lineno">  121 </span>-}
<span class="lineno">  122 </span>makeUnimplementedCostingFun :: (CostingInteger -&gt; model) -&gt; b -&gt; CostingFun model
<span class="lineno">  123 </span><span class="decl"><span class="istickedoff">makeUnimplementedCostingFun c =</span>
<span class="lineno">  124 </span><span class="spaces">  </span><span class="istickedoff">const $ CostingFun (c k) (c k)</span>
<span class="lineno">  125 </span><span class="spaces">  </span><span class="istickedoff">where k = 100_000_000_000</span></span>
<span class="lineno">  126 </span>
<span class="lineno">  127 </span>---------------- Types for use within costing functions ----------------
<span class="lineno">  128 </span>
<span class="lineno">  129 </span>-- | A wrapped 'CostingInteger' that is supposed to be used as an intercept.
<span class="lineno">  130 </span>newtype Intercept = Intercept
<span class="lineno">  131 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unIntercept</span></span></span> :: CostingInteger
<span class="lineno">  132 </span>    } deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  133 </span>      deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  134 </span>
<span class="lineno">  135 </span>-- | A wrapped 'CostingInteger' that is supposed to be used as a slope.
<span class="lineno">  136 </span>newtype Slope = Slope
<span class="lineno">  137 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unSlope</span></span></span> :: CostingInteger
<span class="lineno">  138 </span>    } deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  139 </span>      deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  140 </span>
<span class="lineno">  141 </span>-- | A wrapped 'CostingInteger' that is supposed to be used as the degree 0
<span class="lineno">  142 </span>-- coefficient of a polynomial.
<span class="lineno">  143 </span>newtype Coefficient0 = Coefficient0
<span class="lineno">  144 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unCoefficient0</span></span></span> :: CostingInteger
<span class="lineno">  145 </span>    } deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  146 </span>      deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  147 </span>
<span class="lineno">  148 </span>-- | A wrapped 'CostingInteger' that is supposed to be used as the degree 1
<span class="lineno">  149 </span>-- coefficient of a polynomial.
<span class="lineno">  150 </span>newtype Coefficient1 = Coefficient1
<span class="lineno">  151 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unCoefficient1</span></span></span> :: CostingInteger
<span class="lineno">  152 </span>    } deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  153 </span>      deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  154 </span>
<span class="lineno">  155 </span>-- | A wrapped 'CostingInteger' that is supposed to be used as the degree 2
<span class="lineno">  156 </span>-- coefficient of a polynomial.
<span class="lineno">  157 </span>newtype Coefficient2 = Coefficient2
<span class="lineno">  158 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unCoefficient2</span></span></span> :: CostingInteger
<span class="lineno">  159 </span>    } deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  160 </span>      deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  161 </span>
<span class="lineno">  162 </span>-- | A wrapped 'CostingInteger' that is supposed to be used as the degree (0,0)
<span class="lineno">  163 </span>-- coefficient of a two-variable polynomial.
<span class="lineno">  164 </span>newtype Coefficient00 = Coefficient00
<span class="lineno">  165 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unCoefficient00</span></span></span> :: CostingInteger
<span class="lineno">  166 </span>    } deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  167 </span>      deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  168 </span>
<span class="lineno">  169 </span>-- | A wrapped 'CostingInteger' that is supposed to be used as the degree (1,0)
<span class="lineno">  170 </span>-- coefficient of a two-variable polynomial.
<span class="lineno">  171 </span>newtype Coefficient10 = Coefficient10
<span class="lineno">  172 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unCoefficient10</span></span></span> :: CostingInteger
<span class="lineno">  173 </span>    } deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  174 </span>      deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  175 </span>
<span class="lineno">  176 </span>-- | A wrapped 'CostingInteger' that is supposed to be used as the degree (0,1)
<span class="lineno">  177 </span>-- coefficient of a two-variable polynomial.
<span class="lineno">  178 </span>newtype Coefficient01 = Coefficient01
<span class="lineno">  179 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unCoefficient01</span></span></span> :: CostingInteger
<span class="lineno">  180 </span>    } deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  181 </span>      deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  182 </span>
<span class="lineno">  183 </span>-- | A wrapped 'CostingInteger' that is supposed to be used as the degree (2,0)
<span class="lineno">  184 </span>-- coefficient of a two-variable polynomial.
<span class="lineno">  185 </span>newtype Coefficient20 = Coefficient20
<span class="lineno">  186 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unCoefficient20</span></span></span> :: CostingInteger
<span class="lineno">  187 </span>    } deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  188 </span>      deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  189 </span>
<span class="lineno">  190 </span>-- | A wrapped 'CostingInteger' that is supposed to be used as the degree (1,1)
<span class="lineno">  191 </span>-- coefficient of a two-variable polynomial.
<span class="lineno">  192 </span>newtype Coefficient11 = Coefficient11
<span class="lineno">  193 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unCoefficient11</span></span></span> :: CostingInteger
<span class="lineno">  194 </span>    } deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  195 </span>      deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  196 </span>
<span class="lineno">  197 </span>-- | A wrapped 'CostingInteger' that is supposed to be used as the degree (0,2)
<span class="lineno">  198 </span>-- coefficient of a two-variable polynomial.
<span class="lineno">  199 </span>newtype Coefficient02 = Coefficient02
<span class="lineno">  200 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unCoefficient02</span></span></span> :: CostingInteger
<span class="lineno">  201 </span>    } deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  202 </span>      deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  203 </span>
<span class="lineno">  204 </span>-- | A wrapped 'CostingInteger' that is supposed to be used as the degree (1,2)
<span class="lineno">  205 </span>-- coefficient of a two-variable polynomial.
<span class="lineno">  206 </span>newtype Coefficient12 = Coefficient12
<span class="lineno">  207 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unCoefficient12</span></span></span> :: CostingInteger
<span class="lineno">  208 </span>    } deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  209 </span>      deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  210 </span>
<span class="lineno">  211 </span>---------------- One-argument costing functions ----------------
<span class="lineno">  212 </span>
<span class="lineno">  213 </span>data ModelOneArgument =
<span class="lineno">  214 </span>    ModelOneArgumentConstantCost CostingInteger
<span class="lineno">  215 </span>    | ModelOneArgumentLinearInX OneVariableLinearFunction
<span class="lineno">  216 </span>    deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  217 </span>    deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  218 </span>
<span class="lineno">  219 </span>instance Default ModelOneArgument where
<span class="lineno">  220 </span>    <span class="decl"><span class="istickedoff">def = ModelOneArgumentConstantCost maxBound</span></span>
<span class="lineno">  221 </span>
<span class="lineno">  222 </span>instance UnimplementedCostingFun ModelOneArgument where
<span class="lineno">  223 </span>  <span class="decl"><span class="istickedoff">unimplementedCostingFun = makeUnimplementedCostingFun ModelOneArgumentConstantCost</span></span>
<span class="lineno">  224 </span>
<span class="lineno">  225 </span>{- Note [runCostingFun* API]
<span class="lineno">  226 </span>Costing functions take unlifted values, compute the 'ExMemory' of each of them and then invoke
<span class="lineno">  227 </span>the corresponding @run*Model@ over the computed 'ExMemory's. The reason why we don't just make the
<span class="lineno">  228 </span>costing functions take 'ExMemory's in the first place is that this would move the burden of
<span class="lineno">  229 </span>computing the 'ExMemory's onto the caller, i.e. the user defining the meaning of a builtin and it
<span class="lineno">  230 </span>would be just another hoop to jump through and a completely unnecessary complication for the user.
<span class="lineno">  231 </span>
<span class="lineno">  232 </span>The reason why costing functions take unlifted values are:
<span class="lineno">  233 </span>
<span class="lineno">  234 </span>1. we need to unlift them anyway to compute the result of a builtin application, so since we already
<span class="lineno">  235 </span>   need them elsewhere, we can utilize them in the costing machinery too. Otherwise the costing
<span class="lineno">  236 </span>   machinery would need to do some unlifting itself, which would be wasteful
<span class="lineno">  237 </span>2. the costing function might actually depend on the constants that get fed to the builtin.
<span class="lineno">  238 </span>   For example, checking equality of integers stored in a 'Data' object potentially has a different
<span class="lineno">  239 </span>   complexity to checking equality of lists of bytestrings
<span class="lineno">  240 </span>-}
<span class="lineno">  241 </span>
<span class="lineno">  242 </span>{- Note [Optimizations of runCostingFun*]
<span class="lineno">  243 </span>We optimize all @runCostingFun*@ functions in the same way:
<span class="lineno">  244 </span>
<span class="lineno">  245 </span>1. the two calls to @run*Model@ are placed right after matching on the first argument, so that
<span class="lineno">  246 </span>   they are partially computed and cached, which results in them being called only once per builtin
<span class="lineno">  247 </span>2. we use a strict case-expression for matching, which GHC can't move inside the resulting lambda
<span class="lineno">  248 </span>   (unlike a strict let-expression for example)
<span class="lineno">  249 </span>3. the whole definition is marked with @INLINE@, because it gets worker-wrapper transformed and we
<span class="lineno">  250 </span>   don't want to keep the worker separate from the wrapper as it just results in unnecessary
<span class="lineno">  251 </span>   wrapping-unwrapping
<span class="lineno">  252 </span>
<span class="lineno">  253 </span>In order for @run*Model@ functions to be able to partially compute we need to define them
<span class="lineno">  254 </span>accordingly, i.e. by matching on the first argument and returning a lambda. We wrap one of the
<span class="lineno">  255 </span>clauses with a call to 'lazy', so that GHC does not &quot;optimize&quot; the function by moving matching to
<span class="lineno">  256 </span>the inside of the resulting lambda (which would defeat the whole purpose of caching the function).
<span class="lineno">  257 </span>It's enough to put 'lazy' in only one of the clauses for all of them to be compiled the right way,
<span class="lineno">  258 </span>however adding 'lazy' to all the other clauses too turned out to improve performance by a couple of
<span class="lineno">  259 </span>percent, reasons are unclear.
<span class="lineno">  260 </span>
<span class="lineno">  261 </span>Alternatively, we could use @-fpedantic-bottoms@, which prevents GHC from moving matching above
<span class="lineno">  262 </span>a lambda (see https://github.com/IntersectMBO/plutus/pull/4621), however it doesn't make anything
<span class="lineno">  263 </span>faster, generates more Core and doesn't take much to break, hence we choose the hacky 'lazy'
<span class="lineno">  264 </span>version.
<span class="lineno">  265 </span>
<span class="lineno">  266 </span>Since we want @run*Model@ functions to partially compute, we mark them as @OPAQUE@ to prevent GHC
<span class="lineno">  267 </span>from inlining them and breaking the sharing friendliness. Without the @OPAQUE@ Core doesn't seem
<span class="lineno">  268 </span>to be worse, however it was verified that no @OPAQUE@ causes a slowdown in both the @validation@
<span class="lineno">  269 </span>and @nofib@ benchmarks.
<span class="lineno">  270 </span>
<span class="lineno">  271 </span>Note that looking at the generated Core isn't really enough. We might have enemies down the pipeline,
<span class="lineno">  272 </span>for example @-fstg-lift-lams@ looks suspicious:
<span class="lineno">  273 </span>
<span class="lineno">  274 </span>&gt; Enables the late lambda lifting optimisation on the STG intermediate language. This selectively
<span class="lineno">  275 </span>&gt; lifts local functions to top-level by converting free variables into function parameters.
<span class="lineno">  276 </span>
<span class="lineno">  277 </span>This wasn't investigated.
<span class="lineno">  278 </span>
<span class="lineno">  279 </span>These optimizations gave us a ~3.2% speedup at the time this Note was written.
<span class="lineno">  280 </span>-}
<span class="lineno">  281 </span>
<span class="lineno">  282 </span>-- See Note [runCostingFun* API].
<span class="lineno">  283 </span>runCostingFunOneArgument
<span class="lineno">  284 </span>    :: ExMemoryUsage a1
<span class="lineno">  285 </span>    =&gt; CostingFun ModelOneArgument
<span class="lineno">  286 </span>    -&gt; a1
<span class="lineno">  287 </span>    -&gt; ExBudgetStream
<span class="lineno">  288 </span><span class="decl"><span class="istickedoff">runCostingFunOneArgument (CostingFun cpu mem) =</span>
<span class="lineno">  289 </span><span class="spaces">    </span><span class="istickedoff">case (runOneArgumentModel cpu, runOneArgumentModel mem) of</span>
<span class="lineno">  290 </span><span class="spaces">        </span><span class="istickedoff">(!runCpu, !runMem) -&gt; onMemoryUsages $ \mem1 -&gt;</span>
<span class="lineno">  291 </span><span class="spaces">            </span><span class="istickedoff">zipCostStream</span>
<span class="lineno">  292 </span><span class="spaces">                </span><span class="istickedoff">(runCpu mem1)</span>
<span class="lineno">  293 </span><span class="spaces">                </span><span class="istickedoff">(runMem mem1)</span></span>
<span class="lineno">  294 </span>{-# INLINE runCostingFunOneArgument #-}
<span class="lineno">  295 </span>
<span class="lineno">  296 </span>-- | Take an intercept, a slope and a stream and scale each element of the stream by the slope and
<span class="lineno">  297 </span>-- cons the intercept to the stream afterwards.
<span class="lineno">  298 </span>scaleLinearly :: Intercept -&gt; Slope -&gt; CostStream -&gt; CostStream
<span class="lineno">  299 </span><span class="decl"><span class="istickedoff">scaleLinearly (Intercept intercept) (Slope slope) =</span>
<span class="lineno">  300 </span><span class="spaces">    </span><span class="istickedoff">addCostStream (CostLast intercept) . mapCostStream (slope *)</span></span>
<span class="lineno">  301 </span>{-# INLINE scaleLinearly #-}
<span class="lineno">  302 </span>
<span class="lineno">  303 </span>runOneArgumentModel
<span class="lineno">  304 </span>    :: ModelOneArgument
<span class="lineno">  305 </span>    -&gt; CostStream
<span class="lineno">  306 </span>    -&gt; CostStream
<span class="lineno">  307 </span><span class="decl"><span class="istickedoff">runOneArgumentModel (ModelOneArgumentConstantCost c) =</span>
<span class="lineno">  308 </span><span class="spaces">    </span><span class="istickedoff">lazy $ \_ -&gt; CostLast c</span>
<span class="lineno">  309 </span><span class="spaces"></span><span class="istickedoff">runOneArgumentModel (ModelOneArgumentLinearInX (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  310 </span><span class="spaces">    </span><span class="istickedoff">lazy $ \costs1 -&gt; scaleLinearly intercept slope costs1</span></span>
<span class="lineno">  311 </span>{-# OPAQUE runOneArgumentModel #-}
<span class="lineno">  312 </span>
<span class="lineno">  313 </span>---------------- Two-argument costing functions ----------------
<span class="lineno">  314 </span>
<span class="lineno">  315 </span>{- Because of the way the costing code has evolved the names of the model types
<span class="lineno">  316 </span>below aren't very consistent.  However it's a little difficult to change them
<span class="lineno">  317 </span>because that would change some of the JSON tags in the cost model file.  The
<span class="lineno">  318 </span>basic models are one-variable and two-variable linear models and their names
<span class="lineno">  319 </span>(`OneVariableLinearFunction` and `TwoVariableLinearFunction`) reflect this .
<span class="lineno">  320 </span>Other models have names like `ModelAddedSizes` and it might be more logical if
<span class="lineno">  321 </span>they were called things like `LinearInXPlusY` and so on since these are really
<span class="lineno">  322 </span>abstract functions that don't know anything about sizes.  Also many of the types
<span class="lineno">  323 </span>have their own intercept and slope values because they are linear on some
<span class="lineno">  324 </span>function of the inputs or are linear in some region of the plane.  Maybe these
<span class="lineno">  325 </span>should contain nested objects of type ModelLinearInOneVariable instead, but that
<span class="lineno">  326 </span>would complicate the JSON encoding and might also impact efficiency.
<span class="lineno">  327 </span>-}
<span class="lineno">  328 </span>
<span class="lineno">  329 </span>-- | s * x + I
<span class="lineno">  330 </span>data OneVariableLinearFunction = OneVariableLinearFunction
<span class="lineno">  331 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">oneVariableLinearFunctionIntercept</span></span></span> :: Intercept
<span class="lineno">  332 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">oneVariableLinearFunctionSlope</span></span></span>     :: Slope
<span class="lineno">  333 </span>    } deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  334 </span>    deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  335 </span>
<span class="lineno">  336 </span>-- | s1 * x + s2 * y + I
<span class="lineno">  337 </span>data TwoVariableLinearFunction = TwoVariableLinearFunction
<span class="lineno">  338 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableLinearFunctionIntercept</span></span></span> :: Intercept
<span class="lineno">  339 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableLinearFunctionSlope1</span></span></span>    :: Slope
<span class="lineno">  340 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableLinearFunctionSlope2</span></span></span>    :: Slope
<span class="lineno">  341 </span>    } deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  342 </span>    deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  343 </span>
<span class="lineno">  344 </span>-- | c0 + c1*x + c2*x^2
<span class="lineno">  345 </span>data OneVariableQuadraticFunction = OneVariableQuadraticFunction
<span class="lineno">  346 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">oneVariableQuadraticFunctionC0</span></span></span> :: Coefficient0
<span class="lineno">  347 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">oneVariableQuadraticFunctionC1</span></span></span> :: Coefficient1
<span class="lineno">  348 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">oneVariableQuadraticFunctionC2</span></span></span> :: Coefficient2
<span class="lineno">  349 </span>    } deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  350 </span>    deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  351 </span>
<span class="lineno">  352 </span>evaluateOneVariableQuadraticFunction
<span class="lineno">  353 </span>  :: OneVariableQuadraticFunction
<span class="lineno">  354 </span>  -&gt; CostingInteger
<span class="lineno">  355 </span>  -&gt; CostingInteger
<span class="lineno">  356 </span><span class="decl"><span class="istickedoff">evaluateOneVariableQuadraticFunction</span>
<span class="lineno">  357 </span><span class="spaces">   </span><span class="istickedoff">(OneVariableQuadraticFunction (Coefficient0 c0) (Coefficient1 c1)  (Coefficient2 c2)) x =</span>
<span class="lineno">  358 </span><span class="spaces">       </span><span class="istickedoff">c0 + c1*x + c2*x*x</span></span>
<span class="lineno">  359 </span>{-# INLINE evaluateOneVariableQuadraticFunction #-}
<span class="lineno">  360 </span>
<span class="lineno">  361 </span>{- Note [Minimum values for two-variable quadratic costing functions] Unlike most
<span class="lineno">  362 </span>   of our other costing functions our use cases for two-variable quadratic
<span class="lineno">  363 </span>   costing functions may require one or more negative coefficients, so there's a
<span class="lineno">  364 </span>   danger that we could return a negative cost.  This is unlikely, but we make
<span class="lineno">  365 </span>   certain that it never happens by returning a result that is at never smaller
<span class="lineno">  366 </span>   than a minimum value that is stored along with the coefficients of the
<span class="lineno">  367 </span>   function.
<span class="lineno">  368 </span>-}
<span class="lineno">  369 </span>-- | c00 + c10*x + c01*y + c20*x^2 + c11*c*y + c02*y^2
<span class="lineno">  370 </span>data TwoVariableQuadraticFunction = TwoVariableQuadraticFunction
<span class="lineno">  371 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableQuadraticFunctionMinimum</span></span></span> :: CostingInteger
<span class="lineno">  372 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableQuadraticFunctionC00</span></span></span>     :: Coefficient00
<span class="lineno">  373 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableQuadraticFunctionC10</span></span></span>     :: Coefficient10
<span class="lineno">  374 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableQuadraticFunctionC01</span></span></span>     :: Coefficient01
<span class="lineno">  375 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableQuadraticFunctionC20</span></span></span>     :: Coefficient20
<span class="lineno">  376 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableQuadraticFunctionC11</span></span></span>     :: Coefficient11
<span class="lineno">  377 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableQuadraticFunctionC02</span></span></span>     :: Coefficient02
<span class="lineno">  378 </span>  } deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  379 </span>    deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  380 </span>
<span class="lineno">  381 </span>evaluateTwoVariableQuadraticFunction
<span class="lineno">  382 </span>  :: TwoVariableQuadraticFunction
<span class="lineno">  383 </span>  -&gt; CostingInteger
<span class="lineno">  384 </span>  -&gt; CostingInteger
<span class="lineno">  385 </span>  -&gt; CostingInteger
<span class="lineno">  386 </span><span class="decl"><span class="istickedoff">evaluateTwoVariableQuadraticFunction</span>
<span class="lineno">  387 </span><span class="spaces">   </span><span class="istickedoff">(TwoVariableQuadraticFunction minVal</span>
<span class="lineno">  388 </span><span class="spaces">    </span><span class="istickedoff">(Coefficient00 c00) (Coefficient10 c10)  (Coefficient01 c01)</span>
<span class="lineno">  389 </span><span class="spaces">    </span><span class="istickedoff">(Coefficient20 c20) (Coefficient11 c11) (Coefficient02 c02)</span>
<span class="lineno">  390 </span><span class="spaces">   </span><span class="istickedoff">) x y = max minVal (c00 + c10*x + c01*y + c20*x*x + c11*x*y + c02*y*y)</span></span>
<span class="lineno">  391 </span>  -- We want to be absolutely sure that we don't get back a negative number
<span class="lineno">  392 </span>  -- here: see Note [Minimum values for two-variable quadratic costing functions]
<span class="lineno">  393 </span>{-# INLINE evaluateTwoVariableQuadraticFunction #-}
<span class="lineno">  394 </span>
<span class="lineno">  395 </span>-- | c00 + c01x*y + c12x*y^2
<span class="lineno">  396 </span>-- This is used only for `expModInteger`, whose costing is quite complex.
<span class="lineno">  397 </span>data ExpModCostingFunction = ExpModCostingFunction
<span class="lineno">  398 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">coefficient00</span></span></span> :: Coefficient00
<span class="lineno">  399 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">coefficient11</span></span></span> :: Coefficient11
<span class="lineno">  400 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">coefficient12</span></span></span> :: Coefficient12
<span class="lineno">  401 </span>  } deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  402 </span>  deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  403 </span>
<span class="lineno">  404 </span>{- | Calculate the cost of calling `expModInteger a e m` where a is of size aa, e
<span class="lineno">  405 </span>is of size ee, and m is of size mm.  If aa&gt;mm then the cost is increased by
<span class="lineno">  406 </span>50% to impose a penalty for the extra cost of initially reducing `a` modulo `m`.
<span class="lineno">  407 </span>If large values of `a` really are required then the penalty can be avoided by
<span class="lineno">  408 </span>calling `modInteger` before `expModInteger`.
<span class="lineno">  409 </span>-}
<span class="lineno">  410 </span>evaluateExpModCostingFunction
<span class="lineno">  411 </span>  :: ExpModCostingFunction
<span class="lineno">  412 </span>  -&gt; CostingInteger
<span class="lineno">  413 </span>  -&gt; CostingInteger
<span class="lineno">  414 </span>  -&gt; CostingInteger
<span class="lineno">  415 </span>  -&gt; CostingInteger
<span class="lineno">  416 </span><span class="decl"><span class="istickedoff">evaluateExpModCostingFunction</span>
<span class="lineno">  417 </span><span class="spaces">   </span><span class="istickedoff">(ExpModCostingFunction</span>
<span class="lineno">  418 </span><span class="spaces">    </span><span class="istickedoff">(Coefficient00 c00) (Coefficient11 c11) (Coefficient12 c12))</span>
<span class="lineno">  419 </span><span class="spaces">  </span><span class="istickedoff">aa ee mm = if aa &lt;= mm</span>
<span class="lineno">  420 </span><span class="spaces">             </span><span class="istickedoff">then cost0</span>
<span class="lineno">  421 </span><span class="spaces">             </span><span class="istickedoff">else cost0 + (cost0 `dividedBy` 2)</span>
<span class="lineno">  422 </span><span class="spaces">  </span><span class="istickedoff">where cost0 = c00 + c11*ee*mm + c12*ee*mm*mm</span></span>
<span class="lineno">  423 </span>{-# INLINE evaluateExpModCostingFunction #-}
<span class="lineno">  424 </span>
<span class="lineno">  425 </span>-- | s * (x - y) + I
<span class="lineno">  426 </span>{- In principle we could use ModelConstantOrOneArgument here, but that would
<span class="lineno">  427 </span>change the order of the cost model parameters since the minimum value would come
<span class="lineno">  428 </span>first instead of last, so for the time being we use a special type. We may be
<span class="lineno">  429 </span>able to change this later if we move to a self-describing cost model format
<span class="lineno">  430 </span>where the cost model parameters include the type of the costing function. See
<span class="lineno">  431 </span>Note [Backward compatibility for costing functions]. -}
<span class="lineno">  432 </span>data ModelSubtractedSizes = ModelSubtractedSizes
<span class="lineno">  433 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">modelSubtractedSizesIntercept</span></span></span> :: Intercept
<span class="lineno">  434 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">modelSubtractedSizesSlope</span></span></span>     :: Slope
<span class="lineno">  435 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">modelSubtractedSizesMinimum</span></span></span>   :: CostingInteger
<span class="lineno">  436 </span>    } deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  437 </span>    deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  438 </span>
<span class="lineno">  439 </span>-- | if p then s*x else c; p depends on usage
<span class="lineno">  440 </span>{- NB: this is subsumed by ModelConstantOrOneArgument, but we have to keep it
<span class="lineno">  441 </span>-- for the time being.  See Note [Backward compatibility for costing functions]. -}
<span class="lineno">  442 </span>data ModelConstantOrLinear = ModelConstantOrLinear
<span class="lineno">  443 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">modelConstantOrLinearConstant</span></span></span>  :: CostingInteger
<span class="lineno">  444 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">modelConstantOrLinearIntercept</span></span></span> :: Intercept
<span class="lineno">  445 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">modelConstantOrLinearSlope</span></span></span>     :: Slope
<span class="lineno">  446 </span>    } deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  447 </span>    deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  448 </span>
<span class="lineno">  449 </span>-- | if p then f(x) else c; p depends on usage
<span class="lineno">  450 </span>data ModelConstantOrOneArgument = ModelConstantOrOneArgument
<span class="lineno">  451 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">modelConstantOrOneArgumentConstant</span></span></span> :: CostingInteger
<span class="lineno">  452 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">modelConstantOrOneArgumentModel</span></span></span>    :: ModelOneArgument
<span class="lineno">  453 </span>    } deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  454 </span>    deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  455 </span>
<span class="lineno">  456 </span>-- | if p then f(x,y) else c; p depends on usage
<span class="lineno">  457 </span>data ModelConstantOrTwoArguments = ModelConstantOrTwoArguments
<span class="lineno">  458 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">modelConstantOrTwoArgumentsConstant</span></span></span> :: CostingInteger
<span class="lineno">  459 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">modelConstantOrTwoArgumentsModel</span></span></span>    :: ModelTwoArguments
<span class="lineno">  460 </span>    } deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  461 </span>    deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  462 </span>
<span class="lineno">  463 </span>{- Note [Backward compatibility for costing functions].  The PR at
<span class="lineno">  464 </span>   https://github.com/IntersectMBO/plutus/pull/5857 generalised the costing
<span class="lineno">  465 </span>   function types and made them more composable: in particular,
<span class="lineno">  466 </span>   ModelTwoArgumentsLinearOnDiagonal was replaced by
<span class="lineno">  467 </span>   ModelTwoArgumentsConstOffDiagonal and ModelConstantOrLinear was removed.
<span class="lineno">  468 </span>   However, this changes some of the tags (specifically, for `equalsByteString`
<span class="lineno">  469 </span>   and `equalsString`) in builtinCostModel.json, and these are used in the
<span class="lineno">  470 </span>   Alonzo genesis file and so shouldn't be changed.  For the time being we've
<span class="lineno">  471 </span>   restored the ModelTwoArgumentsLinearOnDiagonal constructor so that we can
<span class="lineno">  472 </span>   still deal with the old tags.  New builtins should use
<span class="lineno">  473 </span>   ModelTwoArgumentsConstOffDiagonal instead.  A better long-term solution might
<span class="lineno">  474 </span>   be to adapt the JSON conversion code to translate linear_on_diagonal objects
<span class="lineno">  475 </span>   to ConstOffDiagonal objects (and perhaps back, although configurable cost
<span class="lineno">  476 </span>   models may mean that we don't need to do that).
<span class="lineno">  477 </span>-}
<span class="lineno">  478 </span>
<span class="lineno">  479 </span>data ModelTwoArguments =
<span class="lineno">  480 </span>    ModelTwoArgumentsConstantCost        CostingInteger
<span class="lineno">  481 </span>  | ModelTwoArgumentsLinearInX           OneVariableLinearFunction
<span class="lineno">  482 </span>  | ModelTwoArgumentsLinearInY           OneVariableLinearFunction
<span class="lineno">  483 </span>  | ModelTwoArgumentsLinearInXAndY       TwoVariableLinearFunction
<span class="lineno">  484 </span>  | ModelTwoArgumentsAddedSizes          OneVariableLinearFunction
<span class="lineno">  485 </span>  | ModelTwoArgumentsSubtractedSizes     ModelSubtractedSizes
<span class="lineno">  486 </span>  | ModelTwoArgumentsMultipliedSizes     OneVariableLinearFunction
<span class="lineno">  487 </span>  | ModelTwoArgumentsMinSize             OneVariableLinearFunction
<span class="lineno">  488 </span>  | ModelTwoArgumentsMaxSize             OneVariableLinearFunction
<span class="lineno">  489 </span>  | ModelTwoArgumentsLinearOnDiagonal    ModelConstantOrLinear
<span class="lineno">  490 </span>  | ModelTwoArgumentsConstOffDiagonal    ModelConstantOrOneArgument
<span class="lineno">  491 </span>  | ModelTwoArgumentsConstAboveDiagonal  ModelConstantOrTwoArguments
<span class="lineno">  492 </span>  | ModelTwoArgumentsConstBelowDiagonal  ModelConstantOrTwoArguments
<span class="lineno">  493 </span>  | ModelTwoArgumentsQuadraticInY        OneVariableQuadraticFunction
<span class="lineno">  494 </span>  | ModelTwoArgumentsQuadraticInXAndY    TwoVariableQuadraticFunction
<span class="lineno">  495 </span>    deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  496 </span>    deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  497 </span>
<span class="lineno">  498 </span>instance Default ModelTwoArguments where
<span class="lineno">  499 </span>    <span class="decl"><span class="istickedoff">def = ModelTwoArgumentsConstantCost maxBound</span></span>
<span class="lineno">  500 </span>
<span class="lineno">  501 </span>instance UnimplementedCostingFun ModelTwoArguments where
<span class="lineno">  502 </span>  <span class="decl"><span class="istickedoff">unimplementedCostingFun = makeUnimplementedCostingFun ModelTwoArgumentsConstantCost</span></span>
<span class="lineno">  503 </span>
<span class="lineno">  504 </span>-- See Note [runCostingFun* API].
<span class="lineno">  505 </span>runCostingFunTwoArguments
<span class="lineno">  506 </span>    :: ( ExMemoryUsage a1
<span class="lineno">  507 </span>       , ExMemoryUsage a2
<span class="lineno">  508 </span>       )
<span class="lineno">  509 </span>    =&gt; CostingFun ModelTwoArguments
<span class="lineno">  510 </span>    -&gt; a1
<span class="lineno">  511 </span>    -&gt; a2
<span class="lineno">  512 </span>    -&gt; ExBudgetStream
<span class="lineno">  513 </span><span class="decl"><span class="istickedoff">runCostingFunTwoArguments (CostingFun cpu mem) =</span>
<span class="lineno">  514 </span><span class="spaces">    </span><span class="istickedoff">case (runTwoArgumentModel cpu, runTwoArgumentModel mem) of</span>
<span class="lineno">  515 </span><span class="spaces">        </span><span class="istickedoff">(!runCpu, !runMem) -&gt; onMemoryUsages $ \mem1 mem2 -&gt;</span>
<span class="lineno">  516 </span><span class="spaces">            </span><span class="istickedoff">zipCostStream</span>
<span class="lineno">  517 </span><span class="spaces">                </span><span class="istickedoff">(runCpu mem1 mem2)</span>
<span class="lineno">  518 </span><span class="spaces">                </span><span class="istickedoff">(runMem mem1 mem2)</span></span>
<span class="lineno">  519 </span>{-# INLINE runCostingFunTwoArguments #-}
<span class="lineno">  520 </span>
<span class="lineno">  521 </span>-- | Take an intercept, two slopes and two streams, and scale each element of
<span class="lineno">  522 </span>-- the first stream by the first slope, each element of the second stream by the
<span class="lineno">  523 </span>-- second slope, add the two scaled streams together, and cons the intercept to
<span class="lineno">  524 </span>-- the stream afterwards.
<span class="lineno">  525 </span>scaleLinearlyTwoVariables :: Intercept -&gt; Slope -&gt; CostStream -&gt; Slope -&gt; CostStream -&gt; CostStream
<span class="lineno">  526 </span><span class="decl"><span class="istickedoff">scaleLinearlyTwoVariables (Intercept intercept) (Slope slope1) stream1 (Slope slope2) stream2 =</span>
<span class="lineno">  527 </span><span class="spaces">    </span><span class="istickedoff">addCostStream</span>
<span class="lineno">  528 </span><span class="spaces">    </span><span class="istickedoff">(CostLast intercept)</span>
<span class="lineno">  529 </span><span class="spaces">    </span><span class="istickedoff">(addCostStream</span>
<span class="lineno">  530 </span><span class="spaces">     </span><span class="istickedoff">(mapCostStream (slope1 *) stream1)</span>
<span class="lineno">  531 </span><span class="spaces">     </span><span class="istickedoff">(mapCostStream (slope2 *) stream2)</span>
<span class="lineno">  532 </span><span class="spaces">    </span><span class="istickedoff">)</span></span>
<span class="lineno">  533 </span>{-# INLINE scaleLinearlyTwoVariables #-}
<span class="lineno">  534 </span>
<span class="lineno">  535 </span>runTwoArgumentModel
<span class="lineno">  536 </span>    :: ModelTwoArguments
<span class="lineno">  537 </span>    -&gt; CostStream
<span class="lineno">  538 </span>    -&gt; CostStream
<span class="lineno">  539 </span>    -&gt; CostStream
<span class="lineno">  540 </span><span class="decl"><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  541 </span><span class="spaces">    </span><span class="istickedoff">(ModelTwoArgumentsConstantCost c) = lazy $ \_ _ -&gt; CostLast c</span>
<span class="lineno">  542 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  543 </span><span class="spaces">    </span><span class="istickedoff">(ModelTwoArgumentsAddedSizes (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  544 </span><span class="spaces">        </span><span class="istickedoff">lazy $ \costs1 costs2 -&gt;</span>
<span class="lineno">  545 </span><span class="spaces">            </span><span class="istickedoff">scaleLinearly intercept slope $ addCostStream costs1 costs2</span>
<span class="lineno">  546 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  547 </span><span class="spaces">    </span><span class="istickedoff">(ModelTwoArgumentsSubtractedSizes (ModelSubtractedSizes intercept slope minSize)) =</span>
<span class="lineno">  548 </span><span class="spaces">        </span><span class="istickedoff">lazy $ \costs1 costs2 -&gt; do</span>
<span class="lineno">  549 </span><span class="spaces">            </span><span class="istickedoff">let !size1 = sumCostStream costs1</span>
<span class="lineno">  550 </span><span class="spaces">                </span><span class="istickedoff">!size2 = sumCostStream costs2</span>
<span class="lineno">  551 </span><span class="spaces">            </span><span class="istickedoff">scaleLinearly intercept slope $ CostLast (max minSize $ size1 - size2)</span>
<span class="lineno">  552 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  553 </span><span class="spaces">    </span><span class="istickedoff">(ModelTwoArgumentsMultipliedSizes (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  554 </span><span class="spaces">        </span><span class="istickedoff">lazy $ \costs1 costs2 -&gt; do</span>
<span class="lineno">  555 </span><span class="spaces">            </span><span class="istickedoff">let !size1 = sumCostStream costs1</span>
<span class="lineno">  556 </span><span class="spaces">                </span><span class="istickedoff">!size2 = sumCostStream costs2</span>
<span class="lineno">  557 </span><span class="spaces">            </span><span class="istickedoff">scaleLinearly intercept slope $ CostLast (size1 * size2)</span>
<span class="lineno">  558 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  559 </span><span class="spaces">    </span><span class="istickedoff">(ModelTwoArgumentsMinSize (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  560 </span><span class="spaces">        </span><span class="istickedoff">lazy $ \costs1 costs2 -&gt; do</span>
<span class="lineno">  561 </span><span class="spaces">            </span><span class="istickedoff">scaleLinearly intercept slope $ minCostStream costs1 costs2</span>
<span class="lineno">  562 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  563 </span><span class="spaces">    </span><span class="istickedoff">(ModelTwoArgumentsMaxSize (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  564 </span><span class="spaces">        </span><span class="istickedoff">lazy $ \costs1 costs2 -&gt; do</span>
<span class="lineno">  565 </span><span class="spaces">            </span><span class="istickedoff">let !size1 = sumCostStream costs1</span>
<span class="lineno">  566 </span><span class="spaces">                </span><span class="istickedoff">!size2 = sumCostStream costs2</span>
<span class="lineno">  567 </span><span class="spaces">            </span><span class="istickedoff">scaleLinearly intercept slope $ CostLast (max size1 size2)</span>
<span class="lineno">  568 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  569 </span><span class="spaces">    </span><span class="istickedoff">(ModelTwoArgumentsLinearInX (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  570 </span><span class="spaces">        </span><span class="istickedoff">lazy $ \costs1 _ -&gt;</span>
<span class="lineno">  571 </span><span class="spaces">            </span><span class="istickedoff">scaleLinearly intercept slope costs1</span>
<span class="lineno">  572 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  573 </span><span class="spaces">    </span><span class="istickedoff">(ModelTwoArgumentsLinearInY (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  574 </span><span class="spaces">        </span><span class="istickedoff">lazy $ \_ costs2 -&gt;</span>
<span class="lineno">  575 </span><span class="spaces">            </span><span class="istickedoff">scaleLinearly intercept slope costs2</span>
<span class="lineno">  576 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  577 </span><span class="spaces">    </span><span class="istickedoff">(ModelTwoArgumentsLinearInXAndY (TwoVariableLinearFunction intercept slope1 slope2)) =</span>
<span class="lineno">  578 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">lazy $ \costs1 costs2 -&gt;</span></span>
<span class="lineno">  579 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">scaleLinearlyTwoVariables intercept slope1 costs1 slope2 costs2</span></span>
<span class="lineno">  580 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  581 </span><span class="spaces">    </span><span class="istickedoff">-- See Note [Backward compatibility for costing functions]</span>
<span class="lineno">  582 </span><span class="spaces">    </span><span class="istickedoff">-- Off the diagonal, return the constant.  On the diagonal, run the one-variable linear model.</span>
<span class="lineno">  583 </span><span class="spaces">    </span><span class="istickedoff">(ModelTwoArgumentsLinearOnDiagonal (ModelConstantOrLinear c intercept slope)) =</span>
<span class="lineno">  584 </span><span class="spaces">        </span><span class="istickedoff">lazy $ \costs1 costs2 -&gt; do</span>
<span class="lineno">  585 </span><span class="spaces">            </span><span class="istickedoff">let !size1 = sumCostStream costs1</span>
<span class="lineno">  586 </span><span class="spaces">                </span><span class="istickedoff">!size2 = sumCostStream costs2</span>
<span class="lineno">  587 </span><span class="spaces">            </span><span class="istickedoff">if size1 == size2</span>
<span class="lineno">  588 </span><span class="spaces">                </span><span class="istickedoff">then scaleLinearly intercept slope $ CostLast size1</span>
<span class="lineno">  589 </span><span class="spaces">                </span><span class="istickedoff">else CostLast c</span>
<span class="lineno">  590 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  591 </span><span class="spaces">    </span><span class="istickedoff">-- Off the diagonal, return the constant.  On the diagonal, run the other model.</span>
<span class="lineno">  592 </span><span class="spaces">    </span><span class="istickedoff">(ModelTwoArgumentsConstOffDiagonal (ModelConstantOrOneArgument c m)) =</span>
<span class="lineno">  593 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">case runOneArgumentModel m of</span></span>
<span class="lineno">  594 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">!run -&gt; lazy $ \costs1 costs2 -&gt; do</span></span>
<span class="lineno">  595 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">let !size1 = sumCostStream costs1</span></span>
<span class="lineno">  596 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">!size2 = sumCostStream costs2</span></span>
<span class="lineno">  597 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">if size1 /= size2</span></span>
<span class="lineno">  598 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">then CostLast c</span></span>
<span class="lineno">  599 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">else run (CostLast size1)</span></span>
<span class="lineno">  600 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  601 </span><span class="spaces">    </span><span class="istickedoff">-- Below the diagonal, return the constant. Above the diagonal, run the other model.</span>
<span class="lineno">  602 </span><span class="spaces">    </span><span class="istickedoff">(ModelTwoArgumentsConstBelowDiagonal (ModelConstantOrTwoArguments c m)) =</span>
<span class="lineno">  603 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">case runTwoArgumentModel m of</span></span>
<span class="lineno">  604 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">!run -&gt; lazy $ \costs1 costs2 -&gt; do</span></span>
<span class="lineno">  605 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">let !size1 = sumCostStream costs1</span></span>
<span class="lineno">  606 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">!size2 = sumCostStream costs2</span></span>
<span class="lineno">  607 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">if size1 &gt; size2</span></span>
<span class="lineno">  608 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">then CostLast c</span></span>
<span class="lineno">  609 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">else run (CostLast size1) (CostLast size2)</span></span>
<span class="lineno">  610 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  611 </span><span class="spaces">    </span><span class="istickedoff">-- Above the diagonal, return the constant. Below the diagonal, run the other model.</span>
<span class="lineno">  612 </span><span class="spaces">    </span><span class="istickedoff">(ModelTwoArgumentsConstAboveDiagonal (ModelConstantOrTwoArguments c m)) =</span>
<span class="lineno">  613 </span><span class="spaces">        </span><span class="istickedoff">case runTwoArgumentModel m of</span>
<span class="lineno">  614 </span><span class="spaces">            </span><span class="istickedoff">!run -&gt; lazy $ \costs1 costs2 -&gt; do</span>
<span class="lineno">  615 </span><span class="spaces">                </span><span class="istickedoff">let !size1 = sumCostStream costs1</span>
<span class="lineno">  616 </span><span class="spaces">                    </span><span class="istickedoff">!size2 = sumCostStream costs2</span>
<span class="lineno">  617 </span><span class="spaces">                </span><span class="istickedoff">if size1 &lt; size2</span>
<span class="lineno">  618 </span><span class="spaces">                    </span><span class="istickedoff">then CostLast c</span>
<span class="lineno">  619 </span><span class="spaces">                    </span><span class="istickedoff">else run (CostLast size1) (CostLast size2)</span>
<span class="lineno">  620 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  621 </span><span class="spaces">    </span><span class="istickedoff">(ModelTwoArgumentsQuadraticInY f) =</span>
<span class="lineno">  622 </span><span class="spaces">        </span><span class="istickedoff">lazy $ \_ costs2 -&gt;</span>
<span class="lineno">  623 </span><span class="spaces">            </span><span class="istickedoff">CostLast $ evaluateOneVariableQuadraticFunction f $ sumCostStream costs2</span>
<span class="lineno">  624 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  625 </span><span class="spaces">    </span><span class="istickedoff">(ModelTwoArgumentsQuadraticInXAndY f) =</span>
<span class="lineno">  626 </span><span class="spaces">        </span><span class="istickedoff">lazy $ \costs1 costs2 -&gt;</span>
<span class="lineno">  627 </span><span class="spaces">             </span><span class="istickedoff">let !size1 = sumCostStream costs1</span>
<span class="lineno">  628 </span><span class="spaces">                 </span><span class="istickedoff">!size2 = sumCostStream costs2</span>
<span class="lineno">  629 </span><span class="spaces">             </span><span class="istickedoff">in CostLast $ evaluateTwoVariableQuadraticFunction f size1 size2</span></span>
<span class="lineno">  630 </span>{-# OPAQUE runTwoArgumentModel #-}
<span class="lineno">  631 </span>
<span class="lineno">  632 </span>
<span class="lineno">  633 </span>---------------- Three-argument costing functions ----------------
<span class="lineno">  634 </span>
<span class="lineno">  635 </span>data ModelThreeArguments =
<span class="lineno">  636 </span>    ModelThreeArgumentsConstantCost           CostingInteger
<span class="lineno">  637 </span>  | ModelThreeArgumentsLinearInX              OneVariableLinearFunction
<span class="lineno">  638 </span>  | ModelThreeArgumentsLinearInY              OneVariableLinearFunction
<span class="lineno">  639 </span>  | ModelThreeArgumentsLinearInZ              OneVariableLinearFunction
<span class="lineno">  640 </span>  | ModelThreeArgumentsQuadraticInZ           OneVariableQuadraticFunction
<span class="lineno">  641 </span>  | ModelThreeArgumentsLiteralInYOrLinearInZ  OneVariableLinearFunction
<span class="lineno">  642 </span>  | ModelThreeArgumentsLinearInMaxYZ          OneVariableLinearFunction
<span class="lineno">  643 </span>  | ModelThreeArgumentsLinearInYAndZ          TwoVariableLinearFunction
<span class="lineno">  644 </span>  | ModelThreeArgumentsQuadraticInYAndZ       TwoVariableQuadraticFunction
<span class="lineno">  645 </span>  | ModelThreeArgumentsExpModCost             ExpModCostingFunction
<span class="lineno">  646 </span>    deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  647 </span>    deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  648 </span>
<span class="lineno">  649 </span>instance Default ModelThreeArguments where
<span class="lineno">  650 </span>    <span class="decl"><span class="istickedoff">def = ModelThreeArgumentsConstantCost maxBound</span></span>
<span class="lineno">  651 </span>
<span class="lineno">  652 </span>instance UnimplementedCostingFun ModelThreeArguments where
<span class="lineno">  653 </span>  <span class="decl"><span class="istickedoff">unimplementedCostingFun = makeUnimplementedCostingFun ModelThreeArgumentsConstantCost</span></span>
<span class="lineno">  654 </span>
<span class="lineno">  655 </span>runThreeArgumentModel
<span class="lineno">  656 </span>    :: ModelThreeArguments
<span class="lineno">  657 </span>    -&gt; CostStream
<span class="lineno">  658 </span>    -&gt; CostStream
<span class="lineno">  659 </span>    -&gt; CostStream
<span class="lineno">  660 </span>    -&gt; CostStream
<span class="lineno">  661 </span><span class="decl"><span class="istickedoff">runThreeArgumentModel (ModelThreeArgumentsConstantCost c) = lazy $ \_ _ _ -&gt; CostLast c</span>
<span class="lineno">  662 </span><span class="spaces"></span><span class="istickedoff">runThreeArgumentModel</span>
<span class="lineno">  663 </span><span class="spaces">    </span><span class="istickedoff">(ModelThreeArgumentsLinearInX (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  664 </span><span class="spaces">        </span><span class="istickedoff">lazy $ \costs1 _ _ -&gt;</span>
<span class="lineno">  665 </span><span class="spaces">            </span><span class="istickedoff">scaleLinearly intercept slope costs1</span>
<span class="lineno">  666 </span><span class="spaces"></span><span class="istickedoff">runThreeArgumentModel</span>
<span class="lineno">  667 </span><span class="spaces">    </span><span class="istickedoff">(ModelThreeArgumentsLinearInY (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  668 </span><span class="spaces">        </span><span class="istickedoff">lazy $ \_ costs2 _ -&gt;</span>
<span class="lineno">  669 </span><span class="spaces">            </span><span class="istickedoff">scaleLinearly intercept slope costs2</span>
<span class="lineno">  670 </span><span class="spaces"></span><span class="istickedoff">runThreeArgumentModel</span>
<span class="lineno">  671 </span><span class="spaces">    </span><span class="istickedoff">(ModelThreeArgumentsLinearInZ (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  672 </span><span class="spaces">        </span><span class="istickedoff">lazy $ \_ _ costs3 -&gt;</span>
<span class="lineno">  673 </span><span class="spaces">            </span><span class="istickedoff">scaleLinearly intercept slope costs3</span>
<span class="lineno">  674 </span><span class="spaces"></span><span class="istickedoff">runThreeArgumentModel</span>
<span class="lineno">  675 </span><span class="spaces">    </span><span class="istickedoff">(ModelThreeArgumentsQuadraticInZ f) =</span>
<span class="lineno">  676 </span><span class="spaces">        </span><span class="istickedoff">lazy $ \_ _ costs3 -&gt; CostLast $ evaluateOneVariableQuadraticFunction f $ sumCostStream costs3</span>
<span class="lineno">  677 </span><span class="spaces"></span><span class="istickedoff">{- Either a literal number of bytes or a linear function.  This is for</span>
<span class="lineno">  678 </span><span class="spaces">   </span><span class="istickedoff">`integerToByteString`, where if the second argument is zero, the output</span>
<span class="lineno">  679 </span><span class="spaces">   </span><span class="istickedoff">bytestring has the minimum length required to contain the converted integer,</span>
<span class="lineno">  680 </span><span class="spaces">   </span><span class="istickedoff">but if the second argument is nonzero it specifies the exact length of the</span>
<span class="lineno">  681 </span><span class="spaces">   </span><span class="istickedoff">output bytestring. We could generalise this to something like `LinearInYOrZ`</span>
<span class="lineno">  682 </span><span class="spaces">   </span><span class="istickedoff">since the argument wrapping takes care of calculating the memory usages for</span>
<span class="lineno">  683 </span><span class="spaces">   </span><span class="istickedoff">us anyway (the costing function here knows nothing about the wrapper: it just</span>
<span class="lineno">  684 </span><span class="spaces">   </span><span class="istickedoff">gets a number from `onMemoryUsages`).</span>
<span class="lineno">  685 </span><span class="spaces"></span><span class="istickedoff">-}</span>
<span class="lineno">  686 </span><span class="spaces"></span><span class="istickedoff">runThreeArgumentModel</span>
<span class="lineno">  687 </span><span class="spaces">    </span><span class="istickedoff">(ModelThreeArgumentsLiteralInYOrLinearInZ (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  688 </span><span class="spaces">        </span><span class="istickedoff">lazy $ \_ costs2 costs3 -&gt;</span>
<span class="lineno">  689 </span><span class="spaces">            </span><span class="istickedoff">let !width = sumCostStream costs2</span>
<span class="lineno">  690 </span><span class="spaces">            </span><span class="istickedoff">in if width == 0</span>
<span class="lineno">  691 </span><span class="spaces">            </span><span class="istickedoff">then scaleLinearly intercept slope costs3</span>
<span class="lineno">  692 </span><span class="spaces">            </span><span class="istickedoff">else costs2</span>
<span class="lineno">  693 </span><span class="spaces"></span><span class="istickedoff">runThreeArgumentModel</span>
<span class="lineno">  694 </span><span class="spaces">    </span><span class="istickedoff">(ModelThreeArgumentsLinearInMaxYZ (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  695 </span><span class="spaces">        </span><span class="istickedoff">lazy $ \_ costs2 costs3 -&gt;</span>
<span class="lineno">  696 </span><span class="spaces">            </span><span class="istickedoff">let !size2 = sumCostStream costs2</span>
<span class="lineno">  697 </span><span class="spaces">                </span><span class="istickedoff">!size3 = sumCostStream costs3</span>
<span class="lineno">  698 </span><span class="spaces">            </span><span class="istickedoff">in scaleLinearly intercept slope $ CostLast (max size2 size3)</span>
<span class="lineno">  699 </span><span class="spaces"></span><span class="istickedoff">runThreeArgumentModel</span>
<span class="lineno">  700 </span><span class="spaces">    </span><span class="istickedoff">(ModelThreeArgumentsLinearInYAndZ (TwoVariableLinearFunction intercept slope2 slope3)) =</span>
<span class="lineno">  701 </span><span class="spaces">        </span><span class="istickedoff">lazy $ \_costs1 costs2 costs3 -&gt;</span>
<span class="lineno">  702 </span><span class="spaces">            </span><span class="istickedoff">scaleLinearlyTwoVariables intercept slope2 costs2 slope3 costs3</span>
<span class="lineno">  703 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  704 </span><span class="spaces"></span><span class="istickedoff">runThreeArgumentModel</span>
<span class="lineno">  705 </span><span class="spaces">  </span><span class="istickedoff">(ModelThreeArgumentsQuadraticInYAndZ f) =</span>
<span class="lineno">  706 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">lazy $ \_ costs2 costs3 -&gt;</span></span>
<span class="lineno">  707 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">let !size2 = sumCostStream costs2</span></span>
<span class="lineno">  708 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">!size3 = sumCostStream costs3</span></span>
<span class="lineno">  709 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">in CostLast $ evaluateTwoVariableQuadraticFunction f size2 size3</span></span>
<span class="lineno">  710 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  711 </span><span class="spaces"></span><span class="istickedoff">runThreeArgumentModel (ModelThreeArgumentsExpModCost f) =</span>
<span class="lineno">  712 </span><span class="spaces">  </span><span class="istickedoff">lazy $ \costs1 costs2 costs3 -&gt;</span>
<span class="lineno">  713 </span><span class="spaces">           </span><span class="istickedoff">let !size1 = sumCostStream costs1</span>
<span class="lineno">  714 </span><span class="spaces">               </span><span class="istickedoff">!size2 = sumCostStream costs2</span>
<span class="lineno">  715 </span><span class="spaces">               </span><span class="istickedoff">!size3 = sumCostStream costs3</span>
<span class="lineno">  716 </span><span class="spaces">           </span><span class="istickedoff">in CostLast $ evaluateExpModCostingFunction f size1 size2 size3</span></span>
<span class="lineno">  717 </span>{-# OPAQUE runThreeArgumentModel #-}
<span class="lineno">  718 </span>
<span class="lineno">  719 </span>-- See Note [runCostingFun* API].
<span class="lineno">  720 </span>runCostingFunThreeArguments
<span class="lineno">  721 </span>    :: ( ExMemoryUsage a1
<span class="lineno">  722 </span>       , ExMemoryUsage a2
<span class="lineno">  723 </span>       , ExMemoryUsage a3
<span class="lineno">  724 </span>       )
<span class="lineno">  725 </span>    =&gt; CostingFun ModelThreeArguments
<span class="lineno">  726 </span>    -&gt; a1
<span class="lineno">  727 </span>    -&gt; a2
<span class="lineno">  728 </span>    -&gt; a3
<span class="lineno">  729 </span>    -&gt; ExBudgetStream
<span class="lineno">  730 </span><span class="decl"><span class="istickedoff">runCostingFunThreeArguments (CostingFun cpu mem) =</span>
<span class="lineno">  731 </span><span class="spaces">    </span><span class="istickedoff">case (runThreeArgumentModel cpu, runThreeArgumentModel mem) of</span>
<span class="lineno">  732 </span><span class="spaces">        </span><span class="istickedoff">(!runCpu, !runMem) -&gt; onMemoryUsages $ \mem1 mem2 mem3 -&gt;</span>
<span class="lineno">  733 </span><span class="spaces">            </span><span class="istickedoff">zipCostStream</span>
<span class="lineno">  734 </span><span class="spaces">                </span><span class="istickedoff">(runCpu mem1 mem2 mem3)</span>
<span class="lineno">  735 </span><span class="spaces">                </span><span class="istickedoff">(runMem mem1 mem2 mem3)</span></span>
<span class="lineno">  736 </span>{-# INLINE runCostingFunThreeArguments #-}
<span class="lineno">  737 </span>
<span class="lineno">  738 </span>
<span class="lineno">  739 </span>---------------- Four-argument costing functions ----------------
<span class="lineno">  740 </span>
<span class="lineno">  741 </span>data ModelFourArguments =
<span class="lineno">  742 </span>      ModelFourArgumentsConstantCost CostingInteger
<span class="lineno">  743 </span>    deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  744 </span>    deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  745 </span>
<span class="lineno">  746 </span>instance Default ModelFourArguments where
<span class="lineno">  747 </span>    <span class="decl"><span class="nottickedoff">def = ModelFourArgumentsConstantCost maxBound</span></span>
<span class="lineno">  748 </span>
<span class="lineno">  749 </span>instance UnimplementedCostingFun ModelFourArguments where
<span class="lineno">  750 </span>  <span class="decl"><span class="istickedoff">unimplementedCostingFun = makeUnimplementedCostingFun ModelFourArgumentsConstantCost</span></span>
<span class="lineno">  751 </span>
<span class="lineno">  752 </span>runFourArgumentModel
<span class="lineno">  753 </span>    :: ModelFourArguments
<span class="lineno">  754 </span>    -&gt; CostStream
<span class="lineno">  755 </span>    -&gt; CostStream
<span class="lineno">  756 </span>    -&gt; CostStream
<span class="lineno">  757 </span>    -&gt; CostStream
<span class="lineno">  758 </span>    -&gt; CostStream
<span class="lineno">  759 </span><span class="decl"><span class="istickedoff">runFourArgumentModel (ModelFourArgumentsConstantCost c) = lazy $ \_ _ _ _ -&gt; CostLast c</span></span>
<span class="lineno">  760 </span>{-# OPAQUE runFourArgumentModel #-}
<span class="lineno">  761 </span>
<span class="lineno">  762 </span>-- See Note [runCostingFun* API].
<span class="lineno">  763 </span>runCostingFunFourArguments
<span class="lineno">  764 </span>    :: ( ExMemoryUsage a1
<span class="lineno">  765 </span>       , ExMemoryUsage a2
<span class="lineno">  766 </span>       , ExMemoryUsage a3
<span class="lineno">  767 </span>       , ExMemoryUsage a4
<span class="lineno">  768 </span>       )
<span class="lineno">  769 </span>    =&gt; CostingFun ModelFourArguments
<span class="lineno">  770 </span>    -&gt; a1
<span class="lineno">  771 </span>    -&gt; a2
<span class="lineno">  772 </span>    -&gt; a3
<span class="lineno">  773 </span>    -&gt; a4
<span class="lineno">  774 </span>    -&gt; ExBudgetStream
<span class="lineno">  775 </span><span class="decl"><span class="istickedoff">runCostingFunFourArguments (CostingFun cpu mem) =</span>
<span class="lineno">  776 </span><span class="spaces">    </span><span class="istickedoff">case (runFourArgumentModel cpu, runFourArgumentModel mem) of</span>
<span class="lineno">  777 </span><span class="spaces">        </span><span class="istickedoff">(!runCpu, !runMem) -&gt; onMemoryUsages $ \mem1 mem2 mem3 mem4 -&gt;</span>
<span class="lineno">  778 </span><span class="spaces">            </span><span class="istickedoff">zipCostStream</span>
<span class="lineno">  779 </span><span class="spaces">                </span><span class="istickedoff">(runCpu <span class="nottickedoff">mem1</span> <span class="nottickedoff">mem2</span> <span class="nottickedoff">mem3</span> <span class="nottickedoff">mem4</span>)</span>
<span class="lineno">  780 </span><span class="spaces">                </span><span class="istickedoff">(runMem <span class="nottickedoff">mem1</span> <span class="nottickedoff">mem2</span> <span class="nottickedoff">mem3</span> <span class="nottickedoff">mem4</span>)</span></span>
<span class="lineno">  781 </span>{-# INLINE runCostingFunFourArguments #-}
<span class="lineno">  782 </span>
<span class="lineno">  783 </span>
<span class="lineno">  784 </span>---------------- Five-argument costing functions ----------------
<span class="lineno">  785 </span>
<span class="lineno">  786 </span>data ModelFiveArguments =
<span class="lineno">  787 </span>      ModelFiveArgumentsConstantCost CostingInteger
<span class="lineno">  788 </span>    deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  789 </span>    deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  790 </span>
<span class="lineno">  791 </span>instance Default ModelFiveArguments where
<span class="lineno">  792 </span>    <span class="decl"><span class="nottickedoff">def = ModelFiveArgumentsConstantCost maxBound</span></span>
<span class="lineno">  793 </span>
<span class="lineno">  794 </span>instance UnimplementedCostingFun ModelFiveArguments where
<span class="lineno">  795 </span>  <span class="decl"><span class="nottickedoff">unimplementedCostingFun = makeUnimplementedCostingFun ModelFiveArgumentsConstantCost</span></span>
<span class="lineno">  796 </span>
<span class="lineno">  797 </span>runFiveArgumentModel
<span class="lineno">  798 </span>    :: ModelFiveArguments
<span class="lineno">  799 </span>    -&gt; CostStream
<span class="lineno">  800 </span>    -&gt; CostStream
<span class="lineno">  801 </span>    -&gt; CostStream
<span class="lineno">  802 </span>    -&gt; CostStream
<span class="lineno">  803 </span>    -&gt; CostStream
<span class="lineno">  804 </span>    -&gt; CostStream
<span class="lineno">  805 </span><span class="decl"><span class="nottickedoff">runFiveArgumentModel (ModelFiveArgumentsConstantCost c) = lazy $ \_ _ _ _ _ -&gt; CostLast c</span></span>
<span class="lineno">  806 </span>{-# OPAQUE runFiveArgumentModel #-}
<span class="lineno">  807 </span>
<span class="lineno">  808 </span>-- See Note [runCostingFun* API].
<span class="lineno">  809 </span>runCostingFunFiveArguments
<span class="lineno">  810 </span>    :: ( ExMemoryUsage a1
<span class="lineno">  811 </span>       , ExMemoryUsage a2
<span class="lineno">  812 </span>       , ExMemoryUsage a3
<span class="lineno">  813 </span>       , ExMemoryUsage a4
<span class="lineno">  814 </span>       , ExMemoryUsage a5
<span class="lineno">  815 </span>       )
<span class="lineno">  816 </span>    =&gt; CostingFun ModelFiveArguments
<span class="lineno">  817 </span>    -&gt; a1
<span class="lineno">  818 </span>    -&gt; a2
<span class="lineno">  819 </span>    -&gt; a3
<span class="lineno">  820 </span>    -&gt; a4
<span class="lineno">  821 </span>    -&gt; a5
<span class="lineno">  822 </span>    -&gt; ExBudgetStream
<span class="lineno">  823 </span><span class="decl"><span class="nottickedoff">runCostingFunFiveArguments (CostingFun cpu mem) =</span>
<span class="lineno">  824 </span><span class="spaces">    </span><span class="nottickedoff">case (runFiveArgumentModel cpu, runFiveArgumentModel mem) of</span>
<span class="lineno">  825 </span><span class="spaces">        </span><span class="nottickedoff">(!runCpu, !runMem) -&gt; onMemoryUsages $ \mem1 mem2 mem3 mem4 mem5 -&gt;</span>
<span class="lineno">  826 </span><span class="spaces">            </span><span class="nottickedoff">zipCostStream</span>
<span class="lineno">  827 </span><span class="spaces">                </span><span class="nottickedoff">(runCpu mem1 mem2 mem3 mem4 mem5)</span>
<span class="lineno">  828 </span><span class="spaces">                </span><span class="nottickedoff">(runMem mem1 mem2 mem3 mem4 mem5)</span></span>
<span class="lineno">  829 </span>{-# INLINE runCostingFunFiveArguments #-}
<span class="lineno">  830 </span>
<span class="lineno">  831 </span>---------------- Six-argument costing functions ----------------
<span class="lineno">  832 </span>
<span class="lineno">  833 </span>data ModelSixArguments =
<span class="lineno">  834 </span>      ModelSixArgumentsConstantCost CostingInteger
<span class="lineno">  835 </span>    deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  836 </span>    deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  837 </span>
<span class="lineno">  838 </span>instance Default ModelSixArguments where
<span class="lineno">  839 </span>    <span class="decl"><span class="istickedoff">def = ModelSixArgumentsConstantCost maxBound</span></span>
<span class="lineno">  840 </span>
<span class="lineno">  841 </span>instance UnimplementedCostingFun ModelSixArguments where
<span class="lineno">  842 </span>  <span class="decl"><span class="nottickedoff">unimplementedCostingFun = makeUnimplementedCostingFun ModelSixArgumentsConstantCost</span></span>
<span class="lineno">  843 </span>
<span class="lineno">  844 </span>runSixArgumentModel
<span class="lineno">  845 </span>    :: ModelSixArguments
<span class="lineno">  846 </span>    -&gt; CostStream
<span class="lineno">  847 </span>    -&gt; CostStream
<span class="lineno">  848 </span>    -&gt; CostStream
<span class="lineno">  849 </span>    -&gt; CostStream
<span class="lineno">  850 </span>    -&gt; CostStream
<span class="lineno">  851 </span>    -&gt; CostStream
<span class="lineno">  852 </span>    -&gt; CostStream
<span class="lineno">  853 </span><span class="decl"><span class="istickedoff">runSixArgumentModel (ModelSixArgumentsConstantCost c) = lazy $ \_ _ _ _ _ _ -&gt; CostLast c</span></span>
<span class="lineno">  854 </span>{-# OPAQUE runSixArgumentModel #-}
<span class="lineno">  855 </span>
<span class="lineno">  856 </span>-- See Note [runCostingFun* API].
<span class="lineno">  857 </span>runCostingFunSixArguments
<span class="lineno">  858 </span>    :: ( ExMemoryUsage a1
<span class="lineno">  859 </span>       , ExMemoryUsage a2
<span class="lineno">  860 </span>       , ExMemoryUsage a3
<span class="lineno">  861 </span>       , ExMemoryUsage a4
<span class="lineno">  862 </span>       , ExMemoryUsage a5
<span class="lineno">  863 </span>       , ExMemoryUsage a6
<span class="lineno">  864 </span>       )
<span class="lineno">  865 </span>    =&gt; CostingFun ModelSixArguments
<span class="lineno">  866 </span>    -&gt; a1
<span class="lineno">  867 </span>    -&gt; a2
<span class="lineno">  868 </span>    -&gt; a3
<span class="lineno">  869 </span>    -&gt; a4
<span class="lineno">  870 </span>    -&gt; a5
<span class="lineno">  871 </span>    -&gt; a6
<span class="lineno">  872 </span>    -&gt; ExBudgetStream
<span class="lineno">  873 </span><span class="decl"><span class="istickedoff">runCostingFunSixArguments (CostingFun cpu mem) =</span>
<span class="lineno">  874 </span><span class="spaces">    </span><span class="istickedoff">case (runSixArgumentModel cpu, runSixArgumentModel mem) of</span>
<span class="lineno">  875 </span><span class="spaces">        </span><span class="istickedoff">(!runCpu, !runMem) -&gt; onMemoryUsages $ \mem1 mem2 mem3 mem4 mem5 mem6 -&gt;</span>
<span class="lineno">  876 </span><span class="spaces">            </span><span class="istickedoff">zipCostStream</span>
<span class="lineno">  877 </span><span class="spaces">                </span><span class="istickedoff">(runCpu <span class="nottickedoff">mem1</span> <span class="nottickedoff">mem2</span> <span class="nottickedoff">mem3</span> <span class="nottickedoff">mem4</span> <span class="nottickedoff">mem5</span> <span class="nottickedoff">mem6</span>)</span>
<span class="lineno">  878 </span><span class="spaces">                </span><span class="istickedoff">(runMem <span class="nottickedoff">mem1</span> <span class="nottickedoff">mem2</span> <span class="nottickedoff">mem3</span> <span class="nottickedoff">mem4</span> <span class="nottickedoff">mem5</span> <span class="nottickedoff">mem6</span>)</span></span>
<span class="lineno">  879 </span>{-# INLINE runCostingFunSixArguments #-}

</pre>
</body>
</html>
