<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# OPTIONS_GHC -fno-warn-orphans #-}
<span class="lineno">    2 </span>
<span class="lineno">    3 </span>{-# LANGUAGE FlexibleInstances    #-}
<span class="lineno">    4 </span>{-# LANGUAGE GADTs                #-}
<span class="lineno">    5 </span>{-# LANGUAGE LambdaCase           #-}
<span class="lineno">    6 </span>{-# LANGUAGE StandaloneDeriving   #-}
<span class="lineno">    7 </span>{-# LANGUAGE TypeApplications     #-}
<span class="lineno">    8 </span>{-# LANGUAGE TypeOperators        #-}
<span class="lineno">    9 </span>{-# LANGUAGE UndecidableInstances #-}
<span class="lineno">   10 </span>
<span class="lineno">   11 </span>-- | Flat instances for Plutus Core types. Make sure to read Note [Stable
<span class="lineno">   12 </span>-- encoding of TPLC] and Note [Stable encoding of UPLC] before touching anything
<span class="lineno">   13 </span>-- in this file.
<span class="lineno">   14 </span>module PlutusCore.FlatInstances
<span class="lineno">   15 </span>    ( safeEncodeBits
<span class="lineno">   16 </span>    ) where
<span class="lineno">   17 </span>
<span class="lineno">   18 </span>import Codec.Extras.FlatViaSerialise
<span class="lineno">   19 </span>import PlutusCore.Core
<span class="lineno">   20 </span>import PlutusCore.Data (Data)
<span class="lineno">   21 </span>import PlutusCore.DeBruijn
<span class="lineno">   22 </span>import PlutusCore.Name.Unique
<span class="lineno">   23 </span>
<span class="lineno">   24 </span>import Data.Proxy
<span class="lineno">   25 </span>import PlutusCore.Flat
<span class="lineno">   26 </span>import PlutusCore.Flat.Decoder
<span class="lineno">   27 </span>import PlutusCore.Flat.Encoder
<span class="lineno">   28 </span>import PlutusPrelude
<span class="lineno">   29 </span>import Universe
<span class="lineno">   30 </span>
<span class="lineno">   31 </span>{- Note [Stable encoding of TPLC]
<span class="lineno">   32 </span>READ THIS BEFORE TOUCHING ANYTHING IN THIS FILE
<span class="lineno">   33 </span>
<span class="lineno">   34 </span>We need the encoding of PLC on the blockchain to be *extremely* stable. It *must not* change
<span class="lineno">   35 </span>arbitrarily, otherwise we'll be unable to read back old transactions and validate them.
<span class="lineno">   36 </span>
<span class="lineno">   37 </span>Consequently we don't use the derivable instances of `Flat` for the PLC types that go
<span class="lineno">   38 </span>on the chain.
<span class="lineno">   39 </span>
<span class="lineno">   40 </span>However, the instances in this file *are* constrained by instances for names, type names,
<span class="lineno">   41 </span>and annotations. What's to stop the instances for *those* changing, thus changing
<span class="lineno">   42 </span>the overall encoding on the chain?
<span class="lineno">   43 </span>
<span class="lineno">   44 </span>The answer is that what goes on the chain is *always* a `Program TyName Name ()`. The instances
<span class="lineno">   45 </span>for `TyName` and `Name` are nailed down here, and the instance for `()` is standard.
<span class="lineno">   46 </span>
<span class="lineno">   47 </span>However, having this flexibility allows us to encode e.g. PLC with substantial annotations
<span class="lineno">   48 </span>(like position information) in situation where the stability is *not* critical, such as
<span class="lineno">   49 </span>for testing.
<span class="lineno">   50 </span>-}
<span class="lineno">   51 </span>
<span class="lineno">   52 </span>{- Note [Encoding/decoding TPLC constructor tags using Flat]
<span class="lineno">   53 </span>Flat saves space when compared to CBOR by allowing tags to use the minimum
<span class="lineno">   54 </span>number of bits required for their encoding.
<span class="lineno">   55 </span>
<span class="lineno">   56 </span>This requires specialised encode/decode functions for each constructor
<span class="lineno">   57 </span>that encodes a different number of possibilities. Here is a list of the
<span class="lineno">   58 </span>tags and their used/available encoding possibilities.
<span class="lineno">   59 </span>
<span class="lineno">   60 </span>** The BELOW table is about Typed-PLC and not UPLC. See `UntypedPlutusCore.Core.Instance.Flat`**
<span class="lineno">   61 </span>
<span class="lineno">   62 </span>| Data type        | Function          | Bit Width | Total | Used | Remaining |
<span class="lineno">   63 </span>|------------------|-------------------|-----------|-------|------|-----------|
<span class="lineno">   64 </span>| default builtins | encodeBuiltin     | 7         | 128   | 54   | 74        |
<span class="lineno">   65 </span>| Kinds            | encodeKind        | 1         | 2     | 2    | 0         |
<span class="lineno">   66 </span>| Types            | encodeType        | 3         | 8     | 7    | 1         |
<span class="lineno">   67 </span>| Terms            | encodeTerm        | 4         | 16    | 12   | 4         |
<span class="lineno">   68 </span>
<span class="lineno">   69 </span>For format stability we are manually assigning the tag values to the
<span class="lineno">   70 </span>constructors (and we do not use a generic algorithm that may change this order).
<span class="lineno">   71 </span>
<span class="lineno">   72 </span>All encodings use the function `safeEncodeBits :: NumBits -&gt; Word8 -&gt; Encoding`, which encodes
<span class="lineno">   73 </span>at most 8 bits of data, and the first argument specifies how many bits from the 8
<span class="lineno">   74 </span>available are actually used. This function also checks the size of the `Word8`
<span class="lineno">   75 </span>argument at runtime.
<span class="lineno">   76 </span>
<span class="lineno">   77 </span>Flat uses an extra function in its class definition called `size`. Since we want
<span class="lineno">   78 </span>to reserve some space for future data constructors and we don't want to have the
<span class="lineno">   79 </span>sizes desynchronised from the encoding and decoding functions we have manual
<span class="lineno">   80 </span>implementations for them (if they have any constructors reserved for future use).
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>By default, Flat does not use any space to serialise `()`.
<span class="lineno">   83 </span>-}
<span class="lineno">   84 </span>
<span class="lineno">   85 </span>{- Note [DeBruijn Index serialization]
<span class="lineno">   86 </span>
<span class="lineno">   87 </span>Back in the days, `Index` was a Natural and we flat (de)-serialized it via Natural.
<span class="lineno">   88 </span>Later `Index` was changed to Word64 (for performance reasons):
<span class="lineno">   89 </span>its flat encoding remained via Natural,
<span class="lineno">   90 </span>but its decoding was changed to a *custom* Word64 decoder.
<span class="lineno">   91 </span>
<span class="lineno">   92 </span>Why custom decoder: there was a bug in Word64 decoder of flat versions &lt;0.5.2 and
<span class="lineno">   93 </span>fixed in flat&gt;=0.5.2.
<span class="lineno">   94 </span>
<span class="lineno">   95 </span>We are now running flat&gt;=0.6, so we switch to the non-custom, fixed flat Word64 decoder.
<span class="lineno">   96 </span>
<span class="lineno">   97 </span>Since we are there, we also switch the encoder of Index from the Natural encoder
<span class="lineno">   98 </span>to Word64 encoder. This encoding change only breaks client-code and not nodes' behavior:
<span class="lineno">   99 </span>the script would just fail earlier at encoding phase (in the client's software)
<span class="lineno">  100 </span>than the later decoding phase (when trying to send the encoded script to the node network and
<span class="lineno">  101 </span>only get back a decoding error, aka phase-1 validation error).
<span class="lineno">  102 </span>This phase-1 validation is in place both for normal (locked scripts) and for inline scripts,
<span class="lineno">  103 </span>so the nodes' behavior does not change.
<span class="lineno">  104 </span>-}
<span class="lineno">  105 </span>
<span class="lineno">  106 </span>safeEncodeBits :: NumBits -&gt; Word8 -&gt; Encoding
<span class="lineno">  107 </span><span class="decl"><span class="istickedoff">safeEncodeBits maxBits v =</span>
<span class="lineno">  108 </span><span class="spaces">  </span><span class="istickedoff">if <span class="tickonlyfalse">2 ^ maxBits &lt;= v</span></span>
<span class="lineno">  109 </span><span class="spaces">  </span><span class="istickedoff">then <span class="nottickedoff">error $ &quot;Overflow detected, cannot fit &quot;</span></span>
<span class="lineno">  110 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">&lt;&gt; show v &lt;&gt; &quot; in &quot; &lt;&gt; show maxBits &lt;&gt; &quot; bits.&quot;</span></span>
<span class="lineno">  111 </span><span class="spaces">  </span><span class="istickedoff">else eBits maxBits v</span></span>
<span class="lineno">  112 </span>
<span class="lineno">  113 </span>constantWidth :: NumBits
<span class="lineno">  114 </span><span class="decl"><span class="istickedoff">constantWidth = 4</span></span>
<span class="lineno">  115 </span>
<span class="lineno">  116 </span>encodeConstant :: Word8 -&gt; Encoding
<span class="lineno">  117 </span><span class="decl"><span class="istickedoff">encodeConstant = safeEncodeBits constantWidth</span></span>
<span class="lineno">  118 </span>
<span class="lineno">  119 </span>decodeConstant :: Get Word8
<span class="lineno">  120 </span><span class="decl"><span class="istickedoff">decodeConstant = dBEBits8 constantWidth</span></span>
<span class="lineno">  121 </span>
<span class="lineno">  122 </span><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">deriving via FlatViaSerialise Data instance Flat Data</span></span></span></span></span></span>
<span class="lineno">  123 </span>
<span class="lineno">  124 </span>decodeKindedUniFlat :: Closed uni =&gt; Get (SomeTypeIn (Kinded uni))
<span class="lineno">  125 </span><span class="decl"><span class="istickedoff">decodeKindedUniFlat =</span>
<span class="lineno">  126 </span><span class="spaces">    </span><span class="istickedoff">go . decodeKindedUni . map (fromIntegral :: Word8 -&gt; Int)</span>
<span class="lineno">  127 </span><span class="spaces">        </span><span class="istickedoff">=&lt;&lt; decodeListWith decodeConstant</span>
<span class="lineno">  128 </span><span class="spaces">        </span><span class="istickedoff">where</span>
<span class="lineno">  129 </span><span class="spaces">        </span><span class="istickedoff">go Nothing    = <span class="nottickedoff">fail &quot;Failed to decode a universe&quot;</span></span>
<span class="lineno">  130 </span><span class="spaces">        </span><span class="istickedoff">go (Just uni) = pure uni</span></span>
<span class="lineno">  131 </span>
<span class="lineno">  132 </span>-- See Note [The G, the Tag and the Auto].
<span class="lineno">  133 </span>instance Closed uni =&gt; Flat (SomeTypeIn uni) where
<span class="lineno">  134 </span>    <span class="decl"><span class="istickedoff">encode (SomeTypeIn uni) =</span>
<span class="lineno">  135 </span><span class="spaces">      </span><span class="istickedoff">encodeListWith encodeConstant .</span>
<span class="lineno">  136 </span><span class="spaces">        </span><span class="istickedoff">map (fromIntegral :: Int -&gt; Word8) $ encodeUni uni</span></span>
<span class="lineno">  137 </span>
<span class="lineno">  138 </span>    <span class="decl"><span class="istickedoff">decode = decodeKindedUniFlat &lt;&amp;&gt; \(SomeTypeIn (Kinded uni)) -&gt; SomeTypeIn uni</span></span>
<span class="lineno">  139 </span>
<span class="lineno">  140 </span>    -- Encode a view of the universe, not the universe itself.
<span class="lineno">  141 </span>    <span class="decl"><span class="istickedoff">size (SomeTypeIn uni) acc =</span>
<span class="lineno">  142 </span><span class="spaces">      </span><span class="istickedoff">acc +</span>
<span class="lineno">  143 </span><span class="spaces">      </span><span class="istickedoff">length (encodeUni uni) * (1 + constantWidth) + -- List Cons (1 bit) + constant</span>
<span class="lineno">  144 </span><span class="spaces">      </span><span class="istickedoff">1</span></span> -- List Nil (1 bit)
<span class="lineno">  145 </span>
<span class="lineno">  146 </span>-- See Note [The G, the Tag and the Auto].
<span class="lineno">  147 </span>instance (Closed uni, uni `Everywhere` Flat) =&gt; Flat (Some (ValueOf uni)) where
<span class="lineno">  148 </span>    <span class="decl"><span class="istickedoff">encode (Some (ValueOf uni x)) = encode (SomeTypeIn uni) &lt;&gt; bring <span class="nottickedoff">(Proxy @Flat)</span> uni (encode x)</span></span>
<span class="lineno">  149 </span>
<span class="lineno">  150 </span>    <span class="decl"><span class="istickedoff">decode =</span>
<span class="lineno">  151 </span><span class="spaces">        </span><span class="istickedoff">decodeKindedUniFlat @uni &gt;&gt;= \(SomeTypeIn (Kinded uni)) -&gt;</span>
<span class="lineno">  152 </span><span class="spaces">            </span><span class="istickedoff">-- See Note [Decoding universes].</span>
<span class="lineno">  153 </span><span class="spaces">            </span><span class="istickedoff">case checkStar <span class="nottickedoff">uni</span> of</span>
<span class="lineno">  154 </span><span class="spaces">                </span><span class="istickedoff">Nothing   -&gt; <span class="nottickedoff">fail &quot;A non-star type can't have a value to decode&quot;</span></span>
<span class="lineno">  155 </span><span class="spaces">                </span><span class="istickedoff">Just Refl -&gt; Some . ValueOf uni &lt;$&gt; bring <span class="nottickedoff">(Proxy @Flat)</span> uni decode</span></span>
<span class="lineno">  156 </span>
<span class="lineno">  157 </span>    -- We need to get the flat instance in scope.
<span class="lineno">  158 </span>    <span class="decl"><span class="istickedoff">size (Some (ValueOf uni x)) acc = size (SomeTypeIn uni) acc</span>
<span class="lineno">  159 </span><span class="spaces">                                        </span><span class="istickedoff">+ bring <span class="nottickedoff">(Proxy @Flat)</span> uni (size x 0)</span></span>
<span class="lineno">  160 </span>
<span class="lineno">  161 </span><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">deriving newtype instance Flat Unique</span></span></span></span></span></span> -- via int
<span class="lineno">  162 </span>
<span class="lineno">  163 </span>instance <span class="decl"><span class="istickedoff">Flat Name</span></span> where
<span class="lineno">  164 </span>    <span class="decl"><span class="istickedoff">encode (Name txt u) = encode txt &lt;&gt; encode u</span></span>
<span class="lineno">  165 </span>    <span class="decl"><span class="istickedoff">decode = Name &lt;$&gt; decode &lt;*&gt; decode</span></span>
<span class="lineno">  166 </span>
<span class="lineno">  167 </span><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">deriving newtype instance Flat TyName</span></span></span></span></span></span> -- via Name
<span class="lineno">  168 </span>
<span class="lineno">  169 </span>instance <span class="decl"><span class="istickedoff">Flat Version</span></span> where
<span class="lineno">  170 </span>    <span class="decl"><span class="istickedoff">encode (Version n n' n'') = encode n &lt;&gt; encode n' &lt;&gt; encode n''</span></span>
<span class="lineno">  171 </span>    <span class="decl"><span class="istickedoff">decode = Version &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span></span>
<span class="lineno">  172 </span>
<span class="lineno">  173 </span>-- | Use 1 bit to encode kind tags.
<span class="lineno">  174 </span>kindTagWidth :: NumBits
<span class="lineno">  175 </span><span class="decl"><span class="istickedoff">kindTagWidth = 1</span></span>
<span class="lineno">  176 </span>
<span class="lineno">  177 </span>encodeKind :: Word8 -&gt; Encoding
<span class="lineno">  178 </span><span class="decl"><span class="istickedoff">encodeKind = safeEncodeBits kindTagWidth</span></span>
<span class="lineno">  179 </span>
<span class="lineno">  180 </span>decodeKind :: Get Word8
<span class="lineno">  181 </span><span class="decl"><span class="istickedoff">decodeKind = dBEBits8 kindTagWidth</span></span>
<span class="lineno">  182 </span>
<span class="lineno">  183 </span>instance Flat ann =&gt; Flat (Kind ann) where
<span class="lineno">  184 </span>    <span class="decl"><span class="istickedoff">encode = \case</span>
<span class="lineno">  185 </span><span class="spaces">        </span><span class="istickedoff">Type ann           -&gt; encodeKind 0 &lt;&gt; encode <span class="nottickedoff">ann</span></span>
<span class="lineno">  186 </span><span class="spaces">        </span><span class="istickedoff">KindArrow ann k k' -&gt; encodeKind 1 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode k  &lt;&gt; encode k'</span></span>
<span class="lineno">  187 </span>
<span class="lineno">  188 </span>    <span class="decl"><span class="istickedoff">decode = go =&lt;&lt; decodeKind</span>
<span class="lineno">  189 </span><span class="spaces">        </span><span class="istickedoff">where go 0 = Type      &lt;$&gt; decode</span>
<span class="lineno">  190 </span><span class="spaces">              </span><span class="istickedoff">go 1 = KindArrow &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  191 </span><span class="spaces">              </span><span class="istickedoff">go _ = <span class="nottickedoff">fail &quot;Failed to decode Kind ()&quot;</span></span></span>
<span class="lineno">  192 </span>
<span class="lineno">  193 </span>    <span class="decl"><span class="istickedoff">size tm sz =</span>
<span class="lineno">  194 </span><span class="spaces">      </span><span class="istickedoff">let</span>
<span class="lineno">  195 </span><span class="spaces">        </span><span class="istickedoff">sz' = sz + kindTagWidth</span>
<span class="lineno">  196 </span><span class="spaces">      </span><span class="istickedoff">in case tm of</span>
<span class="lineno">  197 </span><span class="spaces">        </span><span class="istickedoff">Type ann           -&gt; size <span class="nottickedoff">ann</span> sz'</span>
<span class="lineno">  198 </span><span class="spaces">        </span><span class="istickedoff">KindArrow ann k k' -&gt; size <span class="nottickedoff">ann</span> $ size k $ size k' sz'</span></span>
<span class="lineno">  199 </span>
<span class="lineno">  200 </span>-- | Use 3 bits to encode type tags.
<span class="lineno">  201 </span>typeTagWidth :: NumBits
<span class="lineno">  202 </span><span class="decl"><span class="istickedoff">typeTagWidth = 3</span></span>
<span class="lineno">  203 </span>
<span class="lineno">  204 </span>encodeType :: Word8 -&gt; Encoding
<span class="lineno">  205 </span><span class="decl"><span class="istickedoff">encodeType = safeEncodeBits typeTagWidth</span></span>
<span class="lineno">  206 </span>
<span class="lineno">  207 </span>decodeType :: Get Word8
<span class="lineno">  208 </span><span class="decl"><span class="istickedoff">decodeType = dBEBits8 typeTagWidth</span></span>
<span class="lineno">  209 </span>
<span class="lineno">  210 </span>instance (Closed uni, Flat ann, Flat tyname) =&gt; Flat (Type tyname uni ann) where
<span class="lineno">  211 </span>    <span class="decl"><span class="istickedoff">encode = \case</span>
<span class="lineno">  212 </span><span class="spaces">        </span><span class="istickedoff">TyVar     ann tn      -&gt; encodeType 0 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode tn</span>
<span class="lineno">  213 </span><span class="spaces">        </span><span class="istickedoff">TyFun     ann t t'    -&gt; encodeType 1 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode t   &lt;&gt; encode t'</span>
<span class="lineno">  214 </span><span class="spaces">        </span><span class="istickedoff">TyIFix    ann pat arg -&gt; <span class="nottickedoff">encodeType 2 &lt;&gt; encode ann &lt;&gt; encode pat &lt;&gt; encode arg</span></span>
<span class="lineno">  215 </span><span class="spaces">        </span><span class="istickedoff">TyForall  ann tn k t  -&gt; encodeType 3 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode tn  &lt;&gt; encode k &lt;&gt; encode t</span>
<span class="lineno">  216 </span><span class="spaces">        </span><span class="istickedoff">TyBuiltin ann con     -&gt; encodeType 4 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode con</span>
<span class="lineno">  217 </span><span class="spaces">        </span><span class="istickedoff">TyLam     ann n k t   -&gt; encodeType 5 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode n   &lt;&gt; encode k &lt;&gt; encode t</span>
<span class="lineno">  218 </span><span class="spaces">        </span><span class="istickedoff">TyApp     ann t t'    -&gt; encodeType 6 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode t   &lt;&gt; encode t'</span>
<span class="lineno">  219 </span><span class="spaces">        </span><span class="istickedoff">-- Note that this relies on the instance for lists. We shouldn't use this in the</span>
<span class="lineno">  220 </span><span class="spaces">        </span><span class="istickedoff">-- serious on-chain version but it's okay here.</span>
<span class="lineno">  221 </span><span class="spaces">        </span><span class="istickedoff">TySOP    ann tyls     -&gt; encodeType 7 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode tyls</span></span>
<span class="lineno">  222 </span>
<span class="lineno">  223 </span>    <span class="decl"><span class="istickedoff">decode = go =&lt;&lt; decodeType</span>
<span class="lineno">  224 </span><span class="spaces">        </span><span class="istickedoff">where go 0 = TyVar     &lt;$&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  225 </span><span class="spaces">              </span><span class="istickedoff">go 1 = TyFun     &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  226 </span><span class="spaces">              </span><span class="istickedoff">go 2 = TyIFix    &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  227 </span><span class="spaces">              </span><span class="istickedoff">go 3 = TyForall  &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  228 </span><span class="spaces">              </span><span class="istickedoff">go 4 = TyBuiltin &lt;$&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  229 </span><span class="spaces">              </span><span class="istickedoff">go 5 = TyLam     &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  230 </span><span class="spaces">              </span><span class="istickedoff">go 6 = TyApp     &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  231 </span><span class="spaces">              </span><span class="istickedoff">go 7 = TySOP     &lt;$&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  232 </span><span class="spaces">              </span><span class="istickedoff">go _ = <span class="nottickedoff">fail &quot;Failed to decode Type TyName ()&quot;</span></span></span>
<span class="lineno">  233 </span>
<span class="lineno">  234 </span>    <span class="decl"><span class="istickedoff">size tm sz =</span>
<span class="lineno">  235 </span><span class="spaces">      </span><span class="istickedoff">let</span>
<span class="lineno">  236 </span><span class="spaces">        </span><span class="istickedoff">sz' = sz + typeTagWidth</span>
<span class="lineno">  237 </span><span class="spaces">      </span><span class="istickedoff">in case tm of</span>
<span class="lineno">  238 </span><span class="spaces">        </span><span class="istickedoff">TyVar     ann tn      -&gt; size <span class="nottickedoff">ann</span> $ size tn sz'</span>
<span class="lineno">  239 </span><span class="spaces">        </span><span class="istickedoff">TyFun     ann t t'    -&gt; size <span class="nottickedoff">ann</span> $ size t $ size t' sz'</span>
<span class="lineno">  240 </span><span class="spaces">        </span><span class="istickedoff">TyIFix    ann pat arg -&gt; <span class="nottickedoff">size ann $ size pat $ size arg sz'</span></span>
<span class="lineno">  241 </span><span class="spaces">        </span><span class="istickedoff">TyForall  ann tn k t  -&gt; size <span class="nottickedoff">ann</span> $ size tn $ size k $ size t sz'</span>
<span class="lineno">  242 </span><span class="spaces">        </span><span class="istickedoff">TyBuiltin ann con     -&gt; size <span class="nottickedoff">ann</span> $ size con sz'</span>
<span class="lineno">  243 </span><span class="spaces">        </span><span class="istickedoff">TyLam     ann n k t   -&gt; size <span class="nottickedoff">ann</span> $ size n $ size k $ size t sz'</span>
<span class="lineno">  244 </span><span class="spaces">        </span><span class="istickedoff">TyApp     ann t t'    -&gt; size <span class="nottickedoff">ann</span> $ size t $ size t' sz'</span>
<span class="lineno">  245 </span><span class="spaces">        </span><span class="istickedoff">TySOP     ann tyls    -&gt; size <span class="nottickedoff">ann</span> $ size tyls sz'</span></span>
<span class="lineno">  246 </span>
<span class="lineno">  247 </span>termTagWidth :: NumBits
<span class="lineno">  248 </span><span class="decl"><span class="istickedoff">termTagWidth = 4</span></span>
<span class="lineno">  249 </span>
<span class="lineno">  250 </span>encodeTerm :: Word8 -&gt; Encoding
<span class="lineno">  251 </span><span class="decl"><span class="istickedoff">encodeTerm = safeEncodeBits termTagWidth</span></span>
<span class="lineno">  252 </span>
<span class="lineno">  253 </span>decodeTerm :: Get Word8
<span class="lineno">  254 </span><span class="decl"><span class="istickedoff">decodeTerm = dBEBits8 termTagWidth</span></span>
<span class="lineno">  255 </span>
<span class="lineno">  256 </span>instance ( Closed uni
<span class="lineno">  257 </span>         , uni `Everywhere` Flat
<span class="lineno">  258 </span>         , Flat fun
<span class="lineno">  259 </span>         , Flat ann
<span class="lineno">  260 </span>         , Flat tyname
<span class="lineno">  261 </span>         , Flat name
<span class="lineno">  262 </span>         ) =&gt; Flat (Term tyname name uni fun ann) where
<span class="lineno">  263 </span>    <span class="decl"><span class="istickedoff">encode = \case</span>
<span class="lineno">  264 </span><span class="spaces">        </span><span class="istickedoff">Var      ann n         -&gt; encodeTerm 0 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode n</span>
<span class="lineno">  265 </span><span class="spaces">        </span><span class="istickedoff">TyAbs    ann tn k t    -&gt; encodeTerm 1 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode tn  &lt;&gt; encode k   &lt;&gt; encode t</span>
<span class="lineno">  266 </span><span class="spaces">        </span><span class="istickedoff">LamAbs   ann n ty t    -&gt; encodeTerm 2 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode n   &lt;&gt; encode ty  &lt;&gt; encode t</span>
<span class="lineno">  267 </span><span class="spaces">        </span><span class="istickedoff">Apply    ann t t'      -&gt; encodeTerm 3 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode t   &lt;&gt; encode t'</span>
<span class="lineno">  268 </span><span class="spaces">        </span><span class="istickedoff">Constant ann c         -&gt; encodeTerm 4 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode c</span>
<span class="lineno">  269 </span><span class="spaces">        </span><span class="istickedoff">TyInst   ann t ty      -&gt; encodeTerm 5 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode t   &lt;&gt; encode ty</span>
<span class="lineno">  270 </span><span class="spaces">        </span><span class="istickedoff">Unwrap   ann t         -&gt; encodeTerm 6 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode t</span>
<span class="lineno">  271 </span><span class="spaces">        </span><span class="istickedoff">IWrap    ann pat arg t -&gt; encodeTerm 7 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode pat &lt;&gt; encode arg &lt;&gt; encode t</span>
<span class="lineno">  272 </span><span class="spaces">        </span><span class="istickedoff">Error    ann ty        -&gt; encodeTerm 8 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode ty</span>
<span class="lineno">  273 </span><span class="spaces">        </span><span class="istickedoff">Builtin  ann bn        -&gt; encodeTerm 9 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode bn</span>
<span class="lineno">  274 </span><span class="spaces">        </span><span class="istickedoff">Constr   ann ty i es   -&gt;</span>
<span class="lineno">  275 </span><span class="spaces">          </span><span class="istickedoff">encodeTerm 10</span>
<span class="lineno">  276 </span><span class="spaces">          </span><span class="istickedoff">&lt;&gt; encode <span class="nottickedoff">ann</span></span>
<span class="lineno">  277 </span><span class="spaces">          </span><span class="istickedoff">&lt;&gt; encode ty</span>
<span class="lineno">  278 </span><span class="spaces">          </span><span class="istickedoff">&lt;&gt; encode i</span>
<span class="lineno">  279 </span><span class="spaces">          </span><span class="istickedoff">&lt;&gt; encode es</span>
<span class="lineno">  280 </span><span class="spaces">        </span><span class="istickedoff">Case     ann ty arg cs -&gt;</span>
<span class="lineno">  281 </span><span class="spaces">          </span><span class="istickedoff">encodeTerm 11</span>
<span class="lineno">  282 </span><span class="spaces">          </span><span class="istickedoff">&lt;&gt; encode <span class="nottickedoff">ann</span></span>
<span class="lineno">  283 </span><span class="spaces">          </span><span class="istickedoff">&lt;&gt; encode ty</span>
<span class="lineno">  284 </span><span class="spaces">          </span><span class="istickedoff">&lt;&gt; encode arg</span>
<span class="lineno">  285 </span><span class="spaces">          </span><span class="istickedoff">&lt;&gt; encode cs</span></span>
<span class="lineno">  286 </span>
<span class="lineno">  287 </span>    <span class="decl"><span class="istickedoff">decode = go =&lt;&lt; decodeTerm</span>
<span class="lineno">  288 </span><span class="spaces">        </span><span class="istickedoff">where go 0  = Var      &lt;$&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  289 </span><span class="spaces">              </span><span class="istickedoff">go 1  = TyAbs    &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  290 </span><span class="spaces">              </span><span class="istickedoff">go 2  = LamAbs   &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  291 </span><span class="spaces">              </span><span class="istickedoff">go 3  = Apply    &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  292 </span><span class="spaces">              </span><span class="istickedoff">go 4  = Constant &lt;$&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  293 </span><span class="spaces">              </span><span class="istickedoff">go 5  = TyInst   &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  294 </span><span class="spaces">              </span><span class="istickedoff">go 6  = Unwrap   &lt;$&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  295 </span><span class="spaces">              </span><span class="istickedoff">go 7  = IWrap    &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  296 </span><span class="spaces">              </span><span class="istickedoff">go 8  = Error    &lt;$&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  297 </span><span class="spaces">              </span><span class="istickedoff">go 9  = Builtin  &lt;$&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  298 </span><span class="spaces">              </span><span class="istickedoff">go 10 = Constr   &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  299 </span><span class="spaces">              </span><span class="istickedoff">go 11 = Case     &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  300 </span><span class="spaces">              </span><span class="istickedoff">go _  = <span class="nottickedoff">fail &quot;Failed to decode Term TyName Name ()&quot;</span></span></span>
<span class="lineno">  301 </span>
<span class="lineno">  302 </span>    <span class="decl"><span class="istickedoff">size tm sz =</span>
<span class="lineno">  303 </span><span class="spaces">      </span><span class="istickedoff">let</span>
<span class="lineno">  304 </span><span class="spaces">        </span><span class="istickedoff">sz' = termTagWidth + sz</span>
<span class="lineno">  305 </span><span class="spaces">      </span><span class="istickedoff">in case tm of</span>
<span class="lineno">  306 </span><span class="spaces">        </span><span class="istickedoff">Var      ann n         -&gt; size <span class="nottickedoff">ann</span> $ size n sz'</span>
<span class="lineno">  307 </span><span class="spaces">        </span><span class="istickedoff">TyAbs    ann tn k t    -&gt; size <span class="nottickedoff">ann</span> $ size tn $ size k  $ size t sz'</span>
<span class="lineno">  308 </span><span class="spaces">        </span><span class="istickedoff">LamAbs   ann n ty t    -&gt; size <span class="nottickedoff">ann</span> $ size n $ size ty $ size t sz'</span>
<span class="lineno">  309 </span><span class="spaces">        </span><span class="istickedoff">Apply    ann t t'      -&gt; size <span class="nottickedoff">ann</span> $ size t $ size t' sz'</span>
<span class="lineno">  310 </span><span class="spaces">        </span><span class="istickedoff">Constant ann c         -&gt; size <span class="nottickedoff">ann</span> $ size c sz'</span>
<span class="lineno">  311 </span><span class="spaces">        </span><span class="istickedoff">TyInst   ann t ty      -&gt; size <span class="nottickedoff">ann</span> $ size t $ size ty sz'</span>
<span class="lineno">  312 </span><span class="spaces">        </span><span class="istickedoff">Unwrap   ann t         -&gt; size <span class="nottickedoff">ann</span> $ size t sz'</span>
<span class="lineno">  313 </span><span class="spaces">        </span><span class="istickedoff">IWrap    ann pat arg t -&gt; size <span class="nottickedoff">ann</span> $ size pat $ size arg $ size t sz'</span>
<span class="lineno">  314 </span><span class="spaces">        </span><span class="istickedoff">Error    ann ty        -&gt; size <span class="nottickedoff">ann</span> $ size ty sz'</span>
<span class="lineno">  315 </span><span class="spaces">        </span><span class="istickedoff">Builtin  ann bn        -&gt; size <span class="nottickedoff">ann</span> $ size <span class="nottickedoff">bn</span> sz'</span>
<span class="lineno">  316 </span><span class="spaces">        </span><span class="istickedoff">Constr   ann ty i es   -&gt; size <span class="nottickedoff">ann</span> $ size ty $ size i $ size es sz'</span>
<span class="lineno">  317 </span><span class="spaces">        </span><span class="istickedoff">Case     ann ty arg cs -&gt; size <span class="nottickedoff">ann</span> $ size ty $ size arg $ size cs sz'</span></span>
<span class="lineno">  318 </span>
<span class="lineno">  319 </span>instance <span class="decl"><span class="istickedoff">( Closed uni</span>
<span class="lineno">  320 </span><span class="spaces">         </span><span class="istickedoff">, Flat ann</span>
<span class="lineno">  321 </span><span class="spaces">         </span><span class="istickedoff">, Flat tyname</span>
<span class="lineno">  322 </span><span class="spaces">         </span><span class="istickedoff">, Flat name</span>
<span class="lineno">  323 </span><span class="spaces">         </span><span class="istickedoff">) =&gt; Flat (VarDecl tyname name uni ann)</span></span> where
<span class="lineno">  324 </span>    <span class="decl"><span class="istickedoff">encode (VarDecl t name tyname ) = encode <span class="nottickedoff">t</span> &lt;&gt; encode name &lt;&gt; encode tyname</span></span>
<span class="lineno">  325 </span>    <span class="decl"><span class="istickedoff">decode = VarDecl &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span></span>
<span class="lineno">  326 </span>
<span class="lineno">  327 </span>instance <span class="decl"><span class="istickedoff">(Flat ann, Flat tyname)  =&gt; Flat (TyVarDecl tyname ann)</span></span> where
<span class="lineno">  328 </span>    <span class="decl"><span class="istickedoff">encode (TyVarDecl t tyname kind) = encode <span class="nottickedoff">t</span> &lt;&gt; encode tyname &lt;&gt; encode kind</span></span>
<span class="lineno">  329 </span>    <span class="decl"><span class="istickedoff">decode = TyVarDecl &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span></span>
<span class="lineno">  330 </span>
<span class="lineno">  331 </span>instance <span class="decl"><span class="istickedoff">( Flat ann</span>
<span class="lineno">  332 </span><span class="spaces">         </span><span class="istickedoff">, Flat (Term tyname name uni fun ann)</span>
<span class="lineno">  333 </span><span class="spaces">         </span><span class="istickedoff">) =&gt; Flat (Program tyname name uni fun ann)</span></span> where
<span class="lineno">  334 </span>    <span class="decl"><span class="istickedoff">encode (Program ann v t) = encode <span class="nottickedoff">ann</span> &lt;&gt; encode v &lt;&gt; encode t</span></span>
<span class="lineno">  335 </span>    <span class="decl"><span class="istickedoff">decode = Program &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span></span>
<span class="lineno">  336 </span>
<span class="lineno">  337 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving newtype instance (Flat a) =&gt; Flat (Normalized a)</span></span></span></span></span></span>
<span class="lineno">  338 </span>
<span class="lineno">  339 </span>-- See Note [DeBruijn Index serialization]
<span class="lineno">  340 </span><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">deriving newtype instance Flat Index</span></span></span></span></span></span> -- via word64
<span class="lineno">  341 </span>
<span class="lineno">  342 </span><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">deriving newtype instance Flat DeBruijn</span></span></span></span></span></span> -- via index
<span class="lineno">  343 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving newtype instance Flat TyDeBruijn</span></span></span></span></span></span> -- via debruijn
<span class="lineno">  344 </span>
<span class="lineno">  345 </span>instance <span class="decl"><span class="nottickedoff">Flat NamedDeBruijn</span></span> where
<span class="lineno">  346 </span>    <span class="decl"><span class="nottickedoff">encode (NamedDeBruijn txt ix) = encode txt &lt;&gt; encode ix</span></span>
<span class="lineno">  347 </span>    <span class="decl"><span class="istickedoff">decode = NamedDeBruijn &lt;$&gt; decode &lt;*&gt; decode</span></span>
<span class="lineno">  348 </span>
<span class="lineno">  349 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving newtype instance Flat NamedTyDeBruijn</span></span></span></span></span></span> -- via nameddebruijn
<span class="lineno">  350 </span>
<span class="lineno">  351 </span>-- NOTE: the serialization roundtrip holds iff the invariant binder.index==0 holds
<span class="lineno">  352 </span>instance Flat (Binder DeBruijn) where
<span class="lineno">  353 </span>    <span class="decl"><span class="nottickedoff">size _ = id</span></span> -- zero cost
<span class="lineno">  354 </span>    <span class="decl"><span class="istickedoff">encode _ = mempty</span></span>
<span class="lineno">  355 </span>    <span class="decl"><span class="istickedoff">decode = pure $ Binder $ DeBruijn deBruijnInitIndex</span></span>
<span class="lineno">  356 </span>
<span class="lineno">  357 </span>-- (Binder TyDeBruijn) could similarly have a flat instance, but we don't need it.
<span class="lineno">  358 </span>
<span class="lineno">  359 </span><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">deriving newtype instance Flat (Binder Name)</span></span></span></span></span></span>
<span class="lineno">  360 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving newtype instance Flat (Binder TyName)</span></span></span></span></span></span>
<span class="lineno">  361 </span>-- We could use an alternative, manual Flat-serialization of Named(Ty)DeBruijn
<span class="lineno">  362 </span>-- where we store the name only at the binder and the index only at the use-site (Var/TyVar).
<span class="lineno">  363 </span>-- That would be more compact, but we don't need it at the moment.
<span class="lineno">  364 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">deriving newtype instance Flat (Binder NamedDeBruijn)</span></span></span></span></span></span>
<span class="lineno">  365 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving newtype instance Flat (Binder NamedTyDeBruijn)</span></span></span></span></span></span>
<span class="lineno">  366 </span>
<span class="lineno">  367 </span>{- This instance is going via Flat DeBruijn.
<span class="lineno">  368 </span>FakeNamedDeBruijn &lt;-&gt; DeBruijn are isomorphic: we could use iso-deriving package,
<span class="lineno">  369 </span>but we do not need any other isomorphic Flat deriving for the moment.
<span class="lineno">  370 </span>See Note [Why newtype FakeNamedDeBruijn]
<span class="lineno">  371 </span>-}
<span class="lineno">  372 </span>instance Flat FakeNamedDeBruijn where
<span class="lineno">  373 </span>    <span class="decl"><span class="nottickedoff">size = size . fromFake</span></span>
<span class="lineno">  374 </span>    <span class="decl"><span class="nottickedoff">encode = encode . fromFake</span></span>
<span class="lineno">  375 </span>    <span class="decl"><span class="istickedoff">decode =  toFake &lt;$&gt; decode</span></span>
<span class="lineno">  376 </span>
<span class="lineno">  377 </span>{- This instance is going via Flat (Binder DeBruijn) instance.
<span class="lineno">  378 </span>Binder FakeNamedDeBruijn &lt;-&gt; Binder DeBruijn are isomorphic because
<span class="lineno">  379 </span>FakeNamedDeBruijn &lt;-&gt; DeBruijn are isomorphic and Binder is a functor:
<span class="lineno">  380 </span>we could use iso-deriving package,
<span class="lineno">  381 </span>but  we do not need any other isomorphic Flat deriving for the moment.
<span class="lineno">  382 </span>See Note [Why newtype FakeNamedDeBruijn]
<span class="lineno">  383 </span>NOTE: the serialization roundtrip holds iff the invariant binder.index==0 holds
<span class="lineno">  384 </span>-}
<span class="lineno">  385 </span>instance Flat (Binder FakeNamedDeBruijn) where
<span class="lineno">  386 </span>    <span class="decl"><span class="nottickedoff">size = size . fmap fromFake</span></span>
<span class="lineno">  387 </span>    <span class="decl"><span class="nottickedoff">encode = encode . fmap fromFake</span></span>
<span class="lineno">  388 </span>    <span class="decl"><span class="istickedoff">decode =  fmap toFake &lt;$&gt; decode</span></span>

</pre>
</body>
</html>
