<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>-- editorconfig-checker-disable-file
<span class="lineno">    2 </span>{-# LANGUAGE DataKinds #-}
<span class="lineno">    3 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">    4 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">    5 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">    6 </span>{-# LANGUAGE TemplateHaskell #-}
<span class="lineno">    7 </span>{-# LANGUAGE TypeFamilies #-}
<span class="lineno">    8 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">    9 </span>{-# LANGUAGE UndecidableInstances #-}
<span class="lineno">   10 </span>
<span class="lineno">   11 </span>module UntypedPlutusCore.Core.Instance.Flat where
<span class="lineno">   12 </span>
<span class="lineno">   13 </span>import PlutusCore.Pretty
<span class="lineno">   14 </span>import PlutusCore.Version qualified as PLC
<span class="lineno">   15 </span>import PlutusPrelude
<span class="lineno">   16 </span>import UntypedPlutusCore.Core.Instance.Pretty ()
<span class="lineno">   17 </span>import UntypedPlutusCore.Core.Type
<span class="lineno">   18 </span>
<span class="lineno">   19 </span>import Control.Lens
<span class="lineno">   20 </span>import Control.Monad
<span class="lineno">   21 </span>import Data.Vector qualified as V
<span class="lineno">   22 </span>import PlutusCore.Flat
<span class="lineno">   23 </span>import PlutusCore.Flat.Decoder
<span class="lineno">   24 </span>import PlutusCore.Flat.Encoder
<span class="lineno">   25 </span>import PlutusCore.Flat.Encoder.Strict (sizeListWith)
<span class="lineno">   26 </span>import PlutusCore.FlatInstances
<span class="lineno">   27 </span>import Universe
<span class="lineno">   28 </span>
<span class="lineno">   29 </span>{-
<span class="lineno">   30 </span>The definitions in this file rely on some Flat instances defined for typed plutus core.
<span class="lineno">   31 </span>You can find those in PlutusCore.Flat.
<span class="lineno">   32 </span>-}
<span class="lineno">   33 </span>
<span class="lineno">   34 </span>{- Note [Stable encoding of UPLC]
<span class="lineno">   35 </span>READ THIS BEFORE TOUCHING ANYTHING IN THIS FILE
<span class="lineno">   36 </span>
<span class="lineno">   37 </span>We need the encoding of PLC on the blockchain to be *extremely* stable. It *must not* change
<span class="lineno">   38 </span>arbitrarily, otherwise we'll be unable to read back old transactions and validate them.
<span class="lineno">   39 </span>
<span class="lineno">   40 </span>Consequently we don't use the derivable instances of `Flat` for the PLC types that go
<span class="lineno">   41 </span>on the chain.
<span class="lineno">   42 </span>
<span class="lineno">   43 </span>However, the instances in this file *are* constrained by instances for names, type names,
<span class="lineno">   44 </span>and annotations. What's to stop the instances for *those* changing, thus changing
<span class="lineno">   45 </span>the overall encoding on the chain?
<span class="lineno">   46 </span>
<span class="lineno">   47 </span>The answer is that what goes on the chain is *always* a `Program TyName Name ()`. The instances
<span class="lineno">   48 </span>for `TyName` and `Name` are nailed down here, and the instance for `()` is standard.
<span class="lineno">   49 </span>
<span class="lineno">   50 </span>However, having this flexibility allows us to encode e.g. PLC with substantial annotations
<span class="lineno">   51 </span>(like position information) in situation where the stability is *not* critical, such as
<span class="lineno">   52 </span>for testing.
<span class="lineno">   53 </span>-}
<span class="lineno">   54 </span>
<span class="lineno">   55 </span>{- Note [Encoding/decoding UPLC constructor tags using Flat]
<span class="lineno">   56 </span>Flat saves space when compared to CBOR by allowing tags to use the minimum
<span class="lineno">   57 </span>number of bits required for their encoding.
<span class="lineno">   58 </span>
<span class="lineno">   59 </span>This requires specialised encode/decode functions for each constructor
<span class="lineno">   60 </span>that encodes a different number of possibilities. Here is a list of the
<span class="lineno">   61 </span>tags and their used/available encoding possibilities.
<span class="lineno">   62 </span>
<span class="lineno">   63 </span>\** The BELOW table is for UPLC. **
<span class="lineno">   64 </span>
<span class="lineno">   65 </span>\| Data type        | Function          | Bit Width | Total | Used | Remaining |
<span class="lineno">   66 </span>\|------------------|-------------------|-----------|-------|------|-----------|
<span class="lineno">   67 </span>\| default builtins | encodeBuiltin     | 7         | 128   | 54   | 74        |
<span class="lineno">   68 </span>\| Terms            | encodeTerm        | 4         | 16    | 10   | 6         |
<span class="lineno">   69 </span>
<span class="lineno">   70 </span>For format stability we are manually assigning the tag values to the
<span class="lineno">   71 </span>constructors (and we do not use a generic algorithm that may change this order).
<span class="lineno">   72 </span>
<span class="lineno">   73 </span>All encodings use the function `safeEncodeBits :: NumBits -&gt; Word8 -&gt; Encoding`, which encodes
<span class="lineno">   74 </span>at most 8 bits of data, and the first argument specifies how many bits from the 8
<span class="lineno">   75 </span>available are actually used. This function also checks the size of the `Word8`
<span class="lineno">   76 </span>argument at runtime.
<span class="lineno">   77 </span>
<span class="lineno">   78 </span>Flat uses an extra function in its class definition called `size`. Since we want
<span class="lineno">   79 </span>to reserve some space for future data constructors and we don't want to have the
<span class="lineno">   80 </span>sizes desynchronised from the encoding and decoding functions we have manual
<span class="lineno">   81 </span>implementations for them (if they have any constructors reserved for future use).
<span class="lineno">   82 </span>
<span class="lineno">   83 </span>By default, Flat does not use any space to serialise `()`.
<span class="lineno">   84 </span>-}
<span class="lineno">   85 </span>
<span class="lineno">   86 </span>{- Note [Deserialization size limits]
<span class="lineno">   87 </span>In order to prevent people encoding copyright or otherwise illegal data on the chain, we would like to
<span class="lineno">   88 </span>restrict the amount of data that can be controlled in an unrestricted fashion by the user. Fortunately,
<span class="lineno">   89 </span>most of the encoding does no allow much leeway for a user to control its content (when accounting for the
<span class="lineno">   90 </span>structure of the format itself). The main thing to worry about is bytestrings, but even there, the flat
<span class="lineno">   91 </span>encoding of bytestrings is a sequence of 255-byte chunks. This is okay, since user-controlled data will
<span class="lineno">   92 </span>be broken up by the chunk metadata.
<span class="lineno">   93 </span>-}
<span class="lineno">   94 </span>
<span class="lineno">   95 </span>-- | Using 4 bits to encode term tags.
<span class="lineno">   96 </span>termTagWidth :: NumBits
<span class="lineno">   97 </span><span class="decl"><span class="istickedoff">termTagWidth = 4</span></span>
<span class="lineno">   98 </span>
<span class="lineno">   99 </span>encodeTermTag :: Word8 -&gt; Encoding
<span class="lineno">  100 </span><span class="decl"><span class="istickedoff">encodeTermTag = safeEncodeBits termTagWidth</span></span>
<span class="lineno">  101 </span>
<span class="lineno">  102 </span>decodeTermTag :: Get Word8
<span class="lineno">  103 </span><span class="decl"><span class="istickedoff">decodeTermTag = dBEBits8 termTagWidth</span></span>
<span class="lineno">  104 </span>
<span class="lineno">  105 </span>encodeTerm
<span class="lineno">  106 </span>  :: forall name uni fun ann
<span class="lineno">  107 </span>   . ( Closed uni
<span class="lineno">  108 </span>     , uni `Everywhere` Flat
<span class="lineno">  109 </span>     , Flat fun
<span class="lineno">  110 </span>     , Flat ann
<span class="lineno">  111 </span>     , Flat name
<span class="lineno">  112 </span>     , Flat (Binder name)
<span class="lineno">  113 </span>     )
<span class="lineno">  114 </span>  =&gt; Term name uni fun ann
<span class="lineno">  115 </span>  -&gt; Encoding
<span class="lineno">  116 </span><span class="decl"><span class="istickedoff">encodeTerm = \case</span>
<span class="lineno">  117 </span><span class="spaces">  </span><span class="istickedoff">Var ann n -&gt; encodeTermTag 0 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode n</span>
<span class="lineno">  118 </span><span class="spaces">  </span><span class="istickedoff">Delay ann t -&gt; encodeTermTag 1 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encodeTerm t</span>
<span class="lineno">  119 </span><span class="spaces">  </span><span class="istickedoff">LamAbs ann n t -&gt; encodeTermTag 2 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode (Binder n) &lt;&gt; encodeTerm t</span>
<span class="lineno">  120 </span><span class="spaces">  </span><span class="istickedoff">Apply ann t t' -&gt; encodeTermTag 3 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encodeTerm t &lt;&gt; encodeTerm t'</span>
<span class="lineno">  121 </span><span class="spaces">  </span><span class="istickedoff">Constant ann c -&gt; encodeTermTag 4 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode c</span>
<span class="lineno">  122 </span><span class="spaces">  </span><span class="istickedoff">Force ann t -&gt; encodeTermTag 5 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encodeTerm t</span>
<span class="lineno">  123 </span><span class="spaces">  </span><span class="istickedoff">Error ann -&gt; encodeTermTag 6 &lt;&gt; encode <span class="nottickedoff">ann</span></span>
<span class="lineno">  124 </span><span class="spaces">  </span><span class="istickedoff">Builtin ann bn -&gt; encodeTermTag 7 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode bn</span>
<span class="lineno">  125 </span><span class="spaces">  </span><span class="istickedoff">Constr ann i es -&gt; encodeTermTag 8 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode i &lt;&gt; encodeListWith encodeTerm es</span>
<span class="lineno">  126 </span><span class="spaces">  </span><span class="istickedoff">Case ann arg cs -&gt; encodeTermTag 9 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encodeTerm arg &lt;&gt; encodeListWith encodeTerm (V.toList cs)</span></span>
<span class="lineno">  127 </span>
<span class="lineno">  128 </span>decodeTerm
<span class="lineno">  129 </span>  :: forall name uni fun ann
<span class="lineno">  130 </span>   . ( Closed uni
<span class="lineno">  131 </span>     , uni `Everywhere` Flat
<span class="lineno">  132 </span>     , Flat fun
<span class="lineno">  133 </span>     , Flat ann
<span class="lineno">  134 </span>     , Flat name
<span class="lineno">  135 </span>     , Flat (Binder name)
<span class="lineno">  136 </span>     )
<span class="lineno">  137 </span>  =&gt; Version
<span class="lineno">  138 </span>  -&gt; (fun -&gt; Maybe String)
<span class="lineno">  139 </span>  -&gt; Get (Term name uni fun ann)
<span class="lineno">  140 </span><span class="decl"><span class="istickedoff">decodeTerm version builtinPred = go</span>
<span class="lineno">  141 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  142 </span><span class="spaces">    </span><span class="istickedoff">go = handleTerm =&lt;&lt; decodeTermTag</span>
<span class="lineno">  143 </span><span class="spaces">    </span><span class="istickedoff">handleTerm 0 = Var &lt;$&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  144 </span><span class="spaces">    </span><span class="istickedoff">handleTerm 1 = Delay &lt;$&gt; decode &lt;*&gt; go</span>
<span class="lineno">  145 </span><span class="spaces">    </span><span class="istickedoff">handleTerm 2 = LamAbs &lt;$&gt; decode &lt;*&gt; (unBinder &lt;$&gt; decode) &lt;*&gt; go</span>
<span class="lineno">  146 </span><span class="spaces">    </span><span class="istickedoff">handleTerm 3 = Apply &lt;$&gt; decode &lt;*&gt; go &lt;*&gt; go</span>
<span class="lineno">  147 </span><span class="spaces">    </span><span class="istickedoff">handleTerm 4 = Constant &lt;$&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  148 </span><span class="spaces">    </span><span class="istickedoff">handleTerm 5 = Force &lt;$&gt; decode &lt;*&gt; go</span>
<span class="lineno">  149 </span><span class="spaces">    </span><span class="istickedoff">handleTerm 6 = Error &lt;$&gt; decode</span>
<span class="lineno">  150 </span><span class="spaces">    </span><span class="istickedoff">handleTerm 7 = do</span>
<span class="lineno">  151 </span><span class="spaces">      </span><span class="istickedoff">ann &lt;- decode</span>
<span class="lineno">  152 </span><span class="spaces">      </span><span class="istickedoff">fun &lt;- decode</span>
<span class="lineno">  153 </span><span class="spaces">      </span><span class="istickedoff">let t :: Term name uni fun ann</span>
<span class="lineno">  154 </span><span class="spaces">          </span><span class="istickedoff">t = Builtin ann fun</span>
<span class="lineno">  155 </span><span class="spaces">      </span><span class="istickedoff">case builtinPred fun of</span>
<span class="lineno">  156 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; pure t</span>
<span class="lineno">  157 </span><span class="spaces">        </span><span class="istickedoff">Just e -&gt; fail <span class="nottickedoff">e</span></span>
<span class="lineno">  158 </span><span class="spaces">    </span><span class="istickedoff">handleTerm 8 = do</span>
<span class="lineno">  159 </span><span class="spaces">      </span><span class="istickedoff">unless (version &gt;= PLC.plcVersion110) $ fail $ <span class="nottickedoff">&quot;'constr' is not allowed before version 1.1.0, this program has version: &quot; ++ (show $ pretty version)</span></span>
<span class="lineno">  160 </span><span class="spaces">      </span><span class="istickedoff">Constr &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decodeListWith go</span>
<span class="lineno">  161 </span><span class="spaces">    </span><span class="istickedoff">handleTerm 9 = do</span>
<span class="lineno">  162 </span><span class="spaces">      </span><span class="istickedoff">unless (version &gt;= PLC.plcVersion110) $ fail $ <span class="nottickedoff">&quot;'case' is not allowed before version 1.1.0, this program has version: &quot; ++ (show $ pretty version)</span></span>
<span class="lineno">  163 </span><span class="spaces">      </span><span class="istickedoff">Case &lt;$&gt; decode &lt;*&gt; go &lt;*&gt; (V.fromList &lt;$&gt; decodeListWith go)</span>
<span class="lineno">  164 </span><span class="spaces">    </span><span class="istickedoff">handleTerm t = <span class="nottickedoff">fail $ &quot;Unknown term constructor tag: &quot; ++ show t</span></span></span>
<span class="lineno">  165 </span>
<span class="lineno">  166 </span>sizeTerm
<span class="lineno">  167 </span>  :: forall name uni fun ann
<span class="lineno">  168 </span>   . ( Closed uni
<span class="lineno">  169 </span>     , uni `Everywhere` Flat
<span class="lineno">  170 </span>     , Flat fun
<span class="lineno">  171 </span>     , Flat ann
<span class="lineno">  172 </span>     , Flat name
<span class="lineno">  173 </span>     , Flat (Binder name)
<span class="lineno">  174 </span>     )
<span class="lineno">  175 </span>  =&gt; Term name uni fun ann
<span class="lineno">  176 </span>  -&gt; NumBits
<span class="lineno">  177 </span>  -&gt; NumBits
<span class="lineno">  178 </span><span class="decl"><span class="istickedoff">sizeTerm tm sz =</span>
<span class="lineno">  179 </span><span class="spaces">  </span><span class="istickedoff">let</span>
<span class="lineno">  180 </span><span class="spaces">    </span><span class="istickedoff">sz' = termTagWidth + sz</span>
<span class="lineno">  181 </span><span class="spaces">   </span><span class="istickedoff">in</span>
<span class="lineno">  182 </span><span class="spaces">    </span><span class="istickedoff">case tm of</span>
<span class="lineno">  183 </span><span class="spaces">      </span><span class="istickedoff">Var ann n -&gt; size <span class="nottickedoff">ann</span> $ size n sz'</span>
<span class="lineno">  184 </span><span class="spaces">      </span><span class="istickedoff">Delay ann t -&gt; size <span class="nottickedoff">ann</span> $ sizeTerm t sz'</span>
<span class="lineno">  185 </span><span class="spaces">      </span><span class="istickedoff">LamAbs ann n t -&gt; size <span class="nottickedoff">ann</span> $ size n $ sizeTerm t sz'</span>
<span class="lineno">  186 </span><span class="spaces">      </span><span class="istickedoff">Apply ann t t' -&gt; size <span class="nottickedoff">ann</span> $ sizeTerm t $ sizeTerm t' sz'</span>
<span class="lineno">  187 </span><span class="spaces">      </span><span class="istickedoff">Constant ann c -&gt; size <span class="nottickedoff">ann</span> $ size c sz'</span>
<span class="lineno">  188 </span><span class="spaces">      </span><span class="istickedoff">Force ann t -&gt; size <span class="nottickedoff">ann</span> $ sizeTerm t sz'</span>
<span class="lineno">  189 </span><span class="spaces">      </span><span class="istickedoff">Error ann -&gt; size <span class="nottickedoff">ann</span> sz'</span>
<span class="lineno">  190 </span><span class="spaces">      </span><span class="istickedoff">Builtin ann bn -&gt; size <span class="nottickedoff">ann</span> $ size <span class="nottickedoff">bn</span> sz'</span>
<span class="lineno">  191 </span><span class="spaces">      </span><span class="istickedoff">Constr ann i es -&gt; size <span class="nottickedoff">ann</span> $ size i $ sizeListWith sizeTerm es sz'</span>
<span class="lineno">  192 </span><span class="spaces">      </span><span class="istickedoff">Case ann arg cs -&gt; size <span class="nottickedoff">ann</span> $ sizeTerm arg $ sizeListWith sizeTerm (V.toList cs) sz'</span></span>
<span class="lineno">  193 </span>
<span class="lineno">  194 </span>{-| An encoder for programs.
<span class="lineno">  195 </span>
<span class="lineno">  196 </span>It is not easy to use this correctly with @flat@. The simplest thing
<span class="lineno">  197 </span>is to go via the instance for 'UnrestrictedProgram', which uses this -}
<span class="lineno">  198 </span>encodeProgram
<span class="lineno">  199 </span>  :: forall name uni fun ann
<span class="lineno">  200 </span>   . ( Closed uni
<span class="lineno">  201 </span>     , uni `Everywhere` Flat
<span class="lineno">  202 </span>     , Flat fun
<span class="lineno">  203 </span>     , Flat ann
<span class="lineno">  204 </span>     , Flat name
<span class="lineno">  205 </span>     , Flat (Binder name)
<span class="lineno">  206 </span>     )
<span class="lineno">  207 </span>  =&gt; Program name uni fun ann
<span class="lineno">  208 </span>  -&gt; Encoding
<span class="lineno">  209 </span><span class="decl"><span class="istickedoff">encodeProgram (Program ann v t) = encode <span class="nottickedoff">ann</span> &lt;&gt; encode v &lt;&gt; encodeTerm t</span></span>
<span class="lineno">  210 </span>
<span class="lineno">  211 </span>decodeProgram
<span class="lineno">  212 </span>  :: forall name uni fun ann
<span class="lineno">  213 </span>   . ( Closed uni
<span class="lineno">  214 </span>     , uni `Everywhere` Flat
<span class="lineno">  215 </span>     , Flat fun
<span class="lineno">  216 </span>     , Flat ann
<span class="lineno">  217 </span>     , Flat name
<span class="lineno">  218 </span>     , Flat (Binder name)
<span class="lineno">  219 </span>     )
<span class="lineno">  220 </span>  =&gt; (fun -&gt; Maybe String)
<span class="lineno">  221 </span>  -&gt; Get (Program name uni fun ann)
<span class="lineno">  222 </span><span class="decl"><span class="istickedoff">decodeProgram builtinPred = do</span>
<span class="lineno">  223 </span><span class="spaces">  </span><span class="istickedoff">ann &lt;- decode</span>
<span class="lineno">  224 </span><span class="spaces">  </span><span class="istickedoff">v &lt;- decode</span>
<span class="lineno">  225 </span><span class="spaces">  </span><span class="istickedoff">Program ann v &lt;$&gt; decodeTerm v builtinPred</span></span>
<span class="lineno">  226 </span>
<span class="lineno">  227 </span>sizeProgram
<span class="lineno">  228 </span>  :: forall name uni fun ann
<span class="lineno">  229 </span>   . ( Closed uni
<span class="lineno">  230 </span>     , uni `Everywhere` Flat
<span class="lineno">  231 </span>     , Flat fun
<span class="lineno">  232 </span>     , Flat ann
<span class="lineno">  233 </span>     , Flat name
<span class="lineno">  234 </span>     , Flat (Binder name)
<span class="lineno">  235 </span>     )
<span class="lineno">  236 </span>  =&gt; Program name uni fun ann
<span class="lineno">  237 </span>  -&gt; NumBits
<span class="lineno">  238 </span>  -&gt; NumBits
<span class="lineno">  239 </span><span class="decl"><span class="istickedoff">sizeProgram (Program ann v t) sz = size <span class="nottickedoff">ann</span> $ size v $ sizeTerm t sz</span></span>
<span class="lineno">  240 </span>
<span class="lineno">  241 </span>{-| A program that can be serialized without any restrictions, e.g.
<span class="lineno">  242 </span>on the set of allowable builtins or term constructs. It is generally
<span class="lineno">  243 </span>safe to use this newtype for serializing, but it should only be used
<span class="lineno">  244 </span>for deserializing in tests. -}
<span class="lineno">  245 </span>newtype UnrestrictedProgram name uni fun ann = UnrestrictedProgram {<span class="istickedoff"><span class="decl"><span class="istickedoff">unUnrestrictedProgram</span></span></span> :: Program name uni fun ann}
<span class="lineno">  246 </span>  deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Functor</span></span></span></span>)
<span class="lineno">  247 </span>
<span class="lineno">  248 </span><span class="nottickedoff"><span class="decl"><span class="nottickedoff">makeWrapped ''UnrestrictedProgram</span></span></span>
<span class="lineno">  249 </span>
<span class="lineno">  250 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving newtype instance</span>
<span class="lineno">  251 </span><span class="spaces">  </span><span class="nottickedoff">(Show name, GShow uni, Everywhere uni Show, Show fun, Show ann, Closed uni)</span>
<span class="lineno">  252 </span><span class="spaces">  </span><span class="nottickedoff">=&gt; Show (UnrestrictedProgram name uni fun ann)</span></span></span></span></span></span>
<span class="lineno">  253 </span>
<span class="lineno">  254 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving via</span>
<span class="lineno">  255 </span><span class="spaces">  </span><span class="nottickedoff">PrettyAny (UnrestrictedProgram name uni fun ann)</span>
<span class="lineno">  256 </span><span class="spaces">  </span><span class="nottickedoff">instance</span>
<span class="lineno">  257 </span><span class="spaces">    </span><span class="nottickedoff">DefaultPrettyPlcStrategy (UnrestrictedProgram name uni fun ann)</span>
<span class="lineno">  258 </span><span class="spaces">    </span><span class="nottickedoff">=&gt; PrettyBy PrettyConfigPlc (UnrestrictedProgram name uni fun ann)</span></span></span></span>
<span class="lineno">  259 </span>
<span class="lineno">  260 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving newtype instance</span>
<span class="lineno">  261 </span><span class="spaces">  </span><span class="nottickedoff">(PrettyClassic name, PrettyUni uni, Pretty fun, Pretty ann)</span>
<span class="lineno">  262 </span><span class="spaces">  </span><span class="nottickedoff">=&gt; PrettyBy (PrettyConfigClassic PrettyConfigName) (UnrestrictedProgram name uni fun ann)</span></span></span></span>
<span class="lineno">  263 </span>
<span class="lineno">  264 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving newtype instance</span>
<span class="lineno">  265 </span><span class="spaces">  </span><span class="nottickedoff">(PrettyReadable name, PrettyUni uni, Pretty fun)</span>
<span class="lineno">  266 </span><span class="spaces">  </span><span class="nottickedoff">=&gt; PrettyBy (PrettyConfigReadable PrettyConfigName) (UnrestrictedProgram name uni fun ann)</span></span></span></span>
<span class="lineno">  267 </span>
<span class="lineno">  268 </span>-- This instance does _not_ check for allowable builtins
<span class="lineno">  269 </span>instance
<span class="lineno">  270 </span>  ( Closed uni
<span class="lineno">  271 </span>  , uni `Everywhere` Flat
<span class="lineno">  272 </span>  , Flat fun
<span class="lineno">  273 </span>  , Flat ann
<span class="lineno">  274 </span>  , Flat name
<span class="lineno">  275 </span>  , Flat (Binder name)
<span class="lineno">  276 </span>  )
<span class="lineno">  277 </span>  =&gt; Flat (UnrestrictedProgram name uni fun ann)
<span class="lineno">  278 </span>  where
<span class="lineno">  279 </span>  <span class="decl"><span class="istickedoff">encode (UnrestrictedProgram p) = encodeProgram p</span></span>
<span class="lineno">  280 </span>  <span class="decl"><span class="istickedoff">decode = UnrestrictedProgram &lt;$&gt; decodeProgram (const Nothing)</span></span>
<span class="lineno">  281 </span>
<span class="lineno">  282 </span>  <span class="decl"><span class="istickedoff">size (UnrestrictedProgram p) = sizeProgram p</span></span>

</pre>
</body>
</html>
