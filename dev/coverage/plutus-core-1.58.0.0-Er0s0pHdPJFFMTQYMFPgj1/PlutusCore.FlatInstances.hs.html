<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">    2 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">    3 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">    4 </span>{-# LANGUAGE StandaloneDeriving #-}
<span class="lineno">    5 </span>{-# LANGUAGE TypeApplications #-}
<span class="lineno">    6 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">    7 </span>{-# LANGUAGE UndecidableInstances #-}
<span class="lineno">    8 </span>{-# OPTIONS_GHC -fno-warn-orphans #-}
<span class="lineno">    9 </span>
<span class="lineno">   10 </span>{-| Flat instances for Plutus Core types. Make sure to read Note [Stable
<span class="lineno">   11 </span>encoding of TPLC] and Note [Stable encoding of UPLC] before touching anything
<span class="lineno">   12 </span>in this file. -}
<span class="lineno">   13 </span>module PlutusCore.FlatInstances
<span class="lineno">   14 </span>  ( safeEncodeBits
<span class="lineno">   15 </span>  ) where
<span class="lineno">   16 </span>
<span class="lineno">   17 </span>import Codec.Extras.FlatViaSerialise
<span class="lineno">   18 </span>import PlutusCore.Core
<span class="lineno">   19 </span>import PlutusCore.Data (Data)
<span class="lineno">   20 </span>import PlutusCore.DeBruijn
<span class="lineno">   21 </span>import PlutusCore.Name.Unique
<span class="lineno">   22 </span>
<span class="lineno">   23 </span>import Data.Proxy
<span class="lineno">   24 </span>import PlutusCore.Flat
<span class="lineno">   25 </span>import PlutusCore.Flat.Decoder
<span class="lineno">   26 </span>import PlutusCore.Flat.Encoder
<span class="lineno">   27 </span>import PlutusPrelude
<span class="lineno">   28 </span>import Universe
<span class="lineno">   29 </span>
<span class="lineno">   30 </span>{- Note [Stable encoding of TPLC]
<span class="lineno">   31 </span>READ THIS BEFORE TOUCHING ANYTHING IN THIS FILE
<span class="lineno">   32 </span>
<span class="lineno">   33 </span>We need the encoding of PLC on the blockchain to be *extremely* stable. It *must not* change
<span class="lineno">   34 </span>arbitrarily, otherwise we'll be unable to read back old transactions and validate them.
<span class="lineno">   35 </span>
<span class="lineno">   36 </span>Consequently we don't use the derivable instances of `Flat` for the PLC types that go
<span class="lineno">   37 </span>on the chain.
<span class="lineno">   38 </span>
<span class="lineno">   39 </span>However, the instances in this file *are* constrained by instances for names, type names,
<span class="lineno">   40 </span>and annotations. What's to stop the instances for *those* changing, thus changing
<span class="lineno">   41 </span>the overall encoding on the chain?
<span class="lineno">   42 </span>
<span class="lineno">   43 </span>The answer is that what goes on the chain is *always* a `Program TyName Name ()`. The instances
<span class="lineno">   44 </span>for `TyName` and `Name` are nailed down here, and the instance for `()` is standard.
<span class="lineno">   45 </span>
<span class="lineno">   46 </span>However, having this flexibility allows us to encode e.g. PLC with substantial annotations
<span class="lineno">   47 </span>(like position information) in situation where the stability is *not* critical, such as
<span class="lineno">   48 </span>for testing.
<span class="lineno">   49 </span>-}
<span class="lineno">   50 </span>
<span class="lineno">   51 </span>{- Note [Encoding/decoding TPLC constructor tags using Flat]
<span class="lineno">   52 </span>Flat saves space when compared to CBOR by allowing tags to use the minimum
<span class="lineno">   53 </span>number of bits required for their encoding.
<span class="lineno">   54 </span>
<span class="lineno">   55 </span>This requires specialised encode/decode functions for each constructor
<span class="lineno">   56 </span>that encodes a different number of possibilities. Here is a list of the
<span class="lineno">   57 </span>tags and their used/available encoding possibilities.
<span class="lineno">   58 </span>
<span class="lineno">   59 </span>\** The BELOW table is about Typed-PLC and not UPLC. See `UntypedPlutusCore.Core.Instance.Flat`**
<span class="lineno">   60 </span>
<span class="lineno">   61 </span>\| Data type        | Function          | Bit Width | Total | Used | Remaining |
<span class="lineno">   62 </span>\|------------------|-------------------|-----------|-------|------|-----------|
<span class="lineno">   63 </span>\| default builtins | encodeBuiltin     | 7         | 128   | 54   | 74        |
<span class="lineno">   64 </span>\| Kinds            | encodeKind        | 1         | 2     | 2    | 0         |
<span class="lineno">   65 </span>\| Types            | encodeType        | 3         | 8     | 7    | 1         |
<span class="lineno">   66 </span>\| Terms            | encodeTerm        | 4         | 16    | 12   | 4         |
<span class="lineno">   67 </span>
<span class="lineno">   68 </span>For format stability we are manually assigning the tag values to the
<span class="lineno">   69 </span>constructors (and we do not use a generic algorithm that may change this order).
<span class="lineno">   70 </span>
<span class="lineno">   71 </span>All encodings use the function `safeEncodeBits :: NumBits -&gt; Word8 -&gt; Encoding`, which encodes
<span class="lineno">   72 </span>at most 8 bits of data, and the first argument specifies how many bits from the 8
<span class="lineno">   73 </span>available are actually used. This function also checks the size of the `Word8`
<span class="lineno">   74 </span>argument at runtime.
<span class="lineno">   75 </span>
<span class="lineno">   76 </span>Flat uses an extra function in its class definition called `size`. Since we want
<span class="lineno">   77 </span>to reserve some space for future data constructors and we don't want to have the
<span class="lineno">   78 </span>sizes desynchronised from the encoding and decoding functions we have manual
<span class="lineno">   79 </span>implementations for them (if they have any constructors reserved for future use).
<span class="lineno">   80 </span>
<span class="lineno">   81 </span>By default, Flat does not use any space to serialise `()`.
<span class="lineno">   82 </span>-}
<span class="lineno">   83 </span>
<span class="lineno">   84 </span>{- Note [DeBruijn Index serialization]
<span class="lineno">   85 </span>
<span class="lineno">   86 </span>Back in the days, `Index` was a Natural and we flat (de)-serialized it via Natural.
<span class="lineno">   87 </span>Later `Index` was changed to Word64 (for performance reasons):
<span class="lineno">   88 </span>its flat encoding remained via Natural,
<span class="lineno">   89 </span>but its decoding was changed to a *custom* Word64 decoder.
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>Why custom decoder: there was a bug in Word64 decoder of flat versions &lt;0.5.2 and
<span class="lineno">   92 </span>fixed in flat&gt;=0.5.2.
<span class="lineno">   93 </span>
<span class="lineno">   94 </span>We are now running flat&gt;=0.6, so we switch to the non-custom, fixed flat Word64 decoder.
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>Since we are there, we also switch the encoder of Index from the Natural encoder
<span class="lineno">   97 </span>to Word64 encoder. This encoding change only breaks client-code and not nodes' behavior:
<span class="lineno">   98 </span>the script would just fail earlier at encoding phase (in the client's software)
<span class="lineno">   99 </span>than the later decoding phase (when trying to send the encoded script to the node network and
<span class="lineno">  100 </span>only get back a decoding error, aka phase-1 validation error).
<span class="lineno">  101 </span>This phase-1 validation is in place both for normal (locked scripts) and for inline scripts,
<span class="lineno">  102 </span>so the nodes' behavior does not change.
<span class="lineno">  103 </span>-}
<span class="lineno">  104 </span>
<span class="lineno">  105 </span>safeEncodeBits :: NumBits -&gt; Word8 -&gt; Encoding
<span class="lineno">  106 </span><span class="decl"><span class="istickedoff">safeEncodeBits maxBits v =</span>
<span class="lineno">  107 </span><span class="spaces">  </span><span class="istickedoff">if <span class="tickonlyfalse">2 ^ maxBits &lt;= v</span></span>
<span class="lineno">  108 </span><span class="spaces">    </span><span class="istickedoff">then</span>
<span class="lineno">  109 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">error $</span></span>
<span class="lineno">  110 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">&quot;Overflow detected, cannot fit &quot;</span></span>
<span class="lineno">  111 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&lt;&gt; show v</span></span>
<span class="lineno">  112 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&lt;&gt; &quot; in &quot;</span></span>
<span class="lineno">  113 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&lt;&gt; show maxBits</span></span>
<span class="lineno">  114 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&lt;&gt; &quot; bits.&quot;</span></span>
<span class="lineno">  115 </span><span class="spaces">    </span><span class="istickedoff">else eBits maxBits v</span></span>
<span class="lineno">  116 </span>
<span class="lineno">  117 </span>constantWidth :: NumBits
<span class="lineno">  118 </span><span class="decl"><span class="istickedoff">constantWidth = 4</span></span>
<span class="lineno">  119 </span>
<span class="lineno">  120 </span>encodeConstant :: Word8 -&gt; Encoding
<span class="lineno">  121 </span><span class="decl"><span class="istickedoff">encodeConstant = safeEncodeBits constantWidth</span></span>
<span class="lineno">  122 </span>
<span class="lineno">  123 </span>decodeConstant :: Get Word8
<span class="lineno">  124 </span><span class="decl"><span class="istickedoff">decodeConstant = dBEBits8 constantWidth</span></span>
<span class="lineno">  125 </span>
<span class="lineno">  126 </span><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">deriving via FlatViaSerialise Data instance Flat Data</span></span></span></span></span></span>
<span class="lineno">  127 </span>
<span class="lineno">  128 </span>decodeKindedUniFlat :: Closed uni =&gt; Get (SomeTypeIn (Kinded uni))
<span class="lineno">  129 </span><span class="decl"><span class="istickedoff">decodeKindedUniFlat =</span>
<span class="lineno">  130 </span><span class="spaces">  </span><span class="istickedoff">go . decodeKindedUni . map (fromIntegral :: Word8 -&gt; Int)</span>
<span class="lineno">  131 </span><span class="spaces">    </span><span class="istickedoff">=&lt;&lt; decodeListWith decodeConstant</span>
<span class="lineno">  132 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  133 </span><span class="spaces">    </span><span class="istickedoff">go Nothing = <span class="nottickedoff">fail &quot;Failed to decode a universe&quot;</span></span>
<span class="lineno">  134 </span><span class="spaces">    </span><span class="istickedoff">go (Just uni) = pure uni</span></span>
<span class="lineno">  135 </span>
<span class="lineno">  136 </span>-- See Note [The G, the Tag and the Auto].
<span class="lineno">  137 </span>instance Closed uni =&gt; Flat (SomeTypeIn uni) where
<span class="lineno">  138 </span>  <span class="decl"><span class="istickedoff">encode (SomeTypeIn uni) =</span>
<span class="lineno">  139 </span><span class="spaces">    </span><span class="istickedoff">encodeListWith encodeConstant</span>
<span class="lineno">  140 </span><span class="spaces">      </span><span class="istickedoff">. map (fromIntegral :: Int -&gt; Word8)</span>
<span class="lineno">  141 </span><span class="spaces">      </span><span class="istickedoff">$ encodeUni uni</span></span>
<span class="lineno">  142 </span>
<span class="lineno">  143 </span>  <span class="decl"><span class="istickedoff">decode = decodeKindedUniFlat &lt;&amp;&gt; \(SomeTypeIn (Kinded uni)) -&gt; SomeTypeIn uni</span></span>
<span class="lineno">  144 </span>
<span class="lineno">  145 </span>  -- Encode a view of the universe, not the universe itself.
<span class="lineno">  146 </span>  <span class="decl"><span class="istickedoff">size (SomeTypeIn uni) acc =</span>
<span class="lineno">  147 </span><span class="spaces">    </span><span class="istickedoff">acc</span>
<span class="lineno">  148 </span><span class="spaces">      </span><span class="istickedoff">+ length (encodeUni uni) * (1 + constantWidth)</span>
<span class="lineno">  149 </span><span class="spaces">      </span><span class="istickedoff">+ 1</span></span> -- List Cons (1 bit) + constant
<span class="lineno">  150 </span>      -- List Nil (1 bit)
<span class="lineno">  151 </span>
<span class="lineno">  152 </span>-- See Note [The G, the Tag and the Auto].
<span class="lineno">  153 </span>instance (Closed uni, uni `Everywhere` Flat) =&gt; Flat (Some (ValueOf uni)) where
<span class="lineno">  154 </span>  <span class="decl"><span class="istickedoff">encode (Some (ValueOf uni x)) = encode (SomeTypeIn uni) &lt;&gt; bring <span class="nottickedoff">(Proxy @Flat)</span> uni (encode x)</span></span>
<span class="lineno">  155 </span>
<span class="lineno">  156 </span>  <span class="decl"><span class="istickedoff">decode =</span>
<span class="lineno">  157 </span><span class="spaces">    </span><span class="istickedoff">decodeKindedUniFlat @uni &gt;&gt;= \(SomeTypeIn (Kinded uni)) -&gt;</span>
<span class="lineno">  158 </span><span class="spaces">      </span><span class="istickedoff">-- See Note [Decoding universes].</span>
<span class="lineno">  159 </span><span class="spaces">      </span><span class="istickedoff">case checkStar <span class="nottickedoff">uni</span> of</span>
<span class="lineno">  160 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail &quot;A non-star type can't have a value to decode&quot;</span></span>
<span class="lineno">  161 </span><span class="spaces">        </span><span class="istickedoff">Just Refl -&gt; Some . ValueOf uni &lt;$&gt; bring <span class="nottickedoff">(Proxy @Flat)</span> uni decode</span></span>
<span class="lineno">  162 </span>
<span class="lineno">  163 </span>  -- We need to get the flat instance in scope.
<span class="lineno">  164 </span>  <span class="decl"><span class="istickedoff">size (Some (ValueOf uni x)) acc =</span>
<span class="lineno">  165 </span><span class="spaces">    </span><span class="istickedoff">size (SomeTypeIn uni) acc</span>
<span class="lineno">  166 </span><span class="spaces">      </span><span class="istickedoff">+ bring <span class="nottickedoff">(Proxy @Flat)</span> uni (size x 0)</span></span>
<span class="lineno">  167 </span>
<span class="lineno">  168 </span><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">deriving newtype instance Flat Unique</span></span></span></span></span></span> -- via int
<span class="lineno">  169 </span>
<span class="lineno">  170 </span>instance <span class="decl"><span class="istickedoff">Flat Name</span></span> where
<span class="lineno">  171 </span>  <span class="decl"><span class="istickedoff">encode (Name txt u) = encode txt &lt;&gt; encode u</span></span>
<span class="lineno">  172 </span>  <span class="decl"><span class="istickedoff">decode = Name &lt;$&gt; decode &lt;*&gt; decode</span></span>
<span class="lineno">  173 </span>
<span class="lineno">  174 </span><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">deriving newtype instance Flat TyName</span></span></span></span></span></span> -- via Name
<span class="lineno">  175 </span>
<span class="lineno">  176 </span>instance <span class="decl"><span class="istickedoff">Flat Version</span></span> where
<span class="lineno">  177 </span>  <span class="decl"><span class="istickedoff">encode (Version n n' n'') = encode n &lt;&gt; encode n' &lt;&gt; encode n''</span></span>
<span class="lineno">  178 </span>  <span class="decl"><span class="istickedoff">decode = Version &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span></span>
<span class="lineno">  179 </span>
<span class="lineno">  180 </span>-- | Use 1 bit to encode kind tags.
<span class="lineno">  181 </span>kindTagWidth :: NumBits
<span class="lineno">  182 </span><span class="decl"><span class="istickedoff">kindTagWidth = 1</span></span>
<span class="lineno">  183 </span>
<span class="lineno">  184 </span>encodeKind :: Word8 -&gt; Encoding
<span class="lineno">  185 </span><span class="decl"><span class="istickedoff">encodeKind = safeEncodeBits kindTagWidth</span></span>
<span class="lineno">  186 </span>
<span class="lineno">  187 </span>decodeKind :: Get Word8
<span class="lineno">  188 </span><span class="decl"><span class="istickedoff">decodeKind = dBEBits8 kindTagWidth</span></span>
<span class="lineno">  189 </span>
<span class="lineno">  190 </span>instance Flat ann =&gt; Flat (Kind ann) where
<span class="lineno">  191 </span>  <span class="decl"><span class="istickedoff">encode = \case</span>
<span class="lineno">  192 </span><span class="spaces">    </span><span class="istickedoff">Type ann -&gt; encodeKind 0 &lt;&gt; encode <span class="nottickedoff">ann</span></span>
<span class="lineno">  193 </span><span class="spaces">    </span><span class="istickedoff">KindArrow ann k k' -&gt; encodeKind 1 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode k &lt;&gt; encode k'</span></span>
<span class="lineno">  194 </span>
<span class="lineno">  195 </span>  <span class="decl"><span class="istickedoff">decode = go =&lt;&lt; decodeKind</span>
<span class="lineno">  196 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  197 </span><span class="spaces">      </span><span class="istickedoff">go 0 = Type &lt;$&gt; decode</span>
<span class="lineno">  198 </span><span class="spaces">      </span><span class="istickedoff">go 1 = KindArrow &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  199 </span><span class="spaces">      </span><span class="istickedoff">go _ = <span class="nottickedoff">fail &quot;Failed to decode Kind ()&quot;</span></span></span>
<span class="lineno">  200 </span>
<span class="lineno">  201 </span>  <span class="decl"><span class="istickedoff">size tm sz =</span>
<span class="lineno">  202 </span><span class="spaces">    </span><span class="istickedoff">let</span>
<span class="lineno">  203 </span><span class="spaces">      </span><span class="istickedoff">sz' = sz + kindTagWidth</span>
<span class="lineno">  204 </span><span class="spaces">     </span><span class="istickedoff">in</span>
<span class="lineno">  205 </span><span class="spaces">      </span><span class="istickedoff">case tm of</span>
<span class="lineno">  206 </span><span class="spaces">        </span><span class="istickedoff">Type ann -&gt; size <span class="nottickedoff">ann</span> sz'</span>
<span class="lineno">  207 </span><span class="spaces">        </span><span class="istickedoff">KindArrow ann k k' -&gt; size <span class="nottickedoff">ann</span> $ size k $ size k' sz'</span></span>
<span class="lineno">  208 </span>
<span class="lineno">  209 </span>-- | Use 3 bits to encode type tags.
<span class="lineno">  210 </span>typeTagWidth :: NumBits
<span class="lineno">  211 </span><span class="decl"><span class="istickedoff">typeTagWidth = 3</span></span>
<span class="lineno">  212 </span>
<span class="lineno">  213 </span>encodeType :: Word8 -&gt; Encoding
<span class="lineno">  214 </span><span class="decl"><span class="istickedoff">encodeType = safeEncodeBits typeTagWidth</span></span>
<span class="lineno">  215 </span>
<span class="lineno">  216 </span>decodeType :: Get Word8
<span class="lineno">  217 </span><span class="decl"><span class="istickedoff">decodeType = dBEBits8 typeTagWidth</span></span>
<span class="lineno">  218 </span>
<span class="lineno">  219 </span>instance (Closed uni, Flat ann, Flat tyname) =&gt; Flat (Type tyname uni ann) where
<span class="lineno">  220 </span>  <span class="decl"><span class="istickedoff">encode = \case</span>
<span class="lineno">  221 </span><span class="spaces">    </span><span class="istickedoff">TyVar ann tn -&gt; encodeType 0 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode tn</span>
<span class="lineno">  222 </span><span class="spaces">    </span><span class="istickedoff">TyFun ann t t' -&gt; encodeType 1 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode t &lt;&gt; encode t'</span>
<span class="lineno">  223 </span><span class="spaces">    </span><span class="istickedoff">TyIFix ann pat arg -&gt; <span class="nottickedoff">encodeType 2 &lt;&gt; encode ann &lt;&gt; encode pat &lt;&gt; encode arg</span></span>
<span class="lineno">  224 </span><span class="spaces">    </span><span class="istickedoff">TyForall ann tn k t -&gt; encodeType 3 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode tn &lt;&gt; encode k &lt;&gt; encode t</span>
<span class="lineno">  225 </span><span class="spaces">    </span><span class="istickedoff">TyBuiltin ann con -&gt; encodeType 4 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode con</span>
<span class="lineno">  226 </span><span class="spaces">    </span><span class="istickedoff">TyLam ann n k t -&gt; encodeType 5 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode n &lt;&gt; encode k &lt;&gt; encode t</span>
<span class="lineno">  227 </span><span class="spaces">    </span><span class="istickedoff">TyApp ann t t' -&gt; encodeType 6 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode t &lt;&gt; encode t'</span>
<span class="lineno">  228 </span><span class="spaces">    </span><span class="istickedoff">-- Note that this relies on the instance for lists. We shouldn't use this in the</span>
<span class="lineno">  229 </span><span class="spaces">    </span><span class="istickedoff">-- serious on-chain version but it's okay here.</span>
<span class="lineno">  230 </span><span class="spaces">    </span><span class="istickedoff">TySOP ann tyls -&gt; encodeType 7 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode tyls</span></span>
<span class="lineno">  231 </span>
<span class="lineno">  232 </span>  <span class="decl"><span class="istickedoff">decode = go =&lt;&lt; decodeType</span>
<span class="lineno">  233 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  234 </span><span class="spaces">      </span><span class="istickedoff">go 0 = TyVar &lt;$&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  235 </span><span class="spaces">      </span><span class="istickedoff">go 1 = TyFun &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  236 </span><span class="spaces">      </span><span class="istickedoff">go 2 = TyIFix &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  237 </span><span class="spaces">      </span><span class="istickedoff">go 3 = TyForall &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  238 </span><span class="spaces">      </span><span class="istickedoff">go 4 = TyBuiltin &lt;$&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  239 </span><span class="spaces">      </span><span class="istickedoff">go 5 = TyLam &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  240 </span><span class="spaces">      </span><span class="istickedoff">go 6 = TyApp &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  241 </span><span class="spaces">      </span><span class="istickedoff">go 7 = TySOP &lt;$&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  242 </span><span class="spaces">      </span><span class="istickedoff">go _ = <span class="nottickedoff">fail &quot;Failed to decode Type TyName ()&quot;</span></span></span>
<span class="lineno">  243 </span>
<span class="lineno">  244 </span>  <span class="decl"><span class="istickedoff">size tm sz =</span>
<span class="lineno">  245 </span><span class="spaces">    </span><span class="istickedoff">let</span>
<span class="lineno">  246 </span><span class="spaces">      </span><span class="istickedoff">sz' = sz + typeTagWidth</span>
<span class="lineno">  247 </span><span class="spaces">     </span><span class="istickedoff">in</span>
<span class="lineno">  248 </span><span class="spaces">      </span><span class="istickedoff">case tm of</span>
<span class="lineno">  249 </span><span class="spaces">        </span><span class="istickedoff">TyVar ann tn -&gt; size <span class="nottickedoff">ann</span> $ size tn sz'</span>
<span class="lineno">  250 </span><span class="spaces">        </span><span class="istickedoff">TyFun ann t t' -&gt; size <span class="nottickedoff">ann</span> $ size t $ size t' sz'</span>
<span class="lineno">  251 </span><span class="spaces">        </span><span class="istickedoff">TyIFix ann pat arg -&gt; <span class="nottickedoff">size ann $ size pat $ size arg sz'</span></span>
<span class="lineno">  252 </span><span class="spaces">        </span><span class="istickedoff">TyForall ann tn k t -&gt; size <span class="nottickedoff">ann</span> $ size tn $ size k $ size t sz'</span>
<span class="lineno">  253 </span><span class="spaces">        </span><span class="istickedoff">TyBuiltin ann con -&gt; size <span class="nottickedoff">ann</span> $ size con sz'</span>
<span class="lineno">  254 </span><span class="spaces">        </span><span class="istickedoff">TyLam ann n k t -&gt; size <span class="nottickedoff">ann</span> $ size n $ size k $ size t sz'</span>
<span class="lineno">  255 </span><span class="spaces">        </span><span class="istickedoff">TyApp ann t t' -&gt; size <span class="nottickedoff">ann</span> $ size t $ size t' sz'</span>
<span class="lineno">  256 </span><span class="spaces">        </span><span class="istickedoff">TySOP ann tyls -&gt; size <span class="nottickedoff">ann</span> $ size tyls sz'</span></span>
<span class="lineno">  257 </span>
<span class="lineno">  258 </span>termTagWidth :: NumBits
<span class="lineno">  259 </span><span class="decl"><span class="istickedoff">termTagWidth = 4</span></span>
<span class="lineno">  260 </span>
<span class="lineno">  261 </span>encodeTerm :: Word8 -&gt; Encoding
<span class="lineno">  262 </span><span class="decl"><span class="istickedoff">encodeTerm = safeEncodeBits termTagWidth</span></span>
<span class="lineno">  263 </span>
<span class="lineno">  264 </span>decodeTerm :: Get Word8
<span class="lineno">  265 </span><span class="decl"><span class="istickedoff">decodeTerm = dBEBits8 termTagWidth</span></span>
<span class="lineno">  266 </span>
<span class="lineno">  267 </span>instance
<span class="lineno">  268 </span>  ( Closed uni
<span class="lineno">  269 </span>  , uni `Everywhere` Flat
<span class="lineno">  270 </span>  , Flat fun
<span class="lineno">  271 </span>  , Flat ann
<span class="lineno">  272 </span>  , Flat tyname
<span class="lineno">  273 </span>  , Flat name
<span class="lineno">  274 </span>  )
<span class="lineno">  275 </span>  =&gt; Flat (Term tyname name uni fun ann)
<span class="lineno">  276 </span>  where
<span class="lineno">  277 </span>  <span class="decl"><span class="istickedoff">encode = \case</span>
<span class="lineno">  278 </span><span class="spaces">    </span><span class="istickedoff">Var ann n -&gt; encodeTerm 0 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode n</span>
<span class="lineno">  279 </span><span class="spaces">    </span><span class="istickedoff">TyAbs ann tn k t -&gt; encodeTerm 1 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode tn &lt;&gt; encode k &lt;&gt; encode t</span>
<span class="lineno">  280 </span><span class="spaces">    </span><span class="istickedoff">LamAbs ann n ty t -&gt; encodeTerm 2 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode n &lt;&gt; encode ty &lt;&gt; encode t</span>
<span class="lineno">  281 </span><span class="spaces">    </span><span class="istickedoff">Apply ann t t' -&gt; encodeTerm 3 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode t &lt;&gt; encode t'</span>
<span class="lineno">  282 </span><span class="spaces">    </span><span class="istickedoff">Constant ann c -&gt; encodeTerm 4 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode c</span>
<span class="lineno">  283 </span><span class="spaces">    </span><span class="istickedoff">TyInst ann t ty -&gt; encodeTerm 5 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode t &lt;&gt; encode ty</span>
<span class="lineno">  284 </span><span class="spaces">    </span><span class="istickedoff">Unwrap ann t -&gt; encodeTerm 6 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode t</span>
<span class="lineno">  285 </span><span class="spaces">    </span><span class="istickedoff">IWrap ann pat arg t -&gt; encodeTerm 7 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode pat &lt;&gt; encode arg &lt;&gt; encode t</span>
<span class="lineno">  286 </span><span class="spaces">    </span><span class="istickedoff">Error ann ty -&gt; encodeTerm 8 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode ty</span>
<span class="lineno">  287 </span><span class="spaces">    </span><span class="istickedoff">Builtin ann bn -&gt; encodeTerm 9 &lt;&gt; encode <span class="nottickedoff">ann</span> &lt;&gt; encode bn</span>
<span class="lineno">  288 </span><span class="spaces">    </span><span class="istickedoff">Constr ann ty i es -&gt;</span>
<span class="lineno">  289 </span><span class="spaces">      </span><span class="istickedoff">encodeTerm 10</span>
<span class="lineno">  290 </span><span class="spaces">        </span><span class="istickedoff">&lt;&gt; encode <span class="nottickedoff">ann</span></span>
<span class="lineno">  291 </span><span class="spaces">        </span><span class="istickedoff">&lt;&gt; encode ty</span>
<span class="lineno">  292 </span><span class="spaces">        </span><span class="istickedoff">&lt;&gt; encode i</span>
<span class="lineno">  293 </span><span class="spaces">        </span><span class="istickedoff">&lt;&gt; encode es</span>
<span class="lineno">  294 </span><span class="spaces">    </span><span class="istickedoff">Case ann ty arg cs -&gt;</span>
<span class="lineno">  295 </span><span class="spaces">      </span><span class="istickedoff">encodeTerm 11</span>
<span class="lineno">  296 </span><span class="spaces">        </span><span class="istickedoff">&lt;&gt; encode <span class="nottickedoff">ann</span></span>
<span class="lineno">  297 </span><span class="spaces">        </span><span class="istickedoff">&lt;&gt; encode ty</span>
<span class="lineno">  298 </span><span class="spaces">        </span><span class="istickedoff">&lt;&gt; encode arg</span>
<span class="lineno">  299 </span><span class="spaces">        </span><span class="istickedoff">&lt;&gt; encode cs</span></span>
<span class="lineno">  300 </span>
<span class="lineno">  301 </span>  <span class="decl"><span class="istickedoff">decode = go =&lt;&lt; decodeTerm</span>
<span class="lineno">  302 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  303 </span><span class="spaces">      </span><span class="istickedoff">go 0 = Var &lt;$&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  304 </span><span class="spaces">      </span><span class="istickedoff">go 1 = TyAbs &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  305 </span><span class="spaces">      </span><span class="istickedoff">go 2 = LamAbs &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  306 </span><span class="spaces">      </span><span class="istickedoff">go 3 = Apply &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  307 </span><span class="spaces">      </span><span class="istickedoff">go 4 = Constant &lt;$&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  308 </span><span class="spaces">      </span><span class="istickedoff">go 5 = TyInst &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  309 </span><span class="spaces">      </span><span class="istickedoff">go 6 = Unwrap &lt;$&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  310 </span><span class="spaces">      </span><span class="istickedoff">go 7 = IWrap &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  311 </span><span class="spaces">      </span><span class="istickedoff">go 8 = Error &lt;$&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  312 </span><span class="spaces">      </span><span class="istickedoff">go 9 = Builtin &lt;$&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  313 </span><span class="spaces">      </span><span class="istickedoff">go 10 = Constr &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  314 </span><span class="spaces">      </span><span class="istickedoff">go 11 = Case &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span>
<span class="lineno">  315 </span><span class="spaces">      </span><span class="istickedoff">go _ = <span class="nottickedoff">fail &quot;Failed to decode Term TyName Name ()&quot;</span></span></span>
<span class="lineno">  316 </span>
<span class="lineno">  317 </span>  <span class="decl"><span class="istickedoff">size tm sz =</span>
<span class="lineno">  318 </span><span class="spaces">    </span><span class="istickedoff">let</span>
<span class="lineno">  319 </span><span class="spaces">      </span><span class="istickedoff">sz' = termTagWidth + sz</span>
<span class="lineno">  320 </span><span class="spaces">     </span><span class="istickedoff">in</span>
<span class="lineno">  321 </span><span class="spaces">      </span><span class="istickedoff">case tm of</span>
<span class="lineno">  322 </span><span class="spaces">        </span><span class="istickedoff">Var ann n -&gt; size <span class="nottickedoff">ann</span> $ size n sz'</span>
<span class="lineno">  323 </span><span class="spaces">        </span><span class="istickedoff">TyAbs ann tn k t -&gt; size <span class="nottickedoff">ann</span> $ size tn $ size k $ size t sz'</span>
<span class="lineno">  324 </span><span class="spaces">        </span><span class="istickedoff">LamAbs ann n ty t -&gt; size <span class="nottickedoff">ann</span> $ size n $ size ty $ size t sz'</span>
<span class="lineno">  325 </span><span class="spaces">        </span><span class="istickedoff">Apply ann t t' -&gt; size <span class="nottickedoff">ann</span> $ size t $ size t' sz'</span>
<span class="lineno">  326 </span><span class="spaces">        </span><span class="istickedoff">Constant ann c -&gt; size <span class="nottickedoff">ann</span> $ size c sz'</span>
<span class="lineno">  327 </span><span class="spaces">        </span><span class="istickedoff">TyInst ann t ty -&gt; size <span class="nottickedoff">ann</span> $ size t $ size ty sz'</span>
<span class="lineno">  328 </span><span class="spaces">        </span><span class="istickedoff">Unwrap ann t -&gt; size <span class="nottickedoff">ann</span> $ size t sz'</span>
<span class="lineno">  329 </span><span class="spaces">        </span><span class="istickedoff">IWrap ann pat arg t -&gt; size <span class="nottickedoff">ann</span> $ size pat $ size arg $ size t sz'</span>
<span class="lineno">  330 </span><span class="spaces">        </span><span class="istickedoff">Error ann ty -&gt; size <span class="nottickedoff">ann</span> $ size ty sz'</span>
<span class="lineno">  331 </span><span class="spaces">        </span><span class="istickedoff">Builtin ann bn -&gt; size <span class="nottickedoff">ann</span> $ size <span class="nottickedoff">bn</span> sz'</span>
<span class="lineno">  332 </span><span class="spaces">        </span><span class="istickedoff">Constr ann ty i es -&gt; size <span class="nottickedoff">ann</span> $ size ty $ size i $ size es sz'</span>
<span class="lineno">  333 </span><span class="spaces">        </span><span class="istickedoff">Case ann ty arg cs -&gt; size <span class="nottickedoff">ann</span> $ size ty $ size arg $ size cs sz'</span></span>
<span class="lineno">  334 </span>
<span class="lineno">  335 </span>instance
<span class="lineno">  336 </span>  <span class="decl"><span class="istickedoff">( Closed uni</span>
<span class="lineno">  337 </span><span class="spaces">  </span><span class="istickedoff">, Flat ann</span>
<span class="lineno">  338 </span><span class="spaces">  </span><span class="istickedoff">, Flat tyname</span>
<span class="lineno">  339 </span><span class="spaces">  </span><span class="istickedoff">, Flat name</span>
<span class="lineno">  340 </span><span class="spaces">  </span><span class="istickedoff">)</span>
<span class="lineno">  341 </span><span class="spaces">  </span><span class="istickedoff">=&gt; Flat (VarDecl tyname name uni ann)</span></span>
<span class="lineno">  342 </span>  where
<span class="lineno">  343 </span>  <span class="decl"><span class="istickedoff">encode (VarDecl t name tyname) = encode <span class="nottickedoff">t</span> &lt;&gt; encode name &lt;&gt; encode tyname</span></span>
<span class="lineno">  344 </span>  <span class="decl"><span class="istickedoff">decode = VarDecl &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span></span>
<span class="lineno">  345 </span>
<span class="lineno">  346 </span>instance <span class="decl"><span class="istickedoff">(Flat ann, Flat tyname) =&gt; Flat (TyVarDecl tyname ann)</span></span> where
<span class="lineno">  347 </span>  <span class="decl"><span class="istickedoff">encode (TyVarDecl t tyname kind) = encode <span class="nottickedoff">t</span> &lt;&gt; encode tyname &lt;&gt; encode kind</span></span>
<span class="lineno">  348 </span>  <span class="decl"><span class="istickedoff">decode = TyVarDecl &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span></span>
<span class="lineno">  349 </span>
<span class="lineno">  350 </span>instance
<span class="lineno">  351 </span>  <span class="decl"><span class="istickedoff">( Flat ann</span>
<span class="lineno">  352 </span><span class="spaces">  </span><span class="istickedoff">, Flat (Term tyname name uni fun ann)</span>
<span class="lineno">  353 </span><span class="spaces">  </span><span class="istickedoff">)</span>
<span class="lineno">  354 </span><span class="spaces">  </span><span class="istickedoff">=&gt; Flat (Program tyname name uni fun ann)</span></span>
<span class="lineno">  355 </span>  where
<span class="lineno">  356 </span>  <span class="decl"><span class="istickedoff">encode (Program ann v t) = encode <span class="nottickedoff">ann</span> &lt;&gt; encode v &lt;&gt; encode t</span></span>
<span class="lineno">  357 </span>  <span class="decl"><span class="istickedoff">decode = Program &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode</span></span>
<span class="lineno">  358 </span>
<span class="lineno">  359 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving newtype instance Flat a =&gt; Flat (Normalized a)</span></span></span></span></span></span>
<span class="lineno">  360 </span>
<span class="lineno">  361 </span>-- See Note [DeBruijn Index serialization]
<span class="lineno">  362 </span><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">deriving newtype instance Flat Index</span></span></span></span></span></span> -- via word64
<span class="lineno">  363 </span>
<span class="lineno">  364 </span><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">deriving newtype instance Flat DeBruijn</span></span></span></span></span></span> -- via index
<span class="lineno">  365 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving newtype instance Flat TyDeBruijn</span></span></span></span></span></span> -- via debruijn
<span class="lineno">  366 </span>
<span class="lineno">  367 </span>instance <span class="decl"><span class="nottickedoff">Flat NamedDeBruijn</span></span> where
<span class="lineno">  368 </span>  <span class="decl"><span class="nottickedoff">encode (NamedDeBruijn txt ix) = encode txt &lt;&gt; encode ix</span></span>
<span class="lineno">  369 </span>  <span class="decl"><span class="istickedoff">decode = NamedDeBruijn &lt;$&gt; decode &lt;*&gt; decode</span></span>
<span class="lineno">  370 </span>
<span class="lineno">  371 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving newtype instance Flat NamedTyDeBruijn</span></span></span></span></span></span> -- via nameddebruijn
<span class="lineno">  372 </span>
<span class="lineno">  373 </span>-- NOTE: the serialization roundtrip holds iff the invariant binder.index==0 holds
<span class="lineno">  374 </span>instance Flat (Binder DeBruijn) where
<span class="lineno">  375 </span>  <span class="decl"><span class="nottickedoff">size _ = id</span></span> -- zero cost
<span class="lineno">  376 </span>  <span class="decl"><span class="istickedoff">encode _ = mempty</span></span>
<span class="lineno">  377 </span>  <span class="decl"><span class="istickedoff">decode = pure $ Binder $ DeBruijn deBruijnInitIndex</span></span>
<span class="lineno">  378 </span>
<span class="lineno">  379 </span>-- (Binder TyDeBruijn) could similarly have a flat instance, but we don't need it.
<span class="lineno">  380 </span>
<span class="lineno">  381 </span><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">deriving newtype instance Flat (Binder Name)</span></span></span></span></span></span>
<span class="lineno">  382 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving newtype instance Flat (Binder TyName)</span></span></span></span></span></span>
<span class="lineno">  383 </span>
<span class="lineno">  384 </span>-- We could use an alternative, manual Flat-serialization of Named(Ty)DeBruijn
<span class="lineno">  385 </span>-- where we store the name only at the binder and the index only at the use-site (Var/TyVar).
<span class="lineno">  386 </span>-- That would be more compact, but we don't need it at the moment.
<span class="lineno">  387 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">deriving newtype instance Flat (Binder NamedDeBruijn)</span></span></span></span></span></span>
<span class="lineno">  388 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving newtype instance Flat (Binder NamedTyDeBruijn)</span></span></span></span></span></span>
<span class="lineno">  389 </span>
<span class="lineno">  390 </span>{- This instance is going via Flat DeBruijn.
<span class="lineno">  391 </span>FakeNamedDeBruijn &lt;-&gt; DeBruijn are isomorphic: we could use iso-deriving package,
<span class="lineno">  392 </span>but we do not need any other isomorphic Flat deriving for the moment.
<span class="lineno">  393 </span>See Note [Why newtype FakeNamedDeBruijn]
<span class="lineno">  394 </span>-}
<span class="lineno">  395 </span>instance Flat FakeNamedDeBruijn where
<span class="lineno">  396 </span>  <span class="decl"><span class="nottickedoff">size = size . fromFake</span></span>
<span class="lineno">  397 </span>  <span class="decl"><span class="nottickedoff">encode = encode . fromFake</span></span>
<span class="lineno">  398 </span>  <span class="decl"><span class="istickedoff">decode = toFake &lt;$&gt; decode</span></span>
<span class="lineno">  399 </span>
<span class="lineno">  400 </span>{- This instance is going via Flat (Binder DeBruijn) instance.
<span class="lineno">  401 </span>Binder FakeNamedDeBruijn &lt;-&gt; Binder DeBruijn are isomorphic because
<span class="lineno">  402 </span>FakeNamedDeBruijn &lt;-&gt; DeBruijn are isomorphic and Binder is a functor:
<span class="lineno">  403 </span>we could use iso-deriving package,
<span class="lineno">  404 </span>but  we do not need any other isomorphic Flat deriving for the moment.
<span class="lineno">  405 </span>See Note [Why newtype FakeNamedDeBruijn]
<span class="lineno">  406 </span>NOTE: the serialization roundtrip holds iff the invariant binder.index==0 holds
<span class="lineno">  407 </span>-}
<span class="lineno">  408 </span>instance Flat (Binder FakeNamedDeBruijn) where
<span class="lineno">  409 </span>  <span class="decl"><span class="nottickedoff">size = size . fmap fromFake</span></span>
<span class="lineno">  410 </span>  <span class="decl"><span class="nottickedoff">encode = encode . fmap fromFake</span></span>
<span class="lineno">  411 </span>  <span class="decl"><span class="istickedoff">decode = fmap toFake &lt;$&gt; decode</span></span>

</pre>
</body>
</html>
