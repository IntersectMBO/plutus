<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>-- editorconfig-checker-disable-file
<span class="lineno">    2 </span>{-# LANGUAGE AllowAmbiguousTypes #-}
<span class="lineno">    3 </span>{-# LANGUAGE ConstraintKinds #-}
<span class="lineno">    4 </span>{-# LANGUAGE DataKinds #-}
<span class="lineno">    5 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">    6 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">    7 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">    8 </span>{-# LANGUAGE PolyKinds #-}
<span class="lineno">    9 </span>{-# LANGUAGE QuantifiedConstraints #-}
<span class="lineno">   10 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">   11 </span>{-# LANGUAGE StandaloneKindSignatures #-}
<span class="lineno">   12 </span>{-# LANGUAGE TemplateHaskell #-}
<span class="lineno">   13 </span>{-# LANGUAGE TypeApplications #-}
<span class="lineno">   14 </span>{-# LANGUAGE TypeFamilies #-}
<span class="lineno">   15 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">   16 </span>{-# LANGUAGE UndecidableInstances #-}
<span class="lineno">   17 </span>-- Required only by 'Permits0' for some reason.
<span class="lineno">   18 </span>{-# LANGUAGE UndecidableSuperClasses #-}
<span class="lineno">   19 </span>
<span class="lineno">   20 </span>module Universe.Core
<span class="lineno">   21 </span>  ( Esc
<span class="lineno">   22 </span>  , Some (..)
<span class="lineno">   23 </span>  , SomeTypeIn (..)
<span class="lineno">   24 </span>  , Kinded (..)
<span class="lineno">   25 </span>  , ValueOf (..)
<span class="lineno">   26 </span>  , Contains (..)
<span class="lineno">   27 </span>  , Includes
<span class="lineno">   28 </span>  , knownUniOf
<span class="lineno">   29 </span>  , someType
<span class="lineno">   30 </span>  , someValueOf
<span class="lineno">   31 </span>  , someValue
<span class="lineno">   32 </span>  , someValueType
<span class="lineno">   33 </span>  , DecodeUniM (..)
<span class="lineno">   34 </span>  , Closed (..)
<span class="lineno">   35 </span>  , decodeKindedUni
<span class="lineno">   36 </span>  , peelUniTag
<span class="lineno">   37 </span>  , Permits
<span class="lineno">   38 </span>  , EverywhereAll
<span class="lineno">   39 </span>  , type (&lt;:)
<span class="lineno">   40 </span>  , HasUniApply (..)
<span class="lineno">   41 </span>  , checkStar
<span class="lineno">   42 </span>  , withApplicable
<span class="lineno">   43 </span>  , tryUniApply
<span class="lineno">   44 </span>  , GShow (..)
<span class="lineno">   45 </span>  , gshow
<span class="lineno">   46 </span>  , GEq (..)
<span class="lineno">   47 </span>  , defaultEq
<span class="lineno">   48 </span>  , (:~:) (..)
<span class="lineno">   49 </span>  -- strictly we don't use this, but this is here
<span class="lineno">   50 </span>  -- partially so we have a dependency on dependent-sum
<span class="lineno">   51 </span>  -- directly and so can bound it
<span class="lineno">   52 </span>  , DSum (..)
<span class="lineno">   53 </span>  ) where
<span class="lineno">   54 </span>
<span class="lineno">   55 </span>import Control.Applicative
<span class="lineno">   56 </span>import Control.DeepSeq
<span class="lineno">   57 </span>import Control.Monad
<span class="lineno">   58 </span>import Control.Monad.Trans.State.Strict
<span class="lineno">   59 </span>import Data.Dependent.Sum
<span class="lineno">   60 </span>import Data.GADT.Compare
<span class="lineno">   61 </span>import Data.GADT.DeepSeq
<span class="lineno">   62 </span>import Data.GADT.Show
<span class="lineno">   63 </span>import Data.Hashable
<span class="lineno">   64 </span>import Data.Kind
<span class="lineno">   65 </span>import Data.Proxy
<span class="lineno">   66 </span>import Data.Some.Newtype
<span class="lineno">   67 </span>import Data.Type.Equality
<span class="lineno">   68 </span>import Text.Show.Deriving
<span class="lineno">   69 </span>import Type.Reflection
<span class="lineno">   70 </span>
<span class="lineno">   71 </span>{- Note [Universes]
<span class="lineno">   72 </span>A universe is a collection of tags for types. It can be finite like
<span class="lineno">   73 </span>
<span class="lineno">   74 </span>    data U a where
<span class="lineno">   75 </span>        UUnit :: U ()
<span class="lineno">   76 </span>        UInt  :: U Int
<span class="lineno">   77 </span>
<span class="lineno">   78 </span>(where 'UUnit' is a tag for '()' and 'UInt' is a tag for 'Int') or infinite like
<span class="lineno">   79 </span>
<span class="lineno">   80 </span>    data U a where
<span class="lineno">   81 </span>        UBool :: U Bool
<span class="lineno">   82 </span>        UList :: !(U a) -&gt; U [a]
<span class="lineno">   83 </span>
<span class="lineno">   84 </span>Here are some values of the latter 'U' / the types that they encode
<span class="lineno">   85 </span>
<span class="lineno">   86 </span>        UBool               / Bool
<span class="lineno">   87 </span>        UList UBool         / [Bool]
<span class="lineno">   88 </span>        UList (UList UBool) / [[Bool]]
<span class="lineno">   89 </span>
<span class="lineno">   90 </span>'U' being a GADT allows us to package a type from a universe together with a value of that type.
<span class="lineno">   91 </span>For example,
<span class="lineno">   92 </span>
<span class="lineno">   93 </span>    Some (ValueOf UBool True) :: Some (ValueOf U)
<span class="lineno">   94 </span>
<span class="lineno">   95 </span>We say that a type is in a universe whenever there is a tag for that type in the universe.
<span class="lineno">   96 </span>For example, 'Int' is in 'U', because there exists a tag for 'Int' in 'U' ('UInt').
<span class="lineno">   97 </span>-}
<span class="lineno">   98 </span>
<span class="lineno">   99 </span>{- Note [Representing polymorphism]
<span class="lineno">  100 </span>Consider the following universe (in this example and the ones below bangs on arguments in universes
<span class="lineno">  101 </span>are omitted for clarity):
<span class="lineno">  102 </span>
<span class="lineno">  103 </span>    data U a where
<span class="lineno">  104 </span>        UList :: U a -&gt; U [a]
<span class="lineno">  105 </span>        UInt  :: U Int
<span class="lineno">  106 </span>
<span class="lineno">  107 </span>It has ints and polymorphic lists in it (including lists of lists etc).
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>This representation works perfectly at the value level, you can instantiate functions like
<span class="lineno">  110 </span>
<span class="lineno">  111 </span>    foo :: (uni `Includes` [], uni `Includes` Int) =&gt; &lt;...&gt;
<span class="lineno">  112 </span>    foo = &lt;...&gt;
<span class="lineno">  113 </span>
<span class="lineno">  114 </span>with 'U', it is straightforward to provide a meaninful 'Closed' instance etc. I.e. at the value
<span class="lineno">  115 </span>level polymorphic data types are entirely unproblematic, since they are always fully instantiated
<span class="lineno">  116 </span>there and so there's basically no difference compared to regular monomorphic types.
<span class="lineno">  117 </span>
<span class="lineno">  118 </span>However if you also have the type level in your target language (i.e. it's not some form of an
<span class="lineno">  119 </span>untyped calculus) and the type language supports polymorphism and you have polymorphic built-in
<span class="lineno">  120 </span>functions, then the version of 'U' from the above does not fit as well. For example, you want
<span class="lineno">  121 </span>to be able to represent the following built-in function:
<span class="lineno">  122 </span>
<span class="lineno">  123 </span>    idList :: forall a. [a] -&gt; [a]  -- In the source language (Haskell)
<span class="lineno">  124 </span>    idList : all a. [a] -&gt; [a]      -- In the target language
<span class="lineno">  125 </span>
<span class="lineno">  126 </span>It's obvious how to implement the former, but for the latter you have to put a target language
<span class="lineno">  127 </span>variable (@a@) into a meta type (@[]@), which is not only awkward, but also requires a lot of extra
<span class="lineno">  128 </span>care in every part of the compiler that deals with types, for example in this setting type
<span class="lineno">  129 </span>substitution has to look inside built-in types (and for that reason you have to be able to store
<span class="lineno">  130 </span>not just type variables but full target language types in meta types, 'cause otherwise you can't
<span class="lineno">  131 </span>substitute a type for a type variable and so substitution is broken). So this is really tricky.
<span class="lineno">  132 </span>
<span class="lineno">  133 </span>However instead of putting target language type variables into meta types we can instead have
<span class="lineno">  134 </span>type lambdas inside universes, or, even better, Agda-like operators sections
<span class="lineno">  135 </span>(see https://agda.readthedocs.io/en/v2.6.1.3/language/mixfix-operators.html#mixfix-operators).
<span class="lineno">  136 </span>For that we only need to add another constructor to 'U':
<span class="lineno">  137 </span>
<span class="lineno">  138 </span>    data Hole  -- An empty data type.
<span class="lineno">  139 </span>
<span class="lineno">  140 </span>    data U a where
<span class="lineno">  141 </span>        &lt;...&gt;
<span class="lineno">  142 </span>        UHole :: U Hole
<span class="lineno">  143 </span>
<span class="lineno">  144 </span>That allows us to put @UList UHole@ into a target language type, which displays as @[_]@ and means
<span class="lineno">  145 </span>@\a -&gt; [a]@, which is a neutral (as in, irreducible) type-level function that we can apply via the
<span class="lineno">  146 </span>regular type-level function application constructor, which allows us not to put the argument into
<span class="lineno">  147 </span>the meta type, but instead keep it in the type AST. If we wanted to add pairs as built-in types,
<span class="lineno">  148 </span>we'd add the following constructor:
<span class="lineno">  149 </span>
<span class="lineno">  150 </span>    data U a where
<span class="lineno">  151 </span>        &lt;...&gt;
<span class="lineno">  152 </span>        UPair :: U a -&gt; U b -&gt; U (a, b)
<span class="lineno">  153 </span>
<span class="lineno">  154 </span>and here are some examples of meta types and what they'd mean in the target language:
<span class="lineno">  155 </span>
<span class="lineno">  156 </span>    UPair UInt  (UList UInt)        (Int, [Int])
<span class="lineno">  157 </span>    UPair UInt  UHole               \b -&gt; (Int, b)
<span class="lineno">  158 </span>    UPair UHole (UList UInt)        \a -&gt; (a, [Int])
<span class="lineno">  159 </span>    UPair UHole UHole               \a b -&gt; (a, b)
<span class="lineno">  160 </span>
<span class="lineno">  161 </span>Overall, we need to be careful not to end up using 'UHole' at the term level, and some rather
<span class="lineno">  162 </span>boilerplate-y infrastructure is required to connect the type and term levels of the target
<span class="lineno">  163 </span>language (as you need to manually check if an argument to a built-in function is a list/pair as
<span class="lineno">  164 </span>expected, because with this solution there's no general way (or at least I haven't found one)
<span class="lineno">  165 </span>to match types of arguments against arbitrary-kinded applied type operator sections), but otherwise
<span class="lineno">  166 </span>this solution does make it possible to apply meta types to target language types without infecting
<span class="lineno">  167 </span>the former with the latter.
<span class="lineno">  168 </span>
<span class="lineno">  169 </span>Things however become more complex if you want to be polymorphic over universes in your target
<span class="lineno">  170 </span>language. You can no longer match against a handful of hardcoded type tags. You could introduce type
<span class="lineno">  171 </span>classes like @UniHasList@, @UniHasPair@ etc, but having a class per polymorphic built-in type is
<span class="lineno">  172 </span>clunky and boilerplate-y (and this is in addition to the existing boilerplate-y infrastructure
<span class="lineno">  173 </span>that was mentioned above). It would be nice if we could impose each universe to have a single
<span class="lineno">  174 </span>application constructor and not require polymorphic built-in types to be fully applied at all
<span class="lineno">  175 </span>times (&quot;fully applied&quot; includes &quot;applied to a hole&quot;).
<span class="lineno">  176 </span>
<span class="lineno">  177 </span>So can we index the universe by types of arbitrary kinds and have a single application constructor?
<span class="lineno">  178 </span>Well, we can define
<span class="lineno">  179 </span>
<span class="lineno">  180 </span>    data U (a :: k) where
<span class="lineno">  181 </span>        UProtoList :: U []
<span class="lineno">  182 </span>        UInt       :: U Int
<span class="lineno">  183 </span>        UApply     :: U f -&gt; U a -&gt; U (f a)
<span class="lineno">  184 </span>
<span class="lineno">  185 </span>which allows us to recover the original 'UList' as
<span class="lineno">  186 </span>
<span class="lineno">  187 </span>    pattern UList = UApply UProtoList
<span class="lineno">  188 </span>
<span class="lineno">  189 </span>But 'U' is of kind @forall k. k -&gt; Type@, which is really hard to deal with. For one thing, we lose
<span class="lineno">  190 </span>pretty much any interop with the rest of the ecosystem, for example not only is it not possible to
<span class="lineno">  191 </span>derive 'GEq' or 'GShow' anymore, it's not even correct to say @GEq U@, because 'GEq' expects
<span class="lineno">  192 </span>something of type @k -&gt; Type@ for a particular @k@, while 'U' has a different kind.
<span class="lineno">  193 </span>
<span class="lineno">  194 </span>Our problems with 'U' don't end here. Having a @forall@ in the kind destroys type inference.
<span class="lineno">  195 </span>For example, having
<span class="lineno">  196 </span>
<span class="lineno">  197 </span>    type ISome :: (forall k. k -&gt; Type) -&gt; Type
<span class="lineno">  198 </span>    data ISome f = forall a (x :: a). ISome (f x)
<span class="lineno">  199 </span>
<span class="lineno">  200 </span>    data U (a :: k)
<span class="lineno">  201 </span>
<span class="lineno">  202 </span>we can check that
<span class="lineno">  203 </span>
<span class="lineno">  204 </span>    newtype TypeIn uni a = TypeIn (uni a)
<span class="lineno">  205 </span>
<span class="lineno">  206 </span>    type Test = ISome (TypeIn U)
<span class="lineno">  207 </span>
<span class="lineno">  208 </span>type checks just fine when 'TypeIn' has the following kind signature:
<span class="lineno">  209 </span>
<span class="lineno">  210 </span>    type TypeIn :: (forall k. k -&gt; Type) -&gt; forall l. l -&gt; Type
<span class="lineno">  211 </span>
<span class="lineno">  212 </span>but fails to type check when the final @forall@ is moved to the left:
<span class="lineno">  213 </span>
<span class="lineno">  214 </span>    type TypeIn :: forall l. (forall k. k -&gt; Type) -&gt; l -&gt; Type
<span class="lineno">  215 </span>
<span class="lineno">  216 </span>We could fix it by defining
<span class="lineno">  217 </span>
<span class="lineno">  218 </span>    type IType = forall k. k -&gt; Type
<span class="lineno">  219 </span>
<span class="lineno">  220 </span>and using it everywhere instead of @forall k. k -&gt; Type@, but our problems just start here.
<span class="lineno">  221 </span>For another example, the following does not type check at all:
<span class="lineno">  222 </span>
<span class="lineno">  223 </span>    type IType = forall k. k -&gt; Type
<span class="lineno">  224 </span>
<span class="lineno">  225 </span>    type IValueOf :: IType -&gt; Type -&gt; Type
<span class="lineno">  226 </span>    data IValueOf uni a = IValueOf (uni a) a
<span class="lineno">  227 </span>
<span class="lineno">  228 </span>    instance Eq (IValueOf (uni :: IType) a)
<span class="lineno">  229 </span>
<span class="lineno">  230 </span>GHC does not seem to like that implicitly quantified @uni@ has a higher-rank kind.
<span class="lineno">  231 </span>And it's annoying that we'd need both @Some@ (for values) and @ISome@ (for types).
<span class="lineno">  232 </span>
<span class="lineno">  233 </span>So basically this approach is unusable.
<span class="lineno">  234 </span>
<span class="lineno">  235 </span>But there's another way to spell @forall k. k -&gt; Type@ and it's @(exists k. k) -&gt; Type@ or in
<span class="lineno">  236 </span>Haskell terms:
<span class="lineno">  237 </span>
<span class="lineno">  238 </span>    data Esc = forall k. Esc k
<span class="lineno">  239 </span>
<span class="lineno">  240 </span>    data U (a :: T) where
<span class="lineno">  241 </span>        UProtoList :: U ('Esc [])
<span class="lineno">  242 </span>        UInt       :: U ('Esc Int)
<span class="lineno">  243 </span>        UApply     :: U ('Esc f) -&gt; U ('Esc a) -&gt; U ('Esc (f a))
<span class="lineno">  244 </span>
<span class="lineno">  245 </span>However this variant of 'U' has the disadvantage of not being of the @Type -&gt; Type@ kind
<span class="lineno">  246 </span>(it's @T -&gt; Type@ instead), which means that the user now needs to enable @DataKinds@ just to be
<span class="lineno">  247 </span>able to mention universes (even without actually doing anything with them) and also use those
<span class="lineno">  248 </span>annoying ticks. So instead we can think of @Type@ as a data type itself whose constructors
<span class="lineno">  249 </span>(an infinite amount of them) are things introduced via the @data@ keyword. This gives us
<span class="lineno">  250 </span>
<span class="lineno">  251 </span>    data Esc (a :: k)
<span class="lineno">  252 </span>
<span class="lineno">  253 </span>    data U (a :: Type) where
<span class="lineno">  254 </span>        UProtoList :: U (Esc [])
<span class="lineno">  255 </span>        UInt       :: U (Esc Int)
<span class="lineno">  256 </span>        UApply     :: U (Esc f) -&gt; U (Esc a) -&gt; U (Esc (f a))
<span class="lineno">  257 </span>
<span class="lineno">  258 </span>(note that we haven't introduced any more &quot;openness&quot; with this trick as any kind in Haskell is
<span class="lineno">  259 </span>already weirdly open (including @T@): https://gist.github.com/ekmett/ac881f3dba3f89ec03f8fdb1d8bf0a40)
<span class="lineno">  260 </span>
<span class="lineno">  261 </span>This is the encoding that we use, but unfortunately that required reworking the whole infrastructure
<span class="lineno">  262 </span>that we originally had. For example, 'ValueOf' had to change from
<span class="lineno">  263 </span>
<span class="lineno">  264 </span>    data ValueOf uni a = ValueOf (uni a) a
<span class="lineno">  265 </span>
<span class="lineno">  266 </span>to
<span class="lineno">  267 </span>
<span class="lineno">  268 </span>    data ValueOf uni a = ValueOf (uni (Esc a)) a
<span class="lineno">  269 </span>
<span class="lineno">  270 </span>It is annoying that if we want to talk about partially applied type constructors, then suddenly we
<span class="lineno">  271 </span>need a completely different encoding of universes (and of the whole infrastructure) than the one
<span class="lineno">  272 </span>that we used before we had type constructors (or cared about partially applying them), but I believe
<span class="lineno">  273 </span>it's worth the trouble.
<span class="lineno">  274 </span>-}
<span class="lineno">  275 </span>
<span class="lineno">  276 </span>{- Note [Decoding universes]
<span class="lineno">  277 </span>We have types of arbitrary kinds at the type level, but at the value level every constant must be of
<span class="lineno">  278 </span>kind star. I.e. we have to be able to parse/decode arbitrary types, but ensure that a decoded type
<span class="lineno">  279 </span>is of kind star whenever we expect to parse/decode a constant of that type next. This is one reason
<span class="lineno">  280 </span>why we have all these 'Typeable' constraints lying around.
<span class="lineno">  281 </span>
<span class="lineno">  282 </span>Type-wise this is enforced via 'bring' expecting a @uni (Esc a)@ with @a@ being of kind @Type@.
<span class="lineno">  283 </span>I.e. there is no way one could parse a general type and then attempt to bring a constraint for
<span class="lineno">  284 </span>that type in scope via 'bring' without first ensuring that the type is of kind star.
<span class="lineno">  285 </span>
<span class="lineno">  286 </span>Another reason for having the 'Typeable' constraints is that decoding a type application requires
<span class="lineno">  287 </span>checking that the expected kind of an argument matches the kind of the provided argument due to us
<span class="lineno">  288 </span>having an intrinsically-kinded reprensentation of types.
<span class="lineno">  289 </span>-}
<span class="lineno">  290 </span>
<span class="lineno">  291 </span>{- Note [The TypeApp approach]
<span class="lineno">  292 </span>There's an alternative approach to representing universes supporting partial application of
<span class="lineno">  293 </span>type constructors. The idea is that we only &quot;shield&quot; those types that are of a non-star kind instead
<span class="lineno">  294 </span>of applying @T@ to every single type in the universe. I.e. we specifically embed into @Type@ only
<span class="lineno">  295 </span>(possibly partial) type applications and add one more constructor that allows for &quot;running&quot; such
<span class="lineno">  296 </span>applications:
<span class="lineno">  297 </span>
<span class="lineno">  298 </span>    data TypeApp (a :: k)
<span class="lineno">  299 </span>
<span class="lineno">  300 </span>    data U (a :: Type) where
<span class="lineno">  301 </span>        UProtoList  :: U (TypeApp [])
<span class="lineno">  302 </span>        UInt        :: U Int
<span class="lineno">  303 </span>        UApply      :: U (TypeApp f) -&gt; U a -&gt; U (TypeApp (f a))
<span class="lineno">  304 </span>        URunTypeApp :: U (TypeApp a) -&gt; U a
<span class="lineno">  305 </span>
<span class="lineno">  306 </span>This representation has the advantage of allowing for sharing the universes infrastructure between
<span class="lineno">  307 </span>the monomorphic and polymorphic cases. I.e. we could use good old
<span class="lineno">  308 </span>
<span class="lineno">  309 </span>    data ValueOf uni a = ValueOf (uni a) a
<span class="lineno">  310 </span>
<span class="lineno">  311 </span>instead of having to use the slightly more awkward
<span class="lineno">  312 </span>
<span class="lineno">  313 </span>    data ValueOf uni a = ValueOf (uni (Esc a)) a
<span class="lineno">  314 </span>
<span class="lineno">  315 </span>One problem that this representation has is redundancy: there are two ways to represent the type
<span class="lineno">  316 </span>of lists of integers (for some definition of @SomeTypeIn@):
<span class="lineno">  317 </span>
<span class="lineno">  318 </span>    SomeTypeIn (URunTypeApp (UProtoList `UApply` UInt))
<span class="lineno">  319 </span>    SomeTypeIn (UProtoList `UApply` UInt)
<span class="lineno">  320 </span>
<span class="lineno">  321 </span>In practice it's not a big deal, we just need not to forget to strip the 'URunTypeApp' constructor
<span class="lineno">  322 </span>off whenever that is important (for example, during type normalization).
<span class="lineno">  323 </span>
<span class="lineno">  324 </span>But a more serious problem with this representation is that we lose all the type safety discussed
<span class="lineno">  325 </span>in Note [Decoding universes], which makes it rather easy to shoot oneself in the foot with
<span class="lineno">  326 </span>@error &quot;not supposed to happen&quot;@ happening. I.e. we'd need to perform all the same checks
<span class="lineno">  327 </span>in client code but without the type checker forcing us to do so like it does now, so that's a huge
<span class="lineno">  328 </span>price to pay for some superficial syntactic nicety and hence we choose the safe approach,
<span class="lineno">  329 </span>even though that required reworking all the infrastructure in a backwards-incompatible manner.
<span class="lineno">  330 </span>-}
<span class="lineno">  331 </span>
<span class="lineno">  332 </span>-- See Note [Representing polymorphism].
<span class="lineno">  333 </span>-- | \&quot;Escapes\&quot; a type of an arbitrary kind to fit into 'Type'.
<span class="lineno">  334 </span>type Esc :: forall k. k -&gt; Type
<span class="lineno">  335 </span>data Esc a
<span class="lineno">  336 </span>
<span class="lineno">  337 </span>-- | A particular type from a universe.
<span class="lineno">  338 </span>type SomeTypeIn :: (Type -&gt; Type) -&gt; Type
<span class="lineno">  339 </span>data SomeTypeIn uni = forall k (a :: k). SomeTypeIn !(uni (Esc a))
<span class="lineno">  340 </span>
<span class="lineno">  341 </span>data Kinded uni ta where
<span class="lineno">  342 </span>  Kinded :: Typeable k =&gt; !(uni (Esc a)) -&gt; Kinded uni (Esc (a :: k))
<span class="lineno">  343 </span>
<span class="lineno">  344 </span>-- | A value of a particular type from a universe.
<span class="lineno">  345 </span>type ValueOf :: (Type -&gt; Type) -&gt; Type -&gt; Type
<span class="lineno">  346 </span>data ValueOf uni a = ValueOf !(uni (Esc a)) !a
<span class="lineno">  347 </span>
<span class="lineno">  348 </span>{-| A class for enumerating types and fully instantiated type formers that @uni@ contains.
<span class="lineno">  349 </span>For example, a particular @ExampleUni@ may have monomorphic types in it:
<span class="lineno">  350 </span>
<span class="lineno">  351 </span>    instance ExampleUni `Contains` Integer where &lt;...&gt;
<span class="lineno">  352 </span>    instance ExampleUni `Contains` Bool    where &lt;...&gt;
<span class="lineno">  353 </span>
<span class="lineno">  354 </span>as well as polymorphic ones:
<span class="lineno">  355 </span>
<span class="lineno">  356 </span>    instance ExampleUni `Contains` [] where &lt;...&gt;
<span class="lineno">  357 </span>    instance ExampleUni `Contains` (,) where &lt;...&gt;
<span class="lineno">  358 </span>
<span class="lineno">  359 </span>as well as their instantiations:
<span class="lineno">  360 </span>
<span class="lineno">  361 </span>    instance ExampleUni `Contains` a =&gt; ExampleUni `Contains` [a] where &lt;...&gt;
<span class="lineno">  362 </span>    instance (ExampleUni `Contains` a, ExampleUni `Contains` b) =&gt; ExampleUni `Contains` (a, b) where &lt;...&gt;
<span class="lineno">  363 </span>
<span class="lineno">  364 </span>(a universe can have any subset of the mentioned sorts of types, for example it's fine to have
<span class="lineno">  365 </span>instantiated polymorphic types and not have uninstantiated ones and vice versa)
<span class="lineno">  366 </span>
<span class="lineno">  367 </span>Note that when used as a constraint of a function 'Contains' does not allow you to directly
<span class="lineno">  368 </span>express things like \&quot;@uni@ has the @Integer@, @Bool@ and @[]@ types and type formers\&quot;,
<span class="lineno">  369 </span>because @[]@ is not fully instantiated. So you can only say \&quot;@uni@ has @Integer@, @Bool@,
<span class="lineno">  370 </span>@[Integer]@, @[Bool]@, @[[Integer]]@, @[[Bool]]@ etc\&quot; and such manual enumeration is annoying,
<span class="lineno">  371 </span>so we'd really like to be able to say that @uni@ has lists of arbitrary built-in types
<span class="lineno">  372 </span>(including lists of lists etc). 'Contains' does not allow that, but 'Includes' does.
<span class="lineno">  373 </span>For example, in the body of the following definition:
<span class="lineno">  374 </span>
<span class="lineno">  375 </span>    foo :: (uni `Includes` Integer, uni `Includes` Bool, uni `Includes` []) =&gt; &lt;...&gt;
<span class="lineno">  376 </span>    foo = &lt;...&gt;
<span class="lineno">  377 </span>
<span class="lineno">  378 </span>you can make use of the fact that @uni@ has lists of arbitrary included types (integers,
<span class="lineno">  379 </span>booleans and lists).
<span class="lineno">  380 </span>
<span class="lineno">  381 </span>Hence most of the time opt for using the more flexible 'Includes'.
<span class="lineno">  382 </span>
<span class="lineno">  383 </span>'Includes' is defined in terms of 'Contains', so you only need to provide a 'Contains' instance
<span class="lineno">  384 </span>per type from the universe and you'll get 'Includes' for free. -}
<span class="lineno">  385 </span>type Contains :: forall k. (Type -&gt; Type) -&gt; k -&gt; Constraint
<span class="lineno">  386 </span>class uni `Contains` a where
<span class="lineno">  387 </span>  knownUni :: uni (Esc a)
<span class="lineno">  388 </span>
<span class="lineno">  389 </span>{- Note [The definition of Includes]
<span class="lineno">  390 </span>We need to be able to partially apply 'Includes' (required in the definition of '&lt;:' for example),
<span class="lineno">  391 </span>however if we define 'Includes' as a class alias like that:
<span class="lineno">  392 </span>
<span class="lineno">  393 </span>    class    Contains uni `Permits` a =&gt; uni `Includes` a
<span class="lineno">  394 </span>    instance Contains uni `Permits` a =&gt; uni `Includes` a
<span class="lineno">  395 </span>
<span class="lineno">  396 </span>we get this extra annoying warning:
<span class="lineno">  397 </span>
<span class="lineno">  398 </span>    • The constraint ‘Includes uni ()’ matches
<span class="lineno">  399 </span>        instance forall k (uni :: * -&gt; *) (a :: k).
<span class="lineno">  400 </span>                 Permits (Contains uni) a =&gt;
<span class="lineno">  401 </span>                 Includes uni a
<span class="lineno">  402 </span>      This makes type inference for inner bindings fragile;
<span class="lineno">  403 </span>        either use MonoLocalBinds, or simplify it using the instance
<span class="lineno">  404 </span>
<span class="lineno">  405 </span>at the use site, so instead we define 'Includes' as a type alias of one argument (i.e. 'Includes'
<span class="lineno">  406 </span>has to be immediately applied only to a @uni@ at the use site).
<span class="lineno">  407 </span>-}
<span class="lineno">  408 </span>
<span class="lineno">  409 </span>-- | A @Kinded uni@ contains an @a :: k@ whenever @uni@ contains it and @k@ is 'Typeable'.
<span class="lineno">  410 </span>instance (Typeable k, uni `Contains` a) =&gt; Kinded uni `Contains` (a :: k) where
<span class="lineno">  411 </span>  <span class="decl"><span class="istickedoff">knownUni = Kinded knownUni</span></span>
<span class="lineno">  412 </span>
<span class="lineno">  413 </span>-- See Note [The definition of Includes].
<span class="lineno">  414 </span>{-| @uni `Includes` a@ reads as \&quot;@a@ is in the @uni@\&quot;. @a@ can be of a higher-kind,
<span class="lineno">  415 </span>see the docs of 'Contains' on why you might want that. -}
<span class="lineno">  416 </span>type Includes :: forall k. (Type -&gt; Type) -&gt; k -&gt; Constraint
<span class="lineno">  417 </span>type Includes uni = Permits (Contains uni)
<span class="lineno">  418 </span>
<span class="lineno">  419 </span>-- | Same as 'knownUni', but receives a @proxy@.
<span class="lineno">  420 </span>knownUniOf :: uni `Contains` a =&gt; proxy a -&gt; uni (Esc a)
<span class="lineno">  421 </span><span class="decl"><span class="nottickedoff">knownUniOf _ = knownUni</span></span>
<span class="lineno">  422 </span>
<span class="lineno">  423 </span>-- | Wrap a type into @SomeTypeIn@, provided it's in the universe.
<span class="lineno">  424 </span>someType :: forall k (a :: k) uni. uni `Contains` a =&gt; SomeTypeIn uni
<span class="lineno">  425 </span><span class="decl"><span class="istickedoff">someType = SomeTypeIn $ knownUni @k @uni @a</span></span>
<span class="lineno">  426 </span>
<span class="lineno">  427 </span>-- | Wrap a value into @Some (ValueOf uni)@, given its explicit type tag.
<span class="lineno">  428 </span>someValueOf :: forall a uni. uni (Esc a) -&gt; a -&gt; Some (ValueOf uni)
<span class="lineno">  429 </span><span class="decl"><span class="istickedoff">someValueOf uni = Some . ValueOf uni</span></span>
<span class="lineno">  430 </span>
<span class="lineno">  431 </span>-- | Wrap a value into @Some (ValueOf uni)@, provided its type is in the universe.
<span class="lineno">  432 </span>someValue :: forall a uni. uni `Contains` a =&gt; a -&gt; Some (ValueOf uni)
<span class="lineno">  433 </span><span class="decl"><span class="istickedoff">someValue = someValueOf knownUni</span></span>
<span class="lineno">  434 </span>
<span class="lineno">  435 </span>someValueType :: Some (ValueOf uni) -&gt; SomeTypeIn uni
<span class="lineno">  436 </span><span class="decl"><span class="nottickedoff">someValueType (Some (ValueOf tag _)) = SomeTypeIn tag</span></span>
<span class="lineno">  437 </span>
<span class="lineno">  438 </span>{-| A monad to decode types from a universe in.
<span class="lineno">  439 </span>We use a monad for decoding, because parsing arguments of polymorphic built-in types can peel off
<span class="lineno">  440 </span>an arbitrary amount of type tags from the input list of tags and so we have state, which is
<span class="lineno">  441 </span>convenient to handle with, well, 'StateT'. -}
<span class="lineno">  442 </span>newtype DecodeUniM a = DecodeUniM
<span class="lineno">  443 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unDecodeUniM</span></span></span> :: StateT [Int] Maybe a
<span class="lineno">  444 </span>  }
<span class="lineno">  445 </span>  deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Functor</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Applicative</span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Alternative</span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Monad</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">MonadPlus</span></span></span></span>, <span class="decl"><span class="nottickedoff">MonadFail</span></span>)
<span class="lineno">  446 </span>
<span class="lineno">  447 </span>runDecodeUniM :: [Int] -&gt; DecodeUniM a -&gt; Maybe (a, [Int])
<span class="lineno">  448 </span><span class="decl"><span class="istickedoff">runDecodeUniM is (DecodeUniM a) = runStateT a is</span></span>
<span class="lineno">  449 </span>
<span class="lineno">  450 </span>{-| A universe is 'Closed', if it's known how to constrain every type from the universe and
<span class="lineno">  451 </span>every type can be encoded to / decoded from a sequence of integer tags.
<span class="lineno">  452 </span>The universe doesn't have to be finite and providing support for infinite universes is the
<span class="lineno">  453 </span>reason why we encode a type as a sequence of integer tags as opposed to a single integer tag.
<span class="lineno">  454 </span>For example, given
<span class="lineno">  455 </span>
<span class="lineno">  456 </span>&gt;   data U a where
<span class="lineno">  457 </span>&gt;       UList :: !(U a) -&gt; U [a]
<span class="lineno">  458 </span>&gt;       UInt  :: U Int
<span class="lineno">  459 </span>
<span class="lineno">  460 </span>@UList (UList UInt)@ can be encoded to @[0,0,1]@ where @0@ and @1@ are the integer tags of the
<span class="lineno">  461 </span>@UList@ and @UInt@ constructors, respectively. -}
<span class="lineno">  462 </span>class Closed uni where
<span class="lineno">  463 </span>  -- | A constrant for \&quot;@constr a@ holds for any @a@ from @uni@\&quot;.
<span class="lineno">  464 </span>  type Everywhere uni (constr :: Type -&gt; Constraint) :: Constraint
<span class="lineno">  465 </span>
<span class="lineno">  466 </span>  {-| Encode a type as a sequence of 'Int' tags.
<span class="lineno">  467 </span>  The opposite of 'decodeUni'. -}
<span class="lineno">  468 </span>  encodeUni :: uni a -&gt; [Int]
<span class="lineno">  469 </span>
<span class="lineno">  470 </span>  -- | Decode a type and feed it to the continuation.
<span class="lineno">  471 </span>  withDecodedUni :: (forall k (a :: k). Typeable k =&gt; uni (Esc a) -&gt; DecodeUniM r) -&gt; DecodeUniM r
<span class="lineno">  472 </span>
<span class="lineno">  473 </span>  {-| Bring a @constr a@ instance in scope, provided @a@ is a type from the universe and
<span class="lineno">  474 </span>  @constr@ holds for any type from the universe. -}
<span class="lineno">  475 </span>  bring :: uni `Everywhere` constr =&gt; proxy constr -&gt; uni (Esc a) -&gt; (constr a =&gt; r) -&gt; r
<span class="lineno">  476 </span>
<span class="lineno">  477 </span>{-| Decode a type from a sequence of 'Int' tags.
<span class="lineno">  478 </span>The opposite of 'encodeUni' (modulo invalid input). -}
<span class="lineno">  479 </span>decodeKindedUni :: Closed uni =&gt; [Int] -&gt; Maybe (SomeTypeIn (Kinded uni))
<span class="lineno">  480 </span><span class="decl"><span class="istickedoff">decodeKindedUni is = do</span>
<span class="lineno">  481 </span><span class="spaces">  </span><span class="istickedoff">(x, []) &lt;- runDecodeUniM is $ withDecodedUni $ pure . SomeTypeIn . Kinded</span>
<span class="lineno">  482 </span><span class="spaces">  </span><span class="istickedoff">pure x</span></span>
<span class="lineno">  483 </span>
<span class="lineno">  484 </span>-- &gt;&gt;&gt; runDecodeUniM [1,2,3] peelUniTag
<span class="lineno">  485 </span>-- Just (1,[2,3])
<span class="lineno">  486 </span>-- &gt;&gt;&gt; runDecodeUniM [] peelUniTag
<span class="lineno">  487 </span>-- Nothing
<span class="lineno">  488 </span>-- | Peel off a tag from the input list of type tags.
<span class="lineno">  489 </span>peelUniTag :: DecodeUniM Int
<span class="lineno">  490 </span><span class="decl"><span class="istickedoff">peelUniTag = DecodeUniM $ do</span>
<span class="lineno">  491 </span><span class="spaces">  </span><span class="istickedoff">i : is &lt;- get</span>
<span class="lineno">  492 </span><span class="spaces">  </span><span class="istickedoff">i &lt;$ put is</span></span>
<span class="lineno">  493 </span>
<span class="lineno">  494 </span>-- It's not possible to return a @forall@ from a type family, let alone compute a proper
<span class="lineno">  495 </span>-- quantified context, hence the boilerplate and a finite number of supported cases.
<span class="lineno">  496 </span>
<span class="lineno">  497 </span>type Permits0 :: (Type -&gt; Constraint) -&gt; Type -&gt; Constraint
<span class="lineno">  498 </span>class constr x =&gt; constr `Permits0` x
<span class="lineno">  499 </span>instance constr x =&gt; constr `Permits0` x
<span class="lineno">  500 </span>
<span class="lineno">  501 </span>type Permits1 :: (Type -&gt; Constraint) -&gt; (Type -&gt; Type) -&gt; Constraint
<span class="lineno">  502 </span>class (forall a. constr a =&gt; constr (f a)) =&gt; constr `Permits1` f
<span class="lineno">  503 </span>instance (forall a. constr a =&gt; constr (f a)) =&gt; constr `Permits1` f
<span class="lineno">  504 </span>
<span class="lineno">  505 </span>type Permits2 :: (Type -&gt; Constraint) -&gt; (Type -&gt; Type -&gt; Type) -&gt; Constraint
<span class="lineno">  506 </span>class (forall a b. (constr a, constr b) =&gt; constr (f a b)) =&gt; constr `Permits2` f
<span class="lineno">  507 </span>instance (forall a b. (constr a, constr b) =&gt; constr (f a b)) =&gt; constr `Permits2` f
<span class="lineno">  508 </span>
<span class="lineno">  509 </span>type Permits3 :: (Type -&gt; Constraint) -&gt; (Type -&gt; Type -&gt; Type -&gt; Type) -&gt; Constraint
<span class="lineno">  510 </span>class (forall a b c. (constr a, constr b, constr c) =&gt; constr (f a b c)) =&gt; constr `Permits3` f
<span class="lineno">  511 </span>instance (forall a b c. (constr a, constr b, constr c) =&gt; constr (f a b c)) =&gt; constr `Permits3` f
<span class="lineno">  512 </span>
<span class="lineno">  513 </span>-- I tried defining 'Permits' as a class but that didn't have the right inference properties
<span class="lineno">  514 </span>-- (i.e. I was getting errors in existing code). That probably requires bidirectional instances
<span class="lineno">  515 </span>-- to work, but who cares given that the type family version works alright and can even be
<span class="lineno">  516 </span>-- partially applied (the kind has to be provided immediately though, but that's fine).
<span class="lineno">  517 </span>{-| @constr `Permits` f@ elaborates to one of
<span class="lineno">  518 </span>-
<span class="lineno">  519 </span>    constr f
<span class="lineno">  520 </span>    forall a. constr a =&gt; constr (f a)
<span class="lineno">  521 </span>    forall a b. (constr a, constr b) =&gt; constr (f a b)
<span class="lineno">  522 </span>    forall a b c. (constr a, constr b, constr c) =&gt; constr (f a b c)
<span class="lineno">  523 </span>
<span class="lineno">  524 </span>depending on the kind of @f@. This allows us to say things like
<span class="lineno">  525 </span>
<span class="lineno">  526 </span>   ( constr `Permits` Integer
<span class="lineno">  527 </span>   , constr `Permits` []
<span class="lineno">  528 </span>   , constr `Permits` (,)
<span class="lineno">  529 </span>   )
<span class="lineno">  530 </span>
<span class="lineno">  531 </span>and thus constraint every type from the universe (including polymorphic ones) to satisfy
<span class="lineno">  532 </span>@constr@, which is how we provide an implementation of 'Everywhere' for universes with
<span class="lineno">  533 </span>polymorphic types.
<span class="lineno">  534 </span>
<span class="lineno">  535 </span>'Permits' is an open type family, so you can provide type instances for @f@s expecting
<span class="lineno">  536 </span>more type arguments than 3 if you need that.
<span class="lineno">  537 </span>
<span class="lineno">  538 </span>Note that, say, @constr `Permits` []@ elaborates to
<span class="lineno">  539 </span>
<span class="lineno">  540 </span>    forall a. constr a =&gt; constr [a]
<span class="lineno">  541 </span>
<span class="lineno">  542 </span>and for certain type classes that does not make sense (e.g. the 'Generic' instance of @[]@
<span class="lineno">  543 </span>does not require the type of elements to be 'Generic'), however it's not a problem because
<span class="lineno">  544 </span>we use 'Permit' to constrain the whole universe and so we know that arguments of polymorphic
<span class="lineno">  545 </span>built-in types are builtins themselves are hence do satisfy the constraint and the fact that
<span class="lineno">  546 </span>these constraints on arguments do not get used in the polymorphic case only means that they
<span class="lineno">  547 </span>get ignored. -}
<span class="lineno">  548 </span>type Permits :: forall k. (Type -&gt; Constraint) -&gt; k -&gt; Constraint
<span class="lineno">  549 </span>type family Permits constr
<span class="lineno">  550 </span>
<span class="lineno">  551 </span>type instance Permits @Type constr = Permits0 constr
<span class="lineno">  552 </span>type instance Permits @(Type -&gt; Type) constr = Permits1 constr
<span class="lineno">  553 </span>type instance Permits @(Type -&gt; Type -&gt; Type) constr = Permits2 constr
<span class="lineno">  554 </span>type instance Permits @(Type -&gt; Type -&gt; Type -&gt; Type) constr = Permits3 constr
<span class="lineno">  555 </span>
<span class="lineno">  556 </span>-- We can't use @All (Everywhere uni) constrs@, because 'Everywhere' is an associated type family
<span class="lineno">  557 </span>-- and can't be partially applied, so we have to inline the definition here.
<span class="lineno">  558 </span>type EverywhereAll :: (Type -&gt; Type) -&gt; [Type -&gt; Constraint] -&gt; Constraint
<span class="lineno">  559 </span>type family uni `EverywhereAll` constrs where
<span class="lineno">  560 </span>  uni `EverywhereAll` '[] = ()
<span class="lineno">  561 </span>  uni `EverywhereAll` (constr ': constrs) = (uni `Everywhere` constr, uni `EverywhereAll` constrs)
<span class="lineno">  562 </span>
<span class="lineno">  563 </span>-- | A constraint for \&quot;@uni1@ is a subuniverse of @uni2@\&quot;.
<span class="lineno">  564 </span>type uni1 &lt;: uni2 = uni1 `Everywhere` Includes uni2
<span class="lineno">  565 </span>
<span class="lineno">  566 </span>-- | A class for \&quot;@uni@ has general type application\&quot;.
<span class="lineno">  567 </span>class HasUniApply (uni :: Type -&gt; Type) where
<span class="lineno">  568 </span>  -- | Apply a type constructor to an argument.
<span class="lineno">  569 </span>  uniApply :: forall k l (f :: k -&gt; l) a. uni (Esc f) -&gt; uni (Esc a) -&gt; uni (Esc (f a))
<span class="lineno">  570 </span>
<span class="lineno">  571 </span>  {-| Deconstruct a type application into the function and the argument and feed them to the
<span class="lineno">  572 </span>  continuation. If the type is not an application, then return the default value. -}
<span class="lineno">  573 </span>  matchUniApply
<span class="lineno">  574 </span>    :: uni tb
<span class="lineno">  575 </span>    -- ^ The type.
<span class="lineno">  576 </span>    -&gt; r
<span class="lineno">  577 </span>    -- ^ What to return if the type is not an application.
<span class="lineno">  578 </span>    -&gt; (forall k l (f :: k -&gt; l) a. tb ~ Esc (f a) =&gt; uni (Esc f) -&gt; uni (Esc a) -&gt; r)
<span class="lineno">  579 </span>    -- ^ The continuation taking a function and an argument.
<span class="lineno">  580 </span>    -&gt; r
<span class="lineno">  581 </span>
<span class="lineno">  582 </span>-- See Note [Decoding universes].
<span class="lineno">  583 </span>-- You might think @uni@ is inferrable from the explicitly given argument. Nope, in most cases it's
<span class="lineno">  584 </span>-- not. It seems, kind equalities mess up inference.
<span class="lineno">  585 </span>-- | Check if the kind of the given type from the universe is 'Type'.
<span class="lineno">  586 </span>checkStar :: forall uni a (x :: a). Typeable a =&gt; uni (Esc x) -&gt; Maybe (a :~: Type)
<span class="lineno">  587 </span><span class="decl"><span class="istickedoff">checkStar _ = typeRep @a `testEquality` typeRep @Type</span></span>
<span class="lineno">  588 </span>
<span class="lineno">  589 </span>fromJustM :: MonadPlus f =&gt; Maybe a -&gt; f a
<span class="lineno">  590 </span><span class="decl"><span class="istickedoff">fromJustM = maybe <span class="nottickedoff">mzero</span> pure</span></span>
<span class="lineno">  591 </span>
<span class="lineno">  592 </span>-- See Note [Decoding universes].
<span class="lineno">  593 </span>{-| Check if one type from the universe can be applied to another (i.e. check that the expected
<span class="lineno">  594 </span>kind of the argument matches the actual one) and call the continuation in the refined context.
<span class="lineno">  595 </span>Fail with 'mzero' otherwise. -}
<span class="lineno">  596 </span>withApplicable
<span class="lineno">  597 </span>  :: forall (a :: Type) (ab :: Type) f x uni m r
<span class="lineno">  598 </span>   . (Typeable ab, Typeable a, MonadPlus m)
<span class="lineno">  599 </span>  =&gt; uni (Esc (f :: ab))
<span class="lineno">  600 </span>  -&gt; uni (Esc (x :: a))
<span class="lineno">  601 </span>  -&gt; (forall (b :: Type). (Typeable b, ab ~ (a -&gt; b)) =&gt; m r)
<span class="lineno">  602 </span>  -&gt; m r
<span class="lineno">  603 </span><span class="decl"><span class="istickedoff">withApplicable _ _ k =</span>
<span class="lineno">  604 </span><span class="spaces">  </span><span class="istickedoff">case typeRep @ab of</span>
<span class="lineno">  605 </span><span class="spaces">    </span><span class="istickedoff">Fun repA repB -&gt; do</span>
<span class="lineno">  606 </span><span class="spaces">      </span><span class="istickedoff">-- The type of @(-&gt;)@ is</span>
<span class="lineno">  607 </span><span class="spaces">      </span><span class="istickedoff">--</span>
<span class="lineno">  608 </span><span class="spaces">      </span><span class="istickedoff">--     forall {r1} {r2} (a :: TYPE r1) (b :: TYPE r2). a -&gt; b -&gt; Type</span>
<span class="lineno">  609 </span><span class="spaces">      </span><span class="istickedoff">--</span>
<span class="lineno">  610 </span><span class="spaces">      </span><span class="istickedoff">-- so we need to demonstrate that both @a@ and @b@ are of kind @Type@. We get the former</span>
<span class="lineno">  611 </span><span class="spaces">      </span><span class="istickedoff">-- from checking that the type representation of 'withApplicable'-bound @a@ equals @a@</span>
<span class="lineno">  612 </span><span class="spaces">      </span><span class="istickedoff">-- from @a -&gt; b@, but for the latter we need an explicit check.</span>
<span class="lineno">  613 </span><span class="spaces">      </span><span class="istickedoff">HRefl &lt;- fromJustM $ typeRep @a `eqTypeRep` repA</span>
<span class="lineno">  614 </span><span class="spaces">      </span><span class="istickedoff">Refl &lt;- fromJustM $ typeRepKind repB `testEquality` typeRep @Type</span>
<span class="lineno">  615 </span><span class="spaces">      </span><span class="istickedoff">withTypeable repB k</span>
<span class="lineno">  616 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">mzero</span></span></span>
<span class="lineno">  617 </span>
<span class="lineno">  618 </span>-- | Apply a type constructor to an argument, provided kinds match.
<span class="lineno">  619 </span>tryUniApply
<span class="lineno">  620 </span>  :: (MonadPlus m, HasUniApply uni)
<span class="lineno">  621 </span>  =&gt; SomeTypeIn (Kinded uni) -&gt; SomeTypeIn (Kinded uni) -&gt; m (SomeTypeIn (Kinded uni))
<span class="lineno">  622 </span><span class="decl"><span class="istickedoff">tryUniApply (SomeTypeIn (Kinded uniF)) (SomeTypeIn (Kinded uniA)) =</span>
<span class="lineno">  623 </span><span class="spaces">  </span><span class="istickedoff">withApplicable <span class="nottickedoff">uniF</span> <span class="nottickedoff">uniA</span> $</span>
<span class="lineno">  624 </span><span class="spaces">    </span><span class="istickedoff">pure . SomeTypeIn . Kinded $</span>
<span class="lineno">  625 </span><span class="spaces">      </span><span class="istickedoff">uniF `uniApply` uniA</span></span>
<span class="lineno">  626 </span>
<span class="lineno">  627 </span>{- Note [The G, the Tag and the Auto]
<span class="lineno">  628 </span>Providing instances for
<span class="lineno">  629 </span>
<span class="lineno">  630 </span>    data Some f = forall a. Some (f a)
<span class="lineno">  631 </span>
<span class="lineno">  632 </span>is tricky. There are several things to consider here:
<span class="lineno">  633 </span>
<span class="lineno">  634 </span>1. the G: for some type classes we can provide an instance for @Some f@ for any @f@ generically.
<span class="lineno">  635 </span>Take for example @Show (Some f)@, we could implement it as
<span class="lineno">  636 </span>
<span class="lineno">  637 </span>    instance (forall a. Show (f a)) =&gt; Show (Some f) where
<span class="lineno">  638 </span>        show (Some a) = &quot;Some &quot; ++ show a
<span class="lineno">  639 </span>
<span class="lineno">  640 </span>(with `-XQuantifiedConstraints`). Unfortunately, that breaks @deriving stock (Show)@ for every data type
<span class="lineno">  641 </span>that has @Some f@ somewhere inside it and forces you to use a standalone deriving declaration for
<span class="lineno">  642 </span>each such data type, which is rather annoying, because instance contexts tend to get huge,
<span class="lineno">  643 </span>so it takes time to come up with them or to remember where to copy them from and they also occupy
<span class="lineno">  644 </span>a lot of space (text-wise).
<span class="lineno">  645 </span>
<span class="lineno">  646 </span>Luckily, &quot;Data.GADT.Show&quot; provides
<span class="lineno">  647 </span>
<span class="lineno">  648 </span>    class GShow t where
<span class="lineno">  649 </span>        gshowsPrec :: Int -&gt; t a -&gt; ShowS
<span class="lineno">  650 </span>
<span class="lineno">  651 </span>    gshow :: GShow t =&gt; t a -&gt; String
<span class="lineno">  652 </span>
<span class="lineno">  653 </span>which allows us to define a 'Show' instance for 'Some' as
<span class="lineno">  654 </span>
<span class="lineno">  655 </span>    instance GShow f =&gt; Show (Some f) where
<span class="lineno">  656 </span>        show (Some a) = &quot;Some &quot; ++ gshow a
<span class="lineno">  657 </span>
<span class="lineno">  658 </span>so @GShow f@ is basically an encoding of @forall a. Show (f a)@.
<span class="lineno">  659 </span>
<span class="lineno">  660 </span>2. the Tag: for some type classes we can get away without providing the G version of a type class,
<span class="lineno">  661 </span>e.g. 'Hashable' is handled like that:
<span class="lineno">  662 </span>
<span class="lineno">  663 </span>    instance Closed uni =&gt; Hashable (TypeIn uni a) where
<span class="lineno">  664 </span>        hashWithSalt salt (TypeIn uni) = hashWithSalt salt $ encodeUni uni
<span class="lineno">  665 </span>
<span class="lineno">  666 </span>    instance Closed uni =&gt; Hashable (SomeTypeIn uni) where
<span class="lineno">  667 </span>        hashWithSalt salt (Some s) = hashWithSalt salt s
<span class="lineno">  668 </span>
<span class="lineno">  669 </span>where
<span class="lineno">  670 </span>
<span class="lineno">  671 </span>    class Closed uni where
<span class="lineno">  672 </span>        encodeUni :: uni a -&gt; [Int]
<span class="lineno">  673 </span>        &lt;...&gt;
<span class="lineno">  674 </span>
<span class="lineno">  675 </span>So as long as for each type of a universe you know its encoding as a sequence of integer tags,
<span class="lineno">  676 </span>you can hash any type from the universe via that sequence. 'Flat' is handled in a similar way.
<span class="lineno">  677 </span>
<span class="lineno">  678 </span>The 'Hashable' type class is also interesting in that we do not provide a generic instance for
<span class="lineno">  679 </span>any @Some f@. This is because @f@ can be anything of kind @* -&gt; *@ and we only have 'encodeUni' for
<span class="lineno">  680 </span>universes. In order to stress that the @f@ in this instance has to be a universe we use
<span class="lineno">  681 </span>the 'TypeIn' wrapper:
<span class="lineno">  682 </span>
<span class="lineno">  683 </span>    instance Closed uni =&gt; Hashable (SomeTypeIn uni) where
<span class="lineno">  684 </span>
<span class="lineno">  685 </span>This allows us to hash a type from a universe and a value of a type from a universe in different
<span class="lineno">  686 </span>ways. The latter instance looks like this:
<span class="lineno">  687 </span>
<span class="lineno">  688 </span>    instance (Closed uni, uni `Everywhere` Hashable) =&gt; Hashable (ValueOf uni a) where
<span class="lineno">  689 </span>        hashWithSalt salt (ValueOf uni x) =
<span class="lineno">  690 </span>            bring (Proxy @Hashable) uni $ hashWithSalt salt (SomeTypeIn uni, x)
<span class="lineno">  691 </span>
<span class="lineno">  692 </span>    instance (Closed uni, uni `Everywhere` Hashable) =&gt; Hashable (Some (ValueOf uni)) where
<span class="lineno">  693 </span>        hashWithSalt salt (Some s) = hashWithSalt salt s
<span class="lineno">  694 </span>
<span class="lineno">  695 </span>Here we hash a 'ValueOf' value as a pair of a type from a universe and a value of that type.
<span class="lineno">  696 </span>
<span class="lineno">  697 </span>Another type class for which a generic @Some f@ instance doesn't make sense is 'NFData'.
<span class="lineno">  698 </span>For universes we define
<span class="lineno">  699 </span>
<span class="lineno">  700 </span>    instance NFData (TypeIn uni a) where
<span class="lineno">  701 </span>        rnf (TypeIn uni) = rnf $ encodeUni uni
<span class="lineno">  702 </span>
<span class="lineno">  703 </span>    instance NFData (SomeTypeIn uni) where
<span class="lineno">  704 </span>        rnf (Some s) = rnf s
<span class="lineno">  705 </span>
<span class="lineno">  706 </span>i.e. to fully force a type from a universe it's enough to encode the type as a sequence of integer
<span class="lineno">  707 </span>tags and fully force that sequence.
<span class="lineno">  708 </span>
<span class="lineno">  709 </span>3. the Auto:
<span class="lineno">  710 </span>
<span class="lineno">  711 </span>When we can manually provide an instance for a type class, the two previous approaches work nicely.
<span class="lineno">  712 </span>But for a type class like 'Lift' we really want to use the deriving mechanism in order not to mess
<span class="lineno">  713 </span>with the hairy internal representation ('Exp' and stuff). But 'deriveLift' (and 'makeLift') calls
<span class="lineno">  714 </span>'lift' under the hood while we want it to call 'glift'. So we define a newtype wrapper ('AG') that
<span class="lineno">  715 </span>implements 'Lift' in terms of 'GLift', insert the 'AG' constructor in the right place and invoke
<span class="lineno">  716 </span>'makeLift' which calls 'lift' on 'AG' internally, so the 'lift' gets elaborated to 'glift'
<span class="lineno">  717 </span>as we want it to.
<span class="lineno">  718 </span>
<span class="lineno">  719 </span>And even though we can manually write 'Show' instances, they're handled in the same automated way
<span class="lineno">  720 </span>below, just because the derived instances handle precedence (and thus insert parentheses in right
<span class="lineno">  721 </span>places) out of the box.
<span class="lineno">  722 </span>
<span class="lineno">  723 </span>We should be able to use the same strategy for every type class @X@ when a @makeX@ function
<span class="lineno">  724 </span>(analogous to 'makeLift') is available.
<span class="lineno">  725 </span>-}
<span class="lineno">  726 </span>
<span class="lineno">  727 </span>-- WARNING: DO NOT EXPORT THIS, IT HAS AN UNSOUND 'Lift' INSTANCE USED FOR INTERNAL PURPOSES.
<span class="lineno">  728 </span>{-| A wrapper that allows to provide an instance for a non-general class (e.g. 'Lift' or 'Show')
<span class="lineno">  729 </span>for any @f@ implementing a general class (e.g. 'GLift' or 'GShow'). -}
<span class="lineno">  730 </span>newtype AG f a = AG (f a)
<span class="lineno">  731 </span>
<span class="lineno">  732 </span>$(return []) -- Stage restriction, see https://gitlab.haskell.org/ghc/ghc/issues/9813
<span class="lineno">  733 </span>
<span class="lineno">  734 </span>-------------------- 'Show' / 'GShow'
<span class="lineno">  735 </span>
<span class="lineno">  736 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">GShow f =&gt; Show (AG f a)</span></span></span></span> where
<span class="lineno">  737 </span>  <span class="decl"><span class="istickedoff">showsPrec pr (AG a) = gshowsPrec <span class="nottickedoff">pr</span> a</span></span>
<span class="lineno">  738 </span>
<span class="lineno">  739 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">GShow uni =&gt; Show (SomeTypeIn uni)</span></span></span></span> where
<span class="lineno">  740 </span>  <span class="decl"><span class="istickedoff">showsPrec pr (SomeTypeIn uni) = ($<span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">(makeShowsPrec ''SomeTypeIn)</span></span></span></span>) pr (SomeTypeIn (AG uni))</span></span>
<span class="lineno">  741 </span>
<span class="lineno">  742 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">GShow uni =&gt; Show (Kinded uni ta)</span></span></span></span> where
<span class="lineno">  743 </span>  <span class="decl"><span class="nottickedoff">showsPrec pr (Kinded uni) = ($(makeShowsPrec ''Kinded)) pr (Kinded (AG uni))</span></span>
<span class="lineno">  744 </span>
<span class="lineno">  745 </span>instance GShow uni =&gt; GShow (Kinded uni) where <span class="decl"><span class="nottickedoff">gshowsPrec = showsPrec</span></span>
<span class="lineno">  746 </span>
<span class="lineno">  747 </span>instance (GShow uni, Closed uni, uni `Everywhere` Show) =&gt; GShow (ValueOf uni) where
<span class="lineno">  748 </span>  <span class="decl"><span class="istickedoff">gshowsPrec = showsPrec</span></span>
<span class="lineno">  749 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">(GShow uni, Closed uni, uni `Everywhere` Show) =&gt; Show (ValueOf uni a)</span></span></span></span> where
<span class="lineno">  750 </span>  <span class="decl"><span class="istickedoff">showsPrec pr (ValueOf uni x) =</span>
<span class="lineno">  751 </span><span class="spaces">    </span><span class="istickedoff">bring <span class="nottickedoff">(Proxy @Show)</span> uni $ ($<span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">(makeShowsPrec ''ValueOf)</span></span></span></span>) pr (ValueOf (AG uni) x)</span></span>
<span class="lineno">  752 </span>
<span class="lineno">  753 </span>-------------------- 'Eq' / 'GEq'
<span class="lineno">  754 </span>
<span class="lineno">  755 </span>instance (GEq uni, Closed uni, uni `Everywhere` Eq) =&gt; GEq (ValueOf uni) where
<span class="lineno">  756 </span>  <span class="decl"><span class="istickedoff">ValueOf uni1 x1 `geq` ValueOf uni2 x2 = do</span>
<span class="lineno">  757 </span><span class="spaces">    </span><span class="istickedoff">Refl &lt;- uni1 `geq` uni2</span>
<span class="lineno">  758 </span><span class="spaces">    </span><span class="istickedoff">guard $ bring <span class="nottickedoff">(Proxy @Eq)</span> uni1 (x1 == x2)</span>
<span class="lineno">  759 </span><span class="spaces">    </span><span class="istickedoff">Just <span class="nottickedoff">Refl</span></span></span>
<span class="lineno">  760 </span>
<span class="lineno">  761 </span>instance <span class="decl"><span class="istickedoff">GEq uni =&gt; Eq (SomeTypeIn uni)</span></span> where
<span class="lineno">  762 </span>  <span class="decl"><span class="istickedoff">SomeTypeIn a1 == SomeTypeIn a2 = a1 `defaultEq` a2</span></span>
<span class="lineno">  763 </span>
<span class="lineno">  764 </span>instance <span class="decl"><span class="nottickedoff">(GEq uni, Closed uni, uni `Everywhere` Eq) =&gt; Eq (ValueOf uni a)</span></span> where
<span class="lineno">  765 </span>  <span class="decl"><span class="nottickedoff">(==) = defaultEq</span></span>
<span class="lineno">  766 </span>
<span class="lineno">  767 </span>-------------------- 'Compare' / 'GCompare'
<span class="lineno">  768 </span>
<span class="lineno">  769 </span>instance
<span class="lineno">  770 </span>  (GCompare uni, Closed uni, uni `Everywhere` Ord, uni `Everywhere` Eq)
<span class="lineno">  771 </span>  =&gt; GCompare (ValueOf uni)
<span class="lineno">  772 </span>  where
<span class="lineno">  773 </span>  <span class="decl"><span class="nottickedoff">ValueOf uni1 x1 `gcompare` ValueOf uni2 x2 =</span>
<span class="lineno">  774 </span><span class="spaces">    </span><span class="nottickedoff">case uni1 `gcompare` uni2 of</span>
<span class="lineno">  775 </span><span class="spaces">      </span><span class="nottickedoff">GLT -&gt; GLT</span>
<span class="lineno">  776 </span><span class="spaces">      </span><span class="nottickedoff">GGT -&gt; GGT</span>
<span class="lineno">  777 </span><span class="spaces">      </span><span class="nottickedoff">GEQ -&gt;</span>
<span class="lineno">  778 </span><span class="spaces">        </span><span class="nottickedoff">bring (Proxy @Ord) uni1 $ case x1 `compare` x2 of</span>
<span class="lineno">  779 </span><span class="spaces">          </span><span class="nottickedoff">EQ -&gt; GEQ</span>
<span class="lineno">  780 </span><span class="spaces">          </span><span class="nottickedoff">LT -&gt; GLT</span>
<span class="lineno">  781 </span><span class="spaces">          </span><span class="nottickedoff">GT -&gt; GGT</span></span>
<span class="lineno">  782 </span>
<span class="lineno">  783 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">GCompare uni =&gt; Ord (SomeTypeIn uni)</span></span></span></span></span></span></span></span></span></span></span></span> where
<span class="lineno">  784 </span>  <span class="decl"><span class="nottickedoff">SomeTypeIn a1 `compare` SomeTypeIn a2 = a1 `defaultCompare` a2</span></span>
<span class="lineno">  785 </span>
<span class="lineno">  786 </span>-- We need the 'Eq' constraint in order for @Ord (ValueOf uni a)@ to imply @Eq (ValueOf uni a)@.
<span class="lineno">  787 </span>instance
<span class="lineno">  788 </span>  <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">(GCompare uni, Closed uni, uni `Everywhere` Ord, uni `Everywhere` Eq)</span>
<span class="lineno">  789 </span><span class="spaces">  </span><span class="nottickedoff">=&gt; Ord (ValueOf uni a)</span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno">  790 </span>  where
<span class="lineno">  791 </span>  <span class="decl"><span class="nottickedoff">compare = defaultCompare</span></span>
<span class="lineno">  792 </span>
<span class="lineno">  793 </span>-------------------- 'NFData'
<span class="lineno">  794 </span>
<span class="lineno">  795 </span>instance (Closed uni, uni `Everywhere` NFData) =&gt; GNFData (ValueOf uni) where
<span class="lineno">  796 </span>  <span class="decl"><span class="nottickedoff">grnf (ValueOf uni x) = bring (Proxy @NFData) uni $ rnf x</span></span>
<span class="lineno">  797 </span>
<span class="lineno">  798 </span>instance Closed uni =&gt; NFData (SomeTypeIn uni) where
<span class="lineno">  799 </span>  <span class="decl"><span class="nottickedoff">rnf (SomeTypeIn uni) = rnf $ encodeUni uni</span></span>
<span class="lineno">  800 </span>
<span class="lineno">  801 </span>instance (Closed uni, uni `Everywhere` NFData) =&gt; NFData (ValueOf uni a) where
<span class="lineno">  802 </span>  <span class="decl"><span class="nottickedoff">rnf = grnf</span></span>
<span class="lineno">  803 </span>
<span class="lineno">  804 </span>instance <span class="decl"><span class="nottickedoff">(Closed uni, GEq uni) =&gt; Hashable (SomeTypeIn uni)</span></span> where
<span class="lineno">  805 </span>  <span class="decl"><span class="istickedoff">hashWithSalt salt (SomeTypeIn uni) = hashWithSalt salt $ encodeUni uni</span></span>
<span class="lineno">  806 </span>
<span class="lineno">  807 </span>instance
<span class="lineno">  808 </span>  <span class="decl"><span class="nottickedoff">(Closed uni, GEq uni, uni `Everywhere` Eq, uni `Everywhere` Hashable)</span>
<span class="lineno">  809 </span><span class="spaces">  </span><span class="nottickedoff">=&gt; Hashable (ValueOf uni a)</span></span>
<span class="lineno">  810 </span>  where
<span class="lineno">  811 </span>  <span class="decl"><span class="istickedoff">hashWithSalt salt (ValueOf uni x) =</span>
<span class="lineno">  812 </span><span class="spaces">    </span><span class="istickedoff">bring <span class="nottickedoff">(Proxy @Hashable)</span> uni $ hashWithSalt salt (SomeTypeIn uni, x)</span></span>
<span class="lineno">  813 </span>
<span class="lineno">  814 </span>instance
<span class="lineno">  815 </span>  <span class="decl"><span class="nottickedoff">(Closed uni, GEq uni, uni `Everywhere` Eq, uni `Everywhere` Hashable)</span>
<span class="lineno">  816 </span><span class="spaces">  </span><span class="nottickedoff">=&gt; Hashable (Some (ValueOf uni))</span></span>
<span class="lineno">  817 </span>  where
<span class="lineno">  818 </span>  <span class="decl"><span class="istickedoff">hashWithSalt salt (Some s) = hashWithSalt salt s</span></span>

</pre>
</body>
</html>
