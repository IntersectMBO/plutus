<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>-- editorconfig-checker-disable-file
<span class="lineno">    2 </span>{-# LANGUAGE BangPatterns #-}
<span class="lineno">    3 </span>{-# LANGUAGE DeriveAnyClass #-}
<span class="lineno">    4 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">    5 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">    6 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">    7 </span>{-# LANGUAGE NumericUnderscores #-}
<span class="lineno">    8 </span>{-# LANGUAGE StrictData #-}
<span class="lineno">    9 </span>{-# LANGUAGE TypeFamilies #-}
<span class="lineno">   10 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">   11 </span>{-# LANGUAGE UndecidableInstances #-}
<span class="lineno">   12 </span>
<span class="lineno">   13 </span>module PlutusCore.Evaluation.Machine.CostingFun.Core
<span class="lineno">   14 </span>  ( CostingFun (..)
<span class="lineno">   15 </span>  , UnimplementedCostingFun (..)
<span class="lineno">   16 </span>  , Intercept (..)
<span class="lineno">   17 </span>  , Slope (..)
<span class="lineno">   18 </span>  , Coefficient0 (..)
<span class="lineno">   19 </span>  , Coefficient1 (..)
<span class="lineno">   20 </span>  , Coefficient2 (..)
<span class="lineno">   21 </span>  , Coefficient00 (..)
<span class="lineno">   22 </span>  , Coefficient10 (..)
<span class="lineno">   23 </span>  , Coefficient01 (..)
<span class="lineno">   24 </span>  , Coefficient20 (..)
<span class="lineno">   25 </span>  , Coefficient11 (..)
<span class="lineno">   26 </span>  , Coefficient02 (..)
<span class="lineno">   27 </span>  , Coefficient12 (..)
<span class="lineno">   28 </span>  , OneVariableLinearFunction (..)
<span class="lineno">   29 </span>  , OneVariableQuadraticFunction (..)
<span class="lineno">   30 </span>  , TwoVariableLinearFunction (..)
<span class="lineno">   31 </span>  , TwoVariableQuadraticFunction (..)
<span class="lineno">   32 </span>  , TwoVariableWithInteractionFunction (..)
<span class="lineno">   33 </span>  , ExpModCostingFunction (..)
<span class="lineno">   34 </span>  , ModelSubtractedSizes (..)
<span class="lineno">   35 </span>  , ModelConstantOrLinear (..) -- Deprecated: see below.
<span class="lineno">   36 </span>  , ModelConstantOrOneArgument (..)
<span class="lineno">   37 </span>  , ModelConstantOrTwoArguments (..)
<span class="lineno">   38 </span>  , ModelOneArgument (..)
<span class="lineno">   39 </span>  , ModelTwoArguments (..)
<span class="lineno">   40 </span>  , ModelThreeArguments (..)
<span class="lineno">   41 </span>  , ModelFourArguments (..)
<span class="lineno">   42 </span>  , ModelFiveArguments (..)
<span class="lineno">   43 </span>  , ModelSixArguments (..)
<span class="lineno">   44 </span>  , runCostingFunOneArgument
<span class="lineno">   45 </span>  , runCostingFunTwoArguments
<span class="lineno">   46 </span>  , runCostingFunThreeArguments
<span class="lineno">   47 </span>  , runCostingFunFourArguments
<span class="lineno">   48 </span>  , runCostingFunFiveArguments
<span class="lineno">   49 </span>  , runCostingFunSixArguments
<span class="lineno">   50 </span>  , Hashable
<span class="lineno">   51 </span>  )
<span class="lineno">   52 </span>where
<span class="lineno">   53 </span>
<span class="lineno">   54 </span>import PlutusCore.Evaluation.Machine.CostStream
<span class="lineno">   55 </span>import PlutusCore.Evaluation.Machine.ExBudgetStream
<span class="lineno">   56 </span>import PlutusCore.Evaluation.Machine.ExMemory
<span class="lineno">   57 </span>import PlutusCore.Evaluation.Machine.ExMemoryUsage
<span class="lineno">   58 </span>
<span class="lineno">   59 </span>import Control.DeepSeq
<span class="lineno">   60 </span>import Data.Default.Class
<span class="lineno">   61 </span>import Data.Hashable
<span class="lineno">   62 </span>import Deriving.Aeson
<span class="lineno">   63 </span>import GHC.Exts
<span class="lineno">   64 </span>import Language.Haskell.TH.Syntax hiding
<span class="lineno">   65 </span>  ( Name
<span class="lineno">   66 </span>  , newName
<span class="lineno">   67 </span>  )
<span class="lineno">   68 </span>
<span class="lineno">   69 </span>-- | A class used for convenience in this module, don't export it.
<span class="lineno">   70 </span>class OnMemoryUsages c a where
<span class="lineno">   71 </span>  {-| Turn
<span class="lineno">   72 </span>
<span class="lineno">   73 </span>  &gt; \mem1 ... memN -&gt; f mem1 ... memN
<span class="lineno">   74 </span>
<span class="lineno">   75 </span>  into
<span class="lineno">   76 </span>
<span class="lineno">   77 </span>  &gt; \arg1 ... argN -&gt; f (memoryUsage arg1) ... (memoryUsage argN)
<span class="lineno">   78 </span>
<span class="lineno">   79 </span>  so that we don't need to repeat those 'memoryUsage' calls at every use site, which would also
<span class="lineno">   80 </span>  require binding @arg*@ explicitly, i.e. require even more boilerplate. -}
<span class="lineno">   81 </span>  onMemoryUsages :: c -&gt; a
<span class="lineno">   82 </span>
<span class="lineno">   83 </span>instance
<span class="lineno">   84 </span>  (ab ~ (a -&gt; b), ExMemoryUsage a, OnMemoryUsages c b)
<span class="lineno">   85 </span>  =&gt; OnMemoryUsages (CostStream -&gt; c) ab
<span class="lineno">   86 </span>  where
<span class="lineno">   87 </span>  -- 'inline' is for making sure that 'memoryUsage' does get inlined.
<span class="lineno">   88 </span>  <span class="decl"><span class="istickedoff">onMemoryUsages f = onMemoryUsages . f . flattenCostRose . inline memoryUsage</span></span>
<span class="lineno">   89 </span>  {-# INLINE onMemoryUsages #-}
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>instance ab ~ ExBudgetStream =&gt; OnMemoryUsages ExBudgetStream ab where
<span class="lineno">   92 </span>  <span class="decl"><span class="istickedoff">onMemoryUsages = id</span></span>
<span class="lineno">   93 </span>  {-# INLINE onMemoryUsages #-}
<span class="lineno">   94 </span>
<span class="lineno">   95 </span>{-| A type of costing functions parametric over a model type.  In practice the we
<span class="lineno">   96 </span>have one model type `Model&lt;N&gt;Arguments` for every N, where N is the arity of the
<span class="lineno">   97 </span>builtin whose costs we want to model.  Each model type has a number of
<span class="lineno">   98 </span>constructors defining different &quot;shapes&quot; of N-parameter functions which
<span class="lineno">   99 </span>calculate a cost given the sizes of the builtin's arguments. -}
<span class="lineno">  100 </span>data CostingFun model = CostingFun
<span class="lineno">  101 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">costingFunCpu</span></span></span> :: model
<span class="lineno">  102 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">costingFunMemory</span></span></span> :: model
<span class="lineno">  103 </span>  }
<span class="lineno">  104 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  105 </span>  deriving anyclass (<span class="decl"><span class="istickedoff">Default</span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  106 </span>
<span class="lineno">  107 </span>{-| In the initial stages of implementing a new builtin it is necessary to
<span class="lineno">  108 </span>   provide a temporary costing function which is used until the builtin has been
<span class="lineno">  109 </span>   properly costed: `see CostModelGeneration.md`.  Each `Model&lt;N&gt;Arguments` type
<span class="lineno">  110 </span>   defines an instance of this class where `unimplementedCostingFun` is a
<span class="lineno">  111 </span>   constant costing function which returns a very high cost for all inputs.
<span class="lineno">  112 </span>   This prevents new functions from being used in situations where costs are
<span class="lineno">  113 </span>   important until a sensible costing function has been implemented. -}
<span class="lineno">  114 </span>class UnimplementedCostingFun a where
<span class="lineno">  115 </span>  unimplementedCostingFun :: b -&gt; CostingFun a
<span class="lineno">  116 </span>
<span class="lineno">  117 </span>{-| Make a very expensive pair of CPU and memory costing functions.  The name is
<span class="lineno">  118 </span>   slightly misleading because it actually makes a function which returns such a
<span class="lineno">  119 </span>   pair, which is what is required at the use site in `PlutusCore.Default.Builtins`,
<span class="lineno">  120 </span>   where properly implemented costing functions are constructed from a
<span class="lineno">  121 </span>   BuiltinCostModel object.  We can't use maxBound :: CostingInteger because then the
<span class="lineno">  122 </span>   evaluator always fails; instead we assign a cost of 100,000,000,000, which is well
<span class="lineno">  123 </span>   beyond the current on-chain CPU and memory limits (10,000,000,000 and 14,000,000
<span class="lineno">  124 </span>   respectively) but still allows over 92,000,000 evaluations before the maximum
<span class="lineno">  125 </span>   CostingInteger is reached.  This allows us to use an &quot;uncosted&quot; builtin for
<span class="lineno">  126 </span>   testing and for running costing benchmarks, but will prevent it from being used
<span class="lineno">  127 </span>   when the Plutus Core evaluator is invoked by the ledger. -}
<span class="lineno">  128 </span>makeUnimplementedCostingFun :: (CostingInteger -&gt; model) -&gt; b -&gt; CostingFun model
<span class="lineno">  129 </span><span class="decl"><span class="nottickedoff">makeUnimplementedCostingFun c =</span>
<span class="lineno">  130 </span><span class="spaces">  </span><span class="nottickedoff">const $ CostingFun (c k) (c k)</span>
<span class="lineno">  131 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  132 </span><span class="spaces">    </span><span class="nottickedoff">k = 100_000_000_000</span></span>
<span class="lineno">  133 </span>
<span class="lineno">  134 </span>---------------- Types for use within costing functions ----------------
<span class="lineno">  135 </span>
<span class="lineno">  136 </span>-- | A wrapped 'CostingInteger' that is supposed to be used as an intercept.
<span class="lineno">  137 </span>newtype Intercept = Intercept
<span class="lineno">  138 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unIntercept</span></span></span> :: CostingInteger
<span class="lineno">  139 </span>  }
<span class="lineno">  140 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  141 </span>  deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  142 </span>
<span class="lineno">  143 </span>-- | A wrapped 'CostingInteger' that is supposed to be used as a slope.
<span class="lineno">  144 </span>newtype Slope = Slope
<span class="lineno">  145 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unSlope</span></span></span> :: CostingInteger
<span class="lineno">  146 </span>  }
<span class="lineno">  147 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  148 </span>  deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  149 </span>
<span class="lineno">  150 </span>{-| A wrapped 'CostingInteger' that is supposed to be used as the degree 0
<span class="lineno">  151 </span>coefficient of a polynomial. -}
<span class="lineno">  152 </span>newtype Coefficient0 = Coefficient0
<span class="lineno">  153 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unCoefficient0</span></span></span> :: CostingInteger
<span class="lineno">  154 </span>  }
<span class="lineno">  155 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  156 </span>  deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  157 </span>
<span class="lineno">  158 </span>{-| A wrapped 'CostingInteger' that is supposed to be used as the degree 1
<span class="lineno">  159 </span>coefficient of a polynomial. -}
<span class="lineno">  160 </span>newtype Coefficient1 = Coefficient1
<span class="lineno">  161 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unCoefficient1</span></span></span> :: CostingInteger
<span class="lineno">  162 </span>  }
<span class="lineno">  163 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  164 </span>  deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  165 </span>
<span class="lineno">  166 </span>{-| A wrapped 'CostingInteger' that is supposed to be used as the degree 2
<span class="lineno">  167 </span>coefficient of a polynomial. -}
<span class="lineno">  168 </span>newtype Coefficient2 = Coefficient2
<span class="lineno">  169 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unCoefficient2</span></span></span> :: CostingInteger
<span class="lineno">  170 </span>  }
<span class="lineno">  171 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  172 </span>  deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  173 </span>
<span class="lineno">  174 </span>{-| A wrapped 'CostingInteger' that is supposed to be used as the degree (0,0)
<span class="lineno">  175 </span>coefficient of a two-variable polynomial. -}
<span class="lineno">  176 </span>newtype Coefficient00 = Coefficient00
<span class="lineno">  177 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unCoefficient00</span></span></span> :: CostingInteger
<span class="lineno">  178 </span>  }
<span class="lineno">  179 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  180 </span>  deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  181 </span>
<span class="lineno">  182 </span>{-| A wrapped 'CostingInteger' that is supposed to be used as the degree (1,0)
<span class="lineno">  183 </span>coefficient of a two-variable polynomial. -}
<span class="lineno">  184 </span>newtype Coefficient10 = Coefficient10
<span class="lineno">  185 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unCoefficient10</span></span></span> :: CostingInteger
<span class="lineno">  186 </span>  }
<span class="lineno">  187 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  188 </span>  deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  189 </span>
<span class="lineno">  190 </span>{-| A wrapped 'CostingInteger' that is supposed to be used as the degree (0,1)
<span class="lineno">  191 </span>coefficient of a two-variable polynomial. -}
<span class="lineno">  192 </span>newtype Coefficient01 = Coefficient01
<span class="lineno">  193 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unCoefficient01</span></span></span> :: CostingInteger
<span class="lineno">  194 </span>  }
<span class="lineno">  195 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  196 </span>  deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  197 </span>
<span class="lineno">  198 </span>{-| A wrapped 'CostingInteger' that is supposed to be used as the degree (2,0)
<span class="lineno">  199 </span>coefficient of a two-variable polynomial. -}
<span class="lineno">  200 </span>newtype Coefficient20 = Coefficient20
<span class="lineno">  201 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unCoefficient20</span></span></span> :: CostingInteger
<span class="lineno">  202 </span>  }
<span class="lineno">  203 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  204 </span>  deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  205 </span>
<span class="lineno">  206 </span>{-| A wrapped 'CostingInteger' that is supposed to be used as the degree (1,1)
<span class="lineno">  207 </span>coefficient of a two-variable polynomial. -}
<span class="lineno">  208 </span>newtype Coefficient11 = Coefficient11
<span class="lineno">  209 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unCoefficient11</span></span></span> :: CostingInteger
<span class="lineno">  210 </span>  }
<span class="lineno">  211 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  212 </span>  deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  213 </span>
<span class="lineno">  214 </span>{-| A wrapped 'CostingInteger' that is supposed to be used as the degree (0,2)
<span class="lineno">  215 </span>coefficient of a two-variable polynomial. -}
<span class="lineno">  216 </span>newtype Coefficient02 = Coefficient02
<span class="lineno">  217 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unCoefficient02</span></span></span> :: CostingInteger
<span class="lineno">  218 </span>  }
<span class="lineno">  219 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  220 </span>  deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  221 </span>
<span class="lineno">  222 </span>{-| A wrapped 'CostingInteger' that is supposed to be used as the degree (1,2)
<span class="lineno">  223 </span>coefficient of a two-variable polynomial. -}
<span class="lineno">  224 </span>newtype Coefficient12 = Coefficient12
<span class="lineno">  225 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unCoefficient12</span></span></span> :: CostingInteger
<span class="lineno">  226 </span>  }
<span class="lineno">  227 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  228 </span>  deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Num</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  229 </span>
<span class="lineno">  230 </span>---------------- One-argument costing functions ----------------
<span class="lineno">  231 </span>
<span class="lineno">  232 </span>data ModelOneArgument
<span class="lineno">  233 </span>  = ModelOneArgumentConstantCost CostingInteger
<span class="lineno">  234 </span>  | ModelOneArgumentLinearInX OneVariableLinearFunction
<span class="lineno">  235 </span>  | ModelOneArgumentQuadraticInX OneVariableQuadraticFunction
<span class="lineno">  236 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  237 </span>  deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  238 </span>
<span class="lineno">  239 </span>instance Default ModelOneArgument where
<span class="lineno">  240 </span>  <span class="decl"><span class="istickedoff">def = ModelOneArgumentConstantCost maxBound</span></span>
<span class="lineno">  241 </span>
<span class="lineno">  242 </span>instance UnimplementedCostingFun ModelOneArgument where
<span class="lineno">  243 </span>  <span class="decl"><span class="nottickedoff">unimplementedCostingFun = makeUnimplementedCostingFun ModelOneArgumentConstantCost</span></span>
<span class="lineno">  244 </span>
<span class="lineno">  245 </span>{- Note [runCostingFun* API]
<span class="lineno">  246 </span>Costing functions take unlifted values, compute the 'ExMemory' of each of them and then invoke
<span class="lineno">  247 </span>the corresponding @run*Model@ over the computed 'ExMemory's. The reason why we don't just make the
<span class="lineno">  248 </span>costing functions take 'ExMemory's in the first place is that this would move the burden of
<span class="lineno">  249 </span>computing the 'ExMemory's onto the caller, i.e. the user defining the meaning of a builtin and it
<span class="lineno">  250 </span>would be just another hoop to jump through and a completely unnecessary complication for the user.
<span class="lineno">  251 </span>
<span class="lineno">  252 </span>The reason why costing functions take unlifted values are:
<span class="lineno">  253 </span>
<span class="lineno">  254 </span>1. we need to unlift them anyway to compute the result of a builtin application, so since we already
<span class="lineno">  255 </span>   need them elsewhere, we can utilize them in the costing machinery too. Otherwise the costing
<span class="lineno">  256 </span>   machinery would need to do some unlifting itself, which would be wasteful
<span class="lineno">  257 </span>2. the costing function might actually depend on the constants that get fed to the builtin.
<span class="lineno">  258 </span>   For example, checking equality of integers stored in a 'Data' object potentially has a different
<span class="lineno">  259 </span>   complexity to checking equality of lists of bytestrings
<span class="lineno">  260 </span>-}
<span class="lineno">  261 </span>
<span class="lineno">  262 </span>{- Note [Optimizations of runCostingFun*]
<span class="lineno">  263 </span>We optimize all @runCostingFun*@ functions in the same way:
<span class="lineno">  264 </span>
<span class="lineno">  265 </span>1. the two calls to @run*Model@ are placed right after matching on the first argument, so that
<span class="lineno">  266 </span>   they are partially computed and cached, which results in them being called only once per builtin
<span class="lineno">  267 </span>2. we use a strict case-expression for matching, which GHC can't move inside the resulting lambda
<span class="lineno">  268 </span>   (unlike a strict let-expression for example)
<span class="lineno">  269 </span>3. the whole definition is marked with @INLINE@, because it gets worker-wrapper transformed and we
<span class="lineno">  270 </span>   don't want to keep the worker separate from the wrapper as it just results in unnecessary
<span class="lineno">  271 </span>   wrapping-unwrapping
<span class="lineno">  272 </span>
<span class="lineno">  273 </span>In order for @run*Model@ functions to be able to partially compute we need to define them
<span class="lineno">  274 </span>accordingly, i.e. by matching on the first argument and returning a lambda. We wrap one of the
<span class="lineno">  275 </span>clauses with a call to 'lazy', so that GHC does not &quot;optimize&quot; the function by moving matching to
<span class="lineno">  276 </span>the inside of the resulting lambda (which would defeat the whole purpose of caching the function).
<span class="lineno">  277 </span>It's enough to put 'lazy' in only one of the clauses for all of them to be compiled the right way,
<span class="lineno">  278 </span>however adding 'lazy' to all the other clauses too turned out to improve performance by a couple of
<span class="lineno">  279 </span>percent, reasons are unclear.
<span class="lineno">  280 </span>
<span class="lineno">  281 </span>Alternatively, we could use @-fpedantic-bottoms@, which prevents GHC from moving matching above
<span class="lineno">  282 </span>a lambda (see https://github.com/IntersectMBO/plutus/pull/4621), however it doesn't make anything
<span class="lineno">  283 </span>faster, generates more Core and doesn't take much to break, hence we choose the hacky 'lazy'
<span class="lineno">  284 </span>version.
<span class="lineno">  285 </span>
<span class="lineno">  286 </span>Since we want @run*Model@ functions to partially compute, we mark them as @OPAQUE@ to prevent GHC
<span class="lineno">  287 </span>from inlining them and breaking the sharing friendliness. Without the @OPAQUE@ Core doesn't seem
<span class="lineno">  288 </span>to be worse, however it was verified that no @OPAQUE@ causes a slowdown in both the @validation@
<span class="lineno">  289 </span>and @nofib@ benchmarks.
<span class="lineno">  290 </span>
<span class="lineno">  291 </span>Note that looking at the generated Core isn't really enough. We might have enemies down the pipeline,
<span class="lineno">  292 </span>for example @-fstg-lift-lams@ looks suspicious:
<span class="lineno">  293 </span>
<span class="lineno">  294 </span>&gt; Enables the late lambda lifting optimisation on the STG intermediate language. This selectively
<span class="lineno">  295 </span>&gt; lifts local functions to top-level by converting free variables into function parameters.
<span class="lineno">  296 </span>
<span class="lineno">  297 </span>This wasn't investigated.
<span class="lineno">  298 </span>
<span class="lineno">  299 </span>These optimizations gave us a ~3.2% speedup at the time this Note was written.
<span class="lineno">  300 </span>-}
<span class="lineno">  301 </span>
<span class="lineno">  302 </span>-- See Note [runCostingFun* API].
<span class="lineno">  303 </span>runCostingFunOneArgument
<span class="lineno">  304 </span>  :: ExMemoryUsage a1
<span class="lineno">  305 </span>  =&gt; CostingFun ModelOneArgument
<span class="lineno">  306 </span>  -&gt; a1
<span class="lineno">  307 </span>  -&gt; ExBudgetStream
<span class="lineno">  308 </span><span class="decl"><span class="istickedoff">runCostingFunOneArgument (CostingFun cpu mem) =</span>
<span class="lineno">  309 </span><span class="spaces">  </span><span class="istickedoff">case (runOneArgumentModel cpu, runOneArgumentModel mem) of</span>
<span class="lineno">  310 </span><span class="spaces">    </span><span class="istickedoff">(!runCpu, !runMem) -&gt; onMemoryUsages $ \mem1 -&gt;</span>
<span class="lineno">  311 </span><span class="spaces">      </span><span class="istickedoff">zipCostStream</span>
<span class="lineno">  312 </span><span class="spaces">        </span><span class="istickedoff">(runCpu mem1)</span>
<span class="lineno">  313 </span><span class="spaces">        </span><span class="istickedoff">(runMem mem1)</span></span>
<span class="lineno">  314 </span>{-# INLINE runCostingFunOneArgument #-}
<span class="lineno">  315 </span>
<span class="lineno">  316 </span>{-| Take an intercept, a slope and a stream and scale each element of the stream by the slope and
<span class="lineno">  317 </span>cons the intercept to the stream afterwards. -}
<span class="lineno">  318 </span>scaleLinearly :: Intercept -&gt; Slope -&gt; CostStream -&gt; CostStream
<span class="lineno">  319 </span><span class="decl"><span class="istickedoff">scaleLinearly (Intercept intercept) (Slope slope) =</span>
<span class="lineno">  320 </span><span class="spaces">  </span><span class="istickedoff">addCostStream (CostLast intercept) . mapCostStream (slope *)</span></span>
<span class="lineno">  321 </span>{-# INLINE scaleLinearly #-}
<span class="lineno">  322 </span>
<span class="lineno">  323 </span>{-| Evaluate the polynomial f(x) = ax^2+bx+c on a cost stream.  The lazy
<span class="lineno">  324 </span>strategy used here is based on the fact that
<span class="lineno">  325 </span>
<span class="lineno">  326 </span>  f(r+x) = a(r+x)^2 + b(r+x) + c
<span class="lineno">  327 </span>         = ar^2 + 2axr + ax^2 + br + bx + c
<span class="lineno">  328 </span>         = f(r) + 2axr + ax^2 + bx
<span class="lineno">  329 </span>
<span class="lineno">  330 </span>The name `scaleQuadratically` is perhaps a bit misleading, but it's not clear
<span class="lineno">  331 </span>what would be better. -}
<span class="lineno">  332 </span>scaleQuadratically
<span class="lineno">  333 </span>  :: OneVariableQuadraticFunction
<span class="lineno">  334 </span>  -&gt; CostStream
<span class="lineno">  335 </span>  -&gt; CostStream
<span class="lineno">  336 </span><span class="decl"><span class="istickedoff">scaleQuadratically (OneVariableQuadraticFunction (Coefficient0 c) (Coefficient1 b) (Coefficient2 a)) =</span>
<span class="lineno">  337 </span><span class="spaces">  </span><span class="istickedoff">addCostStream (CostLast c) . go 0</span>
<span class="lineno">  338 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  339 </span><span class="spaces">    </span><span class="istickedoff">go :: CostingInteger -&gt; CostStream -&gt; CostStream</span>
<span class="lineno">  340 </span><span class="spaces">    </span><span class="istickedoff">go !r = \case</span>
<span class="lineno">  341 </span><span class="spaces">      </span><span class="istickedoff">-- r is the running total</span>
<span class="lineno">  342 </span><span class="spaces">      </span><span class="istickedoff">CostLast cost -&gt; CostLast (f cost)</span>
<span class="lineno">  343 </span><span class="spaces">      </span><span class="istickedoff">CostCons cost costs -&gt; CostCons (f cost) (go (r + cost) costs)</span>
<span class="lineno">  344 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  345 </span><span class="spaces">        </span><span class="istickedoff">f :: CostingInteger -&gt; CostingInteger</span>
<span class="lineno">  346 </span><span class="spaces">        </span><span class="istickedoff">f x = 2 * a * x * r + a * x * x + b * x</span></span>
<span class="lineno">  347 </span>{-# INLINE scaleQuadratically #-}
<span class="lineno">  348 </span>
<span class="lineno">  349 </span>runOneArgumentModel
<span class="lineno">  350 </span>  :: ModelOneArgument
<span class="lineno">  351 </span>  -&gt; CostStream
<span class="lineno">  352 </span>  -&gt; CostStream
<span class="lineno">  353 </span><span class="decl"><span class="istickedoff">runOneArgumentModel (ModelOneArgumentConstantCost c) =</span>
<span class="lineno">  354 </span><span class="spaces">  </span><span class="istickedoff">lazy $ \_ -&gt; CostLast c</span>
<span class="lineno">  355 </span><span class="spaces"></span><span class="istickedoff">runOneArgumentModel (ModelOneArgumentLinearInX (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  356 </span><span class="spaces">  </span><span class="istickedoff">lazy $ \costs1 -&gt; scaleLinearly intercept slope costs1</span>
<span class="lineno">  357 </span><span class="spaces"></span><span class="istickedoff">runOneArgumentModel (ModelOneArgumentQuadraticInX f) =</span>
<span class="lineno">  358 </span><span class="spaces">  </span><span class="istickedoff">lazy $ \costs1 -&gt; scaleQuadratically f costs1</span></span>
<span class="lineno">  359 </span>{-# OPAQUE runOneArgumentModel #-}
<span class="lineno">  360 </span>
<span class="lineno">  361 </span>---------------- Two-argument costing functions ----------------
<span class="lineno">  362 </span>
<span class="lineno">  363 </span>{- Because of the way the costing code has evolved the names of the model types
<span class="lineno">  364 </span>below aren't very consistent.  However it's a little difficult to change them
<span class="lineno">  365 </span>because that would change some of the JSON tags in the cost model file.  The
<span class="lineno">  366 </span>basic models are one-variable and two-variable linear models and their names
<span class="lineno">  367 </span>(`OneVariableLinearFunction` and `TwoVariableLinearFunction`) reflect this .
<span class="lineno">  368 </span>Other models have names like `ModelAddedSizes` and it might be more logical if
<span class="lineno">  369 </span>they were called things like `LinearInXPlusY` and so on since these are really
<span class="lineno">  370 </span>abstract functions that don't know anything about sizes.  Also many of the types
<span class="lineno">  371 </span>have their own intercept and slope values because they are linear on some
<span class="lineno">  372 </span>function of the inputs or are linear in some region of the plane.  Maybe these
<span class="lineno">  373 </span>should contain nested objects of type ModelLinearInOneVariable instead, but that
<span class="lineno">  374 </span>would complicate the JSON encoding and might also impact efficiency.
<span class="lineno">  375 </span>-}
<span class="lineno">  376 </span>
<span class="lineno">  377 </span>-- | s * x + I
<span class="lineno">  378 </span>data OneVariableLinearFunction = OneVariableLinearFunction
<span class="lineno">  379 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">oneVariableLinearFunctionIntercept</span></span></span> :: Intercept
<span class="lineno">  380 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">oneVariableLinearFunctionSlope</span></span></span> :: Slope
<span class="lineno">  381 </span>  }
<span class="lineno">  382 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  383 </span>  deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  384 </span>
<span class="lineno">  385 </span>-- | s1 * x + s2 * y + I
<span class="lineno">  386 </span>data TwoVariableLinearFunction = TwoVariableLinearFunction
<span class="lineno">  387 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableLinearFunctionIntercept</span></span></span> :: Intercept
<span class="lineno">  388 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableLinearFunctionSlope1</span></span></span> :: Slope
<span class="lineno">  389 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableLinearFunctionSlope2</span></span></span> :: Slope
<span class="lineno">  390 </span>  }
<span class="lineno">  391 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  392 </span>  deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  393 </span>
<span class="lineno">  394 </span>-- | c0 + c1*x + c2*x^2
<span class="lineno">  395 </span>data OneVariableQuadraticFunction = OneVariableQuadraticFunction
<span class="lineno">  396 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">oneVariableQuadraticFunctionC0</span></span></span> :: Coefficient0
<span class="lineno">  397 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">oneVariableQuadraticFunctionC1</span></span></span> :: Coefficient1
<span class="lineno">  398 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">oneVariableQuadraticFunctionC2</span></span></span> :: Coefficient2
<span class="lineno">  399 </span>  }
<span class="lineno">  400 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  401 </span>  deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  402 </span>
<span class="lineno">  403 </span>{- Note [Minimum values for two-variable quadratic costing functions] Unlike most
<span class="lineno">  404 </span>   of our other costing functions our use cases for two-variable quadratic
<span class="lineno">  405 </span>   costing functions may require one or more negative coefficients, so there's a
<span class="lineno">  406 </span>   danger that we could return a negative cost.  This is unlikely, but we make
<span class="lineno">  407 </span>   certain that it never happens by returning a result that is at never smaller
<span class="lineno">  408 </span>   than a minimum value that is stored along with the coefficients of the
<span class="lineno">  409 </span>   function.
<span class="lineno">  410 </span>-}
<span class="lineno">  411 </span>-- | c00 + c10*x + c01*y + c20*x^2 + c11*c*y + c02*y^2
<span class="lineno">  412 </span>data TwoVariableQuadraticFunction = TwoVariableQuadraticFunction
<span class="lineno">  413 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableQuadraticFunctionMinimum</span></span></span> :: CostingInteger
<span class="lineno">  414 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableQuadraticFunctionC00</span></span></span> :: Coefficient00
<span class="lineno">  415 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableQuadraticFunctionC10</span></span></span> :: Coefficient10
<span class="lineno">  416 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableQuadraticFunctionC01</span></span></span> :: Coefficient01
<span class="lineno">  417 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableQuadraticFunctionC20</span></span></span> :: Coefficient20
<span class="lineno">  418 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableQuadraticFunctionC11</span></span></span> :: Coefficient11
<span class="lineno">  419 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableQuadraticFunctionC02</span></span></span> :: Coefficient02
<span class="lineno">  420 </span>  }
<span class="lineno">  421 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  422 </span>  deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  423 </span>
<span class="lineno">  424 </span>evaluateTwoVariableQuadraticFunction
<span class="lineno">  425 </span>  :: TwoVariableQuadraticFunction
<span class="lineno">  426 </span>  -&gt; CostingInteger
<span class="lineno">  427 </span>  -&gt; CostingInteger
<span class="lineno">  428 </span>  -&gt; CostingInteger
<span class="lineno">  429 </span><span class="decl"><span class="istickedoff">evaluateTwoVariableQuadraticFunction</span>
<span class="lineno">  430 </span><span class="spaces">  </span><span class="istickedoff">( TwoVariableQuadraticFunction</span>
<span class="lineno">  431 </span><span class="spaces">      </span><span class="istickedoff">minVal</span>
<span class="lineno">  432 </span><span class="spaces">      </span><span class="istickedoff">(Coefficient00 c00)</span>
<span class="lineno">  433 </span><span class="spaces">      </span><span class="istickedoff">(Coefficient10 c10)</span>
<span class="lineno">  434 </span><span class="spaces">      </span><span class="istickedoff">(Coefficient01 c01)</span>
<span class="lineno">  435 </span><span class="spaces">      </span><span class="istickedoff">(Coefficient20 c20)</span>
<span class="lineno">  436 </span><span class="spaces">      </span><span class="istickedoff">(Coefficient11 c11)</span>
<span class="lineno">  437 </span><span class="spaces">      </span><span class="istickedoff">(Coefficient02 c02)</span>
<span class="lineno">  438 </span><span class="spaces">    </span><span class="istickedoff">)</span>
<span class="lineno">  439 </span><span class="spaces">  </span><span class="istickedoff">x</span>
<span class="lineno">  440 </span><span class="spaces">  </span><span class="istickedoff">y = max minVal (c00 + c10 * x + c01 * y + c20 * x * x + c11 * x * y + c02 * y * y)</span></span>
<span class="lineno">  441 </span>-- We want to be absolutely sure that we don't get back a negative number
<span class="lineno">  442 </span>-- here: see Note [Minimum values for two-variable quadratic costing functions]
<span class="lineno">  443 </span>{-# INLINE evaluateTwoVariableQuadraticFunction #-}
<span class="lineno">  444 </span>
<span class="lineno">  445 </span>{-| c00 + c01x*y + c12x*y^2
<span class="lineno">  446 </span>This is used only for `expModInteger`, whose costing is quite complex. -}
<span class="lineno">  447 </span>data ExpModCostingFunction = ExpModCostingFunction
<span class="lineno">  448 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">coefficient00</span></span></span> :: Coefficient00
<span class="lineno">  449 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">coefficient11</span></span></span> :: Coefficient11
<span class="lineno">  450 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">coefficient12</span></span></span> :: Coefficient12
<span class="lineno">  451 </span>  }
<span class="lineno">  452 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  453 </span>  deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  454 </span>
<span class="lineno">  455 </span>{-| Calculate the cost of calling `expModInteger a e m` where a is of size aa, e
<span class="lineno">  456 </span>is of size ee, and m is of size mm.  If aa&gt;mm then the cost is increased by
<span class="lineno">  457 </span>50% to impose a penalty for the extra cost of initially reducing `a` modulo `m`.
<span class="lineno">  458 </span>If large values of `a` really are required then the penalty can be avoided by
<span class="lineno">  459 </span>calling `modInteger` before `expModInteger`. -}
<span class="lineno">  460 </span>evaluateExpModCostingFunction
<span class="lineno">  461 </span>  :: ExpModCostingFunction
<span class="lineno">  462 </span>  -&gt; CostingInteger
<span class="lineno">  463 </span>  -&gt; CostingInteger
<span class="lineno">  464 </span>  -&gt; CostingInteger
<span class="lineno">  465 </span>  -&gt; CostingInteger
<span class="lineno">  466 </span><span class="decl"><span class="istickedoff">evaluateExpModCostingFunction</span>
<span class="lineno">  467 </span><span class="spaces">  </span><span class="istickedoff">( ExpModCostingFunction</span>
<span class="lineno">  468 </span><span class="spaces">      </span><span class="istickedoff">(Coefficient00 c00)</span>
<span class="lineno">  469 </span><span class="spaces">      </span><span class="istickedoff">(Coefficient11 c11)</span>
<span class="lineno">  470 </span><span class="spaces">      </span><span class="istickedoff">(Coefficient12 c12)</span>
<span class="lineno">  471 </span><span class="spaces">    </span><span class="istickedoff">)</span>
<span class="lineno">  472 </span><span class="spaces">  </span><span class="istickedoff">aa</span>
<span class="lineno">  473 </span><span class="spaces">  </span><span class="istickedoff">ee</span>
<span class="lineno">  474 </span><span class="spaces">  </span><span class="istickedoff">mm =</span>
<span class="lineno">  475 </span><span class="spaces">    </span><span class="istickedoff">if aa &lt;= mm</span>
<span class="lineno">  476 </span><span class="spaces">      </span><span class="istickedoff">then cost0</span>
<span class="lineno">  477 </span><span class="spaces">      </span><span class="istickedoff">else cost0 + (cost0 `dividedBy` 2)</span>
<span class="lineno">  478 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  479 </span><span class="spaces">      </span><span class="istickedoff">cost0 = c00 + c11 * ee * mm + c12 * ee * mm * mm</span></span>
<span class="lineno">  480 </span>{-# INLINE evaluateExpModCostingFunction #-}
<span class="lineno">  481 </span>
<span class="lineno">  482 </span>-- | s * (x - y) + I
<span class="lineno">  483 </span>
<span class="lineno">  484 </span>{- In principle we could use ModelConstantOrOneArgument here, but that would
<span class="lineno">  485 </span>change the order of the cost model parameters since the minimum value would come
<span class="lineno">  486 </span>first instead of last, so for the time being we use a special type. We may be
<span class="lineno">  487 </span>able to change this later if we move to a self-describing cost model format
<span class="lineno">  488 </span>where the cost model parameters include the type of the costing function. See
<span class="lineno">  489 </span>Note [Backward compatibility for costing functions]. -}
<span class="lineno">  490 </span>data ModelSubtractedSizes = ModelSubtractedSizes
<span class="lineno">  491 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">modelSubtractedSizesIntercept</span></span></span> :: Intercept
<span class="lineno">  492 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">modelSubtractedSizesSlope</span></span></span> :: Slope
<span class="lineno">  493 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">modelSubtractedSizesMinimum</span></span></span> :: CostingInteger
<span class="lineno">  494 </span>  }
<span class="lineno">  495 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  496 </span>  deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  497 </span>
<span class="lineno">  498 </span>-- | if p then s*x else c; p depends on usage
<span class="lineno">  499 </span>
<span class="lineno">  500 </span>{- NB: this is subsumed by ModelConstantOrOneArgument, but we have to keep it
<span class="lineno">  501 </span>-- for the time being.  See Note [Backward compatibility for costing functions]. -}
<span class="lineno">  502 </span>data ModelConstantOrLinear = ModelConstantOrLinear
<span class="lineno">  503 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">modelConstantOrLinearConstant</span></span></span> :: CostingInteger
<span class="lineno">  504 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">modelConstantOrLinearIntercept</span></span></span> :: Intercept
<span class="lineno">  505 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">modelConstantOrLinearSlope</span></span></span> :: Slope
<span class="lineno">  506 </span>  }
<span class="lineno">  507 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  508 </span>  deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  509 </span>
<span class="lineno">  510 </span>-- | if p then f(x) else c; p depends on usage
<span class="lineno">  511 </span>data ModelConstantOrOneArgument = ModelConstantOrOneArgument
<span class="lineno">  512 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">modelConstantOrOneArgumentConstant</span></span></span> :: CostingInteger
<span class="lineno">  513 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">modelConstantOrOneArgumentModel</span></span></span> :: ModelOneArgument
<span class="lineno">  514 </span>  }
<span class="lineno">  515 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  516 </span>  deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  517 </span>
<span class="lineno">  518 </span>-- | if p then f(x,y) else c; p depends on usage
<span class="lineno">  519 </span>data ModelConstantOrTwoArguments = ModelConstantOrTwoArguments
<span class="lineno">  520 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">modelConstantOrTwoArgumentsConstant</span></span></span> :: CostingInteger
<span class="lineno">  521 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">modelConstantOrTwoArgumentsModel</span></span></span> :: ModelTwoArguments
<span class="lineno">  522 </span>  }
<span class="lineno">  523 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  524 </span>  deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  525 </span>
<span class="lineno">  526 </span>-- | c10*x + c01*y + c11*x*y + c00
<span class="lineno">  527 </span>data TwoVariableWithInteractionFunction = TwoVariableWithInteractionFunction
<span class="lineno">  528 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableWithInteractionFunctionC00</span></span></span> :: Coefficient00
<span class="lineno">  529 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableWithInteractionFunctionC10</span></span></span> :: Coefficient10
<span class="lineno">  530 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableWithInteractionFunctionC01</span></span></span> :: Coefficient01
<span class="lineno">  531 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">twoVariableWithInteractionFunctionC11</span></span></span> :: Coefficient11
<span class="lineno">  532 </span>  }
<span class="lineno">  533 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  534 </span>  deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  535 </span>
<span class="lineno">  536 </span>evaluateTwoVariableWithInteractionFunction
<span class="lineno">  537 </span>  :: TwoVariableWithInteractionFunction
<span class="lineno">  538 </span>  -&gt; CostingInteger
<span class="lineno">  539 </span>  -&gt; CostingInteger
<span class="lineno">  540 </span>  -&gt; CostingInteger
<span class="lineno">  541 </span><span class="decl"><span class="istickedoff">evaluateTwoVariableWithInteractionFunction</span>
<span class="lineno">  542 </span><span class="spaces">  </span><span class="istickedoff">( TwoVariableWithInteractionFunction</span>
<span class="lineno">  543 </span><span class="spaces">      </span><span class="istickedoff">(Coefficient00 c00)</span>
<span class="lineno">  544 </span><span class="spaces">      </span><span class="istickedoff">(Coefficient10 c10)</span>
<span class="lineno">  545 </span><span class="spaces">      </span><span class="istickedoff">(Coefficient01 c01)</span>
<span class="lineno">  546 </span><span class="spaces">      </span><span class="istickedoff">(Coefficient11 c11)</span>
<span class="lineno">  547 </span><span class="spaces">    </span><span class="istickedoff">)</span>
<span class="lineno">  548 </span><span class="spaces">  </span><span class="istickedoff">x</span>
<span class="lineno">  549 </span><span class="spaces">  </span><span class="istickedoff">y =</span>
<span class="lineno">  550 </span><span class="spaces">    </span><span class="istickedoff">c10 * x + c01 * y + c11 * (x * y) + c00</span></span>
<span class="lineno">  551 </span>
<span class="lineno">  552 </span>{- Note [Backward compatibility for costing functions].  The PR at
<span class="lineno">  553 </span>   https://github.com/IntersectMBO/plutus/pull/5857 generalised the costing
<span class="lineno">  554 </span>   function types and made them more composable: in particular,
<span class="lineno">  555 </span>   ModelTwoArgumentsLinearOnDiagonal was replaced by
<span class="lineno">  556 </span>   ModelTwoArgumentsConstOffDiagonal and ModelConstantOrLinear was removed.
<span class="lineno">  557 </span>   However, this changes some of the tags (specifically, for `equalsByteString`
<span class="lineno">  558 </span>   and `equalsString`) in builtinCostModel.json, and these are used in the
<span class="lineno">  559 </span>   Alonzo genesis file and so shouldn't be changed.  For the time being we've
<span class="lineno">  560 </span>   restored the ModelTwoArgumentsLinearOnDiagonal constructor so that we can
<span class="lineno">  561 </span>   still deal with the old tags.  New builtins should use
<span class="lineno">  562 </span>   ModelTwoArgumentsConstOffDiagonal instead.  A better long-term solution might
<span class="lineno">  563 </span>   be to adapt the JSON conversion code to translate linear_on_diagonal objects
<span class="lineno">  564 </span>   to ConstOffDiagonal objects (and perhaps back, although configurable cost
<span class="lineno">  565 </span>   models may mean that we don't need to do that).
<span class="lineno">  566 </span>-}
<span class="lineno">  567 </span>
<span class="lineno">  568 </span>data ModelTwoArguments
<span class="lineno">  569 </span>  = ModelTwoArgumentsConstantCost CostingInteger
<span class="lineno">  570 </span>  | ModelTwoArgumentsLinearInX OneVariableLinearFunction
<span class="lineno">  571 </span>  | ModelTwoArgumentsLinearInY OneVariableLinearFunction
<span class="lineno">  572 </span>  | ModelTwoArgumentsLinearInXAndY TwoVariableLinearFunction
<span class="lineno">  573 </span>  | ModelTwoArgumentsAddedSizes OneVariableLinearFunction
<span class="lineno">  574 </span>  | ModelTwoArgumentsSubtractedSizes ModelSubtractedSizes
<span class="lineno">  575 </span>  | ModelTwoArgumentsMultipliedSizes OneVariableLinearFunction
<span class="lineno">  576 </span>  | ModelTwoArgumentsMinSize OneVariableLinearFunction
<span class="lineno">  577 </span>  | ModelTwoArgumentsMaxSize OneVariableLinearFunction
<span class="lineno">  578 </span>  | ModelTwoArgumentsLinearOnDiagonal ModelConstantOrLinear
<span class="lineno">  579 </span>  | ModelTwoArgumentsConstOffDiagonal ModelConstantOrOneArgument
<span class="lineno">  580 </span>  | ModelTwoArgumentsConstAboveDiagonal ModelConstantOrTwoArguments
<span class="lineno">  581 </span>  | ModelTwoArgumentsConstBelowDiagonal ModelConstantOrTwoArguments
<span class="lineno">  582 </span>  | ModelTwoArgumentsQuadraticInY OneVariableQuadraticFunction
<span class="lineno">  583 </span>  | ModelTwoArgumentsQuadraticInXAndY TwoVariableQuadraticFunction
<span class="lineno">  584 </span>  | ModelTwoArgumentsWithInteractionInXAndY TwoVariableWithInteractionFunction
<span class="lineno">  585 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  586 </span>  deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  587 </span>
<span class="lineno">  588 </span>instance Default ModelTwoArguments where
<span class="lineno">  589 </span>  <span class="decl"><span class="istickedoff">def = ModelTwoArgumentsConstantCost maxBound</span></span>
<span class="lineno">  590 </span>
<span class="lineno">  591 </span>instance UnimplementedCostingFun ModelTwoArguments where
<span class="lineno">  592 </span>  <span class="decl"><span class="nottickedoff">unimplementedCostingFun = makeUnimplementedCostingFun ModelTwoArgumentsConstantCost</span></span>
<span class="lineno">  593 </span>
<span class="lineno">  594 </span>-- See Note [runCostingFun* API].
<span class="lineno">  595 </span>runCostingFunTwoArguments
<span class="lineno">  596 </span>  :: ( ExMemoryUsage a1
<span class="lineno">  597 </span>     , ExMemoryUsage a2
<span class="lineno">  598 </span>     )
<span class="lineno">  599 </span>  =&gt; CostingFun ModelTwoArguments
<span class="lineno">  600 </span>  -&gt; a1
<span class="lineno">  601 </span>  -&gt; a2
<span class="lineno">  602 </span>  -&gt; ExBudgetStream
<span class="lineno">  603 </span><span class="decl"><span class="istickedoff">runCostingFunTwoArguments (CostingFun cpu mem) =</span>
<span class="lineno">  604 </span><span class="spaces">  </span><span class="istickedoff">case (runTwoArgumentModel cpu, runTwoArgumentModel mem) of</span>
<span class="lineno">  605 </span><span class="spaces">    </span><span class="istickedoff">(!runCpu, !runMem) -&gt; onMemoryUsages $ \mem1 mem2 -&gt;</span>
<span class="lineno">  606 </span><span class="spaces">      </span><span class="istickedoff">zipCostStream</span>
<span class="lineno">  607 </span><span class="spaces">        </span><span class="istickedoff">(runCpu mem1 mem2)</span>
<span class="lineno">  608 </span><span class="spaces">        </span><span class="istickedoff">(runMem mem1 mem2)</span></span>
<span class="lineno">  609 </span>{-# INLINE runCostingFunTwoArguments #-}
<span class="lineno">  610 </span>
<span class="lineno">  611 </span>{-| Take an intercept, two slopes and two streams, and scale each element of
<span class="lineno">  612 </span>the first stream by the first slope, each element of the second stream by the
<span class="lineno">  613 </span>second slope, add the two scaled streams together, and cons the intercept to
<span class="lineno">  614 </span>the stream afterwards. -}
<span class="lineno">  615 </span>scaleLinearlyTwoVariables :: Intercept -&gt; Slope -&gt; CostStream -&gt; Slope -&gt; CostStream -&gt; CostStream
<span class="lineno">  616 </span><span class="decl"><span class="istickedoff">scaleLinearlyTwoVariables (Intercept intercept) (Slope slope1) stream1 (Slope slope2) stream2 =</span>
<span class="lineno">  617 </span><span class="spaces">  </span><span class="istickedoff">addCostStream</span>
<span class="lineno">  618 </span><span class="spaces">    </span><span class="istickedoff">(CostLast intercept)</span>
<span class="lineno">  619 </span><span class="spaces">    </span><span class="istickedoff">( addCostStream</span>
<span class="lineno">  620 </span><span class="spaces">        </span><span class="istickedoff">(mapCostStream (slope1 *) stream1)</span>
<span class="lineno">  621 </span><span class="spaces">        </span><span class="istickedoff">(mapCostStream (slope2 *) stream2)</span>
<span class="lineno">  622 </span><span class="spaces">    </span><span class="istickedoff">)</span></span>
<span class="lineno">  623 </span>{-# INLINE scaleLinearlyTwoVariables #-}
<span class="lineno">  624 </span>
<span class="lineno">  625 </span>runTwoArgumentModel
<span class="lineno">  626 </span>  :: ModelTwoArguments
<span class="lineno">  627 </span>  -&gt; CostStream
<span class="lineno">  628 </span>  -&gt; CostStream
<span class="lineno">  629 </span>  -&gt; CostStream
<span class="lineno">  630 </span><span class="decl"><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  631 </span><span class="spaces">  </span><span class="istickedoff">(ModelTwoArgumentsConstantCost c) = lazy $ \_ _ -&gt; CostLast c</span>
<span class="lineno">  632 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  633 </span><span class="spaces">  </span><span class="istickedoff">(ModelTwoArgumentsAddedSizes (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  634 </span><span class="spaces">    </span><span class="istickedoff">lazy $ \costs1 costs2 -&gt;</span>
<span class="lineno">  635 </span><span class="spaces">      </span><span class="istickedoff">scaleLinearly intercept slope $ addCostStream costs1 costs2</span>
<span class="lineno">  636 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  637 </span><span class="spaces">  </span><span class="istickedoff">(ModelTwoArgumentsSubtractedSizes (ModelSubtractedSizes intercept slope minSize)) =</span>
<span class="lineno">  638 </span><span class="spaces">    </span><span class="istickedoff">lazy $ \costs1 costs2 -&gt; do</span>
<span class="lineno">  639 </span><span class="spaces">      </span><span class="istickedoff">let !size1 = sumCostStream costs1</span>
<span class="lineno">  640 </span><span class="spaces">          </span><span class="istickedoff">!size2 = sumCostStream costs2</span>
<span class="lineno">  641 </span><span class="spaces">      </span><span class="istickedoff">scaleLinearly intercept slope $ CostLast (max minSize $ size1 - size2)</span>
<span class="lineno">  642 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  643 </span><span class="spaces">  </span><span class="istickedoff">(ModelTwoArgumentsMultipliedSizes (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  644 </span><span class="spaces">    </span><span class="istickedoff">lazy $ \costs1 costs2 -&gt; do</span>
<span class="lineno">  645 </span><span class="spaces">      </span><span class="istickedoff">let !size1 = sumCostStream costs1</span>
<span class="lineno">  646 </span><span class="spaces">          </span><span class="istickedoff">!size2 = sumCostStream costs2</span>
<span class="lineno">  647 </span><span class="spaces">      </span><span class="istickedoff">scaleLinearly intercept slope $ CostLast (size1 * size2)</span>
<span class="lineno">  648 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  649 </span><span class="spaces">  </span><span class="istickedoff">(ModelTwoArgumentsMinSize (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  650 </span><span class="spaces">    </span><span class="istickedoff">lazy $ \costs1 costs2 -&gt; do</span>
<span class="lineno">  651 </span><span class="spaces">      </span><span class="istickedoff">scaleLinearly intercept slope $ minCostStream costs1 costs2</span>
<span class="lineno">  652 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  653 </span><span class="spaces">  </span><span class="istickedoff">(ModelTwoArgumentsMaxSize (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  654 </span><span class="spaces">    </span><span class="istickedoff">lazy $ \costs1 costs2 -&gt; do</span>
<span class="lineno">  655 </span><span class="spaces">      </span><span class="istickedoff">let !size1 = sumCostStream costs1</span>
<span class="lineno">  656 </span><span class="spaces">          </span><span class="istickedoff">!size2 = sumCostStream costs2</span>
<span class="lineno">  657 </span><span class="spaces">      </span><span class="istickedoff">scaleLinearly intercept slope $ CostLast (max size1 size2)</span>
<span class="lineno">  658 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  659 </span><span class="spaces">  </span><span class="istickedoff">(ModelTwoArgumentsLinearInX (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  660 </span><span class="spaces">    </span><span class="istickedoff">lazy $ \costs1 _ -&gt;</span>
<span class="lineno">  661 </span><span class="spaces">      </span><span class="istickedoff">scaleLinearly intercept slope costs1</span>
<span class="lineno">  662 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  663 </span><span class="spaces">  </span><span class="istickedoff">(ModelTwoArgumentsLinearInY (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  664 </span><span class="spaces">    </span><span class="istickedoff">lazy $ \_ costs2 -&gt;</span>
<span class="lineno">  665 </span><span class="spaces">      </span><span class="istickedoff">scaleLinearly intercept slope costs2</span>
<span class="lineno">  666 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  667 </span><span class="spaces">  </span><span class="istickedoff">(ModelTwoArgumentsLinearInXAndY (TwoVariableLinearFunction intercept slope1 slope2)) =</span>
<span class="lineno">  668 </span><span class="spaces">    </span><span class="istickedoff">lazy $ \costs1 costs2 -&gt;</span>
<span class="lineno">  669 </span><span class="spaces">      </span><span class="istickedoff">scaleLinearlyTwoVariables intercept slope1 costs1 slope2 costs2</span>
<span class="lineno">  670 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  671 </span><span class="spaces">  </span><span class="istickedoff">-- See Note [Backward compatibility for costing functions]</span>
<span class="lineno">  672 </span><span class="spaces">  </span><span class="istickedoff">-- Off the diagonal, return the constant.  On the diagonal, run the one-variable linear model.</span>
<span class="lineno">  673 </span><span class="spaces">  </span><span class="istickedoff">(ModelTwoArgumentsLinearOnDiagonal (ModelConstantOrLinear c intercept slope)) =</span>
<span class="lineno">  674 </span><span class="spaces">    </span><span class="istickedoff">lazy $ \costs1 costs2 -&gt; do</span>
<span class="lineno">  675 </span><span class="spaces">      </span><span class="istickedoff">let !size1 = sumCostStream costs1</span>
<span class="lineno">  676 </span><span class="spaces">          </span><span class="istickedoff">!size2 = sumCostStream costs2</span>
<span class="lineno">  677 </span><span class="spaces">      </span><span class="istickedoff">if size1 == size2</span>
<span class="lineno">  678 </span><span class="spaces">        </span><span class="istickedoff">then scaleLinearly intercept slope $ CostLast size1</span>
<span class="lineno">  679 </span><span class="spaces">        </span><span class="istickedoff">else CostLast c</span>
<span class="lineno">  680 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  681 </span><span class="spaces">  </span><span class="istickedoff">-- Off the diagonal, return the constant.  On the diagonal, run the other model.</span>
<span class="lineno">  682 </span><span class="spaces">  </span><span class="istickedoff">(ModelTwoArgumentsConstOffDiagonal (ModelConstantOrOneArgument c m)) =</span>
<span class="lineno">  683 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">case runOneArgumentModel m of</span></span>
<span class="lineno">  684 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">!run -&gt; lazy $ \costs1 costs2 -&gt; do</span></span>
<span class="lineno">  685 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">let !size1 = sumCostStream costs1</span></span>
<span class="lineno">  686 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">!size2 = sumCostStream costs2</span></span>
<span class="lineno">  687 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">if size1 /= size2</span></span>
<span class="lineno">  688 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">then CostLast c</span></span>
<span class="lineno">  689 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">else run (CostLast size1)</span></span>
<span class="lineno">  690 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  691 </span><span class="spaces">  </span><span class="istickedoff">-- Below the diagonal, return the constant. Above the diagonal, run the other model.</span>
<span class="lineno">  692 </span><span class="spaces">  </span><span class="istickedoff">(ModelTwoArgumentsConstBelowDiagonal (ModelConstantOrTwoArguments c m)) =</span>
<span class="lineno">  693 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">case runTwoArgumentModel m of</span></span>
<span class="lineno">  694 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">!run -&gt; lazy $ \costs1 costs2 -&gt; do</span></span>
<span class="lineno">  695 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">let !size1 = sumCostStream costs1</span></span>
<span class="lineno">  696 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">!size2 = sumCostStream costs2</span></span>
<span class="lineno">  697 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">if size1 &gt; size2</span></span>
<span class="lineno">  698 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">then CostLast c</span></span>
<span class="lineno">  699 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">else run (CostLast size1) (CostLast size2)</span></span>
<span class="lineno">  700 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  701 </span><span class="spaces">  </span><span class="istickedoff">-- Above the diagonal, return the constant. Below the diagonal, run the other model.</span>
<span class="lineno">  702 </span><span class="spaces">  </span><span class="istickedoff">(ModelTwoArgumentsConstAboveDiagonal (ModelConstantOrTwoArguments c m)) =</span>
<span class="lineno">  703 </span><span class="spaces">    </span><span class="istickedoff">case runTwoArgumentModel m of</span>
<span class="lineno">  704 </span><span class="spaces">      </span><span class="istickedoff">!run -&gt; lazy $ \costs1 costs2 -&gt; do</span>
<span class="lineno">  705 </span><span class="spaces">        </span><span class="istickedoff">let !size1 = sumCostStream costs1</span>
<span class="lineno">  706 </span><span class="spaces">            </span><span class="istickedoff">!size2 = sumCostStream costs2</span>
<span class="lineno">  707 </span><span class="spaces">        </span><span class="istickedoff">if size1 &lt; size2</span>
<span class="lineno">  708 </span><span class="spaces">          </span><span class="istickedoff">then CostLast c</span>
<span class="lineno">  709 </span><span class="spaces">          </span><span class="istickedoff">else run (CostLast size1) (CostLast size2)</span>
<span class="lineno">  710 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  711 </span><span class="spaces">  </span><span class="istickedoff">(ModelTwoArgumentsQuadraticInY f) =</span>
<span class="lineno">  712 </span><span class="spaces">    </span><span class="istickedoff">lazy $ \_ costs2 -&gt; scaleQuadratically f costs2</span>
<span class="lineno">  713 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel</span>
<span class="lineno">  714 </span><span class="spaces">  </span><span class="istickedoff">(ModelTwoArgumentsQuadraticInXAndY f) =</span>
<span class="lineno">  715 </span><span class="spaces">    </span><span class="istickedoff">lazy $ \costs1 costs2 -&gt;</span>
<span class="lineno">  716 </span><span class="spaces">      </span><span class="istickedoff">let !size1 = sumCostStream costs1</span>
<span class="lineno">  717 </span><span class="spaces">          </span><span class="istickedoff">!size2 = sumCostStream costs2</span>
<span class="lineno">  718 </span><span class="spaces">       </span><span class="istickedoff">in CostLast $ evaluateTwoVariableQuadraticFunction f size1 size2</span>
<span class="lineno">  719 </span><span class="spaces"></span><span class="istickedoff">runTwoArgumentModel (ModelTwoArgumentsWithInteractionInXAndY f) =</span>
<span class="lineno">  720 </span><span class="spaces">  </span><span class="istickedoff">lazy $ \costs1 costs2 -&gt;</span>
<span class="lineno">  721 </span><span class="spaces">    </span><span class="istickedoff">let !size1 = sumCostStream costs1</span>
<span class="lineno">  722 </span><span class="spaces">        </span><span class="istickedoff">!size2 = sumCostStream costs2</span>
<span class="lineno">  723 </span><span class="spaces">     </span><span class="istickedoff">in CostLast $ evaluateTwoVariableWithInteractionFunction f size1 size2</span></span>
<span class="lineno">  724 </span>{-# OPAQUE runTwoArgumentModel #-}
<span class="lineno">  725 </span>
<span class="lineno">  726 </span>---------------- Three-argument costing functions ----------------
<span class="lineno">  727 </span>
<span class="lineno">  728 </span>data ModelThreeArguments
<span class="lineno">  729 </span>  = ModelThreeArgumentsConstantCost CostingInteger
<span class="lineno">  730 </span>  | ModelThreeArgumentsLinearInX OneVariableLinearFunction
<span class="lineno">  731 </span>  | ModelThreeArgumentsLinearInY OneVariableLinearFunction
<span class="lineno">  732 </span>  | ModelThreeArgumentsLinearInZ OneVariableLinearFunction
<span class="lineno">  733 </span>  | ModelThreeArgumentsQuadraticInZ OneVariableQuadraticFunction
<span class="lineno">  734 </span>  | ModelThreeArgumentsLiteralInYOrLinearInZ OneVariableLinearFunction
<span class="lineno">  735 </span>  | ModelThreeArgumentsLinearInMaxYZ OneVariableLinearFunction
<span class="lineno">  736 </span>  | ModelThreeArgumentsLinearInYAndZ TwoVariableLinearFunction
<span class="lineno">  737 </span>  | ModelThreeArgumentsQuadraticInYAndZ TwoVariableQuadraticFunction
<span class="lineno">  738 </span>  | ModelThreeArgumentsExpModCost ExpModCostingFunction
<span class="lineno">  739 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  740 </span>  deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  741 </span>
<span class="lineno">  742 </span>instance Default ModelThreeArguments where
<span class="lineno">  743 </span>  <span class="decl"><span class="istickedoff">def = ModelThreeArgumentsConstantCost maxBound</span></span>
<span class="lineno">  744 </span>
<span class="lineno">  745 </span>instance UnimplementedCostingFun ModelThreeArguments where
<span class="lineno">  746 </span>  <span class="decl"><span class="nottickedoff">unimplementedCostingFun = makeUnimplementedCostingFun ModelThreeArgumentsConstantCost</span></span>
<span class="lineno">  747 </span>
<span class="lineno">  748 </span>runThreeArgumentModel
<span class="lineno">  749 </span>  :: ModelThreeArguments
<span class="lineno">  750 </span>  -&gt; CostStream
<span class="lineno">  751 </span>  -&gt; CostStream
<span class="lineno">  752 </span>  -&gt; CostStream
<span class="lineno">  753 </span>  -&gt; CostStream
<span class="lineno">  754 </span><span class="decl"><span class="istickedoff">runThreeArgumentModel (ModelThreeArgumentsConstantCost c) = lazy $ \_ _ _ -&gt; CostLast c</span>
<span class="lineno">  755 </span><span class="spaces"></span><span class="istickedoff">runThreeArgumentModel</span>
<span class="lineno">  756 </span><span class="spaces">  </span><span class="istickedoff">(ModelThreeArgumentsLinearInX (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  757 </span><span class="spaces">    </span><span class="istickedoff">lazy $ \costs1 _ _ -&gt;</span>
<span class="lineno">  758 </span><span class="spaces">      </span><span class="istickedoff">scaleLinearly intercept slope costs1</span>
<span class="lineno">  759 </span><span class="spaces"></span><span class="istickedoff">runThreeArgumentModel</span>
<span class="lineno">  760 </span><span class="spaces">  </span><span class="istickedoff">(ModelThreeArgumentsLinearInY (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  761 </span><span class="spaces">    </span><span class="istickedoff">lazy $ \_ costs2 _ -&gt;</span>
<span class="lineno">  762 </span><span class="spaces">      </span><span class="istickedoff">scaleLinearly intercept slope costs2</span>
<span class="lineno">  763 </span><span class="spaces"></span><span class="istickedoff">runThreeArgumentModel</span>
<span class="lineno">  764 </span><span class="spaces">  </span><span class="istickedoff">(ModelThreeArgumentsLinearInZ (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  765 </span><span class="spaces">    </span><span class="istickedoff">lazy $ \_ _ costs3 -&gt;</span>
<span class="lineno">  766 </span><span class="spaces">      </span><span class="istickedoff">scaleLinearly intercept slope costs3</span>
<span class="lineno">  767 </span><span class="spaces"></span><span class="istickedoff">runThreeArgumentModel</span>
<span class="lineno">  768 </span><span class="spaces">  </span><span class="istickedoff">(ModelThreeArgumentsQuadraticInZ f) =</span>
<span class="lineno">  769 </span><span class="spaces">    </span><span class="istickedoff">lazy $ \_ _ costs3 -&gt; scaleQuadratically f costs3</span>
<span class="lineno">  770 </span><span class="spaces"></span><span class="istickedoff">{- Either a literal number of bytes or a linear function.  This is for</span>
<span class="lineno">  771 </span><span class="spaces">   </span><span class="istickedoff">`integerToByteString`, where if the second argument is zero, the output</span>
<span class="lineno">  772 </span><span class="spaces">   </span><span class="istickedoff">bytestring has the minimum length required to contain the converted integer,</span>
<span class="lineno">  773 </span><span class="spaces">   </span><span class="istickedoff">but if the second argument is nonzero it specifies the exact length of the</span>
<span class="lineno">  774 </span><span class="spaces">   </span><span class="istickedoff">output bytestring. We could generalise this to something like `LinearInYOrZ`</span>
<span class="lineno">  775 </span><span class="spaces">   </span><span class="istickedoff">since the argument wrapping takes care of calculating the memory usages for</span>
<span class="lineno">  776 </span><span class="spaces">   </span><span class="istickedoff">us anyway (the costing function here knows nothing about the wrapper: it just</span>
<span class="lineno">  777 </span><span class="spaces">   </span><span class="istickedoff">gets a number from `onMemoryUsages`).</span>
<span class="lineno">  778 </span><span class="spaces"></span><span class="istickedoff">-}</span>
<span class="lineno">  779 </span><span class="spaces"></span><span class="istickedoff">runThreeArgumentModel</span>
<span class="lineno">  780 </span><span class="spaces">  </span><span class="istickedoff">(ModelThreeArgumentsLiteralInYOrLinearInZ (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  781 </span><span class="spaces">    </span><span class="istickedoff">lazy $ \_ costs2 costs3 -&gt;</span>
<span class="lineno">  782 </span><span class="spaces">      </span><span class="istickedoff">let !width = sumCostStream costs2</span>
<span class="lineno">  783 </span><span class="spaces">       </span><span class="istickedoff">in if width == 0</span>
<span class="lineno">  784 </span><span class="spaces">            </span><span class="istickedoff">then scaleLinearly intercept slope costs3</span>
<span class="lineno">  785 </span><span class="spaces">            </span><span class="istickedoff">else costs2</span>
<span class="lineno">  786 </span><span class="spaces"></span><span class="istickedoff">runThreeArgumentModel</span>
<span class="lineno">  787 </span><span class="spaces">  </span><span class="istickedoff">(ModelThreeArgumentsLinearInMaxYZ (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  788 </span><span class="spaces">    </span><span class="istickedoff">lazy $ \_ costs2 costs3 -&gt;</span>
<span class="lineno">  789 </span><span class="spaces">      </span><span class="istickedoff">let !size2 = sumCostStream costs2</span>
<span class="lineno">  790 </span><span class="spaces">          </span><span class="istickedoff">!size3 = sumCostStream costs3</span>
<span class="lineno">  791 </span><span class="spaces">       </span><span class="istickedoff">in scaleLinearly intercept slope $ CostLast (max size2 size3)</span>
<span class="lineno">  792 </span><span class="spaces"></span><span class="istickedoff">runThreeArgumentModel</span>
<span class="lineno">  793 </span><span class="spaces">  </span><span class="istickedoff">(ModelThreeArgumentsLinearInYAndZ (TwoVariableLinearFunction intercept slope2 slope3)) =</span>
<span class="lineno">  794 </span><span class="spaces">    </span><span class="istickedoff">lazy $ \_costs1 costs2 costs3 -&gt;</span>
<span class="lineno">  795 </span><span class="spaces">      </span><span class="istickedoff">scaleLinearlyTwoVariables intercept slope2 costs2 slope3 costs3</span>
<span class="lineno">  796 </span><span class="spaces"></span><span class="istickedoff">runThreeArgumentModel</span>
<span class="lineno">  797 </span><span class="spaces">  </span><span class="istickedoff">(ModelThreeArgumentsQuadraticInYAndZ f) =</span>
<span class="lineno">  798 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">lazy $ \_ costs2 costs3 -&gt;</span></span>
<span class="lineno">  799 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">let !size2 = sumCostStream costs2</span></span>
<span class="lineno">  800 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">!size3 = sumCostStream costs3</span></span>
<span class="lineno">  801 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">in CostLast $ evaluateTwoVariableQuadraticFunction f size2 size3</span></span>
<span class="lineno">  802 </span><span class="spaces"></span><span class="istickedoff">runThreeArgumentModel (ModelThreeArgumentsExpModCost f) =</span>
<span class="lineno">  803 </span><span class="spaces">  </span><span class="istickedoff">lazy $ \costs1 costs2 costs3 -&gt;</span>
<span class="lineno">  804 </span><span class="spaces">    </span><span class="istickedoff">let !size1 = sumCostStream costs1</span>
<span class="lineno">  805 </span><span class="spaces">        </span><span class="istickedoff">!size2 = sumCostStream costs2</span>
<span class="lineno">  806 </span><span class="spaces">        </span><span class="istickedoff">!size3 = sumCostStream costs3</span>
<span class="lineno">  807 </span><span class="spaces">     </span><span class="istickedoff">in CostLast $ evaluateExpModCostingFunction f size1 size2 size3</span></span>
<span class="lineno">  808 </span>{-# OPAQUE runThreeArgumentModel #-}
<span class="lineno">  809 </span>
<span class="lineno">  810 </span>-- See Note [runCostingFun* API].
<span class="lineno">  811 </span>runCostingFunThreeArguments
<span class="lineno">  812 </span>  :: ( ExMemoryUsage a1
<span class="lineno">  813 </span>     , ExMemoryUsage a2
<span class="lineno">  814 </span>     , ExMemoryUsage a3
<span class="lineno">  815 </span>     )
<span class="lineno">  816 </span>  =&gt; CostingFun ModelThreeArguments
<span class="lineno">  817 </span>  -&gt; a1
<span class="lineno">  818 </span>  -&gt; a2
<span class="lineno">  819 </span>  -&gt; a3
<span class="lineno">  820 </span>  -&gt; ExBudgetStream
<span class="lineno">  821 </span><span class="decl"><span class="istickedoff">runCostingFunThreeArguments (CostingFun cpu mem) =</span>
<span class="lineno">  822 </span><span class="spaces">  </span><span class="istickedoff">case (runThreeArgumentModel cpu, runThreeArgumentModel mem) of</span>
<span class="lineno">  823 </span><span class="spaces">    </span><span class="istickedoff">(!runCpu, !runMem) -&gt; onMemoryUsages $ \mem1 mem2 mem3 -&gt;</span>
<span class="lineno">  824 </span><span class="spaces">      </span><span class="istickedoff">zipCostStream</span>
<span class="lineno">  825 </span><span class="spaces">        </span><span class="istickedoff">(runCpu mem1 mem2 mem3)</span>
<span class="lineno">  826 </span><span class="spaces">        </span><span class="istickedoff">(runMem mem1 mem2 mem3)</span></span>
<span class="lineno">  827 </span>{-# INLINE runCostingFunThreeArguments #-}
<span class="lineno">  828 </span>
<span class="lineno">  829 </span>---------------- Four-argument costing functions ----------------
<span class="lineno">  830 </span>
<span class="lineno">  831 </span>data ModelFourArguments
<span class="lineno">  832 </span>  = ModelFourArgumentsConstantCost CostingInteger
<span class="lineno">  833 </span>  | ModelFourArgumentsLinearInU OneVariableLinearFunction
<span class="lineno">  834 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  835 </span>  deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  836 </span>
<span class="lineno">  837 </span>instance Default ModelFourArguments where
<span class="lineno">  838 </span>  <span class="decl"><span class="istickedoff">def = ModelFourArgumentsConstantCost maxBound</span></span>
<span class="lineno">  839 </span>
<span class="lineno">  840 </span>instance UnimplementedCostingFun ModelFourArguments where
<span class="lineno">  841 </span>  <span class="decl"><span class="nottickedoff">unimplementedCostingFun = makeUnimplementedCostingFun ModelFourArgumentsConstantCost</span></span>
<span class="lineno">  842 </span>
<span class="lineno">  843 </span>runFourArgumentModel
<span class="lineno">  844 </span>  :: ModelFourArguments
<span class="lineno">  845 </span>  -&gt; CostStream
<span class="lineno">  846 </span>  -&gt; CostStream
<span class="lineno">  847 </span>  -&gt; CostStream
<span class="lineno">  848 </span>  -&gt; CostStream
<span class="lineno">  849 </span>  -&gt; CostStream
<span class="lineno">  850 </span><span class="decl"><span class="istickedoff">runFourArgumentModel (ModelFourArgumentsConstantCost c) = <span class="nottickedoff">lazy $ \_ _ _ _ -&gt; CostLast c</span></span>
<span class="lineno">  851 </span><span class="spaces"></span><span class="istickedoff">runFourArgumentModel</span>
<span class="lineno">  852 </span><span class="spaces">  </span><span class="istickedoff">(ModelFourArgumentsLinearInU (OneVariableLinearFunction intercept slope)) =</span>
<span class="lineno">  853 </span><span class="spaces">    </span><span class="istickedoff">lazy $ \_ _ _ costs4 -&gt;</span>
<span class="lineno">  854 </span><span class="spaces">      </span><span class="istickedoff">scaleLinearly intercept slope costs4</span></span>
<span class="lineno">  855 </span>{-# OPAQUE runFourArgumentModel #-}
<span class="lineno">  856 </span>
<span class="lineno">  857 </span>-- See Note [runCostingFun* API].
<span class="lineno">  858 </span>runCostingFunFourArguments
<span class="lineno">  859 </span>  :: ( ExMemoryUsage a1
<span class="lineno">  860 </span>     , ExMemoryUsage a2
<span class="lineno">  861 </span>     , ExMemoryUsage a3
<span class="lineno">  862 </span>     , ExMemoryUsage a4
<span class="lineno">  863 </span>     )
<span class="lineno">  864 </span>  =&gt; CostingFun ModelFourArguments
<span class="lineno">  865 </span>  -&gt; a1
<span class="lineno">  866 </span>  -&gt; a2
<span class="lineno">  867 </span>  -&gt; a3
<span class="lineno">  868 </span>  -&gt; a4
<span class="lineno">  869 </span>  -&gt; ExBudgetStream
<span class="lineno">  870 </span><span class="decl"><span class="istickedoff">runCostingFunFourArguments (CostingFun cpu mem) =</span>
<span class="lineno">  871 </span><span class="spaces">  </span><span class="istickedoff">case (runFourArgumentModel cpu, runFourArgumentModel mem) of</span>
<span class="lineno">  872 </span><span class="spaces">    </span><span class="istickedoff">(!runCpu, !runMem) -&gt; onMemoryUsages $ \mem1 mem2 mem3 mem4 -&gt;</span>
<span class="lineno">  873 </span><span class="spaces">      </span><span class="istickedoff">zipCostStream</span>
<span class="lineno">  874 </span><span class="spaces">        </span><span class="istickedoff">(runCpu <span class="nottickedoff">mem1</span> <span class="nottickedoff">mem2</span> <span class="nottickedoff">mem3</span> mem4)</span>
<span class="lineno">  875 </span><span class="spaces">        </span><span class="istickedoff">(runMem <span class="nottickedoff">mem1</span> <span class="nottickedoff">mem2</span> <span class="nottickedoff">mem3</span> mem4)</span></span>
<span class="lineno">  876 </span>{-# INLINE runCostingFunFourArguments #-}
<span class="lineno">  877 </span>
<span class="lineno">  878 </span>---------------- Five-argument costing functions ----------------
<span class="lineno">  879 </span>
<span class="lineno">  880 </span>data ModelFiveArguments
<span class="lineno">  881 </span>  = ModelFiveArgumentsConstantCost CostingInteger
<span class="lineno">  882 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  883 </span>  deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  884 </span>
<span class="lineno">  885 </span>instance Default ModelFiveArguments where
<span class="lineno">  886 </span>  <span class="decl"><span class="nottickedoff">def = ModelFiveArgumentsConstantCost maxBound</span></span>
<span class="lineno">  887 </span>
<span class="lineno">  888 </span>instance UnimplementedCostingFun ModelFiveArguments where
<span class="lineno">  889 </span>  <span class="decl"><span class="nottickedoff">unimplementedCostingFun = makeUnimplementedCostingFun ModelFiveArgumentsConstantCost</span></span>
<span class="lineno">  890 </span>
<span class="lineno">  891 </span>runFiveArgumentModel
<span class="lineno">  892 </span>  :: ModelFiveArguments
<span class="lineno">  893 </span>  -&gt; CostStream
<span class="lineno">  894 </span>  -&gt; CostStream
<span class="lineno">  895 </span>  -&gt; CostStream
<span class="lineno">  896 </span>  -&gt; CostStream
<span class="lineno">  897 </span>  -&gt; CostStream
<span class="lineno">  898 </span>  -&gt; CostStream
<span class="lineno">  899 </span><span class="decl"><span class="nottickedoff">runFiveArgumentModel (ModelFiveArgumentsConstantCost c) = lazy $ \_ _ _ _ _ -&gt; CostLast c</span></span>
<span class="lineno">  900 </span>{-# OPAQUE runFiveArgumentModel #-}
<span class="lineno">  901 </span>
<span class="lineno">  902 </span>-- See Note [runCostingFun* API].
<span class="lineno">  903 </span>runCostingFunFiveArguments
<span class="lineno">  904 </span>  :: ( ExMemoryUsage a1
<span class="lineno">  905 </span>     , ExMemoryUsage a2
<span class="lineno">  906 </span>     , ExMemoryUsage a3
<span class="lineno">  907 </span>     , ExMemoryUsage a4
<span class="lineno">  908 </span>     , ExMemoryUsage a5
<span class="lineno">  909 </span>     )
<span class="lineno">  910 </span>  =&gt; CostingFun ModelFiveArguments
<span class="lineno">  911 </span>  -&gt; a1
<span class="lineno">  912 </span>  -&gt; a2
<span class="lineno">  913 </span>  -&gt; a3
<span class="lineno">  914 </span>  -&gt; a4
<span class="lineno">  915 </span>  -&gt; a5
<span class="lineno">  916 </span>  -&gt; ExBudgetStream
<span class="lineno">  917 </span><span class="decl"><span class="nottickedoff">runCostingFunFiveArguments (CostingFun cpu mem) =</span>
<span class="lineno">  918 </span><span class="spaces">  </span><span class="nottickedoff">case (runFiveArgumentModel cpu, runFiveArgumentModel mem) of</span>
<span class="lineno">  919 </span><span class="spaces">    </span><span class="nottickedoff">(!runCpu, !runMem) -&gt; onMemoryUsages $ \mem1 mem2 mem3 mem4 mem5 -&gt;</span>
<span class="lineno">  920 </span><span class="spaces">      </span><span class="nottickedoff">zipCostStream</span>
<span class="lineno">  921 </span><span class="spaces">        </span><span class="nottickedoff">(runCpu mem1 mem2 mem3 mem4 mem5)</span>
<span class="lineno">  922 </span><span class="spaces">        </span><span class="nottickedoff">(runMem mem1 mem2 mem3 mem4 mem5)</span></span>
<span class="lineno">  923 </span>{-# INLINE runCostingFunFiveArguments #-}
<span class="lineno">  924 </span>
<span class="lineno">  925 </span>---------------- Six-argument costing functions ----------------
<span class="lineno">  926 </span>
<span class="lineno">  927 </span>data ModelSixArguments
<span class="lineno">  928 </span>  = ModelSixArgumentsConstantCost CostingInteger
<span class="lineno">  929 </span>  deriving stock (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Lift</span></span></span></span>)
<span class="lineno">  930 </span>  deriving anyclass (<span class="decl"><span class="nottickedoff">NFData</span></span>)
<span class="lineno">  931 </span>
<span class="lineno">  932 </span>instance Default ModelSixArguments where
<span class="lineno">  933 </span>  <span class="decl"><span class="istickedoff">def = ModelSixArgumentsConstantCost maxBound</span></span>
<span class="lineno">  934 </span>
<span class="lineno">  935 </span>instance UnimplementedCostingFun ModelSixArguments where
<span class="lineno">  936 </span>  <span class="decl"><span class="nottickedoff">unimplementedCostingFun = makeUnimplementedCostingFun ModelSixArgumentsConstantCost</span></span>
<span class="lineno">  937 </span>
<span class="lineno">  938 </span>runSixArgumentModel
<span class="lineno">  939 </span>  :: ModelSixArguments
<span class="lineno">  940 </span>  -&gt; CostStream
<span class="lineno">  941 </span>  -&gt; CostStream
<span class="lineno">  942 </span>  -&gt; CostStream
<span class="lineno">  943 </span>  -&gt; CostStream
<span class="lineno">  944 </span>  -&gt; CostStream
<span class="lineno">  945 </span>  -&gt; CostStream
<span class="lineno">  946 </span>  -&gt; CostStream
<span class="lineno">  947 </span><span class="decl"><span class="istickedoff">runSixArgumentModel (ModelSixArgumentsConstantCost c) = lazy $ \_ _ _ _ _ _ -&gt; CostLast c</span></span>
<span class="lineno">  948 </span>{-# OPAQUE runSixArgumentModel #-}
<span class="lineno">  949 </span>
<span class="lineno">  950 </span>-- See Note [runCostingFun* API].
<span class="lineno">  951 </span>runCostingFunSixArguments
<span class="lineno">  952 </span>  :: ( ExMemoryUsage a1
<span class="lineno">  953 </span>     , ExMemoryUsage a2
<span class="lineno">  954 </span>     , ExMemoryUsage a3
<span class="lineno">  955 </span>     , ExMemoryUsage a4
<span class="lineno">  956 </span>     , ExMemoryUsage a5
<span class="lineno">  957 </span>     , ExMemoryUsage a6
<span class="lineno">  958 </span>     )
<span class="lineno">  959 </span>  =&gt; CostingFun ModelSixArguments
<span class="lineno">  960 </span>  -&gt; a1
<span class="lineno">  961 </span>  -&gt; a2
<span class="lineno">  962 </span>  -&gt; a3
<span class="lineno">  963 </span>  -&gt; a4
<span class="lineno">  964 </span>  -&gt; a5
<span class="lineno">  965 </span>  -&gt; a6
<span class="lineno">  966 </span>  -&gt; ExBudgetStream
<span class="lineno">  967 </span><span class="decl"><span class="istickedoff">runCostingFunSixArguments (CostingFun cpu mem) =</span>
<span class="lineno">  968 </span><span class="spaces">  </span><span class="istickedoff">case (runSixArgumentModel cpu, runSixArgumentModel mem) of</span>
<span class="lineno">  969 </span><span class="spaces">    </span><span class="istickedoff">(!runCpu, !runMem) -&gt; onMemoryUsages $ \mem1 mem2 mem3 mem4 mem5 mem6 -&gt;</span>
<span class="lineno">  970 </span><span class="spaces">      </span><span class="istickedoff">zipCostStream</span>
<span class="lineno">  971 </span><span class="spaces">        </span><span class="istickedoff">(runCpu <span class="nottickedoff">mem1</span> <span class="nottickedoff">mem2</span> <span class="nottickedoff">mem3</span> <span class="nottickedoff">mem4</span> <span class="nottickedoff">mem5</span> <span class="nottickedoff">mem6</span>)</span>
<span class="lineno">  972 </span><span class="spaces">        </span><span class="istickedoff">(runMem <span class="nottickedoff">mem1</span> <span class="nottickedoff">mem2</span> <span class="nottickedoff">mem3</span> <span class="nottickedoff">mem4</span> <span class="nottickedoff">mem5</span> <span class="nottickedoff">mem6</span>)</span></span>
<span class="lineno">  973 </span>{-# INLINE runCostingFunSixArguments #-}

</pre>
</body>
</html>
