<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE BangPatterns #-}
<span class="lineno">    2 </span>{-# LANGUAGE DeriveAnyClass #-}
<span class="lineno">    3 </span>{-# LANGUAGE DeriveDataTypeable #-}
<span class="lineno">    4 </span>{-# LANGUAGE DerivingStrategies #-}
<span class="lineno">    5 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">    6 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    7 </span>{-# LANGUAGE TypeApplications #-}
<span class="lineno">    8 </span>
<span class="lineno">    9 </span>module PlutusCore.Data (Data (..)) where
<span class="lineno">   10 </span>
<span class="lineno">   11 </span>import Codec.CBOR.Decoding (Decoder)
<span class="lineno">   12 </span>import Codec.CBOR.Decoding qualified as CBOR
<span class="lineno">   13 </span>import Codec.CBOR.Encoding (Encoding)
<span class="lineno">   14 </span>import Codec.CBOR.Encoding qualified as CBOR
<span class="lineno">   15 </span>import Codec.CBOR.Magic qualified as CBOR
<span class="lineno">   16 </span>import Codec.Serialise (Serialise (decode, encode))
<span class="lineno">   17 </span>import Codec.Serialise.Decoding (decodeSequenceLenIndef, decodeSequenceLenN)
<span class="lineno">   18 </span>import Control.DeepSeq (NFData)
<span class="lineno">   19 </span>import Control.Monad (unless)
<span class="lineno">   20 </span>import Data.Bits (shiftR)
<span class="lineno">   21 </span>import Data.ByteString qualified as BS
<span class="lineno">   22 </span>import Data.ByteString.Base64 qualified as Base64
<span class="lineno">   23 </span>import Data.ByteString.Lazy qualified as BSL
<span class="lineno">   24 </span>import Data.Data qualified
<span class="lineno">   25 </span>import Data.Hashable
<span class="lineno">   26 </span>import Data.Text.Encoding qualified as Text
<span class="lineno">   27 </span>import Data.Word (Word64, Word8)
<span class="lineno">   28 </span>import GHC.Generics
<span class="lineno">   29 </span>import NoThunks.Class
<span class="lineno">   30 </span>import Prettyprinter
<span class="lineno">   31 </span>import Prelude
<span class="lineno">   32 </span>
<span class="lineno">   33 </span>-- Attempting to make this strict made code slower by 2%,
<span class="lineno">   34 </span>-- see https://github.com/IntersectMBO/plutus/pull/4622
<span class="lineno">   35 </span>{-| A generic &quot;data&quot; type.
<span class="lineno">   36 </span>
<span class="lineno">   37 </span>The main constructor 'Constr' represents a datatype value in sum-of-products
<span class="lineno">   38 </span>form: @Constr i args@ represents a use of the @i@th constructor along with its arguments.
<span class="lineno">   39 </span>
<span class="lineno">   40 </span>The other constructors are various primitives. -}
<span class="lineno">   41 </span>data Data
<span class="lineno">   42 </span>  = Constr Integer [Data]
<span class="lineno">   43 </span>  | Map [(Data, Data)]
<span class="lineno">   44 </span>  | List [Data]
<span class="lineno">   45 </span>  | I Integer
<span class="lineno">   46 </span>  | B BS.ByteString
<span class="lineno">   47 </span>  deriving stock (<span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Read</span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Data.Data.Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>)
<span class="lineno">   48 </span>  deriving anyclass (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Hashable</span></span></span></span>, <span class="decl"><span class="nottickedoff">NFData</span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">NoThunks</span></span></span></span></span></span>)
<span class="lineno">   49 </span>
<span class="lineno">   50 </span>instance <span class="decl"><span class="nottickedoff">Pretty Data</span></span> where
<span class="lineno">   51 </span>  <span class="decl"><span class="nottickedoff">pretty = \case</span>
<span class="lineno">   52 </span><span class="spaces">    </span><span class="nottickedoff">Constr _ ds -&gt; angles (sep (punctuate comma (fmap pretty ds)))</span>
<span class="lineno">   53 </span><span class="spaces">    </span><span class="nottickedoff">Map entries -&gt;</span>
<span class="lineno">   54 </span><span class="spaces">      </span><span class="nottickedoff">braces (sep (punctuate comma (fmap (\(k, v) -&gt; pretty k &lt;&gt; &quot;:&quot; &lt;+&gt; pretty v) entries)))</span>
<span class="lineno">   55 </span><span class="spaces">    </span><span class="nottickedoff">List ds -&gt; brackets (sep (punctuate comma (fmap pretty ds)))</span>
<span class="lineno">   56 </span><span class="spaces">    </span><span class="nottickedoff">I i -&gt; pretty i</span>
<span class="lineno">   57 </span><span class="spaces">    </span><span class="nottickedoff">B b -&gt;</span>
<span class="lineno">   58 </span><span class="spaces">      </span><span class="nottickedoff">-- Base64 encode the ByteString since it may contain arbitrary bytes</span>
<span class="lineno">   59 </span><span class="spaces">      </span><span class="nottickedoff">pretty (Text.decodeLatin1 (Base64.encode b))</span></span>
<span class="lineno">   60 </span>
<span class="lineno">   61 </span>{- Note [Encoding via Term]
<span class="lineno">   62 </span>We want to write a custom encoder/decoder for Data (i.e. not use the Generic version), but actually
<span class="lineno">   63 </span>doing this is a pain. So instead we go via the CBOR 'Term' representation, which lets us process a
<span class="lineno">   64 </span>more structured representation, which is a lot easier.
<span class="lineno">   65 </span>-}
<span class="lineno">   66 </span>
<span class="lineno">   67 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Serialise Data</span></span></span></span> where
<span class="lineno">   68 </span>  -- See Note [Encoding via Term]
<span class="lineno">   69 </span>  <span class="decl"><span class="istickedoff">encode = encodeData</span></span>
<span class="lineno">   70 </span>  <span class="decl"><span class="istickedoff">decode = decodeData</span></span>
<span class="lineno">   71 </span>
<span class="lineno">   72 </span>{- Note [CBOR alternative tags]
<span class="lineno">   73 </span>We've proposed to add additional tags to the CBOR standard to cover (essentially) sum types.
<span class="lineno">   74 </span>This is exactly what we need to encode the 'Constr' constructor of 'Data' in an unambiguous way.
<span class="lineno">   75 </span>
<span class="lineno">   76 </span>The tags aren't *quite* accepted yet, but they're clearly going to accept so we might as well
<span class="lineno">   77 </span>start using them.
<span class="lineno">   78 </span>
<span class="lineno">   79 </span>The scheme is:
<span class="lineno">   80 </span>- Alternatives 0-6 -&gt; tags 121-127, followed by the arguments in a list
<span class="lineno">   81 </span>- Alternatives 7-127 -&gt; tags 1280-1400, followed by the arguments in a list
<span class="lineno">   82 </span>- Any alternatives, including those that don't fit in the above -&gt; tag 102 followed by a list
<span class="lineno">   83 </span>containing an unsigned integer for the actual alternative, and then the arguments in a (nested!)
<span class="lineno">   84 </span>list.
<span class="lineno">   85 </span>-}
<span class="lineno">   86 </span>
<span class="lineno">   87 </span>{- Note [The 64-byte limit]
<span class="lineno">   88 </span>We impose a 64-byte *on-the-wire* limit on the leaves of a serialized 'Data'. This prevents people
<span class="lineno">   89 </span>from inserting Mickey Mouse entire.
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>The simplest way of doing this is to check during deserialization that we never deserialize
<span class="lineno">   92 </span>something that uses more than 64-bytes, and this is largely what we do. Then it's the user's problem
<span class="lineno">   93 </span>to not produce something too big.
<span class="lineno">   94 </span>
<span class="lineno">   95 </span>But this is quite inconvenient, so see Note [Evading the 64-byte limit] for how we get around this.
<span class="lineno">   96 </span>-}
<span class="lineno">   97 </span>
<span class="lineno">   98 </span>{- Note [Evading the 64-byte limit]
<span class="lineno">   99 </span>Implementing Note [The 64-byte limit] naively would be quite annoying:
<span class="lineno">  100 </span>- Users would be responsible for not creating Data values with leaves that were too big.
<span class="lineno">  101 </span>- If a script *required* such a thing (e.g. a counter that somehow got above 64 bytes), then the
<span class="lineno">  102 </span>user is totally stuck: the script demands something they cannot represent.
<span class="lineno">  103 </span>
<span class="lineno">  104 </span>This is unpleasant and introduces limits. Probably limits that nobody will hit, but it's nicer to
<span class="lineno">  105 </span>just not have them.
<span class="lineno">  106 </span>And it turns out that we can evade the problem with some clever encoding.
<span class="lineno">  107 </span>
<span class="lineno">  108 </span>The fundamental trick is that an *indefinite-length* CBOR bytestring is just as obfuscated as a list
<span class="lineno">  109 </span>of bytestrings, since it consists of a list of definite-length chunks, and each definite-length
<span class="lineno">  110 </span>chunk must be *tagged* (at least with the size).
<span class="lineno">  111 </span>So we get a sequence like:
<span class="lineno">  112 </span>
<span class="lineno">  113 </span>   &lt;list start&gt;
<span class="lineno">  114 </span>   &lt;chunk length metadata&gt;
<span class="lineno">  115 </span>   &lt;chunk&gt;
<span class="lineno">  116 </span>   &lt;chunk length metadata&gt;
<span class="lineno">  117 </span>   ...
<span class="lineno">  118 </span>   &lt;list end&gt;
<span class="lineno">  119 </span>
<span class="lineno">  120 </span>The chunk length metadata has a prescribed format, such that it's difficult to manipulate it so that
<span class="lineno">  121 </span>it matches your &quot;desired&quot; data.
<span class="lineno">  122 </span>So this effectively breaks up the bytestring in much the same way as a list of &lt;64 byte bytestrings.
<span class="lineno">  123 </span>
<span class="lineno">  124 </span>So that solves the problem for bytestrings on the encoding side:
<span class="lineno">  125 </span>- if they are &lt;=64 bytes, we can just encode them as a normal bytestring
<span class="lineno">  126 </span>- if they are &gt;64 bytes, we encode them as indefinite-length bytestrings with 64-byte chunks
<span class="lineno">  127 </span>
<span class="lineno">  128 </span>On the decoding side, we need to check when we decode that we never decode a definite-length
<span class="lineno">  129 </span>bytestring of &gt;64 bytes. That covers our two cases:
<span class="lineno">  130 </span>- Short definite-length bytestrings are fine
<span class="lineno">  131 </span>- Long indefinite-length bytestrings are just made of short definite-length bytestings.
<span class="lineno">  132 </span>
<span class="lineno">  133 </span>Unfortunately this all means that we have to write our own encoders/decoders so we can produce
<span class="lineno">  134 </span>chunks of the right size and check the sizes when we decode, but that's okay. Users need to do the
<span class="lineno">  135 </span>same thing: anyone encoding `Data` with their own encoders who doesn't split up big bytestrings in
<span class="lineno">  136 </span>this way will get failures when we decode them.
<span class="lineno">  137 </span>
<span class="lineno">  138 </span>For integers, we have two cases. Small integers (&lt;=64bits) can be encoded normally. Big integers are
<span class="lineno">  139 </span>already encoded *with a byte string*. The spec allows this to be an indefinite-length bytestring
<span class="lineno">  140 </span>(although cborg doesn't like it), so we can reuse our trick.
<span class="lineno">  141 </span>Again, we need to write some manual encoders/decoders.
<span class="lineno">  142 </span>-}
<span class="lineno">  143 </span>
<span class="lineno">  144 </span>-- | Turn Data into a CBOR Term.
<span class="lineno">  145 </span>encodeData :: Data -&gt; Encoding
<span class="lineno">  146 </span><span class="decl"><span class="istickedoff">encodeData = \case</span>
<span class="lineno">  147 </span><span class="spaces">  </span><span class="istickedoff">-- See Note [CBOR alternative tags]</span>
<span class="lineno">  148 </span><span class="spaces">  </span><span class="istickedoff">Constr i ds | 0 &lt;= i &amp;&amp; i &lt; 7 -&gt; CBOR.encodeTag (fromIntegral (121 + i)) &lt;&gt; encode ds</span>
<span class="lineno">  149 </span><span class="spaces">  </span><span class="istickedoff">Constr i ds | 7 &lt;= i &amp;&amp; i &lt; 128 -&gt; CBOR.encodeTag (fromIntegral (1280 + (i - 7))) &lt;&gt; encode ds</span>
<span class="lineno">  150 </span><span class="spaces">  </span><span class="istickedoff">Constr i ds</span>
<span class="lineno">  151 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt;</span>
<span class="lineno">  152 </span><span class="spaces">        </span><span class="istickedoff">let tagEncoding =</span>
<span class="lineno">  153 </span><span class="spaces">              </span><span class="istickedoff">if <span class="tickonlytrue">fromIntegral (minBound @Word64) &lt;= i &amp;&amp; i &lt;= fromIntegral (maxBound @Word64)</span></span>
<span class="lineno">  154 </span><span class="spaces">                </span><span class="istickedoff">then CBOR.encodeWord64 (fromIntegral i)</span>
<span class="lineno">  155 </span><span class="spaces">                </span><span class="istickedoff">-- This is a &quot;correct&quot;-ish encoding of the tag, but it will *not* deserialise, since</span>
<span class="lineno">  156 </span><span class="spaces">                </span><span class="istickedoff">-- we insist on a 'Word64' when we deserialise.</span>
<span class="lineno">  157 </span><span class="spaces">                </span><span class="istickedoff">-- So this is really a &quot;soft&quot; failure, without using 'error' or something.</span>
<span class="lineno">  158 </span><span class="spaces">                </span><span class="istickedoff">else <span class="nottickedoff">CBOR.encodeInteger i</span></span>
<span class="lineno">  159 </span><span class="spaces">         </span><span class="istickedoff">in CBOR.encodeTag 102 &lt;&gt; CBOR.encodeListLen 2 &lt;&gt; tagEncoding &lt;&gt; encode ds</span>
<span class="lineno">  160 </span><span class="spaces">  </span><span class="istickedoff">Map es -&gt;</span>
<span class="lineno">  161 </span><span class="spaces">    </span><span class="istickedoff">CBOR.encodeMapLen (fromIntegral $ length es)</span>
<span class="lineno">  162 </span><span class="spaces">      </span><span class="istickedoff">&lt;&gt; mconcat [encode t &lt;&gt; encode t' | (t, t') &lt;- es]</span>
<span class="lineno">  163 </span><span class="spaces">  </span><span class="istickedoff">List ds -&gt; encode ds</span>
<span class="lineno">  164 </span><span class="spaces">  </span><span class="istickedoff">I i -&gt; encodeInteger i</span>
<span class="lineno">  165 </span><span class="spaces">  </span><span class="istickedoff">B b -&gt; encodeBs b</span></span>
<span class="lineno">  166 </span>
<span class="lineno">  167 </span>-- Logic for choosing encoding borrowed from Codec.CBOR.Write
<span class="lineno">  168 </span>-- | Given an integer, create a 'CBOR.Term' that encodes it, following our size restrictions.
<span class="lineno">  169 </span>encodeInteger :: Integer -&gt; Encoding
<span class="lineno">  170 </span>-- If it fits in a Word64, then it's less than 64 bytes for sure, and we can just send it off
<span class="lineno">  171 </span>-- as a normal integer for cborg to deal with
<span class="lineno">  172 </span><span class="decl"><span class="istickedoff">encodeInteger i</span>
<span class="lineno">  173 </span><span class="spaces">  </span><span class="istickedoff">| i &gt;= 0, i &lt;= fromIntegral (maxBound :: Word64) = CBOR.encodeInteger i</span>
<span class="lineno">  174 </span><span class="spaces">  </span><span class="istickedoff">| i &lt; 0, i &gt;= -1 - fromIntegral (maxBound :: Word64) = CBOR.encodeInteger i</span>
<span class="lineno">  175 </span><span class="spaces"></span><span class="istickedoff">-- Otherwise, it would be encoded as a bignum anyway, so we manually do the bignum</span>
<span class="lineno">  176 </span><span class="spaces"></span><span class="istickedoff">-- encoding with a bytestring inside, and since we use bsToTerm, that bytestring will</span>
<span class="lineno">  177 </span><span class="spaces"></span><span class="istickedoff">-- get chunked up if it's too big.</span>
<span class="lineno">  178 </span><span class="spaces"></span><span class="istickedoff">-- See Note [Evading the 64-byte limit]</span>
<span class="lineno">  179 </span><span class="spaces"></span><span class="istickedoff">encodeInteger i | i &gt;= 0 = CBOR.encodeTag 2 &lt;&gt; encodeBs (integerToBytes i)</span>
<span class="lineno">  180 </span><span class="spaces"></span><span class="istickedoff">encodeInteger i | <span class="tickonlytrue">otherwise</span> = CBOR.encodeTag 3 &lt;&gt; encodeBs (integerToBytes (-1 - i))</span></span>
<span class="lineno">  181 </span>
<span class="lineno">  182 </span>-- Taken exactly from Codec.CBOR.Write
<span class="lineno">  183 </span>integerToBytes :: Integer -&gt; BS.ByteString
<span class="lineno">  184 </span><span class="decl"><span class="istickedoff">integerToBytes n0</span>
<span class="lineno">  185 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlyfalse">n0 == 0</span> = <span class="nottickedoff">BS.pack [0]</span></span>
<span class="lineno">  186 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = BS.pack (reverse (go n0))</span>
<span class="lineno">  187 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  188 </span><span class="spaces">    </span><span class="istickedoff">go n</span>
<span class="lineno">  189 </span><span class="spaces">      </span><span class="istickedoff">| n == 0 = []</span>
<span class="lineno">  190 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = narrow n : go (n `shiftR` 8)</span>
<span class="lineno">  191 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  192 </span><span class="spaces">    </span><span class="istickedoff">narrow :: Integer -&gt; Word8</span>
<span class="lineno">  193 </span><span class="spaces">    </span><span class="istickedoff">narrow = fromIntegral</span></span>
<span class="lineno">  194 </span>
<span class="lineno">  195 </span>-- | Given an bytestring, create a 'CBOR.Term' that encodes it, following our size restrictions.
<span class="lineno">  196 </span>encodeBs :: BS.ByteString -&gt; Encoding
<span class="lineno">  197 </span><span class="decl"><span class="istickedoff">encodeBs b | BS.length b &lt;= 64 = CBOR.encodeBytes b</span>
<span class="lineno">  198 </span><span class="spaces"></span><span class="istickedoff">-- It's a bit tricky to get cborg to emit an indefinite-length bytestring with chunks that we</span>
<span class="lineno">  199 </span><span class="spaces"></span><span class="istickedoff">-- control, so we encode it manually</span>
<span class="lineno">  200 </span><span class="spaces"></span><span class="istickedoff">-- See Note [Evading the 64-byte limit]</span>
<span class="lineno">  201 </span><span class="spaces"></span><span class="istickedoff">encodeBs b = CBOR.encodeBytesIndef &lt;&gt; foldMap encode (to64ByteChunks b) &lt;&gt; CBOR.encodeBreak</span></span>
<span class="lineno">  202 </span>
<span class="lineno">  203 </span>-- | Turns a 'BS.ByteString' into a list of &lt;=64 byte chunks.
<span class="lineno">  204 </span>to64ByteChunks :: BS.ByteString -&gt; [BS.ByteString]
<span class="lineno">  205 </span><span class="decl"><span class="istickedoff">to64ByteChunks b</span>
<span class="lineno">  206 </span><span class="spaces">  </span><span class="istickedoff">| BS.length b &gt; 64 =</span>
<span class="lineno">  207 </span><span class="spaces">      </span><span class="istickedoff">let (chunk, rest) = BS.splitAt 64 b</span>
<span class="lineno">  208 </span><span class="spaces">       </span><span class="istickedoff">in chunk : to64ByteChunks rest</span>
<span class="lineno">  209 </span><span class="spaces"></span><span class="istickedoff">to64ByteChunks b = [b]</span></span>
<span class="lineno">  210 </span>
<span class="lineno">  211 </span>{- Note [Definite and indefinite forms of CBOR]
<span class="lineno">  212 </span>CBOR is annoying and you can have both definite (with a fixed length) and indefinite lists, maps,
<span class="lineno">  213 </span>etc.
<span class="lineno">  214 </span>
<span class="lineno">  215 </span>So we have to be careful to handle both cases when decoding. When encoding we mostly don't make
<span class="lineno">  216 </span>the indefinite kinds, but see Note [Evading the 64-byte limit] for some cases where we do.
<span class="lineno">  217 </span>-}
<span class="lineno">  218 </span>
<span class="lineno">  219 </span>-- | Turn a CBOR Term into Data if possible.
<span class="lineno">  220 </span>decodeData :: Decoder s Data
<span class="lineno">  221 </span><span class="decl"><span class="istickedoff">decodeData =</span>
<span class="lineno">  222 </span><span class="spaces">  </span><span class="istickedoff">CBOR.peekTokenType &gt;&gt;= \case</span>
<span class="lineno">  223 </span><span class="spaces">    </span><span class="istickedoff">-- These integers are at most 64 *bits*, so certainly less than 64 *bytes*</span>
<span class="lineno">  224 </span><span class="spaces">    </span><span class="istickedoff">CBOR.TypeUInt -&gt; I &lt;$&gt; CBOR.decodeInteger</span>
<span class="lineno">  225 </span><span class="spaces">    </span><span class="istickedoff">CBOR.TypeUInt64 -&gt; I &lt;$&gt; CBOR.decodeInteger</span>
<span class="lineno">  226 </span><span class="spaces">    </span><span class="istickedoff">CBOR.TypeNInt -&gt; I &lt;$&gt; CBOR.decodeInteger</span>
<span class="lineno">  227 </span><span class="spaces">    </span><span class="istickedoff">CBOR.TypeNInt64 -&gt; I &lt;$&gt; CBOR.decodeInteger</span>
<span class="lineno">  228 </span><span class="spaces">    </span><span class="istickedoff">-- See Note [The 64-byte limit]</span>
<span class="lineno">  229 </span><span class="spaces">    </span><span class="istickedoff">CBOR.TypeInteger -&gt; I &lt;$&gt; decodeBoundedBigInteger</span>
<span class="lineno">  230 </span><span class="spaces">    </span><span class="istickedoff">-- See Note [The 64-byte limit]</span>
<span class="lineno">  231 </span><span class="spaces">    </span><span class="istickedoff">CBOR.TypeBytes -&gt; B &lt;$&gt; decodeBoundedBytes</span>
<span class="lineno">  232 </span><span class="spaces">    </span><span class="istickedoff">CBOR.TypeBytesIndef -&gt; B . BSL.toStrict &lt;$&gt; decodeBoundedBytesIndef</span>
<span class="lineno">  233 </span><span class="spaces">    </span><span class="istickedoff">CBOR.TypeListLen -&gt; decodeList</span>
<span class="lineno">  234 </span><span class="spaces">    </span><span class="istickedoff">CBOR.TypeListLen64 -&gt; <span class="nottickedoff">decodeList</span></span>
<span class="lineno">  235 </span><span class="spaces">    </span><span class="istickedoff">CBOR.TypeListLenIndef -&gt; decodeList</span>
<span class="lineno">  236 </span><span class="spaces">    </span><span class="istickedoff">CBOR.TypeMapLen -&gt; decodeMap</span>
<span class="lineno">  237 </span><span class="spaces">    </span><span class="istickedoff">CBOR.TypeMapLen64 -&gt; <span class="nottickedoff">decodeMap</span></span>
<span class="lineno">  238 </span><span class="spaces">    </span><span class="istickedoff">CBOR.TypeMapLenIndef -&gt; <span class="nottickedoff">decodeMap</span></span>
<span class="lineno">  239 </span><span class="spaces">    </span><span class="istickedoff">CBOR.TypeTag -&gt; decodeConstr</span>
<span class="lineno">  240 </span><span class="spaces">    </span><span class="istickedoff">CBOR.TypeTag64 -&gt; <span class="nottickedoff">decodeConstr</span></span>
<span class="lineno">  241 </span><span class="spaces">    </span><span class="istickedoff">t -&gt; <span class="nottickedoff">fail (&quot;Unrecognized value of type &quot; ++ show t)</span></span></span>
<span class="lineno">  242 </span>
<span class="lineno">  243 </span>decodeBoundedBigInteger :: Decoder s Integer
<span class="lineno">  244 </span><span class="decl"><span class="istickedoff">decodeBoundedBigInteger = do</span>
<span class="lineno">  245 </span><span class="spaces">  </span><span class="istickedoff">tag &lt;- CBOR.decodeTag</span>
<span class="lineno">  246 </span><span class="spaces">  </span><span class="istickedoff">-- Bignums contain a bytestring as the payload</span>
<span class="lineno">  247 </span><span class="spaces">  </span><span class="istickedoff">bs &lt;-</span>
<span class="lineno">  248 </span><span class="spaces">    </span><span class="istickedoff">CBOR.peekTokenType &gt;&gt;= \case</span>
<span class="lineno">  249 </span><span class="spaces">      </span><span class="istickedoff">CBOR.TypeBytes -&gt; decodeBoundedBytes</span>
<span class="lineno">  250 </span><span class="spaces">      </span><span class="istickedoff">CBOR.TypeBytesIndef -&gt; BSL.toStrict &lt;$&gt; decodeBoundedBytesIndef</span>
<span class="lineno">  251 </span><span class="spaces">      </span><span class="istickedoff">t -&gt; <span class="nottickedoff">fail (&quot;Bignum must contain a byte string, got: &quot; ++ show t)</span></span>
<span class="lineno">  252 </span><span class="spaces">  </span><span class="istickedoff">-- Depending on the tag, the bytestring is either a positive or negative integer</span>
<span class="lineno">  253 </span><span class="spaces">  </span><span class="istickedoff">case tag of</span>
<span class="lineno">  254 </span><span class="spaces">    </span><span class="istickedoff">2 -&gt; pure $ CBOR.uintegerFromBytes bs</span>
<span class="lineno">  255 </span><span class="spaces">    </span><span class="istickedoff">3 -&gt; pure $ CBOR.nintegerFromBytes bs</span>
<span class="lineno">  256 </span><span class="spaces">    </span><span class="istickedoff">t -&gt; <span class="nottickedoff">fail (&quot;Bignum tag must be one of 2 or 3, got: &quot; ++ show t)</span></span></span>
<span class="lineno">  257 </span>
<span class="lineno">  258 </span>-- Adapted from Codec.CBOR.Read
<span class="lineno">  259 </span>decodeBoundedBytesIndef :: Decoder s BSL.ByteString
<span class="lineno">  260 </span><span class="decl"><span class="istickedoff">decodeBoundedBytesIndef = CBOR.decodeBytesIndef &gt;&gt; decodeBoundedBytesIndefLen []</span></span>
<span class="lineno">  261 </span>
<span class="lineno">  262 </span>-- Adapted from Codec.CBOR.Read, to call the size-checking bytestring decoder
<span class="lineno">  263 </span>decodeBoundedBytesIndefLen :: [BS.ByteString] -&gt; Decoder s BSL.ByteString
<span class="lineno">  264 </span><span class="decl"><span class="istickedoff">decodeBoundedBytesIndefLen acc = do</span>
<span class="lineno">  265 </span><span class="spaces">  </span><span class="istickedoff">stop &lt;- CBOR.decodeBreakOr</span>
<span class="lineno">  266 </span><span class="spaces">  </span><span class="istickedoff">if stop</span>
<span class="lineno">  267 </span><span class="spaces">    </span><span class="istickedoff">then return $! BSL.fromChunks (reverse acc)</span>
<span class="lineno">  268 </span><span class="spaces">    </span><span class="istickedoff">else do</span>
<span class="lineno">  269 </span><span class="spaces">      </span><span class="istickedoff">!bs &lt;- decodeBoundedBytes</span>
<span class="lineno">  270 </span><span class="spaces">      </span><span class="istickedoff">decodeBoundedBytesIndefLen (bs : acc)</span></span>
<span class="lineno">  271 </span>
<span class="lineno">  272 </span>decodeBoundedBytes :: Decoder s BS.ByteString
<span class="lineno">  273 </span><span class="decl"><span class="istickedoff">decodeBoundedBytes = do</span>
<span class="lineno">  274 </span><span class="spaces">  </span><span class="istickedoff">b &lt;- CBOR.decodeBytes</span>
<span class="lineno">  275 </span><span class="spaces">  </span><span class="istickedoff">-- See Note [The 64-byte limit]</span>
<span class="lineno">  276 </span><span class="spaces">  </span><span class="istickedoff">unless (BS.length b &lt;= 64) $ fail <span class="nottickedoff">&quot;ByteString exceeds 64 bytes&quot;</span></span>
<span class="lineno">  277 </span><span class="spaces">  </span><span class="istickedoff">pure b</span></span>
<span class="lineno">  278 </span>
<span class="lineno">  279 </span>decodeList :: Decoder s Data
<span class="lineno">  280 </span><span class="decl"><span class="istickedoff">decodeList = List &lt;$&gt; decodeListOf decodeData</span></span>
<span class="lineno">  281 </span>
<span class="lineno">  282 </span>decodeListOf :: Decoder s x -&gt; Decoder s [x]
<span class="lineno">  283 </span><span class="decl"><span class="istickedoff">decodeListOf decoder =</span>
<span class="lineno">  284 </span><span class="spaces">  </span><span class="istickedoff">CBOR.decodeListLenOrIndef &gt;&gt;= \case</span>
<span class="lineno">  285 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; decodeSequenceLenIndef (flip (:)) [] reverse decoder</span>
<span class="lineno">  286 </span><span class="spaces">    </span><span class="istickedoff">Just n -&gt; decodeSequenceLenN (flip (:)) [] reverse n decoder</span></span>
<span class="lineno">  287 </span>
<span class="lineno">  288 </span>decodeMap :: Decoder s Data
<span class="lineno">  289 </span><span class="decl"><span class="istickedoff">decodeMap =</span>
<span class="lineno">  290 </span><span class="spaces">  </span><span class="istickedoff">CBOR.decodeMapLenOrIndef &gt;&gt;= \case</span>
<span class="lineno">  291 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">Map &lt;$&gt; decodeSequenceLenIndef (flip (:)) [] reverse decodePair</span></span>
<span class="lineno">  292 </span><span class="spaces">    </span><span class="istickedoff">Just n -&gt; Map &lt;$&gt; decodeSequenceLenN (flip (:)) [] reverse n decodePair</span>
<span class="lineno">  293 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  294 </span><span class="spaces">    </span><span class="istickedoff">decodePair = (,) &lt;$&gt; decodeData &lt;*&gt; decodeData</span></span>
<span class="lineno">  295 </span>
<span class="lineno">  296 </span>-- See Note [CBOR alternative tags] for the encoding scheme.
<span class="lineno">  297 </span>decodeConstr :: Decoder s Data
<span class="lineno">  298 </span><span class="decl"><span class="istickedoff">decodeConstr =</span>
<span class="lineno">  299 </span><span class="spaces">  </span><span class="istickedoff">CBOR.decodeTag64 &gt;&gt;= \case</span>
<span class="lineno">  300 </span><span class="spaces">    </span><span class="istickedoff">102 -&gt; decodeConstrExtended</span>
<span class="lineno">  301 </span><span class="spaces">    </span><span class="istickedoff">t</span>
<span class="lineno">  302 </span><span class="spaces">      </span><span class="istickedoff">| 121 &lt;= t &amp;&amp; t &lt; 128 -&gt;</span>
<span class="lineno">  303 </span><span class="spaces">          </span><span class="istickedoff">Constr (fromIntegral t - 121) &lt;$&gt; decodeListOf decodeData</span>
<span class="lineno">  304 </span><span class="spaces">    </span><span class="istickedoff">t</span>
<span class="lineno">  305 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">1280 &lt;= t &amp;&amp; t &lt; 1401</span> -&gt;</span>
<span class="lineno">  306 </span><span class="spaces">          </span><span class="istickedoff">Constr ((fromIntegral t - 1280) + 7) &lt;$&gt; decodeListOf decodeData</span>
<span class="lineno">  307 </span><span class="spaces">    </span><span class="istickedoff">t -&gt; <span class="nottickedoff">fail (&quot;Unrecognized tag &quot; ++ show t)</span></span>
<span class="lineno">  308 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  309 </span><span class="spaces">    </span><span class="istickedoff">decodeConstrExtended = do</span>
<span class="lineno">  310 </span><span class="spaces">      </span><span class="istickedoff">len &lt;- CBOR.decodeListLenOrIndef</span>
<span class="lineno">  311 </span><span class="spaces">      </span><span class="istickedoff">i &lt;- CBOR.decodeWord64</span>
<span class="lineno">  312 </span><span class="spaces">      </span><span class="istickedoff">args &lt;- decodeListOf decodeData</span>
<span class="lineno">  313 </span><span class="spaces">      </span><span class="istickedoff">case len of</span>
<span class="lineno">  314 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  315 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">done &lt;- CBOR.decodeBreakOr</span></span>
<span class="lineno">  316 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">unless done $ fail &quot;Expected exactly two elements&quot;</span></span>
<span class="lineno">  317 </span><span class="spaces">        </span><span class="istickedoff">Just n -&gt; unless (n == 2) $ <span class="nottickedoff">fail &quot;Expected exactly two elements&quot;</span></span>
<span class="lineno">  318 </span><span class="spaces">      </span><span class="istickedoff">pure $ Constr (fromIntegral i) args</span></span>

</pre>
</body>
</html>
