<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><link rel="stylesheet" type="text/css" href="style.css"
     /><script type="text/javascript" src="highlight.js"
    ></script
    ></head
  ><body
  ><pre
    ><span class="hs-keyword"
      >module</span
      ><span
      > </span
      ><span class="hs-identifier"
      >Codec.Extras.FlatViaSerialise</span
      ><span
      >
</span
      ><span id="line-2"
      ></span
      ><span
      >    </span
      ><span class="hs-special"
      >(</span
      ><span
      > </span
      ><span class="annot"
      ><a href="Codec.Extras.FlatViaSerialise.html#FlatViaSerialise"
	><span class="hs-identifier"
	  >FlatViaSerialise</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="hs-glyph"
      >..</span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-3"
      ></span
      ><span
      >    </span
      ><span class="hs-special"
      >)</span
      ><span
      > </span
      ><span class="hs-keyword"
      >where</span
      ><span
      >
</span
      ><span id="line-4"
      ></span
      ><span
      >
</span
      ><span id="line-5"
      ></span
      ><span class="hs-keyword"
      >import</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/serialise-0.2.6.1/docs/src/Codec.Serialise.html"
	><span class="hs-identifier"
	  >Codec.Serialise</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/serialise-0.2.6.1/docs/src/Codec.Serialise.Class.html#Serialise"
	><span class="hs-identifier"
	  >Serialise</span
	  ></a
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/serialise-0.2.6.1/docs/src/Codec.Serialise.html#deserialiseOrFail"
	><span class="hs-identifier"
	  >deserialiseOrFail</span
	  ></a
	></span
      ><span class="hs-special"
      >,</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/serialise-0.2.6.1/docs/src/Codec.Serialise.html#serialise"
	><span class="hs-identifier"
	  >serialise</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-6"
      ></span
      ><span class="hs-keyword"
      >import</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/bytestring-0.11.5.3/docs/src/Data.ByteString.Lazy.html"
	><span class="hs-identifier"
	  >Data.ByteString.Lazy</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-keyword"
      >qualified</span
      ><span
      > </span
      ><span class="hs-keyword"
      >as</span
      ><span
      > </span
      ><span class="annot"
      ><span class="hs-identifier"
	>BSL</span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >(</span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/bytestring-0.11.5.3/docs/src/Data.ByteString.Lazy.Internal.html#toStrict"
	><span class="hs-identifier"
	  >toStrict</span
	  ></a
	></span
      ><span class="hs-special"
      >)</span
      ><span
      >
</span
      ><span id="line-7"
      ></span
      ><span class="hs-keyword"
      >import</span
      ><span
      > </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/flat-0.6/docs/src/Flat.html"
	><span class="hs-identifier"
	  >Flat</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-8"
      ></span
      ><span
      >
</span
      ><span id="line-9"
      ></span
      ><span class="hs-comment"
      >{- Note [Flat serialisation for strict and lazy bytestrings]
The `flat` serialisation of a bytestring consists of a sequence of chunks, with each chunk preceded
by a single byte saying how long it is.  The end of a serialised bytestring is marked by a
zero-length chunk.  In the Plutus Core specification we recommend that all bytestrings should be
serialised in a canonical way as a sequence of zero or more 255-byte chunks followed by an optional
final chunk of length less than 255 followed by a zero-length chunk (ie, a 0x00 byte). We do allow
the decoder to accept non-canonical encodings.  The `flat` library always encodes strict Haskell
bytestrings in this way, but lazy bytestrings, which are essentially lists of strict bytestrings,
may be encoded non-canonically since it's more efficient just to emit a short chunk as is.  The
Plutus Core `bytestring` type is strict so bytestring values are always encoded canonically.
However, we serialise `Data` objects (and perhaps objects of other types as well) by encoding them
to CBOR and then flat-serialising the resulting bytestring; but the `serialise` method from
`Codec.Serialise` produces lazy bytestrings and if we were to serialise them directly then we could
end up with non-canonical encodings, which would mean that identical `Data` objects might be
serialised into different bytestrings.  To avoid this we convert the output of `serialise` into a
strict bytestring before flat-encoding it.  This may lead to a small loss of efficiency during
encoding, but this doesn't matter because we only ever do flat serialisation off the chain.  We can
convert `Data` objects to bytestrings on the chain using the `serialiseData` builtin, but this
performs CBOR serialisation and the result is always in a canonical form. -}</span
      ><span
      >
</span
      ><span id="line-28"
      ></span
      ><span
      >
</span
      ><span id="line-29"
      ></span
      ><span class="annot"
      ><span class="hs-comment"
	>-- | For deriving 'Flat' instances via 'Serialize'.</span
	></span
      ><span
      >
</span
      ><span id="line-30"
      ></span
      ><span class="hs-keyword"
      >newtype</span
      ><span
      > </span
      ><span id="FlatViaSerialise"
      ><span class="annot"
	><a href="Codec.Extras.FlatViaSerialise.html#FlatViaSerialise"
	  ><span class="hs-identifier hs-var"
	    >FlatViaSerialise</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span id="local-6989586621681818539"
      ><span class="annot"
	><a href="#local-6989586621681818539"
	  ><span class="hs-identifier hs-type"
	    >a</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span id="FlatViaSerialise"
      ><span class="annot"
	><a href="Codec.Extras.FlatViaSerialise.html#FlatViaSerialise"
	  ><span class="hs-identifier hs-var"
	    >FlatViaSerialise</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-special"
      >{</span
      ><span
      > </span
      ><span id="unFlatViaSerialise"
      ><span class="annot"
	><span class="annottext"
	  >forall a. FlatViaSerialise a -&gt; a
</span
	  ><a href="Codec.Extras.FlatViaSerialise.html#unFlatViaSerialise"
	  ><span class="hs-identifier hs-var hs-var"
	    >unFlatViaSerialise</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >::</span
      ><span
      > </span
      ><span class="annot"
      ><a href="#local-6989586621681818539"
	><span class="hs-identifier hs-type"
	  >a</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-special"
      >}</span
      ><span
      >
</span
      ><span id="line-31"
      ></span
      ><span
      >
</span
      ><span id="line-32"
      ></span
      ><span class="hs-keyword"
      >instance</span
      ><span
      > </span
      ><span id="local-6989586621681818549"
      ><span class="annot"
	><a href="https://hackage.haskell.org/package/serialise-0.2.6.1/docs/src/Codec.Serialise.Class.html#Serialise"
	  ><span class="hs-identifier hs-type"
	    >Serialise</span
	    ></a
	  ></span
	><span
	> </span
	><span class="annot"
	><a href="#local-6989586621681818549"
	  ><span class="hs-identifier hs-type"
	    >a</span
	    ></a
	  ></span
	><span
	> </span
	><span class="hs-glyph"
	>=&gt;</span
	><span
	> </span
	><span class="annot"
	><a href="https://hackage.haskell.org/package/flat-0.6/docs/src/Flat.Class.html#Flat"
	  ><span class="hs-identifier hs-type"
	    >Flat</span
	    ></a
	  ></span
	><span
	> </span
	><span class="hs-special"
	>(</span
	><span class="annot"
	><a href="Codec.Extras.FlatViaSerialise.html#FlatViaSerialise"
	  ><span class="hs-identifier hs-type"
	    >FlatViaSerialise</span
	    ></a
	  ></span
	><span
	> </span
	><span class="annot"
	><a href="#local-6989586621681818549"
	  ><span class="hs-identifier hs-type"
	    >a</span
	    ></a
	  ></span
	><span class="hs-special"
	>)</span
	></span
      ><span
      > </span
      ><span class="hs-keyword"
      >where</span
      ><span
      >
</span
      ><span id="line-33"
      ></span
      ><span
      >    </span
      ><span class="hs-comment"
      >-- See Note [Flat serialisation for strict and lazy bytestrings]</span
      ><span
      >
</span
      ><span id="line-34"
      ></span
      ><span
      >    </span
      ><span id="local-6989586621681818583"
      ><span class="annot"
	><span class="annottext"
	  >encode :: FlatViaSerialise a -&gt; Encoding
</span
	  ><a href="#local-6989586621681818583"
	  ><span class="hs-identifier hs-var hs-var hs-var hs-var"
	    >encode</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>ByteString -&gt; Encoding
forall a. Flat a =&gt; a -&gt; Encoding
</span
	><a href="https://hackage.haskell.org/package/flat-0.6/docs/src/Flat.Class.html#encode"
	><span class="hs-identifier hs-var"
	  >encode</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>(ByteString -&gt; Encoding)
-&gt; (FlatViaSerialise a -&gt; ByteString)
-&gt; FlatViaSerialise a
-&gt; Encoding
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#."
	><span class="hs-operator hs-var"
	  >.</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>ByteString -&gt; ByteString
</span
	><a href="https://hackage.haskell.org/package/bytestring-0.11.5.3/docs/src/Data.ByteString.Lazy.Internal.html#toStrict"
	><span class="hs-identifier hs-var"
	  >BSL.toStrict</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>(ByteString -&gt; ByteString)
-&gt; (FlatViaSerialise a -&gt; ByteString)
-&gt; FlatViaSerialise a
-&gt; ByteString
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#."
	><span class="hs-operator hs-var"
	  >.</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>a -&gt; ByteString
forall a. Serialise a =&gt; a -&gt; ByteString
</span
	><a href="https://hackage.haskell.org/package/serialise-0.2.6.1/docs/src/Codec.Serialise.html#serialise"
	><span class="hs-identifier hs-var"
	  >serialise</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>(a -&gt; ByteString)
-&gt; (FlatViaSerialise a -&gt; a) -&gt; FlatViaSerialise a -&gt; ByteString
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#."
	><span class="hs-operator hs-var"
	  >.</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>FlatViaSerialise a -&gt; a
forall a. FlatViaSerialise a -&gt; a
</span
	><a href="Codec.Extras.FlatViaSerialise.html#unFlatViaSerialise"
	><span class="hs-identifier hs-var"
	  >unFlatViaSerialise</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-35"
      ></span
      ><span
      >    </span
      ><span id="local-6989586621681818599"
      ><span class="annot"
	><span class="annottext"
	  >decode :: Get (FlatViaSerialise a)
</span
	  ><a href="#local-6989586621681818599"
	  ><span class="hs-identifier hs-var hs-var hs-var hs-var"
	    >decode</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span class="hs-keyword"
      >do</span
      ><span
      >
</span
      ><span id="line-36"
      ></span
      ><span
      >        </span
      ><span id="local-6989586621681818601"
      ><span class="annot"
	><span class="annottext"
	  >Either DeserialiseFailure a
</span
	  ><a href="#local-6989586621681818601"
	  ><span class="hs-identifier hs-var"
	    >errOrX</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >&lt;-</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>ByteString -&gt; Either DeserialiseFailure a
forall a. Serialise a =&gt; ByteString -&gt; Either DeserialiseFailure a
</span
	><a href="https://hackage.haskell.org/package/serialise-0.2.6.1/docs/src/Codec.Serialise.html#deserialiseOrFail"
	><span class="hs-identifier hs-var"
	  >deserialiseOrFail</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>(ByteString -&gt; Either DeserialiseFailure a)
-&gt; Get ByteString -&gt; Get (Either DeserialiseFailure a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Functor.html#%3C%24%3E"
	><span class="hs-operator hs-var"
	  >&lt;$&gt;</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Get ByteString
forall a. Flat a =&gt; Get a
</span
	><a href="https://hackage.haskell.org/package/flat-0.6/docs/src/Flat.Class.html#decode"
	><span class="hs-identifier hs-var"
	  >decode</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-37"
      ></span
      ><span
      >        </span
      ><span class="hs-keyword"
      >case</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>Either DeserialiseFailure a
</span
	><a href="#local-6989586621681818601"
	><span class="hs-identifier hs-var"
	  >errOrX</span
	  ></a
	></span
      ><span
      > </span
      ><span class="hs-keyword"
      >of</span
      ><span
      >
</span
      ><span id="line-38"
      ></span
      ><span
      >            </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Either.html#Left"
	><span class="hs-identifier hs-type"
	  >Left</span
	  ></a
	></span
      ><span
      > </span
      ><span id="local-6989586621681818603"
      ><span class="annot"
	><span class="annottext"
	  >DeserialiseFailure
</span
	  ><a href="#local-6989586621681818603"
	  ><span class="hs-identifier hs-var"
	    >err</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>String -&gt; Get (FlatViaSerialise a)
forall a. String -&gt; Get a
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Control.Monad.Fail.html#fail"
	><span class="hs-identifier hs-var"
	  >fail</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>(String -&gt; Get (FlatViaSerialise a))
-&gt; String -&gt; Get (FlatViaSerialise a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#%24"
	><span class="hs-operator hs-var"
	  >$</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>DeserialiseFailure -&gt; String
forall a. Show a =&gt; a -&gt; String
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Show.html#show"
	><span class="hs-identifier hs-var"
	  >show</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>DeserialiseFailure
</span
	><a href="#local-6989586621681818603"
	><span class="hs-identifier hs-var"
	  >err</span
	  ></a
	></span
      ><span
      >  </span
      ><span class="hs-comment"
      >-- Here we embed a 'Serialise' error into a 'Flat' one.</span
      ><span
      >
</span
      ><span id="line-39"
      ></span
      ><span
      >            </span
      ><span class="annot"
      ><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/Data.Either.html#Right"
	><span class="hs-identifier hs-type"
	  >Right</span
	  ></a
	></span
      ><span
      > </span
      ><span id="local-6989586621681818605"
      ><span class="annot"
	><span class="annottext"
	  >a
</span
	  ><a href="#local-6989586621681818605"
	  ><span class="hs-identifier hs-var"
	    >x</span
	    ></a
	  ></span
	></span
      ><span
      >  </span
      ><span class="hs-glyph"
      >-&gt;</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>FlatViaSerialise a -&gt; Get (FlatViaSerialise a)
forall a. a -&gt; Get a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#pure"
	><span class="hs-identifier hs-var"
	  >pure</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>(FlatViaSerialise a -&gt; Get (FlatViaSerialise a))
-&gt; FlatViaSerialise a -&gt; Get (FlatViaSerialise a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#%24"
	><span class="hs-operator hs-var"
	  >$</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>a -&gt; FlatViaSerialise a
forall a. a -&gt; FlatViaSerialise a
</span
	><a href="Codec.Extras.FlatViaSerialise.html#FlatViaSerialise"
	><span class="hs-identifier hs-var"
	  >FlatViaSerialise</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>a
</span
	><a href="#local-6989586621681818605"
	><span class="hs-identifier hs-var"
	  >x</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-40"
      ></span
      ><span
      >    </span
      ><span id="local-6989586621681818608"
      ><span class="annot"
	><span class="annottext"
	  >size :: FlatViaSerialise a -&gt; NumBits -&gt; NumBits
</span
	  ><a href="#local-6989586621681818608"
	  ><span class="hs-identifier hs-var hs-var hs-var hs-var"
	    >size</span
	    ></a
	  ></span
	></span
      ><span
      > </span
      ><span class="hs-glyph"
      >=</span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>ByteString -&gt; NumBits -&gt; NumBits
forall a. Flat a =&gt; a -&gt; NumBits -&gt; NumBits
</span
	><a href="https://hackage.haskell.org/package/flat-0.6/docs/src/Flat.Class.html#size"
	><span class="hs-identifier hs-var"
	  >size</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>(ByteString -&gt; NumBits -&gt; NumBits)
-&gt; (FlatViaSerialise a -&gt; ByteString)
-&gt; FlatViaSerialise a
-&gt; NumBits
-&gt; NumBits
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#."
	><span class="hs-operator hs-var"
	  >.</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>ByteString -&gt; ByteString
</span
	><a href="https://hackage.haskell.org/package/bytestring-0.11.5.3/docs/src/Data.ByteString.Lazy.Internal.html#toStrict"
	><span class="hs-identifier hs-var"
	  >BSL.toStrict</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>(ByteString -&gt; ByteString)
-&gt; (FlatViaSerialise a -&gt; ByteString)
-&gt; FlatViaSerialise a
-&gt; ByteString
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#."
	><span class="hs-operator hs-var"
	  >.</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>a -&gt; ByteString
forall a. Serialise a =&gt; a -&gt; ByteString
</span
	><a href="https://hackage.haskell.org/package/serialise-0.2.6.1/docs/src/Codec.Serialise.html#serialise"
	><span class="hs-identifier hs-var"
	  >serialise</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>(a -&gt; ByteString)
-&gt; (FlatViaSerialise a -&gt; a) -&gt; FlatViaSerialise a -&gt; ByteString
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span
	><a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/src/GHC.Base.html#."
	><span class="hs-operator hs-var"
	  >.</span
	  ></a
	></span
      ><span
      > </span
      ><span class="annot"
      ><span class="annottext"
	>FlatViaSerialise a -&gt; a
forall a. FlatViaSerialise a -&gt; a
</span
	><a href="Codec.Extras.FlatViaSerialise.html#unFlatViaSerialise"
	><span class="hs-identifier hs-var"
	  >unFlatViaSerialise</span
	  ></a
	></span
      ><span
      >
</span
      ><span id="line-41"
      ></span
      ></pre
    ></body
  ></html
>
