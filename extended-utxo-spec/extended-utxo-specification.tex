%% Extended UTXO Specification
\newcommand\version{-1}

\title{Formal Specification of the Extended UTXO Model (\red{\textsf{DRAFT}})}

\pagestyle{plain}
\date{11th October 2019}
\author{}

\documentclass[a4paper]{article}

% correct bad hyphenation here
\hyphenation{}

\usepackage{natbib}
\usepackage{url}

% *** MATHS PACKAGES ***
%
\usepackage[cmex10]{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{amsthm}

% *** ALIGNMENT PACKAGES ***
%
\usepackage{array}
\usepackage{float}  %% Try to improve placement of figures.  Doesn't work well with subcaption package.
\usepackage{subcaption}
\usepackage{caption}

\usepackage{subfiles}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{verbatim}
\usepackage{alltt}

%\usepackage{todonotes}
\usepackage[disable]{todonotes}

\usepackage{hyperref}  % This has to go at the end of the packages.


% Stuff for splitting figures over page breaks
%\DeclareCaptionLabelFormat{continued}{#1~#2 (Continued)}
%\captionsetup[ContinuedFloat]{labelformat=continued}

% *** MACROS ***

% A command for making notes with bold titles and an independent
% numbering system.  This is used for a list of notes in the appendix.
\newcounter{note}
\newcommand{\note}[1]{
  \bigskip
  \refstepcounter{note}
  \noindent\textbf{Note \thenote. #1}
}

\newcommand{\todochak}[1]{\todo[inline,color=purple!40,author=chak]{#1}}
\newcommand{\todompj}[1]{\todo[inline,color=yellow!40,author=Michael]{#1}}
\newcommand{\todokwxm}[1]{\todo[inline,color=blue!20,author=kwxm]{#1}}
\newcommand{\todojm}[1]{\todo[inline,color=purple!40,author=Jann]{#1}}

\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\redfootnote}[1]{\red{\footnote{\red{#1}}}}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}
\newcommand{\bluefootnote}[1]{\blue{\footnote{\blue{#1}}}}

%% A version of ^{\prime} for use in text mode
\makeatletter
\DeclareTextCommand{\textprime}{\encodingdefault}{%
  \mbox{$\m@th'\kern-\scriptspace$}%
}
\makeatother

\renewcommand{\i}{\textit}  % Just to speed up typing: replace these in the final version
\renewcommand{\t}{\texttt}  % Just to speed up typing: replace these in the final version
\newcommand{\s}{\textsf}  % Just to speed up typing: replace these in the final version

\newenvironment{arraydefs}[1]{\setlength{\arraycolsep}{0pt}\begin{array}{#1}}{\end{array}}
%
% This is just the array environment with the column separation set to 0.
% This is to enable us to get things like
%
%%   X = (field1: type1,
%         field2: type2,
%         ...
%
% without a space after the ')'. Unfortunately you have to manually insert a space
% at the end of the X so you don't get X=
% There's presumably a better way to do this.
%
% You can also use something like
%
%    \begin{tabular}{r@{ }l@{}l} ...
%
% but the spacing is arguably worse.


%% A figure with rules above and below.
\newcommand\rfskip{7pt}
\newenvironment{ruledfigure}[1]{\begin{figure}[#1]\hrule\vspace{\rfskip}}{\vspace{\rfskip}\hrule\end{figure}}


%% Various text macros
\newcommand{\true}{\textsf{true}}
\newcommand{\false}{\textsf{false}}

\newcommand{\List}[1]{\ensuremath{\s{List}[#1]}}
\newcommand{\Set}[1]{\ensuremath{\s{Set}[#1]}}
\newcommand{\FinSet}[1]{\ensuremath{\s{FinSet}[#1]}}
\newcommand{\Interval}[1]{\ensuremath{\s{Interval}[#1]}}
\newcommand{\extended}[1]{#1^\updownarrow}
\newcommand{\FinSup}[2]{\ensuremath{\s{FinSup}[#1,#2]}}
\newcommand{\support}{\ensuremath{\mathrm{sup}}}
\newcommand{\strictsupport}{\ensuremath{\mathrm{strictsup}}}

\newcommand{\script}{\ensuremath{\s{Script}}}
\newcommand{\ptx}{\ensuremath{\s{PendingTx}}}

% Macros for eutxo things.
\newcommand{\mi}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\txid}{\mi{txid}}
\newcommand{\idx}{\mi{index}}
\newcommand{\inputs}{\mi{inputs}}
\newcommand{\outputs}{\mi{outputs}}
\newcommand{\forge}{\mi{forge}}
\newcommand{\fee}{\mi{fee}}
\newcommand{\addr}{\mi{addr}}
\newcommand{\val}{\mi{value}}  %% \value is already defined

\newcommand{\validator}{\mi{validator}}
\newcommand{\redeemer}{\mi{redeemer}}
\newcommand{\valdata}{\mi{valdata}}
\newcommand{\Data}{\ensuremath{\mathsf{Data}}}

\newcommand{\outputref}{\mi{outputRef}}
\newcommand{\txin}{\mi{in}}
\newcommand{\txout}{\mi{out}}
\newcommand{\id}{\mi{id}}
\newcommand{\getvalue}{\msf{getvalue}}

\newcommand{\msf}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\slotnum}{\msf{SlotNumber}}
\newcommand{\spent}{\msf{spentOutputs}}
\newcommand{\unspent}{\msf{unspentOutputs}}
\newcommand{\txunspent}{\msf{unspentTxOutputs}}
\newcommand{\eutxotx}{\msf{EUtxoTx}}

\newcommand{\qty}{\ensuremath{\s{Quantity}}}
\newcommand{\qtypm}{\ensuremath{\s{Quantity}^{\pm}}}
\newcommand{\newqtytype}{\ensuremath{\s{Quantity}^{\prime}}}
\newcommand{\token}{\ensuremath{\s{Token}}}
\newcommand{\currency}{\ensuremath{\s{CurrencyId}}}
\newcommand{\nativeCur}{\ensuremath{\mathrm{nativeC}}}
\newcommand{\nativeTok}{\ensuremath{\mathrm{nativeT}}}
\newcommand{\injectNative}{\ensuremath{\mathrm{inject}}}

\newcommand{\qtymap}{\ensuremath{\s{QuantityMap}}}
\newcommand{\qtymappm}{\ensuremath{\s{QuantityMap}^{\pm}}}

\newcommand\B{\ensuremath{\mathbb{B}}}
\newcommand\N{\ensuremath{\mathbb{N}}}
\newcommand\Z{\ensuremath{\mathbb{Z}}}
\renewcommand\H{\ensuremath{\mathbb{H}}}
%% \H is usually the Hungarian double acute accent

\newcommand{\emptymap}{\ensuremath{\{\}}}


%% ------------- Start of document ------------- %%

\begin{document}
\maketitle

\section{Introduction: The Extended UTXO Model}
\label{sec:intro}
The Cardano blockchain~\citep{Cardano, Cardano-ledger-spec} uses a
variant of the \textit{Unspent Transaction Output} (UTXO) model used
by Bitcoin.  Transactions consume \textit{unspent outputs} (UTXOs)
from previous transactions and produce new outputs which can be used
as inputs to later transactions.  Unspent outputs are the liquid funds
on the blockchain. Users do not have individual accounts, but rather
have a software \textit{wallet} on a smartphone or PC which manages
UTXOs on the blockchain and can initiate transactions involving UTXOs
owned by the user.  Every core node on the blockchain maintains a
record of all of the currently unspent outputs, the \textit{UTXO set};
when outputs are spent, they are removed from the UTXO set.

This document contains a specification of some extensions of the
UTXO model: the main aim of these extensions is to facilitate the
implementation of \textit{smart contracts}, programs which perform
automated and irrevocable transfer of funds on the blockchain, subject
to certain conditions being met.  A smart contract may involve
multiple transactions, and our aim is to define a transaction model
which enables the implementation of highly expressive contracts.

An important feature of our UTXO models is \textit{scripts},
programs which run on the blockchain to check the validity of
transactions.  In Cardano, scripts will be programs in the Plutus Core
language~\citep{Plutus-Core-spec}. The Extended UTXO models are largely
agnostic as to the scripting language.


\subsection{Structure of the document}
\label{sec:doc-structure}
The papers~\citep{Zahnentferner18-Chimeric} and
\citep{Zahnentferner18-UTxO} give a formal specification of a basic
UTXO model. See Note~\ref{note:basic-utxo} for some background on
this model.

\medskip
\noindent This document proposes two extensions of the basic UTXO
model (EUTXO stands for \textit{Extended UTXO}):

\begin{itemize}
  \item \textbf{EUTXO-1} (Section~\ref{sec:eutxo-1}): this extends the
    basic UTXO model with enhanced scripting features, allowing the
    implementation of complex smart contracts.
  \item \textbf{EUTXO-2} (Section~\ref{sec:eutxo-2}): this adds
    multicurrency features to EUTXO-1, allowing users to define
    \textit{custom currencies} and \textit{non-fungible tokens}.
\end{itemize}


\medskip

The rationale for providing two separate specifications is that (1)
introducing the extensions separately clarifies the structure of the
models and makes it easier to explain the relevant design decisions,
and (2) it is possible that a particular blockchain might not need the
full power of EUTXO-2 and so could use the simpler EUTXO-1 model,
perhaps with less computational overhead.

\medskip

For ease of reference we have kept exposition to a minimum in the main
text.  Some aspects of the specification are explained in more detail
in Appendix~\ref{appendix:comments}, with cross-references in the main
text.  Further explanation and many examples are contained in the
book~\citep{Plutus-book}.


\section{Notation}
This section defines some basic notation.  We generally follow the
notation established by \citep{Zahnentferner18-UTxO}, except that we make use
of finitely-supported functions in most places that \citep{Zahnentferner18-UTxO}
use maps.

\subsection{Basic types}
\noindent Throughout the document we assume a number of basic types.
These are shown in Figure~\ref{fig:basic-types}.

\begin{ruledfigure}{H}
  \center{
    \begin{tabular}{rl}
      \B&: the type of booleans, $\{\false, \true\}$\\
      \N&: the type of natural numbers, $\{0, 1, 2, \ldots\}$\\
      \Z&: the type of integers, $\{,\ldots, -2, -1, 0, 1, 2, \ldots\}$\\
      \H&: the type of \textit{bytestrings}, $\bigcup_{n=0}^{\infty}\{0,1\}^{8n}$\\
      $\qty = \N$&: an amount of currency, always non-negative\\
      $\qtypm = \Z$&: a possibly negative amount of currency\\
      $\slotnum = \N$&: a slot number\\
      $\s{Address} = \N$&: the address of an object in the blockchain\\
      $\s{TxId} = \N$&: the identifier of a previous transaction on the chain\\
    \end{tabular}
  }
  \caption{Basic types}
  \label{fig:basic-types}
\end{ruledfigure}

\noindent We regard $\N$ as a subtype of $\Z$ and convert freely between
natural numbers and non-negative integers.  A bytestring is a sequence
of 8-bit bytes: the symbol $\H$ is used because bytestrings are often
presented as sequences of hexadecimal digits.

\medskip
\noindent In practice an \textsf{Address} will be a
collision-resistant hash of some object (so the address of an object
$X$ is $X^{\#}$ in the notation of Figure~\ref{fig:basic-notation}),
and the blockchain will provide an efficient way to retrieve the
original object given its hash.  Compiled Plutus Core scripts are
stored and transmitted in a serialised form, and when we talk about
the hash of a Plutus Core script we mean the hash of the serialised
version.

% Accessing objects indirectly via addresses is helpful because it can
% help to reduce memory and disk usage: for example, there may be
% scripts for common validation scenarios used in many transactions, and
% it is more efficient to store single copies of such scripts rather
% than having hundreds of transactions each with their own copy.

\medskip
\noindent We assume that every transaction in a ledger has a unique identifier
of type \s{TxId}: in an implementation this would probably be the
hash of the transaction.

\subsection{Basic notation}
Figure~\ref{fig:basic-notation} describes some notation and
conventions used in the remainder of the document.
\begin{ruledfigure}{H}
  \begin{itemize}
\item Types are typeset in $\mathsf{sans~serif}$.

\item All scripts are of type \script{}.

\item The only operation on \script{} from the ledger's
  perspective is applying a validator script to three arguments,
  which is denoted by $\llbracket \cdots \rrbracket :
  \script \rightarrow \Data \times \Data
    \times \Data \rightarrow \B$.
\item A record type with fields $\phi_1, \ldots, \phi_n$ of types $T_1,
  \ldots, T_n$ is denoted by $(\phi_1 : T_1, \ldots, \phi_n : T_n)$.

\item If $t$ is a value of a record type $T$ and $\phi$ is the name
  of a field of $T$ then $t.\phi$ denotes the value of $\phi$ for
  $t$.

\item If $T$ is a type then $\FinSet{T}$ is the type of finite sets
  with elements of type $T$.

\item A list $\lambda$ of type $\List{T}$ is either the empty list
  $[]$ or a list $e :: \lambda'$ with $head$ $e$ of type $T$ and
  $tail$ $\lambda'$ of type $\List{T}$. A list has only a finite
  number of elements.  We denote the $i$th element of a list $\lambda$ by
  $\lambda[i]$ and the length of $\lambda$ by $\left|\lambda\right|$.
%The concatenation of two lists $\lambda_1$ and $\lambda_2$
%  is denoted $\lambda_1 ::: \lambda_2$.

  \item For two types $K$ and $V$ where $V$ is a monoid, $\FinSup{K}{V}$ denotes the type of
    \textit{finitely-supported functions} from $K$ to $V$. That is, there is a
    function $\support : \FinSup{K}{V} \rightarrow \FinSet{K}$ such that
    $k \in \support(f) \Leftarrow f(k) \neq 0$.\footnote{Note that we only
      require the support to be a \textit{superset} of the set of non-zero
      points, rather than equal to it. This simplifies implementations as
      it does not require minimizing the support when new zero points are
      introduced.}
    Equality on finitely-supported functions is defined as pointwise equality
    over their joint support.\footnote{This is exactly the same as normal
      pointwise equality except that it is computationally tractable.}
    \[
      f = g \Leftrightarrow \forall a \in \support(f) \cup \support(g) . f(a) = g(a)
    \]
    The \textit{strict support} $\strictsupport : \FinSup{K}{V} \rightarrow
    \FinSet{K}$ of a finitely supported function is defined as:
    \[
      \strictsupport(f) = \{ f(x) \neq 0 \mid x \in \support(f) \}
    \]

  \item If the type $M$ is a monoid with binary operation $+$ (for
    example, a numeric type) the we define the sum of two finitely-supported
    functions
    $f, g \in \FinSup{K}{M}$ to be the function $f+g \in \FinSup{K}{M}$ with
    support $\support (f+g) = \support f \cup \support g$ given by
    \[(f+g)(k) = f(k) + g(k) \]
    We generalise this to the sum of a finite number of maps using
    the $\sum$ notation in the usual way; care is required if the
    operation $+$ is non-commutative, since then the sum of a number of
    functions will depend on the order in which they appear. Note that
    the type $\FinSup{K}{M}$ itself becomes a monoid under the
    operation $+$ which we have just defined, with the empty function as
    identity element.

  \item If the type $M$ is a group with inverse operation $-$, then we can
    similarly define the inverse of a finitely-supported function $f$ as
    the function $(-f)$ with the same support, given by
    \[ (-f)(k) = -f(k) \]

  \item $x \mapsto f(x)$ denotes an anonymous function.

  \item A cryptographic
    collision-resistant hash of a value $c$ is denoted $c^{\#}$.

  \item For a type $A$ which forms a partial order, $\extended{A}$ is the same
    type extended with a top element $\infty$ and a bottom element $-\infty$.

  \item For a type $A$ which forms a total order,  $\Interval{A}$ is the type
    of intervals over that type, whose endpoints may be either closed or open.
    The type $\Interval{A}$ forms a lattice.

\end{itemize}
\caption{Basic notation}
\label{fig:basic-notation}
\end{ruledfigure}

\subsection{The \Data{} type}
We also define a type \Data{} which can be used to pass information
into scripts in a type-safe manner: see Figure~\ref{fig:data-defn}. The
definition is given here in EBNF form, but can easily be translated to
a Haskell type, for instance.

\begin{ruledfigure}{H}
\begin{alltt}
  \Data =
      "I" \(\N\)
    | "B" \(\H\)
    | "Constr" \(\N (\List{\Data})\)
    | "List" \(\List{\Data}\)
    | "Map" \(\List{\Data\times\Data}\)
\end{alltt}
\caption{The \Data{} type}
\label{fig:data-defn}
\end{ruledfigure}

\noindent Thus values of type \Data{} are nested sums and products
built up recursively from the base types of integers and
bytestrings. This allows one to encode a large variety of first-order
data structures: for example, we could encode values of Haskell's
\verb|Maybe Integer| type using \verb|Constr 0| to represent
\verb|Nothing| and \verb|Constr 1 [I 41]| to encode \verb|Just 41|.


The \texttt{List} and \texttt{Map} constructors are strictly
redundant, but are included for convenience to allow straightforward
encoding of lists and records.

We assume that the scripting language has the ability to parse values
of type \Data{}, converting them into a suitable internal representation.






\section{EUTXO-1: Enhanced scripting}
\label{sec:eutxo-1}
The EUTXO-1 model adds the following new features to the model
proposed in~\citep{Zahnentferner18-UTxO}:

\begin{itemize}
\item Every transaction has a \textit{validity interval}, of type $\Interval{\extended{\slotnum}}$.
  A core node will only process the transaction if
  the current slot number lies within the transaction's validity
  interval.

\item Each unspent output now has a (possibly empty) object $\valdata$ of type
  \Data{} associated with it: we (\red{provisionally}) call this the output's
  \textit{validation data}.  The introduction of the validation data
  increases the expressivity of the model considerably. For example,
  one can use the validation data to propagate state between
  transactions, and this can be used to give a contract the structure
  of a finite state machine; the fact that the validation data is part
  of the output and not the transaction means that the state can
  change without the transaction changing, which makes it easier to
  have an ``identity'' for an ongoing contract.

\item The redeemer script of~\citet{Zahnentferner18-UTxO} has been
  replaced with a redeemer object of type \Data.

\item Validation of an output is performed by running the validator
  script with the redeemer and validation data as input; the validator
  is also provided with information about the pending transaction (ie,
  the transaction which is just about to take place, assuming that
  validation succeeds). This information is contained in a structure
  (also encoded as \Data) which we call \ptx{}: this contains data
  such as the validity interval of the pending transaction and
  information about the inputs and outputs.  See
  Section~\ref{sec:pendingtx} for more information on the \ptx{}
  structure.

\end{itemize}


\noindent At the ledger level, validator scripts now have the type
$
\Data \times \Data \times \Data \rightarrow \B
$. At the Plutus level in Cardano, the validator is a program which
consumes the redeemer, the validation data, and a \Data{} encoding
of the \ptx{} structure as arguments.  The validator may
expect these objects to have some specific form (a single bytestring
or a list of integers, for example) and if it is supplied with data
with an incorrect format it should fail and return \false.

\todokwxm{There's the issue about whether validators return
  \texttt{true/false} or \texttt{()/Error}. Remember to fix this when things have settled down.}

\subsection{A Formal Description of the EUTXO-1 Model}
\label{section:eutxo-spec}

In this section we give a formal description of the EUTXO-1 model.  The
description is given in a straightforward set-theoretic form, which
(a) admits an almost direct translation into Haskell, and (b) should
easily be amenable to mechanical formalisation.  This will potentially
allow us to argue formally about smart contracts and to develop tools
for automatic contract analysis.

The definitions in this section are essentially the definitions of
UTXO-based cryptocurrencies with scripts from
\citep{Zahnentferner18-UTxO}, except that we have added the new
features mentioned above (the validity interval, the validation data
and the \ptx{} structure) and changed the type of the redeemer from
\script{} to \Data{}.

Figure~\ref{fig:eutxo-1-types} lists the types which
describe transactions in the basic EUTXO model.
%%
\begin{ruledfigure}{H}
  \[
  \begin{arraydefs}{rll}

    \s{Output } &= (&\addr: \s{Address},\\
    && \i{value}: \qty,\\
    &&  \valdata: \Data)\\
    \\
    \s{OutputRef } &= (&\i{id}: \s{TxId}, \idx: \s{Int})\\
    \\
    \s{Input } & = (&\i{outputRef}: \s{OutputRef},\\
                 && \i{validator}: \script,\\
                 && \i{redeemer}: \Data)\\
     \\
     \eutxotx\s{ } &= (&\inputs: \FinSet{\s{Input}},\\
     &&\outputs: \List{\s{Output}},\\
     &&\i{validityInterval}: \Interval{\extended{\slotnum}},\\
     && \fee: \qty,\\
     &&\forge: \qty) \\
     \\
     \s{Ledger } &=&\!\List{\eutxotx}\\
  \end{arraydefs}
  \]
  \caption{Types for the EUTXO-1 model}
  \label{fig:eutxo-1-types}
\end{ruledfigure}

\subsubsection{Remarks}
\paragraph{Inputs and outputs. } Note that a transaction has a
\textsf{Set} of inputs but a \textsf{List} of outputs. We use a list
because any subsequent transaction attempting to use an unspent output
$O$ as an input will have to be able to determine exactly where $O$
came from: thus each input of a transaction refers to the output which
it is trying to spend via an \s{OutputRef} which specifies the
transaction which produced the output and an index which says which
output of the transaction is required.

%\todompj{Can we just cite one of the previous descriptions for this?
%  Also: we should check this is still how they do it in the new ledger
%  specs.}

\paragraph{Scripts.} Note that validation data are modelled as components
of outputs, but validator scripts as components of inputs, even though
a validator is conceptually part of an output.  The reasons for this
are explained in Note~\ref{note:scripts}.

\paragraph{Fees.}  Users are charged a fee for the on-chain storage
and execution costs of a transaction, and this is included in the
EUTXO models.  The details are not important for the purposes of the
models, but see Note~\ref{note:fees} for some more discussion.

\paragraph{Special types of transaction.} In a practical
implementation it might be useful to include special cases for common
transaction types such as pay-to-pukbey transactions in order to
increase efficiency and decrease storage requirements (and hence
reduce fees).  These have been omitted from this model because it
subsumes all of the other transaction types we're likely to encounter,
and also because it's difficult to give a definitive list of such
special cases.

\paragraph{Ledger structure.} We model a ledger as a simple
list of transactions: a real blockchain ledger will be more complex
than this, but the only property that we really require is that
transactions in the ledger have some kind of address which allows them
to be uniquely identified and retrieved.

\subsubsection{The \ptx{} type}
\label{sec:pendingtx}
Recall from the introduction to Section~\ref{sec:eutxo-1} that when a
transaction input is being validated, the validator script is supplied
with an object of type \ptx{} which contains information about the
pending transaction.  The \ptx{} type for the current version of
EUTXO-1 is defined in Figure~\ref{fig:ptx-1-types}, along with some
related types.

\begin{ruledfigure}{H}
  \[
  \begin{arraydefs}{rll}

    \s{OutputInfo } &= (& \i{value}: \qty,\\
    && \i{validatorHash}: \s{Address},\\
    &&  \valdata: \Data)\\
    \\
    \s{InputInfo } & = (&\i{inputRef}: \s{OutputRef},\\
                 && \i{validatorHash}: \s{Address},\\
                 && \i{redeemerHash}: \s{Address},\\
                 && \i{value}: \qty)\\
     \\
     \ptx\s{ } &= (&\i{inputInfo}: \List{\s{InputInfo}},\\
     &&\i{thisInput}: \N,\\
     &&\i{outputInfo}: \List{\s{OutputInfo}},\\
     &&\i{validityInterval}: \Interval{\extended{\slotnum}},\\
     && \fee: \qty,\\
     &&\forge: \qty)
   \end{arraydefs}
 \]
  \caption{The \ptx{} type for the EUTXO-1 model}
  \label{fig:ptx-1-types}
\end{ruledfigure}
%%
\noindent The \ptx{} type is essentially a summary of the information
contained in the $\eutxotx$ type in
Figure~\ref{fig:eutxo-1-types}. The \fee{}, \forge{}, and
\i{validityInterval} fields are copied directly from the pending
transaction.  The \i{outputInfo} field contains information about the
outputs which will be produced if the pending transaction validates
successfully: it contains only the address of the relevant validator,
but has the validation data for the output in full.\footnote{See
  Note~\ref{note:validation-data} for further explanation.}
The \i{inputInfo} field contains information about the
inputs to the pending transaction, but provides only the hashes of the
validator and redeemer scripts for the inputs.  The \i{thisInput}
field is an index pointing to the element of \i{inputInfo}
relating to the input currently undergoing validation.
% Note: in the code at the moment, the hashes of the validator
% and redeemer scripts in inputInfo are allowed to be absent
% when we have pubkey inputs.  We're ignoring that special case here.

\medskip
\noindent We also require a function
$$
\tau: \eutxotx \times \N \rightarrow \ptx
$$
which produces the relevant \ptx{} for a transaction $t$ and an input
$i$, and a function
$$
\delta: \ptx \rightarrow \Data
$$
which translates a \ptx{} object into a \Data{} value containing
exactly the same information, encoded in some standard way enabling it
to be accessed by a validator script.  Assuming we have an
appropriate hashing function, it is straightforward to define $\tau$.
The function $\delta$ is implementation-dependent and we will not
discuss it further.

\medskip\todokwxm{But with the advent of \Data{} we \textit{can}
  specify $\delta$.  Maybe we should?}
\todokwxm{... or even just do the whole translation in one step.}

\paragraph{Determinism.}  The information provided in the \ptx{}
structure is sufficiently limited that the validation process
becomes \textit{deterministic},  which has important implications
for fee calculations.  See Note~\ref{note:validation-determinism}
for further discussion.


\subsection{Validity of EUTXO-1 transactions}
\label{sec:eutxo-1-validity}
A number of conditions must be satisfied in order for a transaction
$t$ to be considered valid with respect to a ledger $\lambda$.  In
order to define these we require a couple of auxiliary functions.
Firstly, following~\citep{Zahnentferner18-UTxO} we define

$$
  \txunspent : \eutxotx \rightarrow \FinSet{\s{OutputRef}}
  $$
%
  by
%
$$
\txunspent(t) = \{(id,1), \ldots, (\mathit{id},\left|t.outputs\right|)\}
$$
\noindent (where $\mathit{id}$ is $t$'s unique $\s{TxId}$), and
%
\[
  \unspent : \mathsf{Ledger} \rightarrow \FinSet{\s{OutputRef}}
\]
%
by
%
\begin{align*}
   \unspent([]) &=\emptymap \\
   \unspent(t::\lambda) &= (\unspent(\lambda) \setminus t.\inputs) \cup \txunspent(t).
\end{align*}

\noindent Note that for a completed transaction $t$, $t.\inputs$ is
the set of previously unspent outputs which were spent by $t$.

\medskip
\noindent Given a ledger $\lambda$ and a transaction id $\id$, we
denote by $\lambda\langle\id\rangle$ the unique transaction $T$ in
$\lambda$ with $T.\txid = \id$, if it exists. In our abstract model
where $\lambda$ consists of a list of transactions it would suffice to
take $id$ to be the position of $T$ in $\lambda$, but in an
implementation we would probably have $id = T^{\#}$.

\medskip
\noindent Now given an input $i$ to some transaction in a ledger
$\lambda$ we define
$$
\getvalue(i,\lambda) = \lambda\langle i.\outputref.\txid \rangle.\outputs[i.\outputref.\idx].\val
$$
This function simply returns the value of the input.



\bigskip

\noindent We can now define what it means for a transaction $t$ of
type $\eutxotx$ to be valid for a ledger: see
Figure~\ref{fig:eutxo-1-validity}.  Our definition combines
Definitions 6 and 14 from \citep{Zahnentferner18-UTxO}, differing from
the latter in condition \ref{rule:all-inputs-validate}.
\todokwxm{Check this.}

\begin{ruledfigure}{H}
\begin{enumerate}
    \item \label{rule:all-inputs-refer-to-unspent-outputs} \textbf{All
      inputs refer to unspent outputs:}
      \[
        t.\inputs \subseteq \unspent(\lambda).
      \]
    \item\label{rule:forging} \textbf{Forging:}
      \begin{center}
        \parbox{0.8\textwidth}{ A transaction with a non-zero \forge{}
          field is only valid if the ledger $\lambda$ is empty (that
          is, if it is the initial transaction).}
    \end{center}

    \item \label{rule:value-is-preserved} \textbf{Value is preserved}:
    \[
      t.\forge + \sum_{i \in t.\inputs} \getvalue(i, \lambda) = t.\fee + \sum_{o \in t.\outputs} o.\val.
    \]
    \item \label{rule:no-double-spending} \textbf{No output is double spent:}
    \[
     \textrm{If } i_1, i_2 \in t.\inputs \textrm{ and }  i_1.\mathit{outputRef} = i_2.\mathit{outputRef}
     \textrm{ then } i_1 = i_2.
    \]
    \item\label{rule:all-inputs-validate} \textbf{All inputs validate:}
    \[
    \textrm{For all } i \in t.\inputs,\enspace \llbracket
    i.\validator\rrbracket (\txout(i, \lambda).\valdata,\, i.\redeemer,\,  \delta(\tau(t,i))) = \true.
      \]
    \item\label{rule:validator-scripts-hash} \textbf{Validator scripts hash to their output addresses:}
    \[
      \textrm{For all } i \in t.\inputs,\enspace i.\validator^{\#} = \txout(i, \lambda).\addr.
    \]
\end{enumerate}
\caption{Validity of a transaction $t$ in the EUTXO-1 model}
\label{fig:eutxo-1-validity}
\end{ruledfigure}
\todokwxm{Do we really needs the $\llbracket\cdots\rrbracket$ business?}


\noindent We say that a ledger
$\lambda$ is \textit{valid} if either $\lambda$ is empty or
$\lambda$ is of the form $t::\lambda^{\prime}$ with
$\lambda^{\prime}$ valid and $t$ valid for $\lambda^{\prime}$.


In practice, validity imposes a limit on the size of the
\script{} values of the $\validator$, $\redeemer$ and
$\valdata$ fields and the result of $\delta$. The validation of a
single transaction must take place within one slot, so the evaluation
of $\llbracket ~ \rrbracket$ cannot take longer than one slot.
\todokwxm{Do we need this $\uparrow$?}
\todokwxm{We should probably point out somewhere that the validating node
  typechecks scripts during validation.}

%%\newpage
\section{EUTXO-2: multicurrency support and non-fungible tokens}
\label{sec:eutxo-2}
We now extend the EUTXO-1 model further by introducing features which
allow, among other things, the implementation of new currencies and
\textit{non-fungible tokens} (NFTs).  We assume that the underlying
blockchain has a unique \textit{native currency} which is the
fundamental currency used for paying fees, for example.  The native
currency of the Cardano blockchain is Ada.

\paragraph{Custom currencies.} In addition to the native currency, the
EUTXO-2 model allows an unlimited number of other \textit{custom
  currencies}, possibly user-defined.  Each custom currency has a
unique identifier; the native currency is handled separately and has
no identifier.

\todokwxm{We may wish to implement a DEX to enable exchange of custom
  currencies.  This is a little problematic in Ethereum because the
  Ether currency itself does not conform to ERC-20 and so has to be
  wrapped in another currency before it can participate in DEX trades.
  Will the fact that Ada is treated differently from custom currencies
  in EUTXO cause us difficulties here?}

\paragraph{NFTs.}
A non-fungible token (NFT) is a unique object which can be transferred
to another user, but not duplicated.  NFTs have proven useful in a
number of blockchain applications (see~\citep{ERC-721} for example);
for example, they can represent ownership of some object in a game.
We can implement NFTs as custom currencies whose supply is limited to
a single coin.

\subsection{The definition of EUTXO-2}
In order to support these extensions, we introduce several new types.
Custom currencies are represented by unique \textit{currency
  identifiers} and each currency has a number of \textit{tokens} which
partition each custom currency into a number of sub-currencies.  The
basic idea is that ordinary currencies have a single token whose
sub-currency has an unlimited supply and NFTs have a number of tokens
with the sub-currency for each token limited to a supply of one.


\newcommand{\emspace}{\hspace{1em}}
\newcommand{\espace}{\hspace{1en}}

\begin{ruledfigure}{H}
  \center{
  \begin{tabular}{rll}
    \currency &: & an identifier for a custom currency. This is an alias
                for the \s{Address} type\\
             &  & from Figure~\ref{fig:basic-types}.\\
    \\
    \nativeCur &: & a distinguished \currency{} representing the native currency of the ledger.\\
    \\
    \token   &: & a type consisting of identifiers for individual tokens.  These will probably\\
             &  & be hashes in practice.\\
    \\
    \nativeTok &: & a distinguished \token{} representing the currency token of the native currency.\\
    \\
    \qtymap   &=& \FinSup{\currency}{\FinSup{\token}{\qty}}\\
    \\
    \qtymappm &=& \FinSup{\currency}{\FinSup{\token}{\qtypm}}\\
  \end{tabular}
  }
  \caption{Extra basic types for the EUTXO-2 model}
  \label{fig:more-basic-types}
\end{ruledfigure}

\noindent The \qtymap{} type represents a collection of funds from a
number of currencies and their subcurrencies, with all quantities
being non-negative.  The \qtymappm{} type is similar, but
negative quantities are allowed.

\begin{ruledfigure}{H}
  \[
  \begin{arraydefs}{rll}
    \s{Output}_2 &= (&\addr: \s{Address},\\
    && \val: \qtymap\\
    && \valdata: \Data)\\
    \\
    \s{OutputRef}_2 &= (&\i{id}: \s{TxId}, \idx: \s{Int})\\
    \\
    \s{Input}_2 &= (& \i{outputRef}: \sf{OutputRef}_2,\\
                     && \i{validator}: \script,\\
                     & & \i{redeemer}: \Data)\\
    \\
    \eutxotx_2 &= ( &\inputs: \FinSet{\s{Input}_2},\\
    &&\outputs: \List{\s{Output}_2},\\
    &&\i{validityInterval}: \Interval{\extended{\slotnum}},\\
    &&\fee: \qty,\\
    &&\forge: \qtymap^{\pm})\\
    \\
    \s{Ledger}_2 &=&\!\List{\eutxotx_2}\\
\end{arraydefs}
  \]
  \caption{Types for the EUTXO-2 model}
  \label{fig:eutxo-2-types}
\end{ruledfigure}

\noindent The changes to the basic EUTXO-1 types are now quite simple:
see Figure~\ref{fig:eutxo-2-types}.  We change the type of the $\val$ field
in the \s{Output} type to be \qtymap{}, representing values of all currencies;
we also change the type of the \forge{} field on transactions to \qtymappm{}, to
allow the creation and destruction of funds in all currencies; the
supply of a currency can be reduced by forging a negative amount of that
currency, as in EUTXO-1.

Quantities of the native currency are represented just like any other currency,
using \qtymap{}s with the \nativeCur{} identifier. The one exception is the
\fee{} field, which continues to be a simple \qty{}. This represents a quantity
in the native currency, as fees can only be paid in that.

\subsection{The \ptx{} type for EUTXO-2}
\label{sec:pendingtx-2}
The \ptx{} type must be also be updated for the EUTXO-2 model.  All
that is required is to replace \qty{} by \qtymap{} everywhere in
Figure~\ref{fig:ptx-1-types} except for the \fee{} field: for reference
the details are given in Figure~\ref{fig:ptx-2-types}.
\begin{ruledfigure}{H}
  \[
  \begin{arraydefs}{rll}

    \s{OutputInfo}_2\s{ } &= (& \i{value}: \qtymap,\\
    && \i{validatorHash}: \s{Address},\\
    &&  \i{datascriptHash}: \s{Address})\\
    \\
    \s{InputInfo}_2\s{ }& = (&\i{inputRef}: \s{OutputRef},\\
                 && \i{validatorHash}: \s{Address},\\
                 && \i{redeemerHash}: \s{Address}),\\
                 && \i{value}: \qtymap)\\
     \\
     \ptx_2\s{ } &= (&\i{inputInfo}: \List{\s{InputInfo}_2},\\
     &&\i{thisInput}: \N,\\
     &&\i{outputInfo}: \List{\s{OutputInfo$_2$}},\\
     &&\i{validityInterval}: \Interval{\extended{\slotnum}},\\
     &&\fee: \qty,\\
     &&\forge: \qtymap)
   \end{arraydefs}
 \]
  \caption{The \ptx{} type for the EUTXO-2 model}
  \label{fig:ptx-2-types}
\end{ruledfigure}

\noindent Again we require functions
$$
\tau_2: \eutxotx_2 \times \N \rightarrow \ptx_2
$$
and
$$
\delta_2: \ptx_2 \rightarrow \Data
$$
which can be used to produce an appropriate script from a transaction
and the index of an input.

\subsection{Validity of EUTXO-2 transactions}
\label{sec:eutxo-2-validity}

\bigskip
\noindent The validity conditions from
Figure~\ref{fig:eutxo-1-validity} must also be updated to take account
of multiple currencies.

We use the definitions of \unspent{}  and
\getvalue{} from Section~\ref{sec:eutxo-1-validity} unchanged,
but we also require a function to inject a \qty{} of the native currency
into \qtymap{}. We define:
\begin{displaymath}
  \injectNative(q)(c)(t) = \left\{
    \begin{array}{ll}
      q & \mbox{if $c = \nativeCur$ and $t = \nativeTok$ }\\
      0 & \mbox{otherwise}
    \end{array}
  \right\}
\end{displaymath}

We can now adapt the definition of validity for EUTXO-1
(Figure~\ref{fig:eutxo-1-validity}) to obtain a definition of validity for
EUTXO-2: see Figure~\ref{fig:eutxo-2-validity}.

\begin{ruledfigure}{H}
  \begin{enumerate}
    \item \label{rule:all-inputs-refer-to-unspent-outputs-2} \textbf{All
      inputs refer to unspent outputs:}
      \[
        t.\inputs \subseteq \unspent(\lambda).
      \]
    \item\textbf{Forging:}\\\\
      \begin{minipage}{0.85\textwidth}
        A transaction with a non-zero \forge{} field is only
        valid if either:
        \begin{enumerate}
          \item the ledger $\lambda$ is empty (that is, if it is the initial transaction).
          \item \label{rule:custom-forge}
            for every key $h$ in $\strictsupport(t.\forge)$, there
            exists $i \in t.\inputs$ and $(a,v,d) \in i.\outputs$ with
            $a =h$; in other words, some input must spend an output
            whose address is $h$.
        \end{enumerate}
      \end{minipage}
    \item \textbf{Values are preserved}\\
      \begin{minipage}{0.85\textwidth}
          \label{rule:value-is-preserved-2}
            \[
            t.\forge + \sum_{i \in t.\inputs} \getvalue(i, \lambda) = \injectNative(t.\fee) + \sum_{o \in t.\outputs} o.\val
            \]
      \end{minipage}
    \item \label{rule:no-double-spending-2} \textbf{No output is double spent:}
    \[
     \textrm{If } i_1, i_2 \in t.\inputs \textrm{ and }  i_1.\mathit{outputRef} = i_2.\mathit{outputRef}
     \textrm{ then } i_1 = i_2.
    \]
    \item\label{rule:all-inputs-validate-2} \textbf{All inputs validate:}
    \[
    \textrm{For all } i \in t.\inputs,\enspace \llbracket
    i.\validator\rrbracket(\txout(i,\lambda).\valdata,\, i.\redeemer,\, \delta_2(\tau_2(t, i))) = \true.
      \]
    \item\label{rule:validator-scripts-hash-2} \textbf{Validator scripts hash to their output addresses:}
    \[
      \textrm{For all } i \in t.\inputs,\enspace i.\validator^{\#} = \txout(i, \lambda).\addr.
    \]
  \end{enumerate}
  \caption{Validity of a transaction $t$ in the EUTXO-2 model}
  \label{fig:eutxo-2-validity}

\end{ruledfigure}

\noindent If any of the indexing operations here fail then the
transaction is invalid.

\paragraph{Note.} In rule~\ref{rule:value-is-preserved-2},
$+$ and $\sum$ are the sum of finitely-supported functions as defined in
Figure~\ref{fig:basic-notation}. Essentially we require that the
quantities of each of the individual custom currencies involved in the
transaction are preserved. Recall that values in $\forge$ can
be negative whereas values in outputs must be non-negative.  Thus
rule~\ref{rule:value-is-preserved-2} implies that a
transaction is invalid if it attempts to destroy more of a currency
than is actually available in its inputs.

\subsection{The EUTXO-2 model in practice.}
See~\cite{Plutus-book} for examples of contracts which make use of the
features of the EUTXO-2 model.  See also
Notes~\ref{note:monetary-policies}, \ref{note:eutxo-2-implications},
and \ref{note:eutxo-2-performance} for comments on some technical
aspects of the model.

\appendix
\section{Comments on the specification}
\label{appendix:comments}

\note{The Basic UTXO model: Outputs and scripts.}
\label{note:basic-utxo}
There is no well-defined notion of ownership for UTXOs.  In many
transactions an output will accrue to a single user who is then
entitled to spend it at a later date.  However, in general the notion
of ownership is more complex: an output of a transaction might require
the cooperation of several users before it could be spent, or it might
not be spendable until some other condition has been met (for example
a certain period of time may have to pass).  At the extremes, an
output could be spendable by anyone, or by no-one.

In order to deal with this complexity, an output can be locked by a
\textit{script},%
\footnote{In the Cardano setting, scripts are Plutus Core
  programs~\citep{Plutus-Core-spec} (equivalently, expressions).  }
requiring another script to unlock it.  In the basic model, each input
to a transaction comes with a \i{validator} script which checks that
the transaction is allowed to spend the output. In order to spend an
output, the transaction supplies a value, called the
\i{redeemer}, which provides evidence that the transaction has the
authority to do so;\footnote{The validator plays a role similar to
  that of BitCoin's \texttt{scriptPubKey} and the redeemer to
  \texttt{scriptSig}.  } a process called \i{validation} is then
performed which checks that the redeemer satisfies the conditions
required by the validator. Before a transaction can proceed, all inputs
must be successfully validated: if one or more inputs fails to
validate then the transaction is rejected.

A simple example of this is a \i{pay-to-pubkey} script, where the
redeemer consists of a signature for the current transaction produced
using a private key belonging to the owner of the output.  The
validator (provided by the owner of the output) would check the
signature using a known public key: if the public key corresponds to
the private key then validation succeeds, otherwise it fails.  Thus
the output can only be spent by the owner of the relevant private key


\note{Fees and Costs.}
\label{note:fees}
Users may have to pay a fee in order to have a transaction executed.
In a public blockchain an important reason for this is to deter
hostile agents from carrying out denial of service attacks by
submitting transactions which take a long time or use excessive
amounts of memory.  The precise details of fees in Cardano are outwith
the scope of this document, and indeed have not been fully decided at
the time of writing. However, we expect that the fee will include a
component based on the size of the transaction (including its
associated scripts), and also a so-called \textit{gas} charge to cover
execution costs.  We will have a model specifying the costs of
individual operations during script execution; costs will be monitored
dynamically during execution, and if the gas consumed ever exceeds the
amount covered by the fee then the transaction will fail.

\note{Scripts.}
\label{note:scripts} The spendability of an output is determined by
its validator script, and thus the validator for an output must be
created at the same time as the output is.  Conceptually the validator
is  part of the output, so it may be rather unexpected that
Figure~\ref{fig:eutxo-1-types} defines the validator to be part of an
\textit{input}, with the output only containing the address of the
validator.  The rationale for this is that a validator $V$ for an
output $O$ is not required until $O$ is actually spent, which may be
some time after $O$ was created.  Recall from Note~\ref{note:fees} that the
cost of executing a transaction depends on the size of transaction,
including the associated scripts.  Thus the transaction that produces
the validator only pays for the size of a hash (32 bytes) and the
transaction that runs it pays for the full size of the script. This
strategy also helps to reduce on-chain storage requirements, since
validators can be stored off-chain until needed (and the presence of
the hash in the output can be used to check that the correct validator
is in fact being used when validation occurs), but unspent outputs
persist on-chain in the UTXO set until they are eventually spent.

This strategy is not applied to validation data since, as the name
would suggest, we expect these to be small pieces of data (public
keys, for example) which would not incur large storage charges.

\note{Validation data in \ptx{}}
\label{note:validation-data}
In Figures~\ref{fig:ptx-1-types} and~\ref{fig:ptx-2-types} the
\textsf{OutputInfo} type includes the validation data for the outputs
of the pending transaction in full.  This allows a validator to
inspect outgoing validation data, for example to confirm that its
contents are correct in some sense. This can be useful when validation
data is used to propagate information about the state of a contract to
later transactions.  See~\cite{Plutus-book} for examples of this.
\todokwxm{More specific reference?}



\note{Determinism of the validation process.}
\label{note:validation-determinism} The \ptx{} type is the only
information about the ``outside world'' available to a validator
script at the time of validation.  Allowing the validator access to
this information gives the EUTXO models a considerable amount of
power, as can be seen from the example contracts
in~\cite{Plutus-book}.  However, it is important not to make too much
information available to the validator.  The choice of the \ptx{} type
above means that the information available to the validator is
essentially independent of the state of the blockchain, and in
particular, it is independent of time (note that the check that the
current slot number is within a transaction's validity range takes
place \textit{before} validation is initiated, and the slot number is
not passed to the validator (although the validity range is)).  This
implies that validation is \textit{determinisitic} and validators can
be run off-chain in order to determine their execution cost before
on-chain validation actually occurs.  This helps users to calculate
transaction fees in advance and avoid the possibility of their
transactions failing due to an insufficient fee having been paid (and
also avoids overpayment due to overestimating the fees).

\todokwxm{This may be a little optimistic.  For example, in the
  crowdfunding contract we don't know in advance how many
  contributions will be made, or whether a campaign will succeed or
  fail.  Thus we won't know how much the final transaction will cost
  until just before it happens.}

\note{Monetary policies for custom currencies.}
\label{note:monetary-policies}
The new \textbf{Forging} rule in
Figure~\ref{fig:eutxo-2-validity} enables custom currencies to
implement their own monetary policies: for example, one might wish to
place some limit on the amount of a currency that can be forged, or
restrict the creation of the currency to owners of particular public
keys.

The idea is that a custom currency has a monetary policy which is
defined by some script $H$, and the hash $h = H^{\#}$ is used as the
identifier of the currency.

Whenever a new quantity of the currency is forged,
rules~\ref{rule:custom-forge}, \ref{rule:all-inputs-validate-2}, and
\ref{rule:validator-scripts-hash-2} imply that $H$ must be executed;
$H$ is provided with the \forge{} field of the transaction via the
\ptx{} object, and so it knows how much of the currency is to be
forged and can respond appropriately.

The advantage of this scheme is that custom currencies can be handled
entirely within the smart contract system, without the need to
introduce any extra blockchain infrastructure such as a central
registry of custom currencies.

In practice some refinement of this scheme will be required in order
to (a) allow re-use of a monetary policy for different currencies, and
(b) prevent unauthorised forging of a currency. To deal with (a) we
can make the validator script unique by including a nonce. This still
doesn't prevent unauthorised people from using the script $H$ to
produce currency, but this can be prevented by, for instance,
embedding a reference to an unspent output in the script and
requiring that the currency can only be forged if the referenced
output is spent at the same time, so it can only be forged once.

\smallskip
\todokwxm{Is this exactly what we want?  I think that gives you a
  single opportunity to forge the currency, and then you can't make
  any more. I suppose that you could restrict the ability to forge to
  a particular individual by requiring them to provide something
  signed by their private key when they want to create new money.
  Also, is this a case where an output of value zero would be useful?}

\smallskip
\todokwxm{The use of the term ``forging'' is a bit confusing here,
  since it also means ``counterfeiting''.}

% \todojm{I think there are two different concerns:
%  (1) Using the same monetary policy multiple times;
%   (2) Preventing unauthorised forging of a currency.

% The "referencing an unspent output" trick accomplishes
%   both but is mainly aimed at (2). You could also achieve (1) by
%   embedding any kind of random data in the validator script, like a
%   nonce.
% }


\note{Implications of the EUTXO-2 model.}
\label{note:eutxo-2-implications}
The EUTXO-2 model and the techniques described in
Note~\ref{note:monetary-policies} allow us to implement fungible
(normal) and non-fungible token currencies, as well as ``mixed
states'':
\begin{itemize}
\item Standard (fungible) currencies are implemented by issuing
  currencies with a single \token{}.
\item Non-fungible token currencies are implemented by only ever
  issuing single quantities of many unique \token{}s.
\item Note that there is nothing in this model which enforces
  uniqueness: having multiples of a single \token{} merely means that
  those can be used fungibly. If a currency wants to make sure it only
  issues unique tokens it must track this itself.  These ``mixed'' token
  currencies can have many \token{}s, but these can have more than unit
  quantities in circulation.  These can be useful to model distinct
  categories of thing where there are fungible quantities within
  those, for example share classes. \red{Eh?}
\end{itemize}

\note{Performance issues for EUTXO-2.}
\label{note:eutxo-2-performance}
The EUTXO-2 model will lose some efficiency in comparison to the EUTXO-1
model, simply because the data structures are more complicated.  This
would even apply to transactions which only involve to native
currency, since it would be necessary to check whether the \qtymap{}
contains anything that needs to be processed.  If this is a concern
then one could implement a model with two types of transaction,
essentially just the disjoint union of the EUTXO-1 and EUTXO-2
transaction types. A simple case distinction at the start of a
transaction could then select either a fast native-currency-only
computation or a slower multicurrency computation.  This would be
harder to maintain though.

\smallskip  Another optimisation would be possible if one wished to
implement custom currencies but not NFTs: since in this case every
currency would only have a single token, the tokens could be omitted
and the \qtymap{} replaced with a map from currency ids to quantities.

\smallskip A more significant cost may be that we can no longer use
\verb|{-# UNPACK #-}| when our \qty{} type stops being a simple
combination of wrappers and products around primitives, but this is
again an issue with any multi-currency proposal.

\bibliographystyle{plainnat} %% ... or whatever
\bibliography{extended-utxo-specification}


\end{document}
