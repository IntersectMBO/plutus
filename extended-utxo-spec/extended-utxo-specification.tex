%% Extended UTXO Specification

\newcommand\version{-1}

\title{Formal Specification of the Extended UTXO Model\\--- \\
  \red{\textsf{PRELIMINARY DRAFT!}}}

\pagestyle{plain}
\date{20th May 2019}
\author{}

\documentclass[a4paper]{article}

\usepackage{natbib}

\usepackage{blindtext, graphicx}
\usepackage{url}
%\usepackage{cleveref}
%\usepackage{hyperref}

% *** MATHS PACKAGES ***
%
\usepackage[cmex10]{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{amsthm}

% *** ALIGNMENT PACKAGES ***
%
\usepackage{array}
\usepackage{float}  %% Try to improve placement of figures.  Doesn't work well with subcaption package.
\usepackage{subcaption}
\usepackage{caption}

% Stuff for splitting figures over page breaks
%\DeclareCaptionLabelFormat{continued}{#1~#2 (Continued)}
%\captionsetup[ContinuedFloat]{labelformat=continued}

% correct bad hyphenation here
\hyphenation{}

\usepackage{subfiles}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{verbatim}
\usepackage{todonotes}

\newcommand{\todochak}[1]{\todo[inline,color=purple!40,author=chak]{#1}}
\newcommand{\todompj}[1]{\todo[inline,color=yellow!40,author=Michael]{#1}}
\newcommand{\todokwxm}[1]{\todo[inline,color=green!20,author=kwxm]{#1}}
\newcommand{\todojm}[1]{\todo[inline,color=purple!40,author=Jann]{#1}}


%%% General Misc. Definitions

%% A version of ^{\prime} for use in text mode
\makeatletter
\DeclareTextCommand{\textprime}{\encodingdefault}{%
  \mbox{$\m@th'\kern-\scriptspace$}% 
}
\makeatother

\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\redfootnote}[1]{\red{\footnote{\red{#1}}}}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}
\newcommand{\bluefootnote}[1]{\blue{\footnote{\blue{#1}}}}

\renewcommand{\i}{\textit}  % Just to speed up typing: replace these in the final version
\renewcommand{\t}{\texttt}  % Just to speed up typing: replace these in the final version
\newcommand{\s}{\textsf}  % Just to speed up typing: replace these in the final version

\theoremstyle{definition}  %% This applies to all following \newtheorem items
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}

\newenvironment{arraydefs}[1]{\setlength{\arraycolsep}{0pt}\begin{array}{#1}}{\end{array}}
%
% This is just the array environment with the column separation set to 0.
% This is to enable us to get things like
%
%%   X = (field1: type1,
%         field2: type2,
%         ...
%
% without a space after the ')'. Unfortunately you have to manually insert a space
% at the end of the X so you don't get X=
% There's presumably a better way to do this.
%
% You can also use something like
%
%    \begin{tabular}{r@{ }l@{}l} ...
%
% but the spacing is arguably worse.


\newcommand\rfskip{7pt}
\newenvironment{ruledfigure}[1]{\begin{figure}[#1]\hrule\vspace{\rfskip}}{\vspace{\rfskip}\hrule\end{figure}}

\newcommand{\true}{\textsf{true}}
\newcommand{\false}{\textsf{false}}


\newcommand{\List}[1]{\ensuremath{\s{List}[#1]}}
\newcommand{\Set}[1]{\ensuremath{\s{Set}[#1]}}
\newcommand{\FinSet}[1]{\ensuremath{\s{FinSet}[#1]}}
\newcommand{\Map}[2]{\ensuremath{\s{Map}[#1,#2]}}
\newcommand{\dom}{\ensuremath{\mathop{\mathrm{dom}}}}

\newcommand{\script}{\ensuremath{\s{Script}}}
\newcommand{\info}{\ensuremath{\s{Info}}}

%Macros for eutxo things.
\newcommand{\mi}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\txid}{\mi{txid}}
\newcommand{\idx}{\mi{index}}
\newcommand{\inputs}{\mi{inputs}}
\newcommand{\outputs}{\mi{outputs}}
\newcommand{\forge}{\mi{forge}}
\newcommand{\fee}{\mi{fee}}
\newcommand{\addr}{\mi{addr}}
\newcommand{\val}{\mi{value}}  %% \value is already defined
\newcommand{\nativeval}{\mi{nativeValue}}
\newcommand{\customvals}{\mi{customValues}}
\newcommand{\customforge}{\mi{customForge}}

\newcommand{\validator}{\mi{validator}}
\newcommand{\redeemer}{\mi{redeemer}}
\newcommand{\datascript}{\mi{datascript}}
\newcommand{\outputref}{\mi{outputRef}}
\newcommand{\txin}{\mi{in}}
\newcommand{\txout}{\mi{out}}
\newcommand{\id}{\mi{id}}
\newcommand{\getvalue}{\msf{getvalue}}

\newcommand{\msf}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\slotnum}{\msf{SlotNumber}}
\newcommand{\spent}{\msf{spentOutputs}}
\newcommand{\unspent}{\msf{unspentOutputs}}
\newcommand{\txunspent}{\msf{unspentTxOutputs}}
\newcommand{\eutxotx}{\msf{EUtxoTx}}

\newcommand{\qtytype}{\ensuremath{\s{Quantity}}}
\newcommand{\qtytypepm}{\ensuremath{\s{Quantity}^{\pm}}}
\newcommand{\newqtytype}{\ensuremath{\s{Quantity}^{\prime}}}

\newcommand{\qtymap}{\ensuremath{\s{QuantityMap}}}
\newcommand{\tokenmap}{\ensuremath{\s{TokenMap}}}

\newcommand\B{\ensuremath{\mathbb{B}}}
\newcommand\N{\ensuremath{\mathbb{N}}}
\newcommand\Z{\ensuremath{\mathbb{Z}}}

\newcommand{\emptymap}{\ensuremath{\{\}}}

\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  mathescape=true,
  escapeinside={|}{|}   %% Inside listings you can say things like |\textit{blah blah}|
}


%% ------------- Start of document ------------- %%

\begin{document}
\maketitle

\section{Introduction: The Extended UTXO Model}
\label{sec:intro}
The Cardano blockchain~\citep{Cardano, Cardano-ledger-spec} uses a
variant of the \textit{Unspent Transaction Output} (UTXO) model used
by Bitcoin.  Transactions consume \textit{unspent outputs} (UTXOs)
from previous transactions and produce new outputs which can be used
as inputs to later transactions.  Unspent outputs are the liquid funds
on the blockchain. Users do not have individual accounts, but rather
have a software \textit{wallet} on a smartphone or PC which manages
UTXOs on the blockchain and can initiate transactions involving UTXOs
owned by the user.  Every core node on the blockchain maintains a
record of all of the currently unspent outputs, the \textit{UTXO set};
when outputs are spent, they are removed from the UTXO set.

Our main concern here is to facilitate the implementation of
\textit{smart contracts}: programs which perform automated and
irrevocable transfer of funds on the blockchain, subject to certain
conditions being met.  A smart contract may involve multiple
transactions, and our aim is to define a transaction model which
enables the implementation of highly expressive contracts.

\subsection{Structure of the document}
\label{sec:doc-structure}
This document proposes three extensions of the basic UTXO model, each
one more general than the previous one (EUTXO stands for
\textit{Extended UTXO}):

\begin{itemize}
  \item \textbf{EUTXO-1} (Section~\ref{sec:eutxo-1}): this extends the
    basic UTXO model with enhanced scripting features, allowing the
    implementation of complex smart contracts.
  \item \textbf{EUTXO-2} (Section~\ref{sec:eutxo-2}): this adds
    multicurrency features to EUTXO-1, allowing users to define
    \textit{custom currencies}.
  \item \textbf{EUTXO-3} (Section~\ref{sec:eutxo-3}): this adds direct
    support for non-fungible tokens to EUTXO-2.
\end{itemize}

\noindent We give formal specifications of each of these versions,
based on the models appearing in the
papers~\citep{Zahnentferner18-Chimeric} and
\citep{Zahnentferner18-UTxO}.

\medskip

The rationale for providing three separate specifications is that (1)
introducing extensions one by one clarifies the structure of the
models and makes it easier to explain the relevant design decisions,
and (2) it is possible that a particular blockchain might not need the
full power of EUTXO-3 and so could use a simpler model, perhaps with
less computational overhead.

\bigskip

\noindent Before presenting the extended models we will define some
basic notation and give a little background on the standard UTXO
model.


\section{Notation}
This section defines some basic notation.  We generally follow the
notation established by \citep{Zahnentferner18-UTxO}.

\begin{ruledfigure}{H}
  \begin{itemize}
\item Types are typeset in $\mathsf{sans~serif}$.

\item All scripts are of type $\mathsf{Script}$.

\item The only operation on $\mathsf{Script}$ from the ledger's
  perspective is applying a validator script to three arguments,
  which is denoted by $\llbracket \cdots \rrbracket :
  \mathsf{Script} \rightarrow \mathsf{Script} \times \mathsf{Script}
    \times \mathsf{Script} \rightarrow \B$.

\item A record type with fields $\phi_1, \ldots, \phi_n$ of types $T_1,
  \ldots, T_n$ is denoted by $(\phi_1 : T_1, \ldots, \phi_n : T_n)$.

\item If $t$ is a value of a record type $T$ and $\phi$ is the name
  of a field of $T$ then $t.\phi$ denotes the value of $\phi$ for
  $t$.

\item If $T$ is a type then $\FinSet{T}$ is the type of finite sets
  with elements of type $T$.
  
\item A list $\lambda$ of type $\List{T}$ is either the empty list
  $[]$ or a list $e :: \lambda'$ with $head$ $e$ of type $T$ and
  $tail$ $\lambda'$ of type $\List{T}$. A list has only a finite
  number of elements.  We denote the $i$th element of a list $\lambda$ by
  $\lambda[i]$ and the length of $\lambda$ by $\left|\lambda\right|$.
%The concatenation of two lists $\lambda_1$ and $\lambda_2$
%  is denoted $\lambda_1 ::: \lambda_2$.

  \item For two types $K$ and $V$, $\Map{K}{V}$ denotes the type of
    partial functions from \textit{keys} in $K$ to \textit{values} in
    $V$, and the result of looking up a key $k$ in a map $m$ is
    denoted by $m[k]$.  If $m$ is such map then the \textit{domain} of
    $m$ is $\dom m = \{k \in K: f[k] \mbox{ is defined}\}$; we can
    regard $m$ as a \textit{total} function from $\dom m$ to $V$, and
    for expository purposes we will sometimes regard $m$ as a subset
    of $\dom m \times V$ in the usual way.

    Equality for maps is defined in the obvious way: $m_1 = m_2$ if
    and only if $\dom m_1 = \dom m_2$ and $m_1[k] = m_2[k]$ for all
    $k \in \dom m_1$ (assuming we have decidable equality in $V$).
    
  \item If the type $M$ is a monoid with binary operation $+$ (for
    example, a numeric type) the we define the sum of two maps
    $f, g \in \Map{K}{M}$ to be the map $f+g \in \Map{K}{M}$ with
    domain $\dom (f+g) = \dom f \cup \dom g$ given by
    \[
    (f+g)[k] =
    \left\{ \begin{array}{ll}
        f[k] + g[k] & \mbox{if $k \in \dom f \cap \dom g$}\\
        f[k] & \mbox{if $k \in \dom f \setminus \dom g$}\\
        g[k] & \mbox{if $k \in \dom g \setminus \dom f$}
      \end{array}
      \right.
      \]
      We generalise this to the sum of a finite number of maps using
      the $\sum$ notation in the usual way; care is required if the
      operation $+$ is non-commutative, since then the sum of a number of
      maps will depend on the order in which they appear. Note that
      the type $\Map{K}{M}$ itself becomes a monoid under the
      operation $+$ which we have just defined, with the empty map $\{\}$ as
      identity element.

    \item $x \mapsto f(x)$ denotes an anonymous function.

  \item A cryptographic
    collision-resistant hash of a value $c$ is denoted $c^{\#}$.

  % \item If any operation fails (for example, indexing a list out of
  %   range or trying to spend an output which has already been spent)
  %   then we assume that the containing script returns \false{}
  %   immediately.
\end{itemize}
\caption{Basic notation}
\label{fig:basic-notation}
\end{ruledfigure}

%% Jann: If I remember correctly there will be two phases: Validation
%% of public key outputs, and script validation. The first phase also
%% unlocks the gas cost, and if the second phase fails then the gas
%% cannot be recovered, so the partially validated transaction has to
%% stay on the chain.



\noindent Throughout the document we assume a number of basic types.
These are shown in Figure~\ref{fig:basic-types}.

\begin{ruledfigure}{H}
  \center{
    \begin{tabular}{rl}
      \B&: the type of booleans, $\{\false, \true\}$\\
      \N&: the type of natural numbers, $\{0, 1, 2, \ldots\}$\\
      \Z&: the type of integers, $\{,\ldots, -2, -1, 0, 1, 2, \ldots\}$\\
      $\qtytype = \N$&: an amount of currency, always non-negative\\
      $\qtytypepm = \Z$&: a possibly negative amount of currency\\
      $\s{SlotNumber} = \N$&: a slot number\\
      $\s{Address} = \N$&: the address of an object in the blockchain\\
      $\s{TxId} = \N$&: the identifier of a previous transaction on the chain\\
    \end{tabular}
  }
  \caption{Basic types}
  \label{fig:basic-types}
\end{ruledfigure}

\noindent We regard $\N$ as a subtype of $\Z$ and convert freely between
natural numbers and non-negative integers.

\medskip
\noindent In practice an \textsf{Address} will usually be a hash of
some object (for example, a script), and the blockchain will provide
an efficient way to retrieve the original object given its hash.
Accessing objects indirectly via addresses is helpful because it can
help to reduce memory and disk usage: for example, there may be
scripts for common validation scenarios used in many transactions, and
it is more efficient to store single copies of such scripts rather
than having hundreds of transactions each with their own copy.

\medskip
\noindent We assume that every transaction in a ledger has a unique identifier
of type \s{TxId}: in an implementation this would probably be the
hash of the transaction.





\section{The Basic UTXO model: Outputs and scripts}
\label{sec:utxo-intro}

There is no well-defined notion of ownership for UTXOs.  In many
transactions an output will accrue to a single user who is then
entitled to spend it at a later date.  However, in general the notion
of ownership is more complex: an output of a transaction might require
the cooperation of several users before it could be spent, or it might
not be spendable until some other condition has been met (for example
a certain period of time may have to pass).  At the extremes, an
output could be spendable by anyone, or by no-one.

In order to deal with this complexity, an output can be locked by a
\textit{script},%
\footnote{In the Cardano setting, scripts are Plutus Core
  programs~\citep{Plutus-Core-spec} (equivalently, expressions).
}
requiring another script to unlock it.
In the basic model, each input to a transaction comes with a
\i{validator} script which checks that the transaction is allowed to
spend the output. In order to spend an output, the
transaction supplies another script, called the \i{redeemer},
which provides evidence that the transaction has the authority
to do so.\footnote{The validator plays a role similar to that of BitCoin's
  \texttt{scriptPubKey} and the redeemer to \texttt{scriptSig}.
}

In a process known as \i{validation}, the validator is run with the
redeemer as input, and if it returns \true{} then the output can be
spent.  Before a transaction can proceed, all inputs must be
successfully validated: if one or more inputs fails to validate then
the transaction is rejected.

\todokwxm{Michael suggests that this is misleading.  At the ledger
  level, validation just does something unspecified with the
  validator and redeemer and looks at the result: it is only at the
  level of scripts that we specialise to application.}

A simple example of this is a \i{pay-to-pubkey} script, where the
redeemer consists of a signature for the current transaction produced
using a private key belonging to the owner of the output.  The
validator (provided by the owner of the output) would check the
signature using a known public key: if the public key corresponds to
the private key then validation succeeds, otherwise it fails.  Thus
the output can only be spent by the owner of the relevant private key

\paragraph{Blockchain terminology.}
\label{sec:blockchain-terminology}
We require a little blockchain background. A \textit{blockchain} is a
ledger consisting of a sequence of \textit{blocks}, each block
containing a number of transactions (and possibly other data).  A
typical blockchain will be maintained by a peer-to-peer network
consisting of \textit{core nodes} who compete to execute users'
transactions and create new blocks, generally receiving some monetary
reward for doing so (for example, in order to have a transaction
executed on the chain, users may have to pay a fee). After a
new block has been created, it will be propagated to the rest of the
network, which will eventually reach consensus on the current state of
the blockchain.  The opportunity to create a new block is known as a
\textit{slot}: slots occur at regular intervals (about once every 20
seconds on Cardano), and hence the current \textit{slot number} can be
used as a proxy for time on the blockchain (using real times would
lead to problems with accuracy and synchronisation).

\paragraph{Fees and Costs.}
\label{sec:costs} As mentioned above, users may have to pay a fee in
order to have a transaction executed.  In a public blockchain an
important reason for this is to deter hostile agents from carrying out
denial of service attacks by submitting transactions which take a long
time or use excessive amounts of memory.  In Cardano we expect that
the fee will include a component based on the size of the transaction
(including its associated scripts), and also a so-called \textit{gas}
charge to cover execution costs.  We will have a model specifying the
costs of individual operations during script execution; costs will be
monitored dynamically during execution, and if the gas consumed ever
exceeds the amount covered by the fee then the transaction will fail.


\section{EUTXO-1: Enhanced scripting}
\label{sec:eutxo-1}
The EUTXO-1 model adds the following new features to the model 
proposed in~\citep{Zahnentferner18-UTxO}:

\begin{itemize}
\item Every transaction has a \textit{validity interval}, consisting
  of two slot numbers: a core node will only process the transaction
  if the current slot number lies within the transaction's validity
  interval.

\item During validation, validator scripts are provided with
  information about the pending transaction (ie, the transaction which
  is just about to take place, assuming that validation succeeds);
  this includes things such as the validity interval of the pending
  transaction and the hash of the transaction. This extra information
  allows us to control how the output is spent, which enables us to do
  multi-stage computations within a single contract.  With suitable
  restrictions on the information provided (for example, excluding
  time-dependent quantities such as the slot number), we can ensure
  that script validation is \i{deterministic}, so that on-chain and
  off-chain execution costs are the same.  This makes it much simpler
  for users to calculate transaction fees.  This information has
  some type \info{} which we leave unspecified.

  \todokwxm{This is probably confusing.  At the ledger level we just
    have something of type \s{Script}: it's at the Plutus level that
    we need to worry about what \s{Info} actually is. Can we do this
    sensibly in a Plutus-agnostic way?}

\item We introduce a new script called a \i{data script}, and each
  unspent output has a (possibly empty) data script associated with
  it.  The introduction of the data script increases the expressivity
  of the model considerably. For example, one can use the datascript
  to propagate state between transactions, and this can be used to
  give a contract the structure of a finite state machine; the fact
  that the datascript is part of the output and not the transaction
  means that the state can change without the transaction changing,
  which makes it easier to have an ``identity'' for an ongoing
  contract. \red{Clarify this.}
  
\end{itemize}

% \todojm{Jann: The validity interval is what makes it possible to know the exact
%   parameters to the validation process in advance, before submitting
%   the transaction. When a transaction is submitted, and before it is
%   validated, it enters a queue of pending transactions where it
%   remains until the earlier transactions have been validated. The
%   length of the queue depends on the load of the network, and
%   therefore it is hard to predict the exact slot number when a given
%   transaction will be validated. If validator scripts were able to
%   query the current slot number then the validation result would be
%   non-deterministic (imagine a script that succeeds only if the
%   current slot number is even). Non-deterministic evaluation results
%   make it hard to determine precisely the cost of running the script.

%   By saying that the only notion of time available to validator
%   scripts is the validity interval we solve the problem of
%   non-deterministic script validation. The validity interval is picked
%   by the author of the transaction, and therefore we are guaranteed to
%   get exactly the same result (pass/fail and gas cost) when running the
%   script off-chain, on our own computer, that we get when the script
%   is run on-chain, by a core node.
% }


The information specified by the type $\info$ is the only way for a
validator script to see beyond its own input-output pair and get
information about the transaction that it is part of, and about the
blockchain. This has two implications. First, for any definition of
$\info$ there should be a map $\sigma : \mathsf{Ledger} \times
\mathsf{Transaction} \times \mathsf{Input} \rightarrow
\script$ that generates a script with an \info{} value from the
ledger, the current transaction, and the input that is being
validated. Second, by varying $\info$ -- and hence the information
available to validator scripts -- we can directly change the kinds of
contracts that can be expressed in the EUTXO model. For example, if we
decide that $\info = ()$, the unit type, then our validator scripts would
not get any data about the wider transaction at all. In this setting
even our crowdfunding campaign would be impossible to write because it
requires the script to know the total value of all contributions, and
hence the total value of all inputs to the transaction.  On the other
hand, if $\info$ is too large (for example, if it requires searching far
back in the history of the chain), then it could be expensive to
calculate.  Parameterising things over $\info$ allows us to explore these
sorts of issues in a unified way.

At the ledger level, validator scripts now have the type
$$
\script \times \script \times \script \rightarrow \B
$$
At the Plutus level in Cardano, each script will have a Plutus type
and the types will have to fit the types expected by the validator.

\paragraph{$\info$ in Cardano.}
In our current implementation the $\info$ type contains the following
information for a transaction $T$:
\begin{itemize}
  
\item  The validity interval of $T$.
\item The hash of $T$.
\item For every input of $T$, its value and the hashes of its
  validator, data, and redeemer scripts.
\item For every output of $T$, its value and the hash of its validator and
  data script.
\item The sum of the values of all unspent outputs (of the current
  blockchain without $T$) which are locked by the validator script
       currently being executed.
\end{itemize}

\todokwxm{This is copied directly from
  \s{https://github.com/input-output-hk/plutus/tree/master/docs/extended-utxo},
  but Michael points out re the last item that:}

\todompj{This isn't how the crowdfunding example works. The condition
  isn't ``globally, the outputs locked by this validator exceed the
  threshold'', it is ``in the inputs of this transaction, the outputs
  locked by this validator exceed the threshold''. So you have to spend
  them all to ``prove'' that you've exceeded the threshold, you can't
  claim them individually.}

\todokwxm{... so we should pin down exactly what's required.}

\subsection{A Formal Description of the EUTXO-1 Model}
\label{section:eutxo-spec}

In this section we give a formal description of the EUTXO-1 model.  The
description is given in a straightforward set-theoretic form, which
(a) admits an almost direct translation into Haskell, and (b) should
easily be amenable to mechanical formalisation.  This will potentially
allow us to argue formally about smart contracts and to develop tools
for automatic contract analysis.

The definitions in this section are essentially the definitions of
UTXO-based cryptocurrencies with scripts from
\citep{Zahnentferner18-UTxO}, with the addition of the new features
mentioned above: the validity interval, the data script, and the
state-information function $\sigma$.

Figure~\ref{fig:eutxo-1-types} lists the types which
describe transactions in the basic EUTXO model.


%%
\begin{ruledfigure}{H}
  \[
  \begin{arraydefs}{rll}
    
    \s{Output } &= (&\addr: \s{Address},\\
    && \i{value}: \qtytype,\\
    &&  \i{datascript}: \s{Script})\\
    \\
    \s{OutputRef } &= (&\i{id}: \s{TxId}, \idx: \s{Int})\\
    \\
    \s{Input } & = (&\i{outputRef}: \s{OutputRef},\\
                 && \i{validator}: \s{Script},\\
                 && \i{redeemer}: \s{Script})\\
     \\
     \eutxotx\s{ } &= (&\inputs: \FinSet{\s{Input}},\\
     &&\outputs: \List{\s{Output}},\\
     &&\i{validityInterval}: \slotnum \times \slotnum,\\
     && \fee: \qtytype,\\
     &&\forge: \qtytype) \\
     \\
     \s{Ledger } &=&\!\List{\eutxotx}\\
  \end{arraydefs}
  \]
  \caption{Types the EUTXO-1 model}
  \label{fig:eutxo-1-types}
\end{ruledfigure}

\subsubsection{Remarks}
\paragraph{Inputs and outputs. } Note that a transaction has a
\textsf{Set} of inputs but a \textsf{List} of outputs. We use a list
because any subsequent transaction attempting to use an unspent output
$O$ as an input will have to be able to determine exactly where $O$
came from: thus each input of a transaction refers to the output which
it is trying to spend via an \s{OutputRef} which specifies the
transaction which produced the output and an index which says which
output of the transaction is required.

%\todompj{Can we just cite one of the previous descriptions for this?
%  Also: we should check this is still how they do it in the new ledger
%  specs.}

\paragraph{Scripts.}  Validator scripts are the things that determine
the spendability of outputs, and thus the validator for an output must
be created at the same time as the output is.  Conceptually the
validator is part of the output, so it may be rather unexpected that
Figure~\ref{fig:eutxo-1-types} defines the validator to be part of an
\textit{input}, with the output only containing a hash of the
validator.  The rationale for this is that a validator $V$ for an
output $O$ is not required until $O$ is actually spent, which may be
some time after $O$ was created.  Recall from~\ref{sec:costs} that the
cost of executing a transaction depends on the size of transaction,
including the associated scripts.  Thus the transaction that produces
the validator only pays for the size of a hash (32 bytes) and the
transaction that runs it pays for the full size of the script. This
strategy also helps to reduce on-chain storage requirements, since
validators can be stored off-chain until needed (and the presence of
the hash in the output can be used to check that the correct validator
is in fact being used when validation occurs), but unspent outputs
persist on-chain in the UTXO set until they are eventually spent.

This strategy is not applied to datascripts since, as the name would
suggest, we expect them to be small pieces of data (public keys, for
example) which would not incur large storage charges.
\todokwxm{Exactly what is the rationale for making the datascript
  part of the output and not just a hash?}

\paragraph{Special types of transaction.} In a practical
implementation it might be useful to include special cases for common
transaction types such as pay-to-pukbey transactions in order to
increase efficiency and decrease storage requirements (and hence
reduce fees).  These have been ommitted from this model because it
subsumes all of the other transaction types we're likely to encounter,
and also because it's difficult to give a definitive list of such
special cases.

\paragraph{Signing scripts.}
\ \\
\todokwxm{Do we have to say anything about who signs the various scripts,
  or is this specified elsewhere? If so, where?}
% Before a smart contract is uploaded to
% the blockchain, participants will examine it to satisfy themselves
% that they are happy with its terms.  In particular, they should be
% satisfied with the scripts involved in validation.  However, these
% scripts are run on-chain, and the question arises of how one knows
% that the scripts that run on-chain are the ones that were examined
% beforehand.  This is dealt with by having users digitally sign the
% scripts, with the signatures being verified prior to on-chain
% execution.  In the EUTXO-1 model, the validator and datascript are
% signed by the producer of an output, and the redeemer is signed by the
% consumer.  The details of this are outside the scope of this document.
% \todokwxm{So where are the details actually specified? Also, the
%   producer and consumer aren't people, they're transactions.  There
%   may not be any people involved at all.}
% \todokwxm{Find a reference and cite it.}


\paragraph{Ledger structure.} We model a ledger as a simple
list of transactions: a real blockchain ledger will be more complex
than this, but the only property that we really require is that
transactions in the ledger have some kind of address which allows them
to be uniquely identified and retrieved.

\subsubsection{Validity}
\label{sec:eutxo-1-validity}
A number of conditions must be satisfied in order for a transaction
$t$ to be considered valid with respect to a ledger $\lambda$ and a
given blockchain-information generating function $\sigma :
\mathsf{Ledger} \times \mathsf{Transaction} \times \mathsf{Input}
\rightarrow \mathsf{Script}$.  In order to define these we require a
couple of auxiliary functions.  Firstly,
following~\citep{Zahnentferner18-UTxO} we define

$$
  \txunspent : \eutxotx \rightarrow \FinSet{\s{OutputRef}}
  $$
% 
  by
% 
$$
\txunspent(t) = \{(id,1), \ldots, (\mathit{id},\left|t.outputs\right|)\}
$$
\todokwxm{It might be argued that we should index the outputs starting at 0.
  However this would require an inconvenient $-1$ at the end, and it would
  be ugly if the transaction had no outputs.}
%
\noindent where $\mathit{id}$ is the identifier of the current transaction, and
\todokwxm{Where does the transaction id come from?}
%
\[
  \unspent : \mathsf{Ledger} \rightarrow \FinSet{\s{OutputRef}}
\]
%
by
% 
\begin{align*}
   \unspent([]) &=\emptymap \\
   \unspent(t::\lambda) &= (\unspent(\lambda) \setminus t.\inputs) \cup \txunspent(t).
\end{align*}

\noindent Note that for a completed transaction $t$, $t.\inputs$ is
the set of previously unspent outputs which were spent by $t$.

\medskip
\noindent Given a ledger $\lambda$ and a transaction id $\id$, we
denote by $\lambda\langle\id\rangle$ the unique transaction $T$ in
$\lambda$ with $T.\txid = \id$, if it exists. In our abstract model
where $\lambda$ consists of a list of transactions it would suffice to
take $id$ to be the position of $T$ in $\lambda$, but in an
implementation we would probably have $id = T^{\#}$.

\medskip
\noindent Now given an input $i$ to some transaction in a ledger
$\lambda$ we define
$$
\getvalue(i,\lambda) = \lambda\langle i.\outputref.\txid \rangle.\outputs[i.\outputref.\idx].\val
$$
This function simply returns the value of the input.

\bigskip

\noindent We can now define what it means for a transaction to be
valid for a ledger: see Figure~\ref{fig:eutxo-1-validity}.  Our
definition combines Definitions 6 and 14 from
\citep{Zahnentferner18-UTxO}, differing from the latter in condition
\ref{rule:all-inputs-validate}.


\begin{ruledfigure}{H}
\begin{enumerate}
    \item \label{rule:all-inputs-refer-to-unspent-outputs} \textbf{All
      inputs refer to unspent outputs:}
      \[
        t.\inputs \subseteq \unspent(\lambda).
      \]
    \item\label{rule:forging} \textbf{Forging:}
      \begin{center}
        \parbox{0.8\textwidth}{ A transaction with a non-zero \forge{}
          field is only valid if the ledger $\lambda$ is empty (that
          is, if it is the initial transaction).}
    \end{center}
      
    \item \label{rule:value-is-preserved} \textbf{Value is preserved}:
    \[
      t.\forge + \sum_{i \in t.\inputs} \getvalue(i, \lambda) = t.\fee + \sum_{o \in t.\outputs} o.\val.
    \]
    \item \label{rule:no-double-spending} \textbf{No output is double spent:}
    \[
     \textrm{If } i_1, i_2 \in t.\inputs \textrm{ and }  i_1.\mathit{outputRef} = i_2.\mathit{outputRef}
     \textrm{ then } i_1 = i_2.
    \]
    \item\label{rule:all-inputs-validate} \textbf{All inputs validate:}
    \[
    \textrm{For all } i \in t.\inputs,\enspace \llbracket
    i.\validator(\txout(i, \lambda).\datascript,i.\redeemer, \sigma(\lambda, t, i)) \rrbracket = \true.
      \]
    \item\label{rule:validator-scripts-hash} \textbf{Validator scripts hash to their output addresses:}
    \[
      \textrm{For all } i \in t.\inputs,\enspace i.\validator^{\#} = \txout(i, \lambda).\addr.
    \]
\end{enumerate}
\caption{$\sigma$-validity of a transaction $t$ in the EUTXO-1 model}
\label{fig:eutxo-1-validity}
\end{ruledfigure}

\noindent We say that a ledger $\lambda$ is \textit{$\sigma$-valid}
if either $\lambda$ is empty or $\lambda$ is of the form $t::\lambda^{\prime}$
with $\lambda^{\prime}$ $\sigma$-valid and $t$ $\sigma$-valid for $\lambda^{\prime}$.

In practice, $\sigma$-validity imposes a limit on the size
of the $\mathsf{Script}$ values of the $\validator$, $\redeemer$ and
$\datascript$ fields and the result of $\sigma$. The validation of a
single transaction must take place within one slot, so the evaluation
of $\llbracket ~ \rrbracket$ cannot take longer than one slot
(approximately twenty seconds on the Cardano blockchain).

By parameterising transaction validity by the blockchain information
generating function $\sigma$, we obtain an equivalence class of
transactions that are indistinguishable by validator scripts with
access to the result of $\sigma$.

\subsection{Examples}
\todokwxm{It would be good to have one or more examples here, especially one
  demonstrating what the separation of redeemer and datascript does.}

\todojm{Maybe the guessing game would be a good example. Its data
  script is the hash of the secret, and the redeemer is the guess in
  cleartext. It illustrates that data and redeemer scripts are created
  at different points in time.}

\newpage
\section{EUTXO-2: multicurrency support}
\label{sec:eutxo-2}
We now extend the EUTXO model to allow transactions to deal with
multiple currencies.  We assume that the underlying blockchain has a
unique \textit{native currency} which is the fundamental currency used
for paying fees, for example.  The native currency of the Cardano
blockchain is Ada.

\smallskip
In addition to the native currency, the EUTXO-2 model allows an
unlimited number of other \textit{custom currencies}, possibly
user-defined.  Each custom currency has a unique identifier; the
native currency is handled separately and has no identifier.  To
support custom currencies we introduce three new types: see
Figure~\ref{fig:more-basic-types}.

\smallskip
\todokwxm{Jann says ``Maybe we should mention the native currency
  here, but not write it down in the spec - it's only needed for the
  fee, we don't have a cost model for EUTXO yet, and by ignoring the
  native currency in the definitions we could delete the forge, fee
  and value fields''.  I'm in two minds about this.  Making Ada just the
  same as custom currencies feels a little unnatural, but maybe that's
  just me. Also, I don't think we have fees for custom currencies, so
  that does differentiate the native currency from the others.}

\newcommand{\emspace}{\hspace{1em}}
\newcommand{\espace}{\hspace{1en}}

\begin{ruledfigure}{H}
  \center{
  \begin{tabular}{rll}
  \s{CurrencyID}&: & an identifier for a custom currency. This is an alias
  for the \s{Address} type\\
  & & from Figure~\ref{fig:basic-types}.\\
  \qtymap&:  & \Map{\s{CurrencyID}}{\qtytype}, ie a map from \s{CurrencyID}s to quantities of the\\
  & &   corresponding currencies (represented using the non-negative \qtytype{} type).\\
  & & This allows an output to contain quantities of multiple custom currencies\\
  & & in addition to some quantity (possibly zero) of the native currency.\\

  \s{$\qtymap^{\pm}$} &: &\Map{\s{CurrencyID}}{\qtytypepm}.  This is like \qtymap{}, but currency quantities\\
  & &  may be either positive or negative.
  \end{tabular}
  }
  \caption{Extra basic types for the EUTXO-2 model}
  \label{fig:more-basic-types}
\end{ruledfigure}

\begin{ruledfigure}{H}
  \[
  \begin{arraydefs}{rll}
    \s{Output}_2 &= (&\addr: \s{Address},\\
    && \val: \qtytype\\
    && \customvals: \qtymap,\\
    && \i{datascript}: \s{Script})\\
    \\
    \s{OutputRef}_2 &= (&\i{id}: \s{TxId}, \idx: \s{Int})\\
    \\
    \s{Input}_2 &= (& \i{outputRef}: \sf{OutputRef}_2,\\
                     && \i{validator}: \s{Script},\\
                     & & \i{redeemer}: \s{Script})\\
\\
    \eutxotx_2 &= ( &\inputs: \FinSet{\s{Input}_2},\\
    &&\outputs: \List{\s{Output}_2},\\
    &&\i{validityInterval}: \slotnum \times \slotnum,\\
    &&\fee: \qtytype,\\
    &&\forge: \qtytype,\\
    &&\customforge: \qtymap^{\pm})\\
    \\
    \s{Ledger}_2 &=&\!\List{\eutxotx_2}\\
\end{arraydefs}
  \]
  \caption{Types for the EUTXO-2 model}
  \label{fig:eutxo-2-types}
\end{ruledfigure}

\noindent The changes to the basic EUTXO-1 types are now quite simple: see Figure~\ref{fig:eutxo-2-types}.
We add a \qtymap{} to the \s{Output} type, representing values of custom
currencies; we also add a \customforge{} field of type
$\qtymap^{\pm}$ to transactions to allow the creation and
destruction of tokens in custom currencies; the supply of a custom
currency can be reduced by forging a negative amount of that currency.

The fields \val, \fee, and \forge{} all represent quantities of the
native currency, as in the EUTXO-1 model.

\bigskip
\noindent The validity conditions must also be updated to take account
of multiple currencies: Figure~\ref{fig:eutxo-2-validity} contains
the details.  However, there is a subtlety which we must deal with first.

\paragraph{Zero quantities.}  We require currency quantities to be
non-negative, but we do not insist that they are strictly positive.
Thus an output can contain 0 units of any currency, including the
native currency.  With the introduction of custom currencies, this
presents a problem: should we distinguish between a $\qtymap$ which
explicitly has 0 units of some currency $C$, and one which does not
mention $C$ at all?  The answer depends on the context: if we are
adding together quantities of currencies then it is sensible to regard
the two as being ``the same'', but we may wish to distinguish the two
when talking about outputs for instance, since an output whose
quantity map is $Q_1 = \{(A,0), (B,0), (C,5)\}$ will take up more
space than one with quantity map is $Q_2 = \{(C,5)\}$.  In
Figure~\ref{fig:more-basic-types} we defined equality pointwise, so
$Q_1$ and $Q_2$ are not equal even though they arguably represent the
same amounts of currency.  To deal with this we can use an equivalence
relation which considers two quantity maps to be equivalent if they
differ only by zero values. Using this equivalence relation directly
is somewhat tricky, but fortunately each equivalence class has a
canonical representative, one which has no zero values at all. This
motivates the following definition: for a $\qtymap\ Q$ we define a
function $\mu$ which minimises $Q$ by discarding entries with value
zero:

$$
\mu(Q) = \{(k,v) \in Q: k \ne 0\}
$$

\todokwxm{Maybe this is getting out of hand.  Another way to do this
  would be to define a function $\kappa: K \times \Map{K}{V} \rightarrow V$ with
  $\kappa(k,m) = m[k]$ if $k \in \dom m$ and $\kappa(k) = 0$
  otherwise.  For validity we'd then have to assert that $\kappa(k)$
  balances up for every $k$ in the union of the domains of the various
  maps involved.  This could get typographically messy.}
  
We use the definitions of \unspent{}  and
\getvalue{} from Section~\ref{sec:eutxo-1-validity} unchanged,
but we also require a function to retrieve the values of
custom currencies from inputs. If $t$ is a transaction in a ledger
$\lambda$ and $i \in t.\inputs$, then we define
$$
\s{getCustomValues}(i,\lambda) = \lambda\langle i.\outputref.\txid
\rangle.\outputs[i.\outputref.\idx].\customvals
$$


\begin{ruledfigure}{H}
  \begin{enumerate}
    \item \label{rule:all-inputs-refer-to-unspent-outputs-2} \textbf{All
      inputs refer to unspent outputs:}
      \[
        t.\inputs \subseteq \unspent(\lambda).
      \]
    \item\textbf{Forging:}\\\\
      \begin{minipage}{0.85\textwidth}
          \begin{enumerate}
          \item
              A transaction with a non-zero \forge{} field is only
            valid if the ledger $\lambda$ is empty
            (that is, if it is the initial
            transaction). 
          \item \label{rule:custom-forge}
            A transaction with a non-empty \customforge{} field is
            only valid if for every key $h$ in $t.\customforge$, there
            exists $i \in t.\inputs$ and $(a,v,d) \in i.\outputs$ with
            $a =h$; in other words, some input must spend an output
            whose address is $h$.
          \end{enumerate}
          \end{minipage}
    \item \textbf{Value are preserved}\\
      \begin{minipage}{0.85\textwidth}
          \begin{enumerate}
          \item\label{rule:native-value-is-preserved-2}
            \[
            t.\forge + \sum_{i \in t.\inputs} \getvalue(i, \lambda) = t.\fee + \sum_{o \in t.\outputs} o.\val
            \]

          \item\label{rule:custom-values-are-preserved-2}
            \[
              \mu\left(t.\customforge\, + \sum_{i \in t.\inputs} \s{getCustomValues}(i, \lambda)\right) =
              \mu\left(\sum_{o \in t.\outputs} o.\customvals\right)
            \]
          \end{enumerate}
          
          \end{minipage}
    \item \label{rule:no-double-spending-2} \textbf{No output is double spent:}
    \[
     \textrm{If } i_1, i_2 \in t.\inputs \textrm{ and }  i_1.\mathit{outputRef} = i_2.\mathit{outputRef}
     \textrm{ then } i_1 = i_2.
    \]
    \item\label{rule:all-inputs-validate-2} \textbf{All inputs validate:}
    \[
    \textrm{For all } i \in t.\inputs,\enspace \llbracket
    i.\validator(\txout(i,
    \lambda).\datascript,i.\redeemer, \sigma(\lambda, t, i))
    \rrbracket = \true.
      \]
    \item\label{rule:validator-scripts-hash-2} \textbf{Validator scripts hash to their output addresses:}
    \[
      \textrm{For all } i \in t.\inputs,\enspace i.\validator^{\#} = \txout(i, \lambda).\addr.
    \]
  \end{enumerate}
  \caption{$\sigma$-validity of a transaction $t$ in the EUTXO-2 model}
  \label{fig:eutxo-2-validity}

\end{ruledfigure}

\noindent If any of the indexing operations here fail then the
transaction is invalid.

\paragraph{Note.} In rule~\ref{rule:custom-values-are-preserved-2}, $+$ and $\sum$ are the
sum of maps as defined in Figure~\ref{fig:basic-notation}. Essentially
we require that the quantities of each of the individual custom currencies
involved in the transaction are preserved.  Recall that values in
$\customforge$ can be negative whereas values in outputs must
be non-negative.  Thus rule~\ref{rule:custom-values-are-preserved-2} implies
that a transaction is invalid if it attempts to destroy more of a currency
than is actually available in its inputs.


\paragraph{Monetary policies for custom currencies.}
The new \textbf{Forging}
rule enables custom currencies to implement their own monetary
policies: for example, one might wish to place some limit on the
amount of a currency that can be forged, or restrict the creation of
the currency to owners of particular public keys.

The idea is that a custom currency has a monetary policy which is
defined by some script $H$, and the hash $h = H^{\#}$ is used as the
identifier of the currency.

Whenever a new quantity of
the currency is forged, rules~\ref{rule:custom-forge},
\ref{rule:all-inputs-validate-2}, and
\ref{rule:validator-scripts-hash-2} imply that $H$ must be executed;
$H$ is provided with the \forge{} field of the transaction via
$\sigma$, and so it knows how much of the currency is to be forged and
can respond appropriately.

The advantage of this scheme is that custom currencies can be handled
entirely within the smart contract system, without the need to
introduce any extra blockchain infrastructure such as a central
registry of custom currencies.

In practice some refinement of this scheme will be required in order
to (a) allow re-use of a monetary policy for different currencies, and
(b) prevent unauthorised forging of a currency. To deal with (a) we
can make the validator script unique by including a nonce. This still
doesn't prevent unauthorised people from using the script $H$ to
produce currency, but this can be prevented by, for instance,
embedding a reference to an unspent output in the script and
requiring that the currency can only be forged if the referenced
output is spent at the same time, so it can only be forged once.

\smallskip
\todokwxm{Is this exactly what we want?  I think that gives you a
  single opportunity to forge the currency, and then you can't make
  any more. I suppose that you could restrict the ability to forge to
  a particular individual by requiring them to provide something
  signed by their private key when they want to create new money.
  Also, is this a case where an output of value zero would be useful?}

\smallskip
\todokwxm{The use of the term ``forging'' is a bit confusing here,
  since it also means ``counterfeiting''.}
  
% \todojm{I think there are two different concerns:
%  (1) Using the same monetary policy multiple times;
%   (2) Preventing unauthorised forging of a currency.

% The "referencing an unspent output" trick accomplishes
%   both but is mainly aimed at (2). You could also achieve (1) by
%   embedding any kind of random data in the validator script, like a
%   nonce.
% }

\subsection{Examples}
\subsubsection{Non-fungible tokens}
A non-fungible token (NFT) is a unique object which can be transferred
to another user, but not duplicated.  NFTs have proven useful in a
number of blockchain applications (see~\citep{ERC-721} for example);
for example, they can represent ownership of some object in a game.

\medskip

An important example that motivated the design EUTXO-2 model was the
idea of implementing NFTs as currencies with a supply of 1. If NFTs are
used to represent different stakes in a contract, then a single
instance of a contract requires multiple NFTs, so it is crucial that
currency creation is as lightweight as possible. In our proposal, each
NFT adds a single pay-to-script transaction output to the initial
transaction of the contract, and does not otherwise put a burden on
core nodes.

\medskip 
Here is an example of a validator script that implements a
non-fungible token using our proposal.  This is expressed as a Haskell
function, and is very similar to the Haskell code that would be used
in in a Plutus contract.

\begin{lstlisting}
data NFT = NFT { nftName :: String, nftBootstrapTxOut :: TxOutput }

 nftValidator :: NFT -> Data -> Redeemer -> PendingTx -> ()
 nftValidator (NFT nm txout) _ _ ptx =
  let con1 = ptx `spends` txout
      con2 = ptx `forges` 1 (ownAddress ptx)
  in if con1 && con2 then () else error
\end{lstlisting}

\noindent The function \verb|spends :: PendingTx -> TxOut -> Bool| checks if the
pending transaction spends the output \verb|txout| (uniquely
identified by transaction hash and the index into its list of
outputs). The function
\verb|forges :: PendingTx -> Int -> ByteString -> Bool|
checks if the
pending transaction forges the given amount of the
address. \verb|Data| and \verb|Redeemer| are the types (in Plutus
Core) of the data and redeemer scripts, which we ignore here (so
effectively both are the unit type \verb|()|). For an actual currency we could use the
data script to keep track of the current supply.

Note that the validator script for a given NFT definition is given by
\verb|nftValidator nft|, so its address is the hash of
\verb|nftValidator nft|.

The key is the \verb|nftBootstrapTxOut| field. The condition
\verb|con1| ensures that there is only a single transaction that can
forge a value of the NFT, because \verb|txout| can only be spent once
thanks to the no-double-spending rule. Condition \verb|con2| ensures
that only a single token of the currency is created, effectively
making it non-fungible.

It is of course possible to produce multiple script outputs to the
same address of \verb|nftValidator nft| but only one of them can be spent,
because the referenced tx output can only be spent once.

Note that creating an NFT with this contract requires three
transactions: One for the nftBootstrapTxOut transaction output, one
for producing an output to the NFT address, and one that forges the
token, consuming the output from the NFT address and the
\verb|nftBootstrapTxOut|. Note that the bootstrap transaction output can be
any unspent transaction output owned by us, in particular it can be
the same output that pays the fees for the forging transaction.

\subsubsection{Another example?}
  
\section{EUTXO-3: Non-fungible tokens}
\label{sec:eutxo-3}

We have shown above how NFTs can be implemented in the EUTXO-2 model,
but this method is arguably a little heavyweight.  In this section we
describe the EUTXO-3 model which provides much more lightweight
support of NFTs.

The basic idea is to change the \qtymap{} type used in EUTXO-2.  We
replace it with a type \tokenmap{} which will allow us to support both
fungible and non-fungible tokens with minimal changes to the
other ledger rules: see Figure~\ref{fig:eutxo-3-types}.

\newcommand{\mprime}{m^{\prime}}

\begin{ruledfigure}{H}
  \begin{align*}
  \tokenmap &= \Map{\s{CurrencyId}}{\Map{\s{Token}}{\s{Quantity}}}\\
  \tokenmap^{\pm} &= \Map{\s{CurrencyId}}{\Map{\s{Token}}{\s{Quantity}^{\pm}}}\\
  \end{align*}
  where
  \begin{itemize}
\item \s{CurrencyId} is the type we are using to identify currencies, as in Figure~\ref{fig:eutxo-2-types}.
\item \s{Token} is a type consisting of identifiers for individual
  tokens.  These will probably be hashes in practice.
% \item \s{Quantity} is a type used to measure the amount of a token
%   that is present, probably the type of natural numbers.  
\end{itemize}
\noindent We also require an extended minimisation operator for the \s{TokenMap} type.
$$
\mu_2(m) = \mu(\{(k,v) \in m: \mu(k) \ne \emptymap\})
$$
  \caption{ \tokenmap{} type for EUTXO-3}
  \label{fig:eutxo-3-types}
\end{ruledfigure}

\noindent Note that the comparison and addition operations for maps
defined in Figure~\ref{fig:basic-notation} carry over to the type
\tokenmap.  If we put $\mprime = \mu_2(m)$ then it is guaranteed that
there is no \s{CurrencyId} $c \in \dom \mprime$ with
$\mprime[c] = \emptymap$, and if $c \in \dom \mprime$, then there is
no \s{Token} $t \in \dom \mprime[c]$ with $\mprime[c][t] = 0$.

\medskip
\noindent We define EUTXO-3 by the same types and validity rules as
EUTXO-2, except that we replace \qtymap{} by \tokenmap{} and $\mu$ by
$\mu_2$ everywhere.

\medskip
\todokwxm{Do we want to include the full rules for EUTXO-3 here, or
  perhaps in an appendix?  If this is the model that's
  actually going to be used then we should probably have a
  self-contained description for reference purposes.}
\subsection{Implications}
This model allows us to implement fungible (normal) and non-fungible
token currencies, as well as ``mixed states'':
\begin{itemize}
\item Fungible token currencies are implemented by only ever issuing
  currencies with a single \s{Token}.
\item Non-fungible token currencies are implemented by only ever
  issuing single \s{Quantity}s of many unique \s{Token}s.
\item Note that there is nothing in this model which enforces
  uniqueness: having multiples of a single \s{Token} merely means that
  those can be used fungibly. If a currency wants to make sure it only
  issues unique tokens it must track this itself.  These ``mixed'' token
  currencies can have many \s{Token}s, but these can have more than unit
  \s{Quantity}s in circulation.  These can be useful to model distinct
  categories of thing where there are fungible quantities within
  those, for example share classes. \red{Eh?}
\end{itemize}

\paragraph{Performance.}
\red{I'm just making random stuff up here.}
The UTXO-2 and UTXO-3 models will lose some efficiency in comparison
to the UTXO-1 model, simply because the data structures are more
complicated.  This would even apply to transactions which only involve
to native currency, since it would be necessary to check whether the
\qtymap{} or \tokenmap{} contains anything that needs to be processed.  If this is
a concern then one could implement a model with two types of
transaction, essentially just the disjoint union of the EUTXO-1 and
EUTXO-2 or EUTXO-3 transaction types. A simple case distinction at the
start of a transaction could then select either a fast
native-currency-only computation or a slower multicurrency computation.
This would be harder to maintain though.

\smallskip
A more significant cost may be that we can no longer use \verb|{-# UNPACK #-}|
when our Quantity type stops being a simple combination of wrappers
and products around primitives, but this is again an issue with any
multi-currency proposal.

\todojm{I wonder if the argument that most of the time it takes to
  validate a transaction is spent doing cryptography things applies
  here as well.}
  
\subsection{Further generalisations}
We have assumed that our basic \qtytype{} type is the type of natural
numbers.  However, the models mostly carry over to the case where
\qtytype{} is an arbitrary abelian group.\footnote{In fact, this even
  works for non-abelian groups, but then things get tricky.  If we
  forge $a$ units of currency, then forge $b$ units, then destroy $a$
  units again, we're left with $aba^{-1}$ (or $a+b-a$) units, which
  won't be equal to $b$ in general: if your currency consists of
  elements of the free group on $\{a,b\}$ then things could get pretty
  interesting.  Similar things may happen if we need to split up an
  output to get some change. In the monoid case, we might get
  unexpected cancellation as well: $a+b=0$, but $a,b \ne 0$: consider
  $\mathbb{Z}_{24}$ or something. I suppose doing things like this
  would let us write weird papers to impress the cryptocurrency
  community. It could still be useful for something
  though...}\textsuperscript{,}%
\footnote{We mentioned earlier that the functor $\Map{K}{-}$ preserves
  the property of being a monoid; however, in general it does not
  preserve the property of being a group, abelian or otherwise.  Let
  $K=\{X,Y\}$ and consider the map $m = \{(X,1)\} \in \Map{K}{\Z}$:
  for every map $n$, we have $X \in \dom (m+n)$, so we cannot have
  $m+n = \emptymap$, the identity element of $\Map{K}{\Z}$. However,
  if $M$ is a monoid then the relation $m \equiv n$ if
  $\mu(m) = \mu(n)$ (ie, two maps are equivalent if they only differ by
  elements mapping to 0) is a congruence on the monoid $\Map{K}{M}$,
  and the quotient \textit{is} a group.}

    
  We can even replace \qtytype{} with a commutative
  monoid as long as we relinquish the ability to destroy quantities of
  currencies (since we can no longer subtract in general). Whether
  these generalisations are useful in practice remains to be seen.





\section{What else do we need to worry about?}
\begin{itemize}

\item Should we mention the problem of \textbf{validating the next data script}?
%% https://github.com/input-output-hk/plutus/issues/426

\item Sometimes I'm saying ``datascript'' and at other times ``data script''.
  Maybe we should try to be consistent about this.
  
\item Do we need to worry about who signs the various scripts, or is that
  something the wallet deals with?

\item Who's responsible for looking after the scripts, and where are they kept?
  Presumably scripts will be stored in the chain, but how do they get there?

\item Maybe we should make this more consistent with the ledger specification.
\end{itemize}
  



%% \section{More stuff}

%% When $T$ wants to unlock $O$,
%% the redeemer for the appropriate input of $T$ is applied to three arguments:
%% \begin{itemize}
%% \item A \textit{datascript}, provided by the producer $S$.
%% \item A \textit{validator} script, provided by the producer $S$. 
%% \item A \textit{redeemer} script, provided by the consumer $T$.  
%% \end{itemize}

%% \blue{The GitHub page on Extended UTXO at
%%   https://github.com/input-output-hk/plutus/tree/master/docs/extended-utxo
%%   says ``The validator script must be submitted as part of the
%%   consuming transaction's input, but its content is determined by the
%%   producing transaction.''. I'm finding this difficult to explain.}


%%  When $T$ wants to unlock $O$, the validator for $O$ of $T$ is applied
%%  to three arguments: the redeemer script, the data script, and
%%  information (supplied by the slot leader) about the current
%%  transaction and the state of the blockchain, described by some type
%%  $P$.

%% If the result evaluates to anything other than the Plutus Core
%% \texttt{error} term then validation succeeds and the output is unlocked.

%% Every input of a transaction has an associated redeemer and for the
%% transaction to proceed the redemption of every input must be validated
%% successfully.

%% In the current Plutus implementation, the type $P$ contains the
%% following information:

%% \begin{itemize}
%% \item The validity interval of $T$.
%% \item The hash of $T$.
%% \item For every input of $T$, its value and the hashes of its
%%   validator, data, and redeemer scripts (if the input refers to an output
%%   locked by a script) or the public key and signature (if it refers to
%%   an output locked by a public key)
%% \item For every output of $T$, its value and the hash of its validator
%%   and data script, or the public key that owns it
%% %\item The sum of the values of all unspent outputs (of the current
%%   %blockchain without $T$) which are locked by $O$'s validator script.
%% \end{itemize}

%% The expressivity of contracts depends on the choice of $P$, and $P$
%% may be extended in future to include more information if required.

%% \subsection{Extended UTXO and Standard UTXO}

%% \blue{This is really feeble.}

%% Our extended version of the UTXO model genuinely does offer more than
%% the standard version, as implemented by Bitcoin.

%% %% Duncan: Perhaps one approach to explaining this is to start by
%% %% noting that classically we don't think of data values flowing along
%% %% the edges of the utxo graph, but that this is very useful for
%% %% scripts.

%% \subsubsection{Datascripts}
%% \label{sec:datascripts}
%% Datascripts allow us to separate information about the state
%% of the transaction from the validator script, meaning that we can
%% have situations such as a single validator which refunds outputs
%% to addresses contained in the data script (as in the crowdfunding
%% example).  In the Bitcoin model, each output would require a
%% specialised validator, increasing memory usage.
    
%% \subsubsection{Constraining outputs}
%% \label{sec:constraining-outputs}
%% The fact that the validator receives information about the
%% state of the chain allows us to do things like restricting where
%% the output of a transaction goes, so it's possible to construct
%% graphs of transactions where values are constrained to flow down
%% allowed paths. In the classic model if you can validate at all you
%% can always take the money and keep it.

%% \subsubsection{Deterministic Scripts}
%% \label{sec:deterministic-scripts}
%% When core nodes validate an input spending from a pay-to-script
%% address, they supply two pieces of information to the validator
%% script: The structure of the transaction that is being validated (in
%% form of a list of hashes and signatures), and an indication of the
%% current time (expressed in terms of the slot number: see
%% \ref{subsection:blockchains}).  After a transaction has been submitted
%% to the blockchain, it may linger in the transaction pool for some time
%% before being processed by a core node. Allowing validator scripts to
%% know the exact slot number of their validation would therefore make
%% them non-deterministic, in the sense that their result depends on
%% information that is not known at the time the transaction is
%% submitted.  Non-determinism is a problem because it makes it
%% impossible to accurately compute the gas cost of consuming a
%% pay-to-script output, running counter to our stated goals of
%% measurable and predictable resource consumption.

%% In the Extended UTXO model we add a \emph{validity interval}, an
%% interval of slots, to each transaction's metadata. Core nodes only
%% attempt to validate transactions whose validity interval contains the
%% current slot. When a scripted transaction input is validated, the
%% transaction's validity interval is passed to the validator script,
%% providing information about the current time. Since the validity
%% interval is known at the time the transaction is submitted to the
%% chain, transaction validation in Plutus is completely deterministic.

%% As a result, the exact amount of gas that is required to run the script can be 
%% calculated in advance (by running it), and users do not risk being surprised by 
%% failed validations that still incur fees.    


\bibliographystyle{plainnat} %% ... or whatever
\bibliography{extended-utxo-specification}


\end{document}
