%% Extended UTXO Specification

\newcommand\version{-1}

\title{Formal Specification of the Extended UTXO Model\\--- \\
  \red{\textsf{DRAFT}}}

\pagestyle{plain}
\date{14th June 2019}
\author{}

\documentclass[a4paper]{article}

\usepackage{natbib}

\usepackage{blindtext, graphicx}
\usepackage{url}
%\usepackage{cleveref}
%\usepackage{hyperref}

% *** MATHS PACKAGES ***
%
\usepackage[cmex10]{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{amsthm}

% *** ALIGNMENT PACKAGES ***
%
\usepackage{array}
\usepackage{float}  %% Try to improve placement of figures.  Doesn't work well with subcaption package.
\usepackage{subcaption}
\usepackage{caption}

% Stuff for splitting figures over page breaks
%\DeclareCaptionLabelFormat{continued}{#1~#2 (Continued)}
%\captionsetup[ContinuedFloat]{labelformat=continued}

% correct bad hyphenation here
\hyphenation{}

\usepackage{subfiles}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{verbatim}
\usepackage{todonotes}

\newcommand{\todochak}[1]{\todo[inline,color=purple!40,author=chak]{#1}}
\newcommand{\todompj}[1]{\todo[inline,color=yellow!40,author=Michael]{#1}}
\newcommand{\todokwxm}[1]{\todo[inline,color=blue!20,author=kwxm]{#1}}
\newcommand{\todojm}[1]{\todo[inline,color=purple!40,author=Jann]{#1}}


%%% General Misc. Definitions

%% A version of ^{\prime} for use in text mode
\makeatletter
\DeclareTextCommand{\textprime}{\encodingdefault}{%
  \mbox{$\m@th'\kern-\scriptspace$}% 
}
\makeatother

\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\redfootnote}[1]{\red{\footnote{\red{#1}}}}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}
\newcommand{\bluefootnote}[1]{\blue{\footnote{\blue{#1}}}}

\renewcommand{\i}{\textit}  % Just to speed up typing: replace these in the final version
\renewcommand{\t}{\texttt}  % Just to speed up typing: replace these in the final version
\newcommand{\s}{\textsf}  % Just to speed up typing: replace these in the final version

\theoremstyle{definition}  %% This applies to all following \newtheorem items
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}

\newenvironment{arraydefs}[1]{\setlength{\arraycolsep}{0pt}\begin{array}{#1}}{\end{array}}
%
% This is just the array environment with the column separation set to 0.
% This is to enable us to get things like
%
%%   X = (field1: type1,
%         field2: type2,
%         ...
%
% without a space after the ')'. Unfortunately you have to manually insert a space
% at the end of the X so you don't get X=
% There's presumably a better way to do this.
%
% You can also use something like
%
%    \begin{tabular}{r@{ }l@{}l} ...
%
% but the spacing is arguably worse.


\newcommand\rfskip{7pt}
\newenvironment{ruledfigure}[1]{\begin{figure}[#1]\hrule\vspace{\rfskip}}{\vspace{\rfskip}\hrule\end{figure}}

\newcommand{\true}{\textsf{true}}
\newcommand{\false}{\textsf{false}}


\newcommand{\List}[1]{\ensuremath{\s{List}[#1]}}
\newcommand{\Set}[1]{\ensuremath{\s{Set}[#1]}}
\newcommand{\FinSet}[1]{\ensuremath{\s{FinSet}[#1]}}
\newcommand{\Map}[2]{\ensuremath{\s{Map}[#1,#2]}}
\newcommand{\dom}{\ensuremath{\mathop{\mathrm{dom}}}}

\newcommand{\script}{\ensuremath{\s{Script}}}
\newcommand{\ptx}{\ensuremath{\s{PendingTx}}}

%Macros for eutxo things.
\newcommand{\mi}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\txid}{\mi{txid}}
\newcommand{\idx}{\mi{index}}
\newcommand{\inputs}{\mi{inputs}}
\newcommand{\outputs}{\mi{outputs}}
\newcommand{\forge}{\mi{forge}}
\newcommand{\fee}{\mi{fee}}
\newcommand{\addr}{\mi{addr}}
\newcommand{\val}{\mi{value}}  %% \value is already defined
\newcommand{\nativeval}{\mi{nativeValue}}
\newcommand{\customvals}{\mi{customValues}}
\newcommand{\customforge}{\mi{customForge}}

\newcommand{\validator}{\mi{validator}}
\newcommand{\redeemer}{\mi{redeemer}}
\newcommand{\datascript}{\mi{datascript}}
\newcommand{\outputref}{\mi{outputRef}}
\newcommand{\txin}{\mi{in}}
\newcommand{\txout}{\mi{out}}
\newcommand{\id}{\mi{id}}
\newcommand{\getvalue}{\msf{getvalue}}

\newcommand{\msf}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\slotnum}{\msf{SlotNumber}}
\newcommand{\spent}{\msf{spentOutputs}}
\newcommand{\unspent}{\msf{unspentOutputs}}
\newcommand{\txunspent}{\msf{unspentTxOutputs}}
\newcommand{\eutxotx}{\msf{EUtxoTx}}

\newcommand{\qty}{\ensuremath{\s{Quantity}}}
\newcommand{\qtypm}{\ensuremath{\s{Quantity}^{\pm}}}
\newcommand{\newqtytype}{\ensuremath{\s{Quantity}^{\prime}}}
\newcommand{\token}{\ensuremath{\s{Token}}}

\newcommand{\qtymap}{\ensuremath{\s{QuantityMap}}}
\newcommand{\tokenmap}{\ensuremath{\s{TokenMap}}}

\newcommand\B{\ensuremath{\mathbb{B}}}
\newcommand\N{\ensuremath{\mathbb{N}}}
\newcommand\Z{\ensuremath{\mathbb{Z}}}

\newcommand{\emptymap}{\ensuremath{\{\}}}

\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  mathescape=true,
  escapeinside={|}{|}   %% Inside listings you can say things like |\textit{blah blah}|
}


%% ------------- Start of document ------------- %%

\begin{document}
\maketitle

\section{Introduction: The Extended UTXO Model}
\label{sec:intro}
The Cardano blockchain~\citep{Cardano, Cardano-ledger-spec} uses a
variant of the \textit{Unspent Transaction Output} (UTXO) model used
by Bitcoin.  Transactions consume \textit{unspent outputs} (UTXOs)
from previous transactions and produce new outputs which can be used
as inputs to later transactions.  Unspent outputs are the liquid funds
on the blockchain. Users do not have individual accounts, but rather
have a software \textit{wallet} on a smartphone or PC which manages
UTXOs on the blockchain and can initiate transactions involving UTXOs
owned by the user.  Every core node on the blockchain maintains a
record of all of the currently unspent outputs, the \textit{UTXO set};
when outputs are spent, they are removed from the UTXO set.

Our main concern here is to facilitate the implementation of
\textit{smart contracts}: programs which perform automated and
irrevocable transfer of funds on the blockchain, subject to certain
conditions being met.  A smart contract may involve multiple
transactions, and our aim is to define a transaction model which
enables the implementation of highly expressive contracts.

\subsection{Structure of the document}
\label{sec:doc-structure}
This document proposes two extensions of the basic UTXO model (EUTXO
stands for \textit{Extended UTXO}):

\begin{itemize}
  \item \textbf{EUTXO-1} (Section~\ref{sec:eutxo-1}): this extends the
    basic UTXO model with enhanced scripting features, allowing the
    implementation of complex smart contracts.
  \item \textbf{EUTXO-2} (Section~\ref{sec:eutxo-2}): this adds
    multicurrency features to EUTXO-1, allowing users to define
    \textit{custom currencies} and \textit{non-fungible tokens}.
\end{itemize}

\noindent We give formal specifications of each of these versions,
based on the models appearing in the
papers~\citep{Zahnentferner18-Chimeric} and
\citep{Zahnentferner18-UTxO}.

\medskip

The rationale for providing two separate specifications is that (1)
introducing the extensions separately clarifies the structure of the
models and makes it easier to explain the relevant design decisions,
and (2) it is possible that a particular blockchain might not need the
full power of EUTXO-2 and so could use the simpler EUTXO-1 model,
perhaps with less computational overhead.

\bigskip

\noindent Before presenting the extended models we will define some
basic notation and give a little background on the standard UTXO
model.


\section{Notation}
This section defines some basic notation.  We generally follow the
notation established by \citep{Zahnentferner18-UTxO}.

\begin{ruledfigure}{H}
  \begin{itemize}
\item Types are typeset in $\mathsf{sans~serif}$.

\item All scripts are of type $\mathsf{Script}$.

\item The only operation on $\mathsf{Script}$ from the ledger's
  perspective is applying a validator script to three arguments,
  which is denoted by $\llbracket \cdots \rrbracket :
  \mathsf{Script} \rightarrow \mathsf{Script} \times \mathsf{Script}
    \times \mathsf{Script} \rightarrow \B$.

\item A record type with fields $\phi_1, \ldots, \phi_n$ of types $T_1,
  \ldots, T_n$ is denoted by $(\phi_1 : T_1, \ldots, \phi_n : T_n)$.

\item If $t$ is a value of a record type $T$ and $\phi$ is the name
  of a field of $T$ then $t.\phi$ denotes the value of $\phi$ for
  $t$.

\item If $T$ is a type then $\FinSet{T}$ is the type of finite sets
  with elements of type $T$.
  
\item A list $\lambda$ of type $\List{T}$ is either the empty list
  $[]$ or a list $e :: \lambda'$ with $head$ $e$ of type $T$ and
  $tail$ $\lambda'$ of type $\List{T}$. A list has only a finite
  number of elements.  We denote the $i$th element of a list $\lambda$ by
  $\lambda[i]$ and the length of $\lambda$ by $\left|\lambda\right|$.
%The concatenation of two lists $\lambda_1$ and $\lambda_2$
%  is denoted $\lambda_1 ::: \lambda_2$.

  \item For two types $K$ and $V$, $\Map{K}{V}$ denotes the type of
    partial functions from \textit{keys} in $K$ to \textit{values} in
    $V$, and the result of looking up a key $k$ in a map $m$ is
    denoted by $m[k]$.  If $m$ is such map then the \textit{domain} of
    $m$ is $\dom m = \{k \in K: f[k] \mbox{ is defined}\}$; we can
    regard $m$ as a \textit{total} function from $\dom m$ to $V$, and
    for expository purposes we will sometimes regard $m$ as a subset
    of $\dom m \times V$ in the usual way.

    Equality for maps is defined in the obvious way: $m_1 = m_2$ if
    and only if $\dom m_1 = \dom m_2$ and $m_1[k] = m_2[k]$ for all
    $k \in \dom m_1$ (assuming we have decidable equality in $V$).
    
  \item If the type $M$ is a monoid with binary operation $+$ (for
    example, a numeric type) the we define the sum of two maps
    $f, g \in \Map{K}{M}$ to be the map $f+g \in \Map{K}{M}$ with
    domain $\dom (f+g) = \dom f \cup \dom g$ given by
    \[
    (f+g)[k] =
    \left\{ \begin{array}{ll}
        f[k] + g[k] & \mbox{if $k \in \dom f \cap \dom g$}\\
        f[k] & \mbox{if $k \in \dom f \setminus \dom g$}\\
        g[k] & \mbox{if $k \in \dom g \setminus \dom f$}
      \end{array}
      \right.
      \]
      We generalise this to the sum of a finite number of maps using
      the $\sum$ notation in the usual way; care is required if the
      operation $+$ is non-commutative, since then the sum of a number of
      maps will depend on the order in which they appear. Note that
      the type $\Map{K}{M}$ itself becomes a monoid under the
      operation $+$ which we have just defined, with the empty map $\{\}$ as
      identity element.

    \item $x \mapsto f(x)$ denotes an anonymous function.

  \item A cryptographic
    collision-resistant hash of a value $c$ is denoted $c^{\#}$.

\end{itemize}
\caption{Basic notation}
\label{fig:basic-notation}
\end{ruledfigure}


\noindent Throughout the document we assume a number of basic types.
These are shown in Figure~\ref{fig:basic-types}.

\begin{ruledfigure}{H}
  \center{
    \begin{tabular}{rl}
      \B&: the type of booleans, $\{\false, \true\}$\\
      \N&: the type of natural numbers, $\{0, 1, 2, \ldots\}$\\
      \Z&: the type of integers, $\{,\ldots, -2, -1, 0, 1, 2, \ldots\}$\\
      $\qty = \N$&: an amount of currency, always non-negative\\
      $\qtypm = \Z$&: a possibly negative amount of currency\\
      $\s{SlotNumber} = \N$&: a slot number\\
      $\s{Address} = \N$&: the address of an object in the blockchain\\
      $\s{TxId} = \N$&: the identifier of a previous transaction on the chain\\
    \end{tabular}
  }
  \caption{Basic types}
  \label{fig:basic-types}
\end{ruledfigure}

\noindent We regard $\N$ as a subtype of $\Z$ and convert freely between
natural numbers and non-negative integers.

\medskip
\noindent In practice an \textsf{Address} will usually be a hash of
some object (for example, a script), and the blockchain will provide
an efficient way to retrieve the original object given its hash.

% Accessing objects indirectly via addresses is helpful because it can
% help to reduce memory and disk usage: for example, there may be
% scripts for common validation scenarios used in many transactions, and
% it is more efficient to store single copies of such scripts rather
% than having hundreds of transactions each with their own copy.

\medskip
\noindent We assume that every transaction in a ledger has a unique identifier
of type \s{TxId}: in an implementation this would probably be the
hash of the transaction.





\section{The Basic UTXO model: Outputs and scripts}
\label{sec:utxo-intro}

There is no well-defined notion of ownership for UTXOs.  In many
transactions an output will accrue to a single user who is then
entitled to spend it at a later date.  However, in general the notion
of ownership is more complex: an output of a transaction might require
the cooperation of several users before it could be spent, or it might
not be spendable until some other condition has been met (for example
a certain period of time may have to pass).  At the extremes, an
output could be spendable by anyone, or by no-one.

In order to deal with this complexity, an output can be locked by a
\textit{script},%
\footnote{In the Cardano setting, scripts are Plutus Core
  programs~\citep{Plutus-Core-spec} (equivalently, expressions).  }
requiring another script to unlock it.  In the basic model, each input
to a transaction comes with a \i{validator} script which checks that
the transaction is allowed to spend the output. In order to spend an
output, the transaction supplies another script, called the
\i{redeemer}, which provides evidence that the transaction has the
authority to do so;\footnote{The validator plays a role similar to
  that of BitCoin's \texttt{scriptPubKey} and the redeemer to
  \texttt{scriptSig}.  } a process called \i{validation} is then
performed which checks that the redeemer satisfies the conditions
required by the redeemer. Before a transaction can proceed, all inputs
must be successfully validated: if one or more inputs fails to
validate then the transaction is rejected.

A simple example of this is a \i{pay-to-pubkey} script, where the
redeemer consists of a signature for the current transaction produced
using a private key belonging to the owner of the output.  The
validator (provided by the owner of the output) would check the
signature using a known public key: if the public key corresponds to
the private key then validation succeeds, otherwise it fails.  Thus
the output can only be spent by the owner of the relevant private key

\paragraph{Fees and Costs.}
\label{sec:costs} Users may have to pay a fee in order to have a
transaction executed.  In a public blockchain an important reason for
this is to deter hostile agents from carrying out denial of service
attacks by submitting transactions which take a long time or use
excessive amounts of memory.  In Cardano we expect that the fee will
include a component based on the size of the transaction (including
its associated scripts), and also a so-called \textit{gas} charge to
cover execution costs.  We will have a model specifying the costs of
individual operations during script execution; costs will be monitored
dynamically during execution, and if the gas consumed ever exceeds the
amount covered by the fee then the transaction will fail.


\section{EUTXO-1: Enhanced scripting}
\label{sec:eutxo-1}
The EUTXO-1 model adds the following new features to the model 
proposed in~\citep{Zahnentferner18-UTxO}:

\begin{itemize}
\item Every transaction has a \textit{validity interval}, consisting
  of a range of slot numbers:\footnote{A \textit{slot} is the
    opportunity to create a new block, occurring approximately every
    20 seconds in Cardano.  The slot number is a useful measure of
    time on the blockchain, avoiding difficulties with synchronisation
    and accuracy.} a core node will only process the transaction if
  the current slot number lies within the transaction's validity
  interval.

\item We introduce a new script called a \i{data script}, and each
  unspent output has a (possibly empty) data script associated with
  it.  The introduction of the data script increases the expressivity
  of the model considerably. For example, one can use the datascript
  to propagate state between transactions, and this can be used to
  give a contract the structure of a finite state machine; the fact
  that the datascript is part of the output and not the transaction
  means that the state can change without the transaction changing,
  which makes it easier to have an ``identity'' for an ongoing
  contract: we will return to this issue in
  Section~\ref{sec:validating-next}.
  
\item Validation is performed by running the validator script with the
  redeemer and data script as input; the validator is also provided
  with information about the pending transaction (ie, the transaction
  which is just about to take place, assuming that validation
  succeeds); this information is contained in a structure which we call
  \ptx{} which contains data such as the validity interval of the
  pending transaction and information about the inputs and outputs.
  See Section~\ref{sec:pendingtx} for more information on the $\ptx$
  structure.
  
\end{itemize}


\noindent At the ledger level, validator scripts now have the type
$$
\script \times \script \times \script \rightarrow \B
$$
At the Plutus level in Cardano, the validator is a program which
consumes the redeemer, the datascript, and the Plutus Core encoding of
the $\ptx$ structure as agruments: each script will have a Plutus type
and the types will have to fit the types expected by the validator.

\subsection{A Formal Description of the EUTXO-1 Model}
\label{section:eutxo-spec}

In this section we give a formal description of the EUTXO-1 model.  The
description is given in a straightforward set-theoretic form, which
(a) admits an almost direct translation into Haskell, and (b) should
easily be amenable to mechanical formalisation.  This will potentially
allow us to argue formally about smart contracts and to develop tools
for automatic contract analysis.

The definitions in this section are essentially the definitions of
UTXO-based cryptocurrencies with scripts from
\citep{Zahnentferner18-UTxO}, with the addition of the new features
mentioned above: the validity interval and the $\ptx$ structure.

Figure~\ref{fig:eutxo-1-types} lists the types which
describe transactions in the basic EUTXO model.


%%
\begin{ruledfigure}{H}
  \[
  \begin{arraydefs}{rll}
    
    \s{Output } &= (&\addr: \s{Address},\\
    && \i{value}: \qty,\\
    &&  \i{datascript}: \s{Script})\\
    \\
    \s{OutputRef } &= (&\i{id}: \s{TxId}, \idx: \s{Int})\\
    \\
    \s{Input } & = (&\i{outputRef}: \s{OutputRef},\\
                 && \i{validator}: \s{Script},\\
                 && \i{redeemer}: \s{Script})\\
     \\
     \eutxotx\s{ } &= (&\inputs: \FinSet{\s{Input}},\\
     &&\outputs: \List{\s{Output}},\\
     &&\i{validityInterval}: \slotnum \times (\slotnum \cup \{\infty\}),\\
     && \fee: \qty,\\
     &&\forge: \qty) \\
     \\
     \s{Ledger } &=&\!\List{\eutxotx}\\
  \end{arraydefs}
  \]
  \caption{Types for the EUTXO-1 model}
  \label{fig:eutxo-1-types}
\end{ruledfigure}

\subsubsection{Remarks}
\paragraph{Inputs and outputs. } Note that a transaction has a
\textsf{Set} of inputs but a \textsf{List} of outputs. We use a list
because any subsequent transaction attempting to use an unspent output
$O$ as an input will have to be able to determine exactly where $O$
came from: thus each input of a transaction refers to the output which
it is trying to spend via an \s{OutputRef} which specifies the
transaction which produced the output and an index which says which
output of the transaction is required.

%\todompj{Can we just cite one of the previous descriptions for this?
%  Also: we should check this is still how they do it in the new ledger
%  specs.}

\paragraph{Scripts.} The spendability of an output is determined by
its validator script, and thus the validator for an output must be
created at the same time as the output is.  Conceptually the validator
is part of the output, so it may be rather unexpected that
Figure~\ref{fig:eutxo-1-types} defines the validator to be part of an
\textit{input}, with the output only containing a hash of the
validator.  The rationale for this is that a validator $V$ for an
output $O$ is not required until $O$ is actually spent, which may be
some time after $O$ was created.  Recall from~\ref{sec:costs} that the
cost of executing a transaction depends on the size of transaction,
including the associated scripts.  Thus the transaction that produces
the validator only pays for the size of a hash (32 bytes) and the
transaction that runs it pays for the full size of the script. This
strategy also helps to reduce on-chain storage requirements, since
validators can be stored off-chain until needed (and the presence of
the hash in the output can be used to check that the correct validator
is in fact being used when validation occurs), but unspent outputs
persist on-chain in the UTXO set until they are eventually spent.

This strategy is not applied to datascripts since, as the name would
suggest, we expect them to be small pieces of data (public keys, for
example) which would not incur large storage charges.
\todokwxm{Exactly what is the rationale for making the datascript
  part of the output and not just a hash?}

\paragraph{Validity intervals.} We allow the second component of a
validity interval to take the value $\infty$ to indicate that there is
no upper bound on the validity of a transaction.  Slot numbers start
at 0, so if the first component of the validity interval is 0
then there is no lower bound on the transaction's validity.

\paragraph{Special types of transaction.} In a practical
implementation it might be useful to include special cases for common
transaction types such as pay-to-pukbey transactions in order to
increase efficiency and decrease storage requirements (and hence
reduce fees).  These have been omitted from this model because it
subsumes all of the other transaction types we're likely to encounter,
and also because it's difficult to give a definitive list of such
special cases.

\paragraph{Ledger structure.} We model a ledger as a simple
list of transactions: a real blockchain ledger will be more complex
than this, but the only property that we really require is that
transactions in the ledger have some kind of address which allows them
to be uniquely identified and retrieved.

\subsubsection{The $\ptx$ type}
\label{sec:pendingtx}
For the current version of EUTXO-1 we define the $\ptx$ type
to be
\begin{ruledfigure}{H}
  $$
  \ptx = \eutxotx \times \s{OutputRef}
  $$
  \caption{The $\ptx$ type}
  \label{fig:pendingtx}
\end{ruledfigure}
We also require a function
$$
\sigma: \ptx \rightarrow \script
$$
which converts a $\ptx$ object into a script.

As we will see below, when we are validating an input $i$ the
$\ptx$ script will be constructed from the pending transaction and the
output being spent by $i$.  

\paragraph{Determinism.} The $\ptx$ type is the only information about
the ``outside world'' available to a validator script at the time of
validation.  Allowing the validator access to this information gives
the EUTXO model a considerable amount of power.  \red{(like what?)}
However, it is important not to make too much information available to
the validator.  The choice of the $\ptx$ type above means that the
information available to the validator is essentially independent of
the state of the blockchain, and in particular, it is independent of
time (note that the check that the current slot number is within a
transaction's validity range takes place \textit{before} validation is
initiated, and the slot number is not passed to the validator
(although the validity range is)).  This implies that validation is
\textit{determinisitic} and validators can be run off-chain in order
to determine their execution cost before on-chain validation actually
occurs.  This helps users to calculate transaction fees in advance and
avoid the possibility of their transactions failing due to an
insufficient fee having been paid (and also avoids overpayment due to
overestimating the fees).

\todokwxm{This can't be precisely true.  For example, in the
  crowdfunding contract we don't know in advance how many
  contributions will be made, or whether a campaign will succeed or
  fail.  Thus we won't know how much the final transaction will cost
  until just before it happens.}
  

\subsection{Validity of EUTXO-1 transactions}
\label{sec:eutxo-1-validity}
A number of conditions must be satisfied in order for a transaction
$t$ to be considered valid with respect to a ledger $\lambda$.  In
order to define these we require a couple of auxiliary functions.
Firstly, following~\citep{Zahnentferner18-UTxO} we define

$$
  \txunspent : \eutxotx \rightarrow \FinSet{\s{OutputRef}}
  $$
% 
  by
% 
$$
\txunspent(t) = \{(id,1), \ldots, (\mathit{id},\left|t.outputs\right|)\}
$$
\noindent (where $\mathit{id}$ is the identifier of the current transaction), and
\todokwxm{Where does the transaction id come from?}
%
\[
  \unspent : \mathsf{Ledger} \rightarrow \FinSet{\s{OutputRef}}
\]
%
by
% 
\begin{align*}
   \unspent([]) &=\emptymap \\
   \unspent(t::\lambda) &= (\unspent(\lambda) \setminus t.\inputs) \cup \txunspent(t).
\end{align*}

\noindent Note that for a completed transaction $t$, $t.\inputs$ is
the set of previously unspent outputs which were spent by $t$.

\medskip
\noindent Given a ledger $\lambda$ and a transaction id $\id$, we
denote by $\lambda\langle\id\rangle$ the unique transaction $T$ in
$\lambda$ with $T.\txid = \id$, if it exists. In our abstract model
where $\lambda$ consists of a list of transactions it would suffice to
take $id$ to be the position of $T$ in $\lambda$, but in an
implementation we would probably have $id = T^{\#}$.

\medskip
\noindent Now given an input $i$ to some transaction in a ledger
$\lambda$ we define
$$
\getvalue(i,\lambda) = \lambda\langle i.\outputref.\txid \rangle.\outputs[i.\outputref.\idx].\val
$$
This function simply returns the value of the input.



\bigskip

\noindent We can now define what it means for a transaction to be
valid for a ledger: see Figure~\ref{fig:eutxo-1-validity}.  Our
definition combines Definitions 6 and 14 from
\citep{Zahnentferner18-UTxO}, differing from the latter in condition
\ref{rule:all-inputs-validate}.


\begin{ruledfigure}{H}
\begin{enumerate}
    \item \label{rule:all-inputs-refer-to-unspent-outputs} \textbf{All
      inputs refer to unspent outputs:}
      \[
        t.\inputs \subseteq \unspent(\lambda).
      \]
    \item\label{rule:forging} \textbf{Forging:}
      \begin{center}
        \parbox{0.8\textwidth}{ A transaction with a non-zero \forge{}
          field is only valid if the ledger $\lambda$ is empty (that
          is, if it is the initial transaction).}
    \end{center}
      
    \item \label{rule:value-is-preserved} \textbf{Value is preserved}:
    \[
      t.\forge + \sum_{i \in t.\inputs} \getvalue(i, \lambda) = t.\fee + \sum_{o \in t.\outputs} o.\val.
    \]
    \item \label{rule:no-double-spending} \textbf{No output is double spent:}
    \[
     \textrm{If } i_1, i_2 \in t.\inputs \textrm{ and }  i_1.\mathit{outputRef} = i_2.\mathit{outputRef}
     \textrm{ then } i_1 = i_2.
    \]
    \item\label{rule:all-inputs-validate} \textbf{All inputs validate:}
    \[
    \textrm{For all } i \in t.\inputs,\enspace \llbracket
    i.\validator(\txout(i, \lambda).\datascript,\, i.\redeemer,\,  \sigma(t,i)) \rrbracket = \true.
      \]
    \item\label{rule:validator-scripts-hash} \textbf{Validator scripts hash to their output addresses:}
    \[
      \textrm{For all } i \in t.\inputs,\enspace i.\validator^{\#} = \txout(i, \lambda).\addr.
    \]
\end{enumerate}
\caption{Validity of a transaction $t$ in the EUTXO-1 model}
\label{fig:eutxo-1-validity}
\end{ruledfigure}

\noindent We say that a ledger
$\lambda$ is \textit{valid} if either $\lambda$ is empty or
$\lambda$ is of the form $t::\lambda^{\prime}$ with
$\lambda^{\prime}$ valid and $t$ valid for $\lambda^{\prime}$.


In practice, validity imposes a limit on the size of the
$\mathsf{Script}$ values of the $\validator$, $\redeemer$ and
$\datascript$ fields and the result of $\sigma$. The validation of a
single transaction must take place within one slot, so the evaluation
of $\llbracket ~ \rrbracket$ cannot take longer than one slot.

\subsection{Validating the next data script}
\label{sec:validating-next}
\red{(To follow)}

\newpage
\section{EUTXO-2: multicurrency support and non-fungible tokens}
\label{sec:eutxo-2}
We now extend the EUTXO-1 model further by introducing features which
allow, among other things, the implementation of new currencies and
\textit{non-fungible tokens} (NFTs).  We assume that the underlying
blockchain has a unique \textit{native currency} which is the
fundamental currency used for paying fees, for example.  The native
currency of the Cardano blockchain is Ada.

\smallskip
\todokwxm{Jann says ``Maybe we should mention the native currency
  here, but not write it down in the spec - it's only needed for the
  fee, we don't have a cost model for EUTXO yet, and by ignoring the
  native currency in the definitions we could delete the forge, fee
  and value fields''.  I'm in two minds about this.  Making Ada just the
  same as custom currencies feels a little unnatural, but maybe that's
  just me. Also, I don't think we have fees for custom currencies, so
  that does differentiate the native currency from the others.}

\paragraph{Custom currencies.} In addition to the native currency, the
EUTXO-2 model allows an unlimited number of other \textit{custom
  currencies}, possibly user-defined.  Each custom currency has a
unique identifier; the native currency is handled separately and has
no identifier.

\paragraph{NFTs.}
A non-fungible token (NFT) is a unique object which can be transferred
to another user, but not duplicated.  NFTs have proven useful in a
number of blockchain applications (see~\citep{ERC-721} for example);
for example, they can represent ownership of some object in a game.
We can implement NFTs as custom currencies whose supply is limited to
a single coin.

\subsection{The definition of EUTXO-2}
In order to support these extensions, we introduce several new types.
Custom currencies are represented by unique \textit{currency
  identifiers} and each currency has a number of \textit{tokens} which
partition each custom currency into a number of sub-currencies.  The
basic idea is that ordinary currencies have a single token whose
sub-currency has an unlimited supply and NFTs have a number of tokens
with the sub-currency for each token limited to a supply of one.


\newcommand{\emspace}{\hspace{1em}}
\newcommand{\espace}{\hspace{1en}}

\begin{ruledfigure}{H}
  \center{
  \begin{tabular}{rll}
  \s{CurrencyID}&: & an identifier for a custom currency. This is an alias
  for the \s{Address} type\\
                & & from Figure~\ref{fig:basic-types}.\\
    \\
    \s{Token}&:& a type consisting of identifiers for individual tokens.  These will probably\\
               & &be hashes in practice.\\
\\
    \qtymap &=& \Map{\s{CurrencyId}}{\Map{\s{Token}}{\s{Quantity}}}\\
    \\
  $\qtymap^{\pm}$ &=& \Map{\s{CurrencyId}}{\Map{\s{Token}}{\s{Quantity}^{\pm}}}\\
  \end{tabular}
  }
  \caption{Extra basic types for the EUTXO-2 model}
  \label{fig:more-basic-types}
\end{ruledfigure}

\noindent The $\qtymap$ type represents a collection of funds from a
number of currencies and their subcurrencies, with all quantities
being non-negative.  The $\qtymap^{\pm}$ type is similar, but
negative quantities are allowed.

\begin{ruledfigure}{H}
  \[
  \begin{arraydefs}{rll}
    \s{Output}_2 &= (&\addr: \s{Address},\\
    && \val: \qty\\
    && \customvals: \qtymap,\\
    && \i{datascript}: \s{Script})\\
    \\
    \s{OutputRef}_2 &= (&\i{id}: \s{TxId}, \idx: \s{Int})\\
    \\
    \s{Input}_2 &= (& \i{outputRef}: \sf{OutputRef}_2,\\
                     && \i{validator}: \s{Script},\\
                     & & \i{redeemer}: \s{Script})\\
\\
    \eutxotx_2 &= ( &\inputs: \FinSet{\s{Input}_2},\\
    &&\outputs: \List{\s{Output}_2},\\
    &&\i{validityInterval}: \slotnum \times (\slotnum \cup \{\infty\}),\\
    &&\fee: \qty,\\
    &&\forge: \qty,\\
    &&\customforge: \qtymap^{\pm})\\
    \\
    \s{Ledger}_2 &=&\!\List{\eutxotx_2}\\
\end{arraydefs}
  \]
  \caption{Types for the EUTXO-2 model}
  \label{fig:eutxo-2-types}
\end{ruledfigure}

\noindent The changes to the basic EUTXO-1 types are now quite simple:
see Figure~\ref{fig:eutxo-2-types}.  We add a \qtymap{} to the
\s{Output} type, representing values of custom currencies; we also add
a \customforge{} field of type $\qtymap^{\pm}$ to transactions to
allow the creation and destruction of funds in custom currencies; the
supply of a custom currency can be reduced by forging a negative
amount of that currency.

The fields \val, \fee, and \forge{} all represent quantities of the
native currency, as in the EUTXO-1 model.

\subsection{Validity of EUTXO-2 transactions}

\bigskip
\noindent The validity conditions from
Figure~\ref{fig:eutxo-1-validity} must also be updated to take account
of multiple currencies.  However, there is a subtlety which we must
deal with first.

\paragraph{Zero quantities.}  We require currency quantities to be
non-negative, but we do not insist that they are strictly positive.
Thus an output can contain 0 units of any (sub)currency, including the
native currency.  With the introduction of custom currencies, this
presents a problem: should we distinguish between a $\qtymap$ which
explicitly has 0 units of some currency $C$ and one which does not
mention $C$ at all?  The answer depends on the context: if we are
adding together quantities of currencies then it is sensible to regard
the two as being ``the same'', but we may wish to distinguish the two
when talking about outputs for instance, since an output whose
quantity map is
$Q_1 = \{(A,{(t,0)}), (B,\{(u,0)\}), (C,\{(v,5), (w,0)\})\}$ will take
up more space than one whose quantity map is $Q_2 = \{(C,\{(v,5)\})\}$.
In Figure~\ref{fig:more-basic-types} we defined equality pointwise, so
$Q_1$ and $Q_2$ are not equal even though they arguably represent the
same amounts of currency.  To deal with this we can use an equivalence
relation which considers two quantity maps to be equivalent if they
differ only by zero values. Using this equivalence relation directly
is somewhat tricky, but fortunately each equivalence class has a
canonical representative, one which has no zero values at all. This
motivates the following definitions:

\begin{gather*}
  \mu_1: \Map{\token}{\qty} \rightarrow \Map{\token}{\qty} \\
  \mu_1(M) = \{(t,v) \in M: v \ne 0\}\\
  \\
  \mu: \qtymap  \rightarrow \qtymap\\
  \mu(Q) = \{(c,\mu_1(M)): (c,M) \in Q \mbox{ and } \mu_1(M) \ne \{\}\}\\
\end{gather*}

\newcommand{\mprime}{M^{\prime}}

\noindent For each currency in a $\qtymap$ $Q$, the auxiliary
operation $\mu_1$ firstly discards all tokens which occur with value
0; the operation $\mu$ then discards all currencies which have no
tokens left.  If we put $\mprime = \mu(M)$ then it is guaranteed that
$\mprime[c] \ne \{\}$ for all $c \in \dom{\mprime}$ and that
$M^{\prime}[c][t] \ne 0$ for all $c \in \dom{M^{\prime}}$ and
$t \in \dom{M^{\prime}[c]}$,
  

\medskip
\todokwxm{Maybe this is getting out of hand.  Another way to do this
  would be to define a function $\kappa: K \times \Map{K}{V} \rightarrow V$ with
  $\kappa(k,m) = m[k]$ if $k \in \dom m$ and $\kappa(k) = 0$
  otherwise.  For validity we'd then have to assert that $\kappa(k)$
  balances up for every $k$ in the union of the domains of the various
  maps involved.  This could get typographically messy.}
  
We use the definitions of \unspent{}  and
\getvalue{} from Section~\ref{sec:eutxo-1-validity} unchanged,
but we also require a function to retrieve the values of
custom currencies from inputs. If $t$ is a transaction in a ledger
$\lambda$ and $i \in t.\inputs$, then we define
$$
\s{getCustomValues}(i,\lambda) = \lambda\langle i.\outputref.\txid
\rangle.\outputs[i.\outputref.\idx].\customvals
$$

We can now adapt the definition of validity for EUTXO-1
(Figure~\ref{fig:eutxo-1-validity}) to obtain a definition of validity for
EUTXO-2: see Figure~\ref{fig:eutxo-2-validity}.

\begin{ruledfigure}{H}
  \begin{enumerate}
    \item \label{rule:all-inputs-refer-to-unspent-outputs-2} \textbf{All
      inputs refer to unspent outputs:}
      \[
        t.\inputs \subseteq \unspent(\lambda).
      \]
    \item\textbf{Forging:}\\\\
      \begin{minipage}{0.85\textwidth}
          \begin{enumerate}
          \item
              A transaction with a non-zero \forge{} field is only
            valid if the ledger $\lambda$ is empty
            (that is, if it is the initial
            transaction). 
          \item \label{rule:custom-forge}
            A transaction with a non-empty \customforge{} field is
            only valid if for every key $h$ in $t.\customforge$, there
            exists $i \in t.\inputs$ and $(a,v,d) \in i.\outputs$ with
            $a =h$; in other words, some input must spend an output
            whose address is $h$.
          \end{enumerate}
          \end{minipage}
    \item \textbf{Values are preserved}\\
      \begin{minipage}{0.85\textwidth}
          \begin{enumerate}
          \item\label{rule:native-value-is-preserved-2}
            \[
            t.\forge + \sum_{i \in t.\inputs} \getvalue(i, \lambda) = t.\fee + \sum_{o \in t.\outputs} o.\val
            \]

          \item\label{rule:custom-values-are-preserved-2}
            \[
              \mu\left(t.\customforge\, + \sum_{i \in t.\inputs} \s{getCustomValues}(i, \lambda)\right) =
              \mu\left(\sum_{o \in t.\outputs} o.\customvals\right)
            \]
          \end{enumerate}
          
          \end{minipage}
    \item \label{rule:no-double-spending-2} \textbf{No output is double spent:}
    \[
     \textrm{If } i_1, i_2 \in t.\inputs \textrm{ and }  i_1.\mathit{outputRef} = i_2.\mathit{outputRef}
     \textrm{ then } i_1 = i_2.
    \]
    \item\label{rule:all-inputs-validate-2} \textbf{All inputs validate:}
    \[
    \textrm{For all } i \in t.\inputs,\enspace \llbracket
    i.\validator(\txout(i,\lambda).\datascript,\, i.\redeemer,\, \sigma(t, i))
    \rrbracket = \true.
      \]
    \item\label{rule:validator-scripts-hash-2} \textbf{Validator scripts hash to their output addresses:}
    \[
      \textrm{For all } i \in t.\inputs,\enspace i.\validator^{\#} = \txout(i, \lambda).\addr.
    \]
  \end{enumerate}
  \caption{Validity of a transaction $t$ in the EUTXO-2 model}
  \label{fig:eutxo-2-validity}

\end{ruledfigure}

\noindent If any of the indexing operations here fail then the
transaction is invalid.

\paragraph{Note.} In rule~\ref{rule:custom-values-are-preserved-2},
$+$ and $\sum$ are the sum of maps as defined in
Figure~\ref{fig:basic-notation}. Essentially we require that the
quantities of each of the individual custom currencies involved in the
transaction are preserved.  Recall that values in $\customforge$ can
be negative whereas values in outputs must be non-negative.  Thus
rule~\ref{rule:custom-values-are-preserved-2} implies that a
transaction is invalid if it attempts to destroy more of a currency
than is actually available in its inputs.


\subsection{Monetary policies for custom currencies}
\label{sec:monetary-policies}
The new \textbf{Forging} rule in
Figure~\ref{fig:eutxo-2-validity} enables custom currencies to
implement their own monetary policies: for example, one might wish to
place some limit on the amount of a currency that can be forged, or
restrict the creation of the currency to owners of particular public
keys.

The idea is that a custom currency has a monetary policy which is
defined by some script $H$, and the hash $h = H^{\#}$ is used as the
identifier of the currency.

Whenever a new quantity of the currency is forged,
rules~\ref{rule:custom-forge}, \ref{rule:all-inputs-validate-2}, and
\ref{rule:validator-scripts-hash-2} imply that $H$ must be executed;
$H$ is provided with the \forge{} field of the transaction via the
$\ptx$ object, and so it knows how much of the currency is to be
forged and can respond appropriately.

The advantage of this scheme is that custom currencies can be handled
entirely within the smart contract system, without the need to
introduce any extra blockchain infrastructure such as a central
registry of custom currencies.

In practice some refinement of this scheme will be required in order
to (a) allow re-use of a monetary policy for different currencies, and
(b) prevent unauthorised forging of a currency. To deal with (a) we
can make the validator script unique by including a nonce. This still
doesn't prevent unauthorised people from using the script $H$ to
produce currency, but this can be prevented by, for instance,
embedding a reference to an unspent output in the script and
requiring that the currency can only be forged if the referenced
output is spent at the same time, so it can only be forged once.

\smallskip
\todokwxm{Is this exactly what we want?  I think that gives you a
  single opportunity to forge the currency, and then you can't make
  any more. I suppose that you could restrict the ability to forge to
  a particular individual by requiring them to provide something
  signed by their private key when they want to create new money.
  Also, is this a case where an output of value zero would be useful?}

\smallskip
\todokwxm{The use of the term ``forging'' is a bit confusing here,
  since it also means ``counterfeiting''.}
  
% \todojm{I think there are two different concerns:
%  (1) Using the same monetary policy multiple times;
%   (2) Preventing unauthorised forging of a currency.

% The "referencing an unspent output" trick accomplishes
%   both but is mainly aimed at (2). You could also achieve (1) by
%   embedding any kind of random data in the validator script, like a
%   nonce.
% }


\subsection{Implications of the EUTXO-2 model}
The EUTXO-2 model and the techniques described in
Section~\ref{sec:monetary-policies} allow us to implement fungible
(normal) and non-fungible token currencies, as well as ``mixed
states'':
\begin{itemize}
\item Standard (fungible) currencies are implemented by issuing
  currencies with a single \s{Token}.
\item Non-fungible token currencies are implemented by only ever
  issuing single quantities of many unique \s{Token}s.
\item Note that there is nothing in this model which enforces
  uniqueness: having multiples of a single \s{Token} merely means that
  those can be used fungibly. If a currency wants to make sure it only
  issues unique tokens it must track this itself.  These ``mixed'' token
  currencies can have many \s{Token}s, but these can have more than unit
  quantities in circulation.  These can be useful to model distinct
  categories of thing where there are fungible quantities within
  those, for example share classes. \red{Eh?}
\end{itemize}

\paragraph{Performance.}
\red{I'm just making random stuff up here.}  The UTXO-2 model will
lose some efficiency in comparison to the UTXO-1 model, simply because
the data structures are more complicated.  This would even apply to
transactions which only involve to native currency, since it would be
necessary to check whether the \qtymap{} contains anything that needs
to be processed.  If this is a concern then one could implement a
model with two types of transaction, essentially just the disjoint
union of the EUTXO-1 and EUTXO-2 transaction types. A simple case
distinction at the start of a transaction could then select either a
fast native-currency-only computation or a slower multicurrency
computation.  This would be harder to maintain though.

\smallskip  Another optimisation would be possible if one wished to
implement custom currencies but not NFTs: since in this case every
currency would only have a single token, the tokens could be omitted
and the $\qtymap$ replaced with a map from currency ids to quantities.

\smallskip A more significant cost may be that we can no longer use
\verb|{-# UNPACK #-}| when our Quantity type stops being a simple
combination of wrappers and products around primitives, but this is
again an issue with any multi-currency proposal.

\todojm{I wonder if the argument that most of the time it takes to
  validate a transaction is spent doing cryptography things applies
  here as well.}
  
  \section{Examples}
  \todokwxm{Do we want some examples to illustrate how this stuff
    works in practice?  It would be particularly useful to have an
    example showing how the datascript allows you to propagate state
  through the transactions comprising a contract.}

  \todojm{Maybe the guessing game would be a good example
    for EUTXO-1. Its data script is the hash of the secret, and the
    redeemer is the guess in cleartext. It illustrates that data and
    redeemer scripts are created at different points in time.}




\section{What else do we need to worry about?}
\begin{itemize}

\item Sometimes I'm saying ``datascript'' and at other times ``data script''.
  Maybe we should try to be consistent about this.
  
\item Do we need to worry about who signs the various scripts, or is that
  something the wallet deals with?

\item Who's responsible for looking after the scripts, and where are they kept?
  Presumably scripts will be stored in the chain, but how do they get there?

\item Maybe we should make this more consistent with the ledger specification.
\end{itemize}
  



\bibliographystyle{plainnat} %% ... or whatever
\bibliography{extended-utxo-specification}


\end{document}


