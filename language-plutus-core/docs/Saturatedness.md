# Saturated vs unsaturated built-in functions

There are two ways to have built-in functions in the AST of `Term`:

1. either it's saturated application `AppBuiltinFunction BuiltinFunction [Type] [Term]` where a built-in function is always applied to the exact number of type and term arguments that it expects, e.g. `AddInteger` has to always be applied to two term arguments

2. or it's unsaturated application:

```haskell
data Term
    = <...>
    | BuiltinFunction BuiltinFunction
    | Inst Term Type
    | Apply Term Term
```

where a built-in function can be partially applied, e.g. it's allowed to apply `AddInteger` to just one argument and pass the partially applied function as an argument to some higher-order function like `map`

Those two representations are very similar. Differences:

- with saturated builtins everything becomes n-ary: we need to do lots of folds, monadic traversals, and so on which we don't need with unsaturated builtins. This is particularly annoying when we have an LHS and an RHS of something, because that requires (occasionally monadic) zipping, checking that lists of arguments are of the same length, etc. This is particularly evident in the type checker (version [with unsaturated builtins](https://github.com/input-output-hk/plutus/blob/607b67164fd984abc26977d438f37497fd832142/language-plutus-core/src/Language/PlutusCore/TypeCheck/Internal.hs), version [with saturated builtins](https://github.com/input-output-hk/plutus/blob/97edb99f216f8d112072b2e22ce2e3730723f907/language-plutus-core/src/Language/PlutusCore/TypeCheck/Internal.hs))
- it's much easier to type check unsaturated built-in functions than saturated ones. The reason is that with unsaturated builtins you only need to handle the `Apply` constructor and that'll cover both an application of a lambda and an application of a builtin. In particular, having a built-in `id : all a. a -> a` type checking of `id {integer} 0` and `id {integer -> integer} (addInteger 1) 2` proceeds the same way with unsaturated builtins as only the `Apply` case needs to be handled. With saturated builtins the latter term looks as `[ id {integer} (\x -> [ addInteger 1 x ]) ] 2` (where `[_]` denotes a saturated builtin application) and type checking such a term amounts to handling two cases: `Apply` for the lambda returned from `id` and `AppBuiltinFunction` for the two builtin applications. And that causes some inconvenience, because writing the latter term as `[ id {integer} (\x -> [ addInteger 1 x ]) 2 ]` (`2` is now inside the saturated application) is illegal as saturated application has to contain the exact number of arguments that are necessary for the application to compute. So now we have two syntactic ways to write the same term, one of which is illegal and needs to be ruled out by the type checker and it's not enough to know the type of `id` for that (as it's the same in both the cases): you have to pass in the actual `TypeScheme` of the builtin, since it contains the info on how many arguments the builtin expects. I.e. with unsaturated builtins we only care about the type of a builtin and a builtin application is no different to a lambda application w.r.t. type checking, while with saturated builtins there's quite more logic involved. Particularly because with saturated builtins we need to juggle lists in the type checker, which is mostly straightforward, but is considerably more code than what we need in order to handle unsaturated builtins. Having more code in the type checker relying on global uniqueness is generally a bad idea, because that's more room for making a mistake and breaking global uniqueness (which is absolutely trivial) and a bigger haystack to dig in
- we had a hypothesis that having saturated builtins leads to a more efficient evaluator than having unsaturated ones. But once we've obtained [the actual numbers](https://github.com/input-output-hk/plutus/blob/0a71a3561c7fad49d591b5046c9a85a38acef60a/notes/fomega/evaluation/CEK-variations-stats.md) it turned out that there isn't much difference in terms of performance. It is also important to note that given that we Scott-encode all data types, there are a myriad of lambdas in a final program and so those unoptimied "unsaturated" lambdas are probably going to dominate execution time anyway (compared to execution time of _invocations_ of built-in functions, not generally). And if we have n-ary lambdas and applications, then we can use them to emulate saturated builtins. Evaluation of builtins proceeds the same way for the original CEK machine + saturated builtins and the alternative CEK machine + unsaturated builtins (I literally just copypasted the code from the branch implementing the former into the branch implementing the latter and tweaked it a bit), so whether builtins are saturated or not doesn't seem to affect evaluation in any significant way (apart from the corner case where we have the original CEK machine and unsaturated builtins, but that is only due to the original CEK machine not being as flexible as the alternative one)
- with unsaturated built-in functions we can write `map (addInteger 1) xs` while with saturated once we have to write `map (\x -> addInteger 1 x) xs`. It doesn't seem like this is in any way important to the end user as that transformation can be done by the Plutus Tx compiler without any trouble
- with saturated builtins one can't directly embed a `BuiltinFunction` into a `Term`, the function needs to be eta-expanded to become a `Term`. This is a small annoyance and not a big deal in practice
- saturated builtins kinda force us to only have built-in functions whose types are either [monotypes or polytypes](https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Syntax). I.e. we can't have a built-in like `unsafeCoerce : all a. a -> all b. b`, because there's an `all` going after a `->`. Not a big deal in practice, because you can always float all `all`s in the type of a builtin to the left and recover the original type by defining a derivative function that use type/term lambdas as appropirate and feeds all bound variables to the builtin the way it expects them
- it's clear from the syntax of a saturated builtin application how many arguments a builtin needs to compute (the exact number of arguments the builtin is applied to). This makes certain things much nicer with saturated builtins than with unsaturated ones: one can always eta-contract an eta-expanded built-in function with saturated builtins (see [this discussion](https://mail.google.com/mail/u/0/#inbox/FMfcgxwJXBxCJMXVnNxVHbhpfPKVpXNq) on the Plutus mailing list), while with unsaturated builtins eta-contraction is only safe when a built-in is not applied to more arguments than it needs in order to compute (which is not enforced statically like with saturated builtins). Similarly, one can decide whether a builtin application constitutes a value or not (i.e. whether it can compute or not) trivially with saturated builtins (a builtin application always computes) and for unsaturated ones that requires retrieving the `TypeScheme` of a builtin, which is rather inconvenient (especially given the fact that an unsaturated builtin gets applied the same way as a lambda, so you need to traverse an iterated application to reach its head and then check if it's a builtin or not)

So in general, differences are minor and either of the approaches is fine. Sometimes saturated builtins are more convenient, sometimes unsaturated ones.
