-- | This module defines various types and functions useful for testing.

{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE RankNTypes            #-}
{-# LANGUAGE UndecidableInstances  #-}

module Language.PlutusCore.Generators.Test
    ( TypeEvalCheckError (..)
    , TypeEvalCheckResult (..)
    , TypeEvalCheckM
    , typeEvalCheckBy
    , unsafeTypeEvalCheck
    , sampleTermValue
    , sampleProgramValueGolden
    , propEvaluate
    ) where

import           Language.PlutusCore
import           Language.PlutusCore.Constant
import           Language.PlutusCore.Evaluation.CkMachine
import           Language.PlutusCore.Evaluation.Result
import           Language.PlutusCore.Generators.Interesting
import           Language.PlutusCore.Generators.Internal.TypedBuiltinGen
import           Language.PlutusCore.Generators.Internal.Utils
import           Language.PlutusCore.Pretty
import           PlutusPrelude                                           hiding (hoist, (</>))

import           Control.Monad.Except
import           Control.Monad.Morph
import qualified Data.Text.IO                                            as Text
import           Data.Traversable
import           Hedgehog                                                hiding (Size, Var, eval)
import           System.FilePath                                         ((</>))

{- Note [Type-eval checking]
We generate terms along with values they are supposed to evaluate to. Before evaluating a term,
we type check it. Then we evaluate the term and check whether the expected result matches with
the actual one. Thus "type-eval checking".
-}

-- | The type of errors that can occur during type-eval checking.
data TypeEvalCheckError
    = TypeEvalCheckErrorIllFormed (Error ())
    | TypeEvalCheckErrorIllEvaled (Value TyName Name ()) (Value TyName Name ())
      -- ^ The former is an expected result of evaluation, the latter -- is an actual one.

-- | Type-eval checking of a term results in a value of this type.
data TypeEvalCheckResult = TypeEvalCheckResult
    { _termCheckResultType  :: NormalizedType TyNameWithKind ()
      -- ^ The type of the term.
    , _termCheckResultValue :: EvaluationResult
      -- ^ The result of evaluation of the term.
    }

instance (PrettyBy config (Error ()), PrettyBy config (Value TyName Name ())) =>
        PrettyBy config TypeEvalCheckError where
    prettyBy config (TypeEvalCheckErrorIllFormed err)             =
        "The term is ill-formed:" <+> prettyBy config err
    prettyBy config (TypeEvalCheckErrorIllEvaled expected actual) =
        "The expected value:" <+> prettyBy config expected <> hardline <>
        "doesn't match with the actual value:" <+> prettyBy config actual

-- | The monad type-eval checking runs in.
type TypeEvalCheckM = ExceptT TypeEvalCheckError Quote

-- See Note [Type-eval checking].
-- | Type check and evaluate a term and check that the expected result is equal to the actual one.
typeEvalCheckBy
    :: (Term TyName Name () -> EvaluationResult) -- ^ An evaluator.
    -> TermOf (TypedBuiltinValue Size a)
    -> TypeEvalCheckM (TermOf TypeEvalCheckResult)
typeEvalCheckBy eval (TermOf term tbv) = TermOf term <$> do
    let typecheck = annotateTerm >=> typecheckTerm (TypeCheckCfg 1000 $ TypeConfig True mempty)
    termTy <- convertErrors TypeEvalCheckErrorIllFormed $ typecheck term
    resExpected <- liftQuote $ unsafeMakeBuiltin tbv
    fmap (TypeEvalCheckResult termTy) . for (eval term) $ \resActual ->
        if resExpected == resActual
            then return resActual
            else throwError $ TypeEvalCheckErrorIllEvaled resExpected resActual

-- | Throw a PLC error.
errorPlc :: PrettyBy PrettyConfigPlc err => err -> b
errorPlc = error . docString . prettyPlcCondensedErrorBy debugPrettyConfigPlcClassic

-- | Type check and evaluate a term and check that the expected result is equal to the actual one.
-- Throw an error in case something goes wrong.
unsafeTypeEvalCheck
    :: forall a. TermOf (TypedBuiltinValue Size a) -> Quote (Maybe (TermOf (Value TyName Name ())))
unsafeTypeEvalCheck termOfTbv = do
    errOrRes <- runExceptT $ typeEvalCheckBy evaluateCk termOfTbv
    pure $ case errOrRes of
        Left err         -> errorPlc err
        Right termOfTecr -> traverse (evaluationResultToMaybe . _termCheckResultValue) termOfTecr

-- | Generate a term using a given generator and check that it's well-typed and evaluates correctly.
sampleTermValue :: TermGen Size a -> IO (TermOf (Value TyName Name ()))
sampleTermValue genTerm = runQuoteSampleSucceed $ genTerm >>= liftQuote . unsafeTypeEvalCheck

-- | Generate a pair of files: @<folder>.<name>.plc@ and @<folder>.<name>.plc.golden@.
-- The first file contains a term generated by a term generator (wrapped in 'Program'),
-- the second file contains the result of evaluation of the term.
sampleProgramValueGolden
    :: String          -- ^ @folder@
    -> String          -- ^ @name@
    -> TermGen Size a  -- ^ A term generator.
    -> IO ()
sampleProgramValueGolden folder name genTerm = do
    let filePlc       = folder </> (name ++ ".plc")
        filePlcGolden = folder </> (name ++ ".plc.golden")
    TermOf term value <- sampleTermValue genTerm
    Text.writeFile filePlc       . prettyPlcDefText $ Program () (Version () 0 1 0) term
    Text.writeFile filePlcGolden $ prettyPlcDefText value

-- | A property-based testing procedure for evaluators.
-- Checks whether a term generated along with the value it's supposed to compute to
-- indeed computes to that value according to the provided evaluate.
propEvaluate
    :: (Term TyName Name () -> EvaluationResult)       -- ^ An evaluator.
    -> GenT Quote (TermOf (TypedBuiltinValue Size a))  -- ^ A term/value generator.
    -> Property
propEvaluate eval genTermOfTbv = property . hoist (return . runQuote) $ do
    termOfTbv <- forAllNoShowT genTermOfTbv
    case runQuote . runExceptT $ typeEvalCheckBy eval termOfTbv of
        Left (TypeEvalCheckErrorIllFormed err)             -> errorPlc err
        Left (TypeEvalCheckErrorIllEvaled expected actual) ->
            expected === actual  -- We know that these two are disctinct, but there is no nice way we
                                 -- can report this via 'hedgehog' except by comparing them here again.
        Right _                                            -> return ()
