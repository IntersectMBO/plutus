{-# LANGUAGE TemplateHaskell  #-}
{-# LANGUAGE DataKinds        #-}
{-# LANGUAGE TypeApplications #-}
module Main(main) where

import           Control.Lens
import           Control.Monad              (void)
import           Control.Monad.Trans.Except (runExcept)
import           Data.Either                (isLeft, isRight)
import           Data.Foldable              (fold, traverse_)
import           Data.List                  (sort)
import qualified Data.Map                   as Map
import qualified Data.Set                   as Set
import           Data.Monoid                (Sum (..))
import           Hedgehog                   (Property, forAll, property)
import qualified Hedgehog
import qualified Hedgehog.Gen               as Gen
import qualified Hedgehog.Range             as Range
import           Test.Tasty
import           Test.Tasty.Hedgehog        (testProperty)
import           Language.PlutusTx.TH       (compile)
import qualified Language.PlutusTx.Builtins as Builtins
import qualified Language.PlutusTx.Prelude  as PlutusTx

import           Wallet
import qualified Wallet.API                 as W
import           Wallet.Emulator
import           Wallet.Generators          (Mockchain (..))
import qualified Wallet.Generators          as Gen
import           Ledger
import qualified Ledger.Index          as Index
import qualified Wallet.Graph

main :: IO ()
main = defaultMain tests

tests :: TestTree
tests = testGroup "all tests" [
    testGroup "UTXO model" [
        testProperty "initial transaction is valid" initialTxnValid,
        testProperty "compute UTxO of trivial blockchain" utxo,
        testProperty "validate transaction" txnValid,
        testProperty "validate transaction when it can be validated" txnValidFrom
        ],
    testGroup "UTXO index" [
        testProperty "create an index of transactions" txnIndex,
        testProperty "use the index to validate transactions" txnIndexValid
        ],
    testGroup "traces" [
        testProperty "accept valid txn" validTrace,
        testProperty "reject invalid txn" invalidTrace,
        testProperty "notify wallet" notifyWallet,
        testProperty "react to blockchain events" eventTrace,
        testProperty "watch funds at an address" notifyWallet,
        testProperty "log script validation failures" invalidScript,
        testProperty "payToPubkey" payToPubKeyScript,
        testProperty "payToPubkey-2" payToPubKeyScript2
        ],
    testGroup "intervals" [
        testProperty "member" intvlMember,
        testProperty "contains" intvlContains
        ],
    testGroup "Etc." [
        testProperty "splitVal" splitVal,
        testProperty "selectCoin" selectCoinProp,
        testProperty "txnFlows" txnFlowsTest
        ]
    ]

initialTxnValid :: Property
initialTxnValid = property $ do
    (i, _) <- forAll . pure $ Gen.genInitialTransaction Gen.generatorModel
    Gen.assertValid i Gen.emptyChain

utxo :: Property
utxo = property $ do
    Mockchain block o <- forAll Gen.genMockchain
    Hedgehog.assert (unspentOutputs [block] == o)

txnValid :: Property
txnValid = property $ do
    (m, txn) <- forAll genChainTxn
    Gen.assertValid txn m

txnValidFrom :: Property
txnValidFrom = property $ do
    (e, _) <- forAll $ Gen.runTraceOn Gen.generatorModel validFromTransaction
    Hedgehog.assert $ isRight e

-- | Submits a transaction that is valid in the future, then adds a number of 
--   slots, then verifies that the transaction has been validated.
validFromTransaction :: Trace MockWallet ()
validFromTransaction = do
    let [w1, w2] = Wallet <$> [1, 2]
        updateAll = processPending >>= walletsNotifyBlock [w1, w2]
    updateAll

    -- Set the validation interval to (5, 5] for the 
    -- transaction generated by payToPublicKey_
    -- so that the transaction can be validated only during slot 5
    let range = W.singleton 5

    walletAction w1 $ payToPublicKey_ range 5 (PubKey 2)

    -- Add some blocks so that the transaction is validated
    addBlocks 50 >>= traverse_ (walletsNotifyBlock [w1, w2])
    traverse_ (uncurry assertOwnFundsEq) [
        (w1, 100000 - 5),
        (w2, 100000 + 5)]

txnIndex :: Property
txnIndex = property $ do
    (m, txn) <- forAll genChainTxn
    let (result, st) = Gen.runTrace m $ processPending >> simpleTrace txn
    Hedgehog.assert (Index.initialise (_chainNewestFirst st) == _index st)

txnIndexValid :: Property
txnIndexValid = property $ do
    (m, txn) <- forAll genChainTxn
    let (result, st) = Gen.runTrace m processPending
        idx = _index st
    Hedgehog.assert (Right () == Index.runValidation (Index.validateTransaction 0 txn) idx)

-- | Submit a transaction to the blockchain and assert that it has been
--   validated
simpleTrace :: Tx -> Trace MockWallet ()
simpleTrace txn = do
    [txn'] <- walletAction (Wallet 1) $ submitTxn txn
    block <- processPending
    assertIsValidated txn'

validTrace :: Property
validTrace = property $ do
    (m, txn) <- forAll genChainTxn
    let (result, st) = Gen.runTrace m $ processPending >> simpleTrace txn
    Hedgehog.assert (isRight result)
    Hedgehog.assert ([] == _txPool st)

invalidTrace :: Property
invalidTrace = property $ do
    (m, txn) <- forAll genChainTxn
    let invalidTxn = txn { txFee = 0 }
        (result, st) = Gen.runTrace m $ simpleTrace invalidTxn
    Hedgehog.assert (isLeft result)
    Hedgehog.assert ([] == _txPool st)
    Hedgehog.assert (not (null $ _emulatorLog st))
    Hedgehog.assert (case _emulatorLog st of
        SlotAdd _ : TxnValidationFail _ _ : _ -> True
        _                                      -> False)

invalidScript :: Property
invalidScript = property $ do
    (m, txn1) <- forAll genChainTxn

    -- modify one of the outputs to be a script output
    index <- forAll $ Gen.int (Range.linear 0 ((length $ txOutputs txn1) -1))
    let scriptTxn = txn1 & outputs . element index %~ \o -> scriptTxOut (txOutValue o) failValidator unitData
    Hedgehog.annotateShow (scriptTxn)
    let outToSpend = (txOutRefs scriptTxn) !! index
    let totalVal = txOutValue (fst outToSpend)

    -- try and spend the script output
    invalidTxn <- forAll $ Gen.genValidTransactionSpending (Set.fromList [scriptTxIn (snd outToSpend) failValidator unitRedeemer]) totalVal
    Hedgehog.annotateShow (invalidTxn)

    let (result, st) = Gen.runTrace m $ do
            processPending
            walletAction (Wallet 1) $ submitTxn scriptTxn
            processPending
            walletAction (Wallet 1) $ submitTxn invalidTxn
            processPending

    Hedgehog.assert (isRight result)
    Hedgehog.assert ([] == _txPool st)
    Hedgehog.assert (not (null $ _emulatorLog st))
    Hedgehog.annotateShow (_emulatorLog st)
    Hedgehog.assert $ case _emulatorLog st of
        SlotAdd{} : TxnValidationFail _ (ScriptFailure ["I always fail everything"]) : _
            -> True
        _
            -> False

    where
        failValidator :: ValidatorScript
        failValidator = ValidatorScript $ fromCompiledCode $$(compile [|| \() () () -> $$(PlutusTx.traceH) "I always fail everything" (Builtins.error @()) ||])

splitVal :: Property
splitVal = property $ do
    i <- forAll $ Gen.int $ Range.linear 1 (100000 :: Int)
    n <- forAll $ Gen.int $ Range.linear 1 100
    vs <- forAll $ Gen.splitVal n i
    Hedgehog.assert $ sum vs == i
    Hedgehog.assert $ length vs <= n

selectCoinProp :: Property
selectCoinProp = property $ do
    inputs <- forAll $ zip [1..] <$> Gen.list (Range.linear 1 1000) Gen.genValue
    target <- forAll Gen.genValue
    let result = runExcept (selectCoin inputs target)
    case result of
        Left _ ->
            Hedgehog.assert $ (sum $ snd <$> inputs) < target
        Right (ins, change) ->
            Hedgehog.assert $ (sum $ snd <$> ins) == target + change

txnFlowsTest :: Property
txnFlowsTest = property $ do
    (_, e) <- forAll $ Gen.runTraceOn Gen.generatorModel pubKeyTransactions
    let chain = _chainNewestFirst e
        numTx = length $ fold chain
        flows = Wallet.Graph.txnFlows [] chain
        -- there should be at least one link per tx
        -- plus some for the unspent outputs
    Hedgehog.assert (length flows > numTx)

notifyWallet :: Property
notifyWallet = property $ do
    let w = Wallet 1
    (e, EmulatorState{ _walletStates = st }) <- forAll
        $ Gen.runTraceOn Gen.generatorModel
        $ processPending >>= walletNotifyBlock w
    let ttl = Map.lookup w st
    Hedgehog.assert $ (getSum . foldMap (Sum . txOutValue) . view ownFunds <$> ttl) == Just initialBalance

eventTrace :: Property
eventTrace = property $ do
    let w = Wallet 1
    (e, EmulatorState{ _walletStates = st }) <- forAll
        $ Gen.runTraceOn Gen.generatorModel
        $ do
            processPending >>= walletNotifyBlock w
            let mkPayment =
                    EventHandler $ \_ -> payToPublicKey_ W.always 100 (PubKey 2)
                trigger = slotRangeT (W.intervalFrom 3)

            -- schedule the `mkPayment` action to run when slot 3 is
            -- reached.
            b1 <- walletAction (Wallet 1) $ register trigger mkPayment
            walletNotifyBlock w b1

            -- advance the clock to trigger `mkPayment`
            addBlocks 2 >>= traverse_ (walletNotifyBlock w)
            void (processPending >>= walletNotifyBlock w)
    let ttl = Map.lookup w st

    -- if `mkPayment` was run then the funds of wallet 1 should be reduced by 100
    Hedgehog.assert $ (getSum . foldMap (Sum . txOutValue) . view ownFunds <$> ttl) == Just (initialBalance - 100)

payToPubKeyScript2 :: Property
payToPubKeyScript2 = property $ do
    let [w1, w2, w3] = Wallet <$> [1, 2, 3]
        updateAll = processPending >>= walletsNotifyBlock [w1, w2, w3]
    (e, _) <- forAll
        $ Gen.runTraceOn Gen.generatorModel
        $ do
            updateAll
            walletAction (Wallet 1) $ payToPublicKey_ W.always (initialBalance - 1) (PubKey 2)
            updateAll
            walletAction (Wallet 2) $ payToPublicKey_ W.always (initialBalance + 1) (PubKey 3)
            updateAll
            walletAction (Wallet 3) $ payToPublicKey_ W.always (initialBalance + 1) (PubKey 1)
            updateAll
            walletAction (Wallet 1) $ payToPublicKey_ W.always 2 (PubKey 2)
            updateAll
            traverse_ (uncurry assertOwnFundsEq) [
                (w1, initialBalance),
                (w2, initialBalance),
                (w3, initialBalance)]
    Hedgehog.assert $ isRight e

pubKeyTransactions :: Trace MockWallet ()
pubKeyTransactions = do
    let [w1, w2, w3] = Wallet <$> [1, 2, 3]
        updateAll = processPending >>= walletsNotifyBlock [w1, w2, w3]
    updateAll
    walletAction (Wallet 1) $ payToPublicKey_ W.always 5 (PubKey 2)
    updateAll
    walletAction (Wallet 2) $ payToPublicKey_ W.always 5 (PubKey 3)
    updateAll
    walletAction (Wallet 3) $ payToPublicKey_ W.always 5 (PubKey 1)
    updateAll
    traverse_ (uncurry assertOwnFundsEq) [
        (w1, 100000),
        (w2, 100000),
        (w3, 100000)]

payToPubKeyScript :: Property
payToPubKeyScript = property $ do
    (e, _) <- forAll $ Gen.runTraceOn Gen.generatorModel pubKeyTransactions
    Hedgehog.assert $ isRight e

watchFundsAtAddress :: Property
watchFundsAtAddress = property $ do
    let w = Wallet 1
        pkTarget = PubKey 2
    (e, EmulatorState{ _walletStates = st }) <- forAll
        $ Gen.runTraceOn Gen.generatorModel
        $ do
            processPending >>= walletNotifyBlock w
            let mkPayment =
                    EventHandler $ \_ -> payToPublicKey_ W.always 100 (PubKey 2)
                t1 = slotRangeT (W.interval 3 4)
                t2 = fundsAtAddressT (pubKeyAddress pkTarget) (W.intervalFrom 1)
            walletNotifyBlock w =<<
                (walletAction (Wallet 1) $ do
                    register t1 mkPayment
                    register t2 mkPayment)

            -- after 3 blocks, t1 should fire, triggering the first payment of 100 to PubKey 2
            -- after 4 blocks, t2 should fire, triggering the second payment of 100
            addBlocks 3 >>= traverse_ (walletNotifyBlock w)
            void (processPending >>= walletNotifyBlock w)
    let ttl = Map.lookup w st
    Hedgehog.assert $ (getSum . foldMap (Sum . txOutValue) . view ownFunds <$> ttl) == Just (initialBalance - 200)

genChainTxn :: Hedgehog.MonadGen m => m (Mockchain, Tx)
genChainTxn = do
    m <- Gen.genMockchain
    txn <- Gen.genValidTransaction m
    pure (m, txn)

initialBalance :: Value
initialBalance = 100000

intvlMember :: Property
intvlMember = property $ do
    (i1, i2) <- forAll $ (,) <$> Gen.int Range.linearBounded <*> Gen.int Range.linearBounded
    let (from, to) = (Slot $ min i1 i2, Slot $ max i1 i2)
        i          = W.interval from to
    Hedgehog.assert $ W.member from i || W.empty i
    Hedgehog.assert $ (not $ W.member to i) || W.empty i

intvlContains :: Property
intvlContains = property $ do
    -- generate two intervals from a sorted list of ints
    -- the outer interval contains the inner interval
    ints <- forAll $ traverse (const $ Gen.int Range.linearBounded) [1..4]
    let [i1, i2, i3, i4] = fmap Slot $ sort ints
        outer = W.interval i1 i4
        inner = W.interval i2 i3
        
    Hedgehog.assert $ W.contains outer inner
