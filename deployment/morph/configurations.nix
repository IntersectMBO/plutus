let
  plutus = import ../../. { system = "x86_64-linux"; };
  pkgs = plutus.pkgs;
  # machines.json is a file generated by terraform. We want defaults if it doesn't exist
  # so that we can run tests of the NixOS config on Hydra
  machines =
    let p = ./machines.json;
    in
    if builtins.pathExists p
    then plutus.pkgs.lib.importJSON p
    else { rootSshKeys = [ ]; monitoringSshKeys = [ ]; };
  stdOverlays = [ ];
  nixpkgsLocation = (builtins.fromJSON (builtins.readFile ../../nix/sources.json)).nixpkgs.url;
  ports = {
    http = 80;
    ssh = 22;
    prometheus = 9090;
    nodeExporter = 9100;
    webGhcExporter = 9091;
    pab-webserver = 8080;
    plutus-playground-webserver = 8080;
    marlowe-playground-webserver = 9080;
  };
  options = { inherit stdOverlays machines nixpkgsLocation ports; };
  monitoringKeys = machines.monitoringSshKeys;
  defaultMachine = (import ./default-machine.nix) options;
  web-ghc = plutus.web-ghc;
  webGhcMachine = import ./webghc.nix;
  prometheusMachine = import ./prometheus.nix;
  pabMachine = import ./pab.nix;
  playgroundsMachine = import ./playgrounds.nix;
in
{
  # We partially apply mkInstance, it also expects other values like hostName
  # however this means we can add it later on a host-by-host basis while haveing exactly 
  # the same config that we can test separately in Hydra with a fake values
  webGhc = webGhcMachine.mkInstance (options // { inherit defaultMachine web-ghc monitoringKeys; });
  prometheus = prometheusMachine.mkInstance (options // { inherit defaultMachine monitoringKeys; });
  pab = pabMachine.mkInstance (options // { inherit defaultMachine monitoringKeys pkgs;inherit (plutus) marlowe-dashboard plutus-pab marlowe-app; });
  playgrounds = playgroundsMachine.mkInstance (options // { inherit defaultMachine monitoringKeys pkgs;inherit (plutus) marlowe-dashboard plutus-playground marlowe-playground; });
  inherit pkgs ports;
}
