{-# LANGUAGE Strict #-}
{-# OPTIONS_GHC -fexpose-all-unfoldings #-}

module PlutusTx.AsData.Internal where

import PlutusTx.Builtins.Internal (BuiltinData (..))
import PlutusTx.IsData.Class

-- See Note [Compiling AsData Matchers]

-- | This function is for internal compiler use only, and should not be used elsewhere.
wrapUnsafeFromBuiltinData :: forall a. (UnsafeFromData a) => BuiltinData -> a
wrapUnsafeFromBuiltinData = unsafeFromBuiltinData
{-# NOINLINE wrapUnsafeFromBuiltinData #-}

{- Note [Compiling AsData Matchers]

The AsData matchers, such as `AsData.Budget.Types.$mInts`, eagerly unpack all fields,
even for unused fields. This leads to strict dead bindings. Since they are strict and
the inliner doesn't know that they are effect-free, it can't remove them.

It is not uncommon that only one or a small number of fields in `ScriptContext` are used,
so this could cause severe performance penalties.

The matches are generated by GHC for pattern synonyms, not written by hand. As a result,
they are unfortunately not customizable - for example, by attaching certain annotations
to certain variables as signals for the Plinth compiler.

The workaround is this `wrapUnsafeFromBuiltinData` function, which wraps `unsafeFromBuiltinData`.
It is marked NOINLINE so that GHC doesn't inline it, yet its unfolding is made available
via `-fexpose-all-unfoldings`. `wrapUnsafeFromBuiltinData` is supposed to be used by
AsData only, and not elsewhere, and the Plinth compiler relies on it to identify
which functions are AsData matchers.

An AsData macher unpacks the fields and passes them to a continuation. What we need is
to mark the variables bound in the continuation as safe to inline. For instance, if the
continuation is `\x y z w -> f x` (indicating a data type with 4 fields, of which only the
first is used), marking `x`, `y`, `z` and `w` as safe to inline allows the inliner to
drop the unused ones.

-}
