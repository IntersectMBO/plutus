(let
    !caseList' : all a r. r -> (a -> list a -> r) -> list a -> r
      = /\a r ->
          \(z : r) (f : a -> list a -> r) (xs : list a) ->
            chooseList
              {a}
              {all dead. r}
              xs
              (/\dead -> z)
              (/\dead -> f (headList {a} xs) (tailList {a} xs))
              {r}
  in
  letrec
    data (List :: * -> *) a | List_match where
      Nil : List a
      Cons : a -> List a -> List a
  in
  letrec
    ~go : list data -> List bytestring
      = caseList'
          {data}
          {List bytestring}
          (Nil {bytestring})
          (\(x : data) (xs : list data) ->
             Cons {bytestring} (unBData x) (go xs))
  in
  let
    data Bool | Bool_match where
      True : Bool
      False : Bool
    data Credential | Credential_match where
      PubKeyCredential : bytestring -> Credential
      ScriptCredential : bytestring -> Credential
    data Unit | Unit_match where
      Unit : Unit
    !traceError : all a. string -> a
      = /\a ->
          \(str : string) -> let !x : Unit = trace {Unit} str Unit in error {a}
    !`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData` : data -> Credential
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          Bool_match
            (ifThenElse {Bool} (equalsInteger 0 index) True False)
            {all dead. Credential}
            (/\dead -> PubKeyCredential (unBData (headList {data} args)))
            (/\dead ->
               Bool_match
                 (ifThenElse {Bool} (equalsInteger 1 index) True False)
                 {all dead. Credential}
                 (/\dead -> ScriptCredential (unBData (headList {data} args)))
                 (/\dead -> traceError {Credential} "PT1")
                 {all dead. dead})
            {all dead. dead}
    data StakingCredential | StakingCredential_match where
      StakingHash : Credential -> StakingCredential
      StakingPtr : integer -> integer -> integer -> StakingCredential
    !`$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData` :
       data -> StakingCredential
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          Bool_match
            (ifThenElse {Bool} (equalsInteger 0 index) True False)
            {all dead. StakingCredential}
            (/\dead ->
               StakingHash
                 (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                    (headList {data} args)))
            (/\dead ->
               Bool_match
                 (ifThenElse {Bool} (equalsInteger 1 index) True False)
                 {all dead. StakingCredential}
                 (/\dead ->
                    let
                      !l : list data = tailList {data} args
                    in
                    StakingPtr
                      (unIData (headList {data} args))
                      (unIData (headList {data} l))
                      (unIData (headList {data} (tailList {data} l))))
                 (/\dead -> traceError {StakingCredential} "PT1")
                 {all dead. dead})
            {all dead. dead}
    data DCert | DCert_match where
      DCertDelegDeRegKey : StakingCredential -> DCert
      DCertDelegDelegate : StakingCredential -> bytestring -> DCert
      DCertDelegRegKey : StakingCredential -> DCert
      DCertGenesis : DCert
      DCertMir : DCert
      DCertPoolRegister : bytestring -> bytestring -> DCert
      DCertPoolRetire : bytestring -> integer -> DCert
    !`$fUnsafeFromDataDCert_$cunsafeFromBuiltinData` :
       data -> DCert
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          Bool_match
            (ifThenElse {Bool} (equalsInteger 0 index) True False)
            {all dead. DCert}
            (/\dead ->
               DCertDelegRegKey
                 (`$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData`
                    (headList {data} args)))
            (/\dead ->
               Bool_match
                 (ifThenElse {Bool} (equalsInteger 1 index) True False)
                 {all dead. DCert}
                 (/\dead ->
                    DCertDelegDeRegKey
                      (`$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData`
                         (headList {data} args)))
                 (/\dead ->
                    Bool_match
                      (ifThenElse {Bool} (equalsInteger 2 index) True False)
                      {all dead. DCert}
                      (/\dead ->
                         DCertDelegDelegate
                           (`$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData`
                              (headList {data} args))
                           (unBData (headList {data} (tailList {data} args))))
                      (/\dead ->
                         Bool_match
                           (ifThenElse
                              {Bool}
                              (equalsInteger 3 index)
                              True
                              False)
                           {all dead. DCert}
                           (/\dead ->
                              DCertPoolRegister
                                (unBData (headList {data} args))
                                (unBData
                                   (headList {data} (tailList {data} args))))
                           (/\dead ->
                              Bool_match
                                (ifThenElse
                                   {Bool}
                                   (equalsInteger 4 index)
                                   True
                                   False)
                                {all dead. DCert}
                                (/\dead ->
                                   DCertPoolRetire
                                     (unBData (headList {data} args))
                                     (unIData
                                        (headList
                                           {data}
                                           (tailList {data} args))))
                                (/\dead ->
                                   Bool_match
                                     (ifThenElse
                                        {Bool}
                                        (equalsInteger 5 index)
                                        True
                                        False)
                                     {all dead. DCert}
                                     (/\dead -> DCertGenesis)
                                     (/\dead ->
                                        Bool_match
                                          (ifThenElse
                                             {Bool}
                                             (equalsInteger 6 index)
                                             True
                                             False)
                                          {all dead. DCert}
                                          (/\dead -> DCertMir)
                                          (/\dead -> traceError {DCert} "PT1")
                                          {all dead. dead})
                                     {all dead. dead})
                                {all dead. dead})
                           {all dead. dead})
                      {all dead. dead})
                 {all dead. dead})
            {all dead. dead}
  in
  letrec
    ~go : list data -> List DCert
      = caseList'
          {data}
          {List DCert}
          (Nil {DCert})
          (\(x : data) (xs : list data) ->
             Cons
               {DCert}
               (`$fUnsafeFromDataDCert_$cunsafeFromBuiltinData` x)
               (go xs))
  in
  let
    data (Maybe :: * -> *) a | Maybe_match where
      Just : a -> Maybe a
      Nothing : Maybe a
    !`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData` :
       all a. (\a -> data -> a) a -> data -> Maybe a
      = /\a ->
          \(`$dUnsafeFromData` : (\a -> data -> a) a) (d : data) ->
            let
              !tup : pair integer (list data) = unConstrData d
              !index : integer = fstPair {integer} {list data} tup
              !args : list data = sndPair {integer} {list data} tup
            in
            Bool_match
              (ifThenElse {Bool} (equalsInteger 1 index) True False)
              {all dead. Maybe a}
              (/\dead -> Nothing {a})
              (/\dead ->
                 Bool_match
                   (ifThenElse {Bool} (equalsInteger 0 index) True False)
                   {all dead. Maybe a}
                   (/\dead ->
                      Just {a} (`$dUnsafeFromData` (headList {data} args)))
                   (/\dead -> traceError {Maybe a} "PT1")
                   {all dead. dead})
              {all dead. dead}
    data (Tuple2 :: * -> * -> *) a b | Tuple2_match where
      Tuple2 : a -> b -> Tuple2 a b
    !`$fUnsafeFromDataMap_$cunsafeFromBuiltinData` :
       all k v.
         (\a -> data -> a) k ->
         (\a -> data -> a) v ->
         data ->
         (\k v -> List (Tuple2 k v)) k v
      = /\k v ->
          \(`$dUnsafeFromData` : (\a -> data -> a) k)
           (`$dUnsafeFromData` : (\a -> data -> a) v) ->
            letrec
              ~go : list (pair data data) -> List (Tuple2 k v)
                = caseList'
                    {pair data data}
                    {List (Tuple2 k v)}
                    (Nil {Tuple2 k v})
                    (\(tup : pair data data) (tups : list (pair data data)) ->
                       Cons
                         {Tuple2 k v}
                         (Tuple2
                            {k}
                            {v}
                            (`$dUnsafeFromData` (fstPair {data} {data} tup))
                            (`$dUnsafeFromData` (sndPair {data} {data} tup)))
                         (go tups))
            in
            \(d : data) -> go (unMapData d)
    ~`$fUnsafeFromDataValue` :
       data -> (\k v -> List (Tuple2 k v)) bytestring integer
      = `$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
          {bytestring}
          {integer}
          unBData
          unIData
    data Address | Address_match where
      Address : Credential -> Maybe StakingCredential -> Address
    data OutputDatum | OutputDatum_match where
      NoOutputDatum : OutputDatum
      OutputDatum : data -> OutputDatum
      OutputDatumHash : bytestring -> OutputDatum
    data TxOut | TxOut_match where
      TxOut :
        Address ->
        (\k v -> List (Tuple2 k v))
          bytestring
          ((\k v -> List (Tuple2 k v)) bytestring integer) ->
        OutputDatum ->
        Maybe bytestring ->
        TxOut
    !`$fUnsafeFromDataTxOut_$cunsafeFromBuiltinData` :
       data -> TxOut
      = \(eta : data) ->
          let
            !tup : pair integer (list data) = unConstrData eta
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          Bool_match
            (ifThenElse {Bool} (equalsInteger 0 index) True False)
            {all dead. TxOut}
            (/\dead ->
               let
                 !l : list data = tailList {data} args
                 !l : list data = tailList {data} l
               in
               TxOut
                 (let
                   !tup : pair integer (list data)
                     = unConstrData (headList {data} args)
                   !index : integer = fstPair {integer} {list data} tup
                   !args : list data = sndPair {integer} {list data} tup
                 in
                 Bool_match
                   (ifThenElse {Bool} (equalsInteger 0 index) True False)
                   {all dead. Address}
                   (/\dead ->
                      Address
                        (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                           (headList {data} args))
                        (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                           {StakingCredential}
                           `$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData`
                           (headList {data} (tailList {data} args))))
                   (/\dead -> traceError {Address} "PT1")
                   {all dead. dead})
                 (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                    {bytestring}
                    {(\k v -> List (Tuple2 k v)) bytestring integer}
                    unBData
                    `$fUnsafeFromDataValue`
                    (headList {data} l))
                 (let
                   !tup : pair integer (list data)
                     = unConstrData (headList {data} l)
                   !index : integer = fstPair {integer} {list data} tup
                   !args : list data = sndPair {integer} {list data} tup
                 in
                 Bool_match
                   (ifThenElse {Bool} (equalsInteger 0 index) True False)
                   {all dead. OutputDatum}
                   (/\dead -> NoOutputDatum)
                   (/\dead ->
                      Bool_match
                        (ifThenElse {Bool} (equalsInteger 1 index) True False)
                        {all dead. OutputDatum}
                        (/\dead ->
                           OutputDatumHash (unBData (headList {data} args)))
                        (/\dead ->
                           Bool_match
                             (ifThenElse
                                {Bool}
                                (equalsInteger 2 index)
                                True
                                False)
                             {all dead. OutputDatum}
                             (/\dead -> OutputDatum (headList {data} args))
                             (/\dead -> traceError {OutputDatum} "PT1")
                             {all dead. dead})
                        {all dead. dead})
                   {all dead. dead})
                 (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                    {bytestring}
                    unBData
                    (headList {data} (tailList {data} l))))
            (/\dead -> traceError {TxOut} "PT1")
            {all dead. dead}
  in
  letrec
    ~go : list data -> List TxOut
      = caseList'
          {data}
          {List TxOut}
          (Nil {TxOut})
          (\(x : data) (xs : list data) ->
             Cons
               {TxOut}
               (`$fUnsafeFromDataTxOut_$cunsafeFromBuiltinData` x)
               (go xs))
  in
  let
    !`$fUnsafeFromDataTxId_$cunsafeFromBuiltinData` : data -> bytestring
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          Bool_match
            (ifThenElse {Bool} (equalsInteger 0 index) True False)
            {all dead. bytestring}
            (/\dead -> unBData (headList {data} args))
            (/\dead -> traceError {bytestring} "PT1")
            {all dead. dead}
    data TxOutRef | TxOutRef_match where
      TxOutRef : bytestring -> integer -> TxOutRef
    !`$fUnsafeFromDataTxOutRef_$cunsafeFromBuiltinData` : data -> TxOutRef
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          Bool_match
            (ifThenElse {Bool} (equalsInteger 0 index) True False)
            {all dead. TxOutRef}
            (/\dead ->
               TxOutRef
                 (`$fUnsafeFromDataTxId_$cunsafeFromBuiltinData`
                    (headList {data} args))
                 (unIData (headList {data} (tailList {data} args))))
            (/\dead -> traceError {TxOutRef} "PT1")
            {all dead. dead}
    data TxInInfo | TxInInfo_match where
      TxInInfo : TxOutRef -> TxOut -> TxInInfo
    !`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData` : data -> TxInInfo
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          Bool_match
            (ifThenElse {Bool} (equalsInteger 0 index) True False)
            {all dead. TxInInfo}
            (/\dead ->
               TxInInfo
                 (`$fUnsafeFromDataTxOutRef_$cunsafeFromBuiltinData`
                    (headList {data} args))
                 (`$fUnsafeFromDataTxOut_$cunsafeFromBuiltinData`
                    (headList {data} (tailList {data} args))))
            (/\dead -> traceError {TxInInfo} "PT1")
            {all dead. dead}
  in
  letrec
    ~go : list data -> List TxInInfo
      = caseList'
          {data}
          {List TxInInfo}
          (Nil {TxInInfo})
          (\(x : data) (xs : list data) ->
             Cons
               {TxInInfo}
               (`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData` x)
               (go xs))
  in
  letrec
    ~go : list data -> List TxInInfo
      = caseList'
          {data}
          {List TxInInfo}
          (Nil {TxInInfo})
          (\(x : data) (xs : list data) ->
             Cons
               {TxInInfo}
               (`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData` x)
               (go xs))
  in
  let
    !equalsByteString : bytestring -> bytestring -> Bool
      = \(x : bytestring) (y : bytestring) ->
          ifThenElse {Bool} (equalsByteString x y) True False
    !`$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData` : data -> data
      = \(d : data) -> d
    !`$fUnsafeFromDataBool_$cunsafeFromBuiltinData` : data -> Bool
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          Bool_match
            (ifThenElse {Bool} (equalsInteger 0 index) True False)
            {all dead. Bool}
            (/\dead -> False)
            (/\dead ->
               Bool_match
                 (ifThenElse {Bool} (equalsInteger 1 index) True False)
                 {all dead. Bool}
                 (/\dead -> True)
                 (/\dead -> traceError {Bool} "PT1")
                 {all dead. dead})
            {all dead. dead}
    data (Extended :: * -> *) a | Extended_match where
      Finite : a -> Extended a
      NegInf : Extended a
      PosInf : Extended a
    !`$fUnsafeFromDataExtended_$cunsafeFromBuiltinData` :
       all a. (\a -> data -> a) a -> data -> Extended a
      = /\a ->
          \(`$dUnsafeFromData` : (\a -> data -> a) a) (d : data) ->
            let
              !tup : pair integer (list data) = unConstrData d
              !index : integer = fstPair {integer} {list data} tup
              !args : list data = sndPair {integer} {list data} tup
            in
            Bool_match
              (ifThenElse {Bool} (equalsInteger 0 index) True False)
              {all dead. Extended a}
              (/\dead -> NegInf {a})
              (/\dead ->
                 Bool_match
                   (ifThenElse {Bool} (equalsInteger 1 index) True False)
                   {all dead. Extended a}
                   (/\dead ->
                      Finite {a} (`$dUnsafeFromData` (headList {data} args)))
                   (/\dead ->
                      Bool_match
                        (ifThenElse {Bool} (equalsInteger 2 index) True False)
                        {all dead. Extended a}
                        (/\dead -> PosInf {a})
                        (/\dead -> traceError {Extended a} "PT1")
                        {all dead. dead})
                   {all dead. dead})
              {all dead. dead}
    data ScriptPurpose | ScriptPurpose_match where
      Certifying : DCert -> ScriptPurpose
      Minting : bytestring -> ScriptPurpose
      Rewarding : StakingCredential -> ScriptPurpose
      Spending : TxOutRef -> ScriptPurpose
    !`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData` :
       data -> ScriptPurpose
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          Bool_match
            (ifThenElse {Bool} (equalsInteger 0 index) True False)
            {all dead. ScriptPurpose}
            (/\dead -> Minting (unBData (headList {data} args)))
            (/\dead ->
               Bool_match
                 (ifThenElse {Bool} (equalsInteger 1 index) True False)
                 {all dead. ScriptPurpose}
                 (/\dead ->
                    Spending
                      (`$fUnsafeFromDataTxOutRef_$cunsafeFromBuiltinData`
                         (headList {data} args)))
                 (/\dead ->
                    Bool_match
                      (ifThenElse {Bool} (equalsInteger 2 index) True False)
                      {all dead. ScriptPurpose}
                      (/\dead ->
                         Rewarding
                           (`$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData`
                              (headList {data} args)))
                      (/\dead ->
                         Bool_match
                           (ifThenElse
                              {Bool}
                              (equalsInteger 3 index)
                              True
                              False)
                           {all dead. ScriptPurpose}
                           (/\dead ->
                              Certifying
                                (`$fUnsafeFromDataDCert_$cunsafeFromBuiltinData`
                                   (headList {data} args)))
                           (/\dead -> traceError {ScriptPurpose} "PT1")
                           {all dead. dead})
                      {all dead. dead})
                 {all dead. dead})
            {all dead. dead}
    data (LowerBound :: * -> *) a | LowerBound_match where
      LowerBound : Extended a -> Bool -> LowerBound a
    data (UpperBound :: * -> *) a | UpperBound_match where
      UpperBound : Extended a -> Bool -> UpperBound a
    data (Interval :: * -> *) a | Interval_match where
      Interval : LowerBound a -> UpperBound a -> Interval a
    data TxInfo | TxInfo_match where
      TxInfo :
        List TxInInfo ->
        List TxInInfo ->
        List TxOut ->
        (\k v -> List (Tuple2 k v))
          bytestring
          ((\k v -> List (Tuple2 k v)) bytestring integer) ->
        (\k v -> List (Tuple2 k v))
          bytestring
          ((\k v -> List (Tuple2 k v)) bytestring integer) ->
        List DCert ->
        (\k v -> List (Tuple2 k v)) StakingCredential integer ->
        Interval integer ->
        List bytestring ->
        (\k v -> List (Tuple2 k v)) ScriptPurpose data ->
        (\k v -> List (Tuple2 k v)) bytestring data ->
        bytestring ->
        TxInfo
    data ScriptContext | ScriptContext_match where
      ScriptContext : TxInfo -> ScriptPurpose -> ScriptContext
  in
  \(obsScriptCred : data)
   (ctx : data) ->
    ScriptContext_match
      (let
        !tup : pair integer (list data) = unConstrData ctx
        !index : integer = fstPair {integer} {list data} tup
        !args : list data = sndPair {integer} {list data} tup
      in
      Bool_match
        (ifThenElse {Bool} (equalsInteger 0 index) True False)
        {all dead. ScriptContext}
        (/\dead ->
           ScriptContext
             (let
               !tup : pair integer (list data)
                 = unConstrData (headList {data} args)
               !index : integer = fstPair {integer} {list data} tup
               !args : list data = sndPair {integer} {list data} tup
             in
             Bool_match
               (ifThenElse {Bool} (equalsInteger 0 index) True False)
               {all dead. TxInfo}
               (/\dead ->
                  let
                    !l : list data = tailList {data} args
                    !l : list data = tailList {data} l
                    !l : list data = tailList {data} l
                    !l : list data = tailList {data} l
                    !l : list data = tailList {data} l
                    !l : list data = tailList {data} l
                    !l : list data = tailList {data} l
                    !l : list data = tailList {data} l
                    !l : list data = tailList {data} l
                    !l : list data = tailList {data} l
                  in
                  TxInfo
                    (let
                      !d : data = headList {data} args
                    in
                    go (unListData d))
                    (let
                      !d : data = headList {data} l
                    in
                    go (unListData d))
                    (let
                      !d : data = headList {data} l
                    in
                    go (unListData d))
                    (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                       {bytestring}
                       {(\k v -> List (Tuple2 k v)) bytestring integer}
                       unBData
                       `$fUnsafeFromDataValue`
                       (headList {data} l))
                    (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                       {bytestring}
                       {(\k v -> List (Tuple2 k v)) bytestring integer}
                       unBData
                       `$fUnsafeFromDataValue`
                       (headList {data} l))
                    (let
                      !d : data = headList {data} l
                    in
                    go (unListData d))
                    (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                       {StakingCredential}
                       {integer}
                       `$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData`
                       unIData
                       (headList {data} l))
                    (let
                      !tup : pair integer (list data)
                        = unConstrData (headList {data} l)
                      !index : integer = fstPair {integer} {list data} tup
                      !args : list data = sndPair {integer} {list data} tup
                    in
                    Bool_match
                      (ifThenElse {Bool} (equalsInteger 0 index) True False)
                      {all dead. Interval integer}
                      (/\dead ->
                         Interval
                           {integer}
                           (let
                             !tup : pair integer (list data)
                               = unConstrData (headList {data} args)
                             !index : integer
                               = fstPair {integer} {list data} tup
                             !args : list data
                               = sndPair {integer} {list data} tup
                           in
                           Bool_match
                             (ifThenElse
                                {Bool}
                                (equalsInteger 0 index)
                                True
                                False)
                             {all dead. LowerBound integer}
                             (/\dead ->
                                LowerBound
                                  {integer}
                                  (`$fUnsafeFromDataExtended_$cunsafeFromBuiltinData`
                                     {integer}
                                     unIData
                                     (headList {data} args))
                                  (`$fUnsafeFromDataBool_$cunsafeFromBuiltinData`
                                     (headList {data} (tailList {data} args))))
                             (/\dead -> traceError {LowerBound integer} "PT1")
                             {all dead. dead})
                           (let
                             !tup : pair integer (list data)
                               = unConstrData
                                   (headList {data} (tailList {data} args))
                             !index : integer
                               = fstPair {integer} {list data} tup
                             !args : list data
                               = sndPair {integer} {list data} tup
                           in
                           Bool_match
                             (ifThenElse
                                {Bool}
                                (equalsInteger 0 index)
                                True
                                False)
                             {all dead. UpperBound integer}
                             (/\dead ->
                                UpperBound
                                  {integer}
                                  (`$fUnsafeFromDataExtended_$cunsafeFromBuiltinData`
                                     {integer}
                                     unIData
                                     (headList {data} args))
                                  (`$fUnsafeFromDataBool_$cunsafeFromBuiltinData`
                                     (headList {data} (tailList {data} args))))
                             (/\dead -> traceError {UpperBound integer} "PT1")
                             {all dead. dead}))
                      (/\dead -> traceError {Interval integer} "PT1")
                      {all dead. dead})
                    (let
                      !d : data = headList {data} l
                    in
                    go (unListData d))
                    (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                       {ScriptPurpose}
                       {data}
                       `$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData`
                       `$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData`
                       (headList {data} l))
                    (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                       {bytestring}
                       {data}
                       unBData
                       `$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData`
                       (headList {data} l))
                    (`$fUnsafeFromDataTxId_$cunsafeFromBuiltinData`
                       (headList {data} (tailList {data} l))))
               (/\dead -> traceError {TxInfo} "PT1")
               {all dead. dead})
             (`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData`
                (headList {data} (tailList {data} args))))
        (/\dead -> traceError {ScriptContext} "PT1")
        {all dead. dead})
      {Unit}
      (\(ipv : TxInfo) (ipv : ScriptPurpose) ->
         TxInfo_match
           ipv
           {Unit}
           (\(ipv : List TxInInfo)
             (ipv : List TxInInfo)
             (ipv : List TxOut)
             (ipv :
                (\k v -> List (Tuple2 k v))
                  bytestring
                  ((\k v -> List (Tuple2 k v)) bytestring integer))
             (ipv :
                (\k v -> List (Tuple2 k v))
                  bytestring
                  ((\k v -> List (Tuple2 k v)) bytestring integer))
             (ipv : List DCert)
             (ipv : (\k v -> List (Tuple2 k v)) StakingCredential integer)
             (ipv : Interval integer)
             (ipv : List bytestring)
             (ipv : (\k v -> List (Tuple2 k v)) ScriptPurpose data)
             (ipv : (\k v -> List (Tuple2 k v)) bytestring data)
             (ipv : bytestring) ->
              let
                !obsScriptCred' : StakingCredential
                  = `$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData`
                      obsScriptCred
              in
              letrec
                !go : List (Tuple2 StakingCredential integer) -> Bool
                  = \(ds : List (Tuple2 StakingCredential integer)) ->
                      List_match
                        {Tuple2 StakingCredential integer}
                        ds
                        {all dead. Bool}
                        (/\dead -> False)
                        (\(x : Tuple2 StakingCredential integer)
                          (xs : List (Tuple2 StakingCredential integer)) ->
                           /\dead ->
                             Bool_match
                               (Tuple2_match
                                  {StakingCredential}
                                  {integer}
                                  x
                                  {Bool}
                                  (\(ipv : StakingCredential) (ipv : integer) ->
                                     StakingCredential_match
                                       ipv
                                       {Bool}
                                       (\(l : Credential) ->
                                          StakingCredential_match
                                            obsScriptCred'
                                            {Bool}
                                            (\(r : Credential) ->
                                               Credential_match
                                                 l
                                                 {Bool}
                                                 (\(l : bytestring) ->
                                                    Credential_match
                                                      r
                                                      {Bool}
                                                      (\(r : bytestring) ->
                                                         equalsByteString l r)
                                                      (\(ipv : bytestring) ->
                                                         False))
                                                 (\(a : bytestring) ->
                                                    Credential_match
                                                      r
                                                      {Bool}
                                                      (\(ipv : bytestring) ->
                                                         False)
                                                      (\(a' : bytestring) ->
                                                         equalsByteString
                                                           a
                                                           a')))
                                            (\(ipv : integer)
                                              (ipv : integer)
                                              (ipv : integer) ->
                                               False))
                                       (\(a : integer)
                                         (b : integer)
                                         (c : integer) ->
                                          StakingCredential_match
                                            obsScriptCred'
                                            {Bool}
                                            (\(ipv : Credential) -> False)
                                            (\(a' : integer)
                                              (b' : integer)
                                              (c' : integer) ->
                                               Bool_match
                                                 (ifThenElse
                                                    {Bool}
                                                    (equalsInteger a a')
                                                    True
                                                    False)
                                                 {all dead. Bool}
                                                 (/\dead ->
                                                    Bool_match
                                                      (ifThenElse
                                                         {Bool}
                                                         (equalsInteger b b')
                                                         True
                                                         False)
                                                      {all dead. Bool}
                                                      (/\dead ->
                                                         ifThenElse
                                                           {Bool}
                                                           (equalsInteger c c')
                                                           True
                                                           False)
                                                      (/\dead -> False)
                                                      {all dead. dead})
                                                 (/\dead -> False)
                                                 {all dead. dead}))))
                               {all dead. Bool}
                               (/\dead -> True)
                               (/\dead -> go xs)
                               {all dead. dead})
                        {all dead. dead}
              in
              Bool_match
                (go ipv)
                {all dead. Unit}
                (/\dead -> Unit)
                (/\dead -> error {Unit})
                {all dead. dead})))
  (Constr 0 [Constr 0 [B #736f6d6543726564656e7469616c]])
  (Constr 0
     [ Constr 0
         [ List []
         , List []
         , List
             [ Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 1)])]
                 , Constr 0 []
                 , Constr 1 [] ]
             , Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 2)])]
                 , Constr 0 []
                 , Constr 1 [] ]
             , Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 3)])]
                 , Constr 0 []
                 , Constr 1 [] ]
             , Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 4)])]
                 , Constr 0 []
                 , Constr 1 [] ]
             , Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 5)])]
                 , Constr 0 []
                 , Constr 1 [] ]
             , Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 6)])]
                 , Constr 0 []
                 , Constr 1 [] ]
             , Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 7)])]
                 , Constr 0 []
                 , Constr 1 [] ]
             , Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 8)])]
                 , Constr 0 []
                 , Constr 1 [] ]
             , Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 9)])]
                 , Constr 0 []
                 , Constr 1 [] ]
             , Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 10)])]
                 , Constr 0 []
                 , Constr 1 [] ]
             , Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 11)])]
                 , Constr 0 []
                 , Constr 1 [] ]
             , Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 12)])]
                 , Constr 0 []
                 , Constr 1 [] ]
             , Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 13)])]
                 , Constr 0 []
                 , Constr 1 [] ]
             , Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 14)])]
                 , Constr 0 []
                 , Constr 1 [] ]
             , Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 15)])]
                 , Constr 0 []
                 , Constr 1 [] ]
             , Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 16)])]
                 , Constr 0 []
                 , Constr 1 [] ]
             , Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 17)])]
                 , Constr 0 []
                 , Constr 1 [] ]
             , Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 18)])]
                 , Constr 0 []
                 , Constr 1 [] ]
             , Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 19)])]
                 , Constr 0 []
                 , Constr 1 [] ]
             , Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 20)])]
                 , Constr 0 []
                 , Constr 1 [] ] ]
         , Map []
         , Map []
         , List []
         , Map
             [ (Constr 0 [Constr 0 [B #746573744372656431]], I 1)
             , (Constr 0 [Constr 0 [B #746573744372656432]], I 2)
             , (Constr 0 [Constr 0 [B #746573744372656433]], I 3)
             , (Constr 0 [Constr 0 [B #746573744372656434]], I 4)
             , (Constr 0 [Constr 0 [B #746573744372656435]], I 5)
             , (Constr 0 [Constr 0 [B #746573744372656436]], I 6)
             , (Constr 0 [Constr 0 [B #746573744372656437]], I 7)
             , (Constr 0 [Constr 0 [B #746573744372656438]], I 8)
             , (Constr 0 [Constr 0 [B #746573744372656439]], I 9)
             , (Constr 0 [Constr 0 [B #74657374437265643130]], I 10)
             , (Constr 0 [Constr 0 [B #74657374437265643131]], I 11)
             , (Constr 0 [Constr 0 [B #74657374437265643132]], I 12)
             , (Constr 0 [Constr 0 [B #74657374437265643133]], I 13)
             , (Constr 0 [Constr 0 [B #74657374437265643134]], I 14)
             , (Constr 0 [Constr 0 [B #74657374437265643135]], I 15)
             , (Constr 0 [Constr 0 [B #74657374437265643136]], I 16)
             , (Constr 0 [Constr 0 [B #74657374437265643137]], I 17)
             , (Constr 0 [Constr 0 [B #74657374437265643138]], I 18)
             , (Constr 0 [Constr 0 [B #74657374437265643139]], I 19)
             , (Constr 0 [Constr 0 [B #74657374437265643230]], I 20)
             , ( Constr 0 [Constr 0 [B #736f6d6543726564656e7469616c]]
             , I 10000 ) ]
         , Constr 0
             [ Constr 0 [Constr 0 [], Constr 1 []]
             , Constr 0 [Constr 2 [], Constr 1 []] ]
         , List []
         , Map []
         , Map []
         , Constr 0 [B #] ]
     , Constr 1 [Constr 0 [Constr 0 [B #], I 0]] ])