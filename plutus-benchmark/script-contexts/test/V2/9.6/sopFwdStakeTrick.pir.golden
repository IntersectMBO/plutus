let
  data Credential | Credential_match where
    PubKeyCredential : bytestring -> Credential
    ScriptCredential : bytestring -> Credential
  data StakingCredential | StakingCredential_match where
    StakingHash : Credential -> StakingCredential
    StakingPtr : integer -> integer -> integer -> StakingCredential
  !`$fEqStakingCredential_$c==` : StakingCredential -> StakingCredential -> bool
    = \(ds : StakingCredential) (ds : StakingCredential) ->
        StakingCredential_match
          ds
          {bool}
          (\(l : Credential) ->
             StakingCredential_match
               ds
               {bool}
               (\(r : Credential) ->
                  Credential_match
                    l
                    {bool}
                    (\(l : bytestring) ->
                       Credential_match
                         r
                         {bool}
                         (\(r : bytestring) -> equalsByteString l r)
                         (\(ipv : bytestring) -> False))
                    (\(a : bytestring) ->
                       Credential_match
                         r
                         {bool}
                         (\(ipv : bytestring) -> False)
                         (\(a' : bytestring) -> equalsByteString a a')))
               (\(ipv : integer) (ipv : integer) (ipv : integer) -> False))
          (\(a : integer) (b : integer) (c : integer) ->
             StakingCredential_match
               ds
               {bool}
               (\(ipv : Credential) -> False)
               (\(a' : integer) (b' : integer) (c' : integer) ->
                  case
                    (all dead. bool)
                    (equalsInteger a a')
                    [ (/\dead -> False)
                    , (/\dead ->
                         case
                           (all dead. bool)
                           (equalsInteger b b')
                           [(/\dead -> False), (/\dead -> equalsInteger c c')]
                           {all dead. dead}) ]
                    {all dead. dead}))
  !`$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData` : data -> data
    = \(d : data) -> d
  data (Extended :: * -> *) a | Extended_match where
    Finite : a -> Extended a
    NegInf : Extended a
    PosInf : Extended a
  !`$fUnsafeFromDataExtended_$cunsafeFromBuiltinData` :
     all a. (\a -> data -> a) a -> data -> Extended a
    = /\a ->
        \(`$dUnsafeFromData` : (\a -> data -> a) a) (d : data) ->
          case
            (Extended a)
            d
            [ (NegInf {a})
            , (\(arg : data) -> Finite {a} (`$dUnsafeFromData` arg))
            , (PosInf {a}) ]
in
letrec
  data (List :: * -> *) a | List_match where
    Nil : List a
    Cons : a -> List a -> List a
in
let
  !`$fUnsafeFromDataList_$cunsafeFromBuiltinData` :
     all a. (\a -> data -> a) a -> data -> List a
    = /\a ->
        \(`$dUnsafeFromData` : (\a -> data -> a) a) ->
          letrec
            !go : list data -> List a
              = \(xs : list data) ->
                  case
                    (List a)
                    xs
                    [ (\(x : data) (xs : list data) ->
                         Cons {a} (`$dUnsafeFromData` x) (go xs))
                    , (Nil {a}) ]
          in
          \(d : data) -> go (unListData d)
  !`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData` : data -> Credential
    = \(d : data) ->
        case
          Credential
          d
          [ (\(arg : data) -> PubKeyCredential (unBData arg))
          , (\(arg : data) -> ScriptCredential (unBData arg)) ]
  !`$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData` :
     data -> StakingCredential
    = \(d : data) ->
        case
          StakingCredential
          d
          [ (\(arg : data) ->
               StakingHash
                 (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData` arg))
          , (\(arg : data) (arg : data) (arg : data) ->
               StakingPtr (unIData arg) (unIData arg) (unIData arg)) ]
  data DCert | DCert_match where
    DCertDelegDeRegKey : StakingCredential -> DCert
    DCertDelegDelegate : StakingCredential -> bytestring -> DCert
    DCertDelegRegKey : StakingCredential -> DCert
    DCertGenesis : DCert
    DCertMir : DCert
    DCertPoolRegister : bytestring -> bytestring -> DCert
    DCertPoolRetire : bytestring -> integer -> DCert
  !`$fUnsafeFromDataDCert_$cunsafeFromBuiltinData` : data -> DCert
    = \(d : data) ->
        case
          DCert
          d
          [ (\(arg : data) ->
               DCertDelegRegKey
                 (`$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData`
                    arg))
          , (\(arg : data) ->
               DCertDelegDeRegKey
                 (`$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData`
                    arg))
          , (\(arg : data) (arg : data) ->
               DCertDelegDelegate
                 (`$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData`
                    arg)
                 (unBData arg))
          , (\(arg : data) (arg : data) ->
               DCertPoolRegister (unBData arg) (unBData arg))
          , (\(arg : data) (arg : data) ->
               DCertPoolRetire (unBData arg) (unIData arg))
          , DCertGenesis
          , DCertMir ]
  data TxOutRef | TxOutRef_match where
    TxOutRef : bytestring -> integer -> TxOutRef
  !`$fUnsafeFromDataTxOutRef_$cunsafeFromBuiltinData` : data -> TxOutRef
    = \(d : data) ->
        case
          TxOutRef
          d
          [ (\(arg : data) (arg : data) ->
               TxOutRef
                 (case bytestring arg [(\(arg : data) -> unBData arg)])
                 (unIData arg)) ]
  data ScriptPurpose | ScriptPurpose_match where
    Certifying : DCert -> ScriptPurpose
    Minting : bytestring -> ScriptPurpose
    Rewarding : StakingCredential -> ScriptPurpose
    Spending : TxOutRef -> ScriptPurpose
  !`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData` :
     data -> ScriptPurpose
    = \(d : data) ->
        case
          ScriptPurpose
          d
          [ (\(arg : data) -> Minting (unBData arg))
          , (\(arg : data) ->
               Spending
                 (`$fUnsafeFromDataTxOutRef_$cunsafeFromBuiltinData` arg))
          , (\(arg : data) ->
               Rewarding
                 (`$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData`
                    arg))
          , (\(arg : data) ->
               Certifying
                 (`$fUnsafeFromDataDCert_$cunsafeFromBuiltinData` arg)) ]
  data (Maybe :: * -> *) a | Maybe_match where
    Just : a -> Maybe a
    Nothing : Maybe a
  !`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData` :
     all a. (\a -> data -> a) a -> data -> Maybe a
    = /\a ->
        \(`$dUnsafeFromData` : (\a -> data -> a) a) (d : data) ->
          case
            (Maybe a)
            d
            [ (\(arg : data) -> Just {a} (`$dUnsafeFromData` arg))
            , (Nothing {a}) ]
  data (Tuple2 :: * -> * -> *) a b | Tuple2_match where
    Tuple2 : a -> b -> Tuple2 a b
  !`$fUnsafeFromDataMap_$cunsafeFromBuiltinData` :
     all k v.
       (\a -> data -> a) k ->
       (\a -> data -> a) v ->
       data ->
       (\k v -> List (Tuple2 k v)) k v
    = /\k v ->
        \(`$dUnsafeFromData` : (\a -> data -> a) k)
         (`$dUnsafeFromData` : (\a -> data -> a) v) ->
          letrec
            !go : list (pair data data) -> List (Tuple2 k v)
              = \(xs : list (pair data data)) ->
                  case
                    (List (Tuple2 k v))
                    xs
                    [ (\(tup : pair data data) (tups : list (pair data data)) ->
                         Cons
                           {Tuple2 k v}
                           (Tuple2
                              {k}
                              {v}
                              (`$dUnsafeFromData`
                                 (case
                                    data
                                    tup
                                    [(\(l : data) (r : data) -> l)]))
                              (`$dUnsafeFromData`
                                 (case
                                    data
                                    tup
                                    [(\(l : data) (r : data) -> r)])))
                           (go tups))
                    , (Nil {Tuple2 k v}) ]
          in
          \(d : data) -> go (unMapData d)
  ~`$fUnsafeFromDataValue` :
     data -> (\k v -> List (Tuple2 k v)) bytestring integer
    = `$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
        {bytestring}
        {integer}
        unBData
        unIData
  data Address | Address_match where
    Address : Credential -> Maybe StakingCredential -> Address
  data OutputDatum | OutputDatum_match where
    NoOutputDatum : OutputDatum
    OutputDatum : data -> OutputDatum
    OutputDatumHash : bytestring -> OutputDatum
  data TxOut | TxOut_match where
    TxOut :
      Address ->
      (\k v -> List (Tuple2 k v))
        bytestring
        ((\k v -> List (Tuple2 k v)) bytestring integer) ->
      OutputDatum ->
      Maybe bytestring ->
      TxOut
  !`$fUnsafeFromDataTxOut_$cunsafeFromBuiltinData` :
     data -> TxOut
    = \(eta : data) ->
        case
          TxOut
          eta
          [ (\(arg : data)
              (arg : data)
              (arg : data)
              (arg : data) ->
               TxOut
                 (case
                    Address
                    arg
                    [ (\(arg : data)
                        (arg : data) ->
                         Address
                           (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                              arg)
                           (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                              {StakingCredential}
                              `$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData`
                              arg)) ])
                 (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                    {bytestring}
                    {(\k v -> List (Tuple2 k v)) bytestring integer}
                    unBData
                    `$fUnsafeFromDataValue`
                    arg)
                 (case
                    OutputDatum
                    arg
                    [ NoOutputDatum
                    , (\(arg : data) -> OutputDatumHash (unBData arg))
                    , (\(arg : data) -> OutputDatum arg) ])
                 (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                    {bytestring}
                    unBData
                    arg)) ]
  data TxInInfo | TxInInfo_match where
    TxInInfo : TxOutRef -> TxOut -> TxInInfo
  !`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData` : data -> TxInInfo
    = \(d : data) ->
        case
          TxInInfo
          d
          [ (\(arg : data) (arg : data) ->
               TxInInfo
                 (`$fUnsafeFromDataTxOutRef_$cunsafeFromBuiltinData` arg)
                 (`$fUnsafeFromDataTxOut_$cunsafeFromBuiltinData` arg)) ]
  data (LowerBound :: * -> *) a | LowerBound_match where
    LowerBound : Extended a -> bool -> LowerBound a
  data (UpperBound :: * -> *) a | UpperBound_match where
    UpperBound : Extended a -> bool -> UpperBound a
  data (Interval :: * -> *) a | Interval_match where
    Interval : LowerBound a -> UpperBound a -> Interval a
  data TxInfo | TxInfo_match where
    TxInfo :
      List TxInInfo ->
      List TxInInfo ->
      List TxOut ->
      (\k v -> List (Tuple2 k v))
        bytestring
        ((\k v -> List (Tuple2 k v)) bytestring integer) ->
      (\k v -> List (Tuple2 k v))
        bytestring
        ((\k v -> List (Tuple2 k v)) bytestring integer) ->
      List DCert ->
      (\k v -> List (Tuple2 k v)) StakingCredential integer ->
      Interval integer ->
      List bytestring ->
      (\k v -> List (Tuple2 k v)) ScriptPurpose data ->
      (\k v -> List (Tuple2 k v)) bytestring data ->
      bytestring ->
      TxInfo
  data ScriptContext | ScriptContext_match where
    ScriptContext : TxInfo -> ScriptPurpose -> ScriptContext
  data Unit | Unit_match where
    Unit : Unit
in
\(obsScriptCred : data)
 (ctx : data) ->
  ScriptContext_match
    (case
       ScriptContext
       ctx
       [ (\(arg : data)
           (arg : data) ->
            ScriptContext
              (case
                 TxInfo
                 arg
                 [ (\(arg : data)
                     (arg : data)
                     (arg : data)
                     (arg : data)
                     (arg : data)
                     (arg : data)
                     (arg : data)
                     (arg : data)
                     (arg : data)
                     (arg : data)
                     (arg : data)
                     (arg : data) ->
                      TxInfo
                        (`$fUnsafeFromDataList_$cunsafeFromBuiltinData`
                           {TxInInfo}
                           `$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData`
                           arg)
                        (`$fUnsafeFromDataList_$cunsafeFromBuiltinData`
                           {TxInInfo}
                           `$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData`
                           arg)
                        (`$fUnsafeFromDataList_$cunsafeFromBuiltinData`
                           {TxOut}
                           `$fUnsafeFromDataTxOut_$cunsafeFromBuiltinData`
                           arg)
                        (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                           {bytestring}
                           {(\k v -> List (Tuple2 k v)) bytestring integer}
                           unBData
                           `$fUnsafeFromDataValue`
                           arg)
                        (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                           {bytestring}
                           {(\k v -> List (Tuple2 k v)) bytestring integer}
                           unBData
                           `$fUnsafeFromDataValue`
                           arg)
                        (`$fUnsafeFromDataList_$cunsafeFromBuiltinData`
                           {DCert}
                           `$fUnsafeFromDataDCert_$cunsafeFromBuiltinData`
                           arg)
                        (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                           {StakingCredential}
                           {integer}
                           `$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData`
                           unIData
                           arg)
                        (case
                           (Interval integer)
                           arg
                           [ (\(arg : data)
                               (arg : data) ->
                                Interval
                                  {integer}
                                  (case
                                     (LowerBound integer)
                                     arg
                                     [ (\(arg : data)
                                         (arg : data) ->
                                          LowerBound
                                            {integer}
                                            (`$fUnsafeFromDataExtended_$cunsafeFromBuiltinData`
                                               {integer}
                                               unIData
                                               arg)
                                            (case bool arg [False, True])) ])
                                  (case
                                     (UpperBound integer)
                                     arg
                                     [ (\(arg : data)
                                         (arg : data) ->
                                          UpperBound
                                            {integer}
                                            (`$fUnsafeFromDataExtended_$cunsafeFromBuiltinData`
                                               {integer}
                                               unIData
                                               arg)
                                            (case
                                               bool
                                               arg
                                               [False, True])) ])) ])
                        (`$fUnsafeFromDataList_$cunsafeFromBuiltinData`
                           {bytestring}
                           unBData
                           arg)
                        (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                           {ScriptPurpose}
                           {data}
                           `$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData`
                           `$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData`
                           arg)
                        (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                           {bytestring}
                           {data}
                           unBData
                           `$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData`
                           arg)
                        (case
                           bytestring
                           arg
                           [(\(arg : data) -> unBData arg)])) ])
              (`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData` arg)) ])
    {Unit}
    (\(ds : TxInfo)
      (ds : ScriptPurpose) ->
       TxInfo_match
         ds
         {Unit}
         (\(ds : List TxInInfo)
           (ds : List TxInInfo)
           (ds : List TxOut)
           (ds :
              (\k v -> List (Tuple2 k v))
                bytestring
                ((\k v -> List (Tuple2 k v)) bytestring integer))
           (ds :
              (\k v -> List (Tuple2 k v))
                bytestring
                ((\k v -> List (Tuple2 k v)) bytestring integer))
           (ds : List DCert)
           (ds : (\k v -> List (Tuple2 k v)) StakingCredential integer) ->
            let
              !`$j` :
                 StakingCredential -> integer -> Unit
                = \(a : StakingCredential) ->
                    let
                      !`$j` :
                         StakingCredential -> integer -> Unit
                        = \(a : StakingCredential)
                           (ds : integer) ->
                            let
                              !obsScriptCred' :
                                 StakingCredential
                                = `$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData`
                                    obsScriptCred
                            in
                            letrec
                              !go :
                                 List (Tuple2 StakingCredential integer) -> Unit
                                = \(ds :
                                      List
                                        (Tuple2 StakingCredential integer)) ->
                                    List_match
                                      {Tuple2 StakingCredential integer}
                                      ds
                                      {all dead. Unit}
                                      (/\dead ->
                                         let
                                           !x : Unit
                                             = trace {Unit} "not found" Unit
                                         in
                                         error {Unit})
                                      (\(ds : Tuple2 StakingCredential integer)
                                        (xs' :
                                           List
                                             (Tuple2
                                                StakingCredential
                                                integer)) ->
                                         /\dead ->
                                           Tuple2_match
                                             {StakingCredential}
                                             {integer}
                                             ds
                                             {Unit}
                                             (\(c' : StakingCredential)
                                               (i : integer) ->
                                                case
                                                  (all dead. Unit)
                                                  (`$fEqStakingCredential_$c==`
                                                     c'
                                                     obsScriptCred')
                                                  [ (/\dead -> go xs')
                                                  , (/\dead -> Unit) ]
                                                  {all dead. dead}))
                                      {all dead. dead}
                            in
                            case
                              (all dead. Unit)
                              (`$fEqStakingCredential_$c==` obsScriptCred' a)
                              [ (/\dead ->
                                   case
                                     (all dead. Unit)
                                     (`$fEqStakingCredential_$c==`
                                        obsScriptCred'
                                        a)
                                     [(/\dead -> go ds), (/\dead -> Unit)]
                                     {all dead. dead})
                              , (/\dead -> Unit) ]
                              {all dead. dead}
                      !`$j` : List (Tuple2 StakingCredential integer) -> Unit
                        = \(rest : List (Tuple2 StakingCredential integer)) ->
                            List_match
                              {Tuple2 StakingCredential integer}
                              rest
                              {all dead. Unit}
                              (/\dead ->
                                 let
                                   !x : Unit = trace {Unit} "PT8" Unit
                                 in
                                 Tuple2_match
                                   {StakingCredential}
                                   {integer}
                                   (error {Tuple2 StakingCredential integer})
                                   {Unit}
                                   (\(a : StakingCredential) (ds : integer) ->
                                      `$j` a ds))
                              (\(x : Tuple2 StakingCredential integer)
                                (ds :
                                   List (Tuple2 StakingCredential integer)) ->
                                 /\dead ->
                                   Tuple2_match
                                     {StakingCredential}
                                     {integer}
                                     x
                                     {Unit}
                                     (\(a : StakingCredential) (ds : integer) ->
                                        `$j` a ds))
                              {all dead. dead}
                    in
                    \(ds : integer) ->
                      List_match
                        {Tuple2 StakingCredential integer}
                        ds
                        {all dead. Unit}
                        (/\dead ->
                           `$j`
                             (let
                               !x : Unit = trace {Unit} "PT9" Unit
                             in
                             error {List (Tuple2 StakingCredential integer)}))
                        (\(ds : Tuple2 StakingCredential integer)
                          (as : List (Tuple2 StakingCredential integer)) ->
                           /\dead -> `$j` as)
                        {all dead. dead}
            in
            \(ds : Interval integer)
             (ds : List bytestring)
             (ds : (\k v -> List (Tuple2 k v)) ScriptPurpose data)
             (ds : (\k v -> List (Tuple2 k v)) bytestring data)
             (ds : bytestring) ->
              List_match
                {Tuple2 StakingCredential integer}
                ds
                {all dead. Unit}
                (/\dead ->
                   let
                     !x : Unit = trace {Unit} "PT8" Unit
                   in
                   Tuple2_match
                     {StakingCredential}
                     {integer}
                     (error {Tuple2 StakingCredential integer})
                     {Unit}
                     (\(a : StakingCredential) (ds : integer) -> `$j` a ds))
                (\(x : Tuple2 StakingCredential integer)
                  (ds : List (Tuple2 StakingCredential integer)) ->
                   /\dead ->
                     Tuple2_match
                       {StakingCredential}
                       {integer}
                       x
                       {Unit}
                       (\(a : StakingCredential) (ds : integer) -> `$j` a ds))
                {all dead. dead}))