(letrec
    data (List :: * -> *) a | List_match where
      Nil : List a
      Cons : a -> List a -> List a
  in
  letrec
    !go : list data -> List bytestring
      = \(xs : list data) ->
          case
            (List bytestring)
            xs
            [ (\(x : data) (xs : list data) ->
                 Cons {bytestring} (unBData x) (go xs))
            , (Nil {bytestring}) ]
  in
  let
    data Credential | Credential_match where
      PubKeyCredential : bytestring -> Credential
      ScriptCredential : bytestring -> Credential
    data Unit | Unit_match where
      Unit : Unit
    !traceError : all a. string -> a
      = /\a ->
          \(str : string) -> let !x : Unit = trace {Unit} str Unit in error {a}
    !`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData` : data -> Credential
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          case
            (all dead. Credential)
            (equalsInteger 0 index)
            [ (/\dead ->
                 case
                   (all dead. Credential)
                   (equalsInteger 1 index)
                   [ (/\dead -> traceError {Credential} "PT1")
                   , (/\dead ->
                        ScriptCredential (unBData (headList {data} args))) ]
                   {all dead. dead})
            , (/\dead -> PubKeyCredential (unBData (headList {data} args))) ]
            {all dead. dead}
    data StakingCredential | StakingCredential_match where
      StakingHash : Credential -> StakingCredential
      StakingPtr : integer -> integer -> integer -> StakingCredential
    !`$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData` :
       data -> StakingCredential
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          case
            (all dead. StakingCredential)
            (equalsInteger 0 index)
            [ (/\dead ->
                 case
                   (all dead. StakingCredential)
                   (equalsInteger 1 index)
                   [ (/\dead -> traceError {StakingCredential} "PT1")
                   , (/\dead ->
                        let
                          !l : list data = tailList {data} args
                        in
                        StakingPtr
                          (unIData (headList {data} args))
                          (unIData (headList {data} l))
                          (unIData (headList {data} (tailList {data} l)))) ]
                   {all dead. dead})
            , (/\dead ->
                 StakingHash
                   (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                      (headList {data} args))) ]
            {all dead. dead}
    data DCert | DCert_match where
      DCertDelegDeRegKey : StakingCredential -> DCert
      DCertDelegDelegate : StakingCredential -> bytestring -> DCert
      DCertDelegRegKey : StakingCredential -> DCert
      DCertGenesis : DCert
      DCertMir : DCert
      DCertPoolRegister : bytestring -> bytestring -> DCert
      DCertPoolRetire : bytestring -> integer -> DCert
    !`$fUnsafeFromDataDCert_$cunsafeFromBuiltinData` :
       data -> DCert
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          case
            (all dead. DCert)
            (equalsInteger 0 index)
            [ (/\dead ->
                 case
                   (all dead. DCert)
                   (equalsInteger 1 index)
                   [ (/\dead ->
                        case
                          (all dead. DCert)
                          (equalsInteger 2 index)
                          [ (/\dead ->
                               case
                                 (all dead. DCert)
                                 (equalsInteger 3 index)
                                 [ (/\dead ->
                                      case
                                        (all dead. DCert)
                                        (equalsInteger 4 index)
                                        [ (/\dead ->
                                             case
                                               (all dead. DCert)
                                               (equalsInteger 5 index)
                                               [ (/\dead ->
                                                    case
                                                      (all dead. DCert)
                                                      (equalsInteger 6 index)
                                                      [ (/\dead ->
                                                           traceError
                                                             {DCert}
                                                             "PT1")
                                                      , (/\dead -> DCertMir) ]
                                                      {all dead. dead})
                                               , (/\dead -> DCertGenesis) ]
                                               {all dead. dead})
                                        , (/\dead ->
                                             DCertPoolRetire
                                               (unBData (headList {data} args))
                                               (unIData
                                                  (headList
                                                     {data}
                                                     (tailList {data} args)))) ]
                                        {all dead. dead})
                                 , (/\dead ->
                                      DCertPoolRegister
                                        (unBData (headList {data} args))
                                        (unBData
                                           (headList
                                              {data}
                                              (tailList {data} args)))) ]
                                 {all dead. dead})
                          , (/\dead ->
                               DCertDelegDelegate
                                 (`$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData`
                                    (headList {data} args))
                                 (unBData
                                    (headList {data} (tailList {data} args)))) ]
                          {all dead. dead})
                   , (/\dead ->
                        DCertDelegDeRegKey
                          (`$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData`
                             (headList {data} args))) ]
                   {all dead. dead})
            , (/\dead ->
                 DCertDelegRegKey
                   (`$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData`
                      (headList {data} args))) ]
            {all dead. dead}
  in
  letrec
    !go : list data -> List DCert
      = \(xs : list data) ->
          case
            (List DCert)
            xs
            [ (\(x : data) (xs : list data) ->
                 Cons
                   {DCert}
                   (`$fUnsafeFromDataDCert_$cunsafeFromBuiltinData` x)
                   (go xs))
            , (Nil {DCert}) ]
  in
  let
    data (Maybe :: * -> *) a | Maybe_match where
      Just : a -> Maybe a
      Nothing : Maybe a
    !`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData` :
       all a. (\a -> data -> a) a -> data -> Maybe a
      = /\a ->
          \(`$dUnsafeFromData` : (\a -> data -> a) a) (d : data) ->
            let
              !tup : pair integer (list data) = unConstrData d
              !index : integer = fstPair {integer} {list data} tup
              !args : list data = sndPair {integer} {list data} tup
            in
            case
              (all dead. Maybe a)
              (equalsInteger 1 index)
              [ (/\dead ->
                   case
                     (all dead. Maybe a)
                     (equalsInteger 0 index)
                     [ (/\dead -> traceError {Maybe a} "PT1")
                     , (/\dead ->
                          Just
                            {a}
                            (`$dUnsafeFromData` (headList {data} args))) ]
                     {all dead. dead})
              , (/\dead -> Nothing {a}) ]
              {all dead. dead}
    data (Tuple2 :: * -> * -> *) a b | Tuple2_match where
      Tuple2 : a -> b -> Tuple2 a b
    !`$fUnsafeFromDataMap_$cunsafeFromBuiltinData` :
       all k v.
         (\a -> data -> a) k ->
         (\a -> data -> a) v ->
         data ->
         (\k v -> List (Tuple2 k v)) k v
      = /\k v ->
          \(`$dUnsafeFromData` : (\a -> data -> a) k)
           (`$dUnsafeFromData` : (\a -> data -> a) v) ->
            letrec
              !go : list (pair data data) -> List (Tuple2 k v)
                = \(xs : list (pair data data)) ->
                    case
                      (List (Tuple2 k v))
                      xs
                      [ (\(tup : pair data data)
                          (tups : list (pair data data)) ->
                           Cons
                             {Tuple2 k v}
                             (Tuple2
                                {k}
                                {v}
                                (`$dUnsafeFromData` (fstPair {data} {data} tup))
                                (`$dUnsafeFromData`
                                   (sndPair {data} {data} tup)))
                             (go tups))
                      , (Nil {Tuple2 k v}) ]
            in
            \(d : data) -> go (unMapData d)
    ~`$fUnsafeFromDataValue` :
       data -> (\k v -> List (Tuple2 k v)) bytestring integer
      = `$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
          {bytestring}
          {integer}
          unBData
          unIData
    data Address | Address_match where
      Address : Credential -> Maybe StakingCredential -> Address
    data OutputDatum | OutputDatum_match where
      NoOutputDatum : OutputDatum
      OutputDatum : data -> OutputDatum
      OutputDatumHash : bytestring -> OutputDatum
    data TxOut | TxOut_match where
      TxOut :
        Address ->
        (\k v -> List (Tuple2 k v))
          bytestring
          ((\k v -> List (Tuple2 k v)) bytestring integer) ->
        OutputDatum ->
        Maybe bytestring ->
        TxOut
    !`$fUnsafeFromDataTxOut_$cunsafeFromBuiltinData` :
       data -> TxOut
      = \(eta : data) ->
          let
            !tup : pair integer (list data) = unConstrData eta
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          case
            (all dead. TxOut)
            (equalsInteger 0 index)
            [ (/\dead -> traceError {TxOut} "PT1")
            , (/\dead ->
                 let
                   !l : list data = tailList {data} args
                   !l : list data = tailList {data} l
                 in
                 TxOut
                   (let
                     !tup : pair integer (list data)
                       = unConstrData (headList {data} args)
                     !index : integer = fstPair {integer} {list data} tup
                     !args : list data = sndPair {integer} {list data} tup
                   in
                   case
                     (all dead. Address)
                     (equalsInteger 0 index)
                     [ (/\dead -> traceError {Address} "PT1")
                     , (/\dead ->
                          Address
                            (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                               (headList {data} args))
                            (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                               {StakingCredential}
                               `$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData`
                               (headList {data} (tailList {data} args)))) ]
                     {all dead. dead})
                   (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                      {bytestring}
                      {(\k v -> List (Tuple2 k v)) bytestring integer}
                      unBData
                      `$fUnsafeFromDataValue`
                      (headList {data} l))
                   (let
                     !tup : pair integer (list data)
                       = unConstrData (headList {data} l)
                     !index : integer = fstPair {integer} {list data} tup
                     !args : list data = sndPair {integer} {list data} tup
                   in
                   case
                     (all dead. OutputDatum)
                     (equalsInteger 0 index)
                     [ (/\dead ->
                          case
                            (all dead. OutputDatum)
                            (equalsInteger 1 index)
                            [ (/\dead ->
                                 case
                                   (all dead. OutputDatum)
                                   (equalsInteger 2 index)
                                   [ (/\dead -> traceError {OutputDatum} "PT1")
                                   , (/\dead ->
                                        OutputDatum (headList {data} args)) ]
                                   {all dead. dead})
                            , (/\dead ->
                                 OutputDatumHash
                                   (unBData (headList {data} args))) ]
                            {all dead. dead})
                     , (/\dead -> NoOutputDatum) ]
                     {all dead. dead})
                   (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                      {bytestring}
                      unBData
                      (headList {data} (tailList {data} l)))) ]
            {all dead. dead}
  in
  letrec
    !go : list data -> List TxOut
      = \(xs : list data) ->
          case
            (List TxOut)
            xs
            [ (\(x : data) (xs : list data) ->
                 Cons
                   {TxOut}
                   (`$fUnsafeFromDataTxOut_$cunsafeFromBuiltinData` x)
                   (go xs))
            , (Nil {TxOut}) ]
  in
  let
    !`$fUnsafeFromDataTxId_$cunsafeFromBuiltinData` : data -> bytestring
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          case
            (all dead. bytestring)
            (equalsInteger 0 index)
            [ (/\dead -> traceError {bytestring} "PT1")
            , (/\dead -> unBData (headList {data} args)) ]
            {all dead. dead}
    data TxOutRef | TxOutRef_match where
      TxOutRef : bytestring -> integer -> TxOutRef
    !`$fUnsafeFromDataTxOutRef_$cunsafeFromBuiltinData` : data -> TxOutRef
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          case
            (all dead. TxOutRef)
            (equalsInteger 0 index)
            [ (/\dead -> traceError {TxOutRef} "PT1")
            , (/\dead ->
                 TxOutRef
                   (`$fUnsafeFromDataTxId_$cunsafeFromBuiltinData`
                      (headList {data} args))
                   (unIData (headList {data} (tailList {data} args)))) ]
            {all dead. dead}
    data TxInInfo | TxInInfo_match where
      TxInInfo : TxOutRef -> TxOut -> TxInInfo
    !`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData` : data -> TxInInfo
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          case
            (all dead. TxInInfo)
            (equalsInteger 0 index)
            [ (/\dead -> traceError {TxInInfo} "PT1")
            , (/\dead ->
                 TxInInfo
                   (`$fUnsafeFromDataTxOutRef_$cunsafeFromBuiltinData`
                      (headList {data} args))
                   (`$fUnsafeFromDataTxOut_$cunsafeFromBuiltinData`
                      (headList {data} (tailList {data} args)))) ]
            {all dead. dead}
  in
  letrec
    !go : list data -> List TxInInfo
      = \(xs : list data) ->
          case
            (List TxInInfo)
            xs
            [ (\(x : data) (xs : list data) ->
                 Cons
                   {TxInInfo}
                   (`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData` x)
                   (go xs))
            , (Nil {TxInInfo}) ]
  in
  letrec
    !go : list data -> List TxInInfo
      = \(xs : list data) ->
          case
            (List TxInInfo)
            xs
            [ (\(x : data) (xs : list data) ->
                 Cons
                   {TxInInfo}
                   (`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData` x)
                   (go xs))
            , (Nil {TxInInfo}) ]
  in
  let
    !`$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData` : data -> data
      = \(d : data) -> d
    !`$fUnsafeFromDataBool_$cunsafeFromBuiltinData` : data -> bool
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          case
            (all dead. bool)
            (equalsInteger 0 index)
            [ (/\dead ->
                 case
                   (all dead. bool)
                   (equalsInteger 1 index)
                   [(/\dead -> traceError {bool} "PT1"), (/\dead -> True)]
                   {all dead. dead})
            , (/\dead -> False) ]
            {all dead. dead}
    data (Extended :: * -> *) a | Extended_match where
      Finite : a -> Extended a
      NegInf : Extended a
      PosInf : Extended a
    !`$fUnsafeFromDataExtended_$cunsafeFromBuiltinData` :
       all a. (\a -> data -> a) a -> data -> Extended a
      = /\a ->
          \(`$dUnsafeFromData` : (\a -> data -> a) a) (d : data) ->
            let
              !tup : pair integer (list data) = unConstrData d
              !index : integer = fstPair {integer} {list data} tup
              !args : list data = sndPair {integer} {list data} tup
            in
            case
              (all dead. Extended a)
              (equalsInteger 0 index)
              [ (/\dead ->
                   case
                     (all dead. Extended a)
                     (equalsInteger 1 index)
                     [ (/\dead ->
                          case
                            (all dead. Extended a)
                            (equalsInteger 2 index)
                            [ (/\dead -> traceError {Extended a} "PT1")
                            , (/\dead -> PosInf {a}) ]
                            {all dead. dead})
                     , (/\dead ->
                          Finite
                            {a}
                            (`$dUnsafeFromData` (headList {data} args))) ]
                     {all dead. dead})
              , (/\dead -> NegInf {a}) ]
              {all dead. dead}
    data ScriptPurpose | ScriptPurpose_match where
      Certifying : DCert -> ScriptPurpose
      Minting : bytestring -> ScriptPurpose
      Rewarding : StakingCredential -> ScriptPurpose
      Spending : TxOutRef -> ScriptPurpose
    !`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData` :
       data -> ScriptPurpose
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          case
            (all dead. ScriptPurpose)
            (equalsInteger 0 index)
            [ (/\dead ->
                 case
                   (all dead. ScriptPurpose)
                   (equalsInteger 1 index)
                   [ (/\dead ->
                        case
                          (all dead. ScriptPurpose)
                          (equalsInteger 2 index)
                          [ (/\dead ->
                               case
                                 (all dead. ScriptPurpose)
                                 (equalsInteger 3 index)
                                 [ (/\dead -> traceError {ScriptPurpose} "PT1")
                                 , (/\dead ->
                                      Certifying
                                        (`$fUnsafeFromDataDCert_$cunsafeFromBuiltinData`
                                           (headList {data} args))) ]
                                 {all dead. dead})
                          , (/\dead ->
                               Rewarding
                                 (`$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData`
                                    (headList {data} args))) ]
                          {all dead. dead})
                   , (/\dead ->
                        Spending
                          (`$fUnsafeFromDataTxOutRef_$cunsafeFromBuiltinData`
                             (headList {data} args))) ]
                   {all dead. dead})
            , (/\dead -> Minting (unBData (headList {data} args))) ]
            {all dead. dead}
    data (LowerBound :: * -> *) a | LowerBound_match where
      LowerBound : Extended a -> bool -> LowerBound a
    data (UpperBound :: * -> *) a | UpperBound_match where
      UpperBound : Extended a -> bool -> UpperBound a
    data (Interval :: * -> *) a | Interval_match where
      Interval : LowerBound a -> UpperBound a -> Interval a
    data TxInfo | TxInfo_match where
      TxInfo :
        List TxInInfo ->
        List TxInInfo ->
        List TxOut ->
        (\k v -> List (Tuple2 k v))
          bytestring
          ((\k v -> List (Tuple2 k v)) bytestring integer) ->
        (\k v -> List (Tuple2 k v))
          bytestring
          ((\k v -> List (Tuple2 k v)) bytestring integer) ->
        List DCert ->
        (\k v -> List (Tuple2 k v)) StakingCredential integer ->
        Interval integer ->
        List bytestring ->
        (\k v -> List (Tuple2 k v)) ScriptPurpose data ->
        (\k v -> List (Tuple2 k v)) bytestring data ->
        bytestring ->
        TxInfo
    data ScriptContext | ScriptContext_match where
      ScriptContext : TxInfo -> ScriptPurpose -> ScriptContext
  in
  \(d : data) ->
    let
      !ds :
         ScriptContext
        = let
          !tup : pair integer (list data) = unConstrData d
          !index : integer = fstPair {integer} {list data} tup
          !args : list data = sndPair {integer} {list data} tup
        in
        case
          (all dead. ScriptContext)
          (equalsInteger 0 index)
          [ (/\dead -> traceError {ScriptContext} "PT1")
          , (/\dead ->
               ScriptContext
                 (let
                   !tup : pair integer (list data)
                     = unConstrData (headList {data} args)
                   !index : integer = fstPair {integer} {list data} tup
                   !args : list data = sndPair {integer} {list data} tup
                 in
                 case
                   (all dead. TxInfo)
                   (equalsInteger 0 index)
                   [ (/\dead -> traceError {TxInfo} "PT1")
                   , (/\dead ->
                        let
                          !l : list data = tailList {data} args
                          !l : list data = tailList {data} l
                          !l : list data = tailList {data} l
                          !l : list data = tailList {data} l
                          !l : list data = tailList {data} l
                          !l : list data = tailList {data} l
                          !l : list data = tailList {data} l
                          !l : list data = tailList {data} l
                          !l : list data = tailList {data} l
                          !l : list data = tailList {data} l
                        in
                        TxInfo
                          (let
                            !d : data = headList {data} args
                          in
                          go (unListData d))
                          (let
                            !d : data = headList {data} l
                          in
                          go (unListData d))
                          (let
                            !d : data = headList {data} l
                          in
                          go (unListData d))
                          (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                             {bytestring}
                             {(\k v -> List (Tuple2 k v)) bytestring integer}
                             unBData
                             `$fUnsafeFromDataValue`
                             (headList {data} l))
                          (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                             {bytestring}
                             {(\k v -> List (Tuple2 k v)) bytestring integer}
                             unBData
                             `$fUnsafeFromDataValue`
                             (headList {data} l))
                          (let
                            !d : data = headList {data} l
                          in
                          go (unListData d))
                          (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                             {StakingCredential}
                             {integer}
                             `$fUnsafeFromDataStakingCredential_$cunsafeFromBuiltinData`
                             unIData
                             (headList {data} l))
                          (let
                            !tup : pair integer (list data)
                              = unConstrData (headList {data} l)
                            !index : integer = fstPair {integer} {list data} tup
                            !args : list data
                              = sndPair {integer} {list data} tup
                          in
                          case
                            (all dead. Interval integer)
                            (equalsInteger 0 index)
                            [ (/\dead -> traceError {Interval integer} "PT1")
                            , (/\dead ->
                                 Interval
                                   {integer}
                                   (let
                                     !tup : pair integer (list data)
                                       = unConstrData (headList {data} args)
                                     !index : integer
                                       = fstPair {integer} {list data} tup
                                     !args : list data
                                       = sndPair {integer} {list data} tup
                                   in
                                   case
                                     (all dead. LowerBound integer)
                                     (equalsInteger 0 index)
                                     [ (/\dead ->
                                          traceError {LowerBound integer} "PT1")
                                     , (/\dead ->
                                          LowerBound
                                            {integer}
                                            (`$fUnsafeFromDataExtended_$cunsafeFromBuiltinData`
                                               {integer}
                                               unIData
                                               (headList {data} args))
                                            (`$fUnsafeFromDataBool_$cunsafeFromBuiltinData`
                                               (headList
                                                  {data}
                                                  (tailList {data} args)))) ]
                                     {all dead. dead})
                                   (let
                                     !tup : pair integer (list data)
                                       = unConstrData
                                           (headList
                                              {data}
                                              (tailList {data} args))
                                     !index : integer
                                       = fstPair {integer} {list data} tup
                                     !args : list data
                                       = sndPair {integer} {list data} tup
                                   in
                                   case
                                     (all dead. UpperBound integer)
                                     (equalsInteger 0 index)
                                     [ (/\dead ->
                                          traceError {UpperBound integer} "PT1")
                                     , (/\dead ->
                                          UpperBound
                                            {integer}
                                            (`$fUnsafeFromDataExtended_$cunsafeFromBuiltinData`
                                               {integer}
                                               unIData
                                               (headList {data} args))
                                            (`$fUnsafeFromDataBool_$cunsafeFromBuiltinData`
                                               (headList
                                                  {data}
                                                  (tailList {data} args)))) ]
                                     {all dead. dead})) ]
                            {all dead. dead})
                          (let
                            !d : data = headList {data} l
                          in
                          go (unListData d))
                          (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                             {ScriptPurpose}
                             {data}
                             `$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData`
                             `$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData`
                             (headList {data} l))
                          (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                             {bytestring}
                             {data}
                             unBData
                             `$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData`
                             (headList {data} l))
                          (`$fUnsafeFromDataTxId_$cunsafeFromBuiltinData`
                             (headList {data} (tailList {data} l)))) ]
                   {all dead. dead})
                 (`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData`
                    (headList {data} (tailList {data} args)))) ]
          {all dead. dead}
    in
    Unit)
  (Constr 0
     [ Constr 0
         [ List []
         , List []
         , List
             [ Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 1)])]
                 , Constr 0 []
                 , Constr 1 [] ] ]
         , Map []
         , Map []
         , List []
         , Map []
         , Constr 0
             [ Constr 0 [Constr 0 [], Constr 1 []]
             , Constr 0 [Constr 2 [], Constr 1 []] ]
         , List []
         , Map []
         , Map []
         , Constr 0 [B #] ]
     , Constr 1 [Constr 0 [Constr 0 [B #], I 0]] ])