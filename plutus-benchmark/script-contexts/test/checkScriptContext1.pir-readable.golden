(let
    !`$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData` : data -> data
      = \(d : data) -> d
    data Unit | Unit_match where
      Unit : Unit
    !reconstructCaseError : string = "PT1"
    data Bool | Bool_match where
      True : Bool
      False : Bool
    !unitval : unit = ()
    !`$fUnsafeFromDataBool_$cunsafeFromBuiltinData` : data -> Bool
      = \(d : data) ->
          let
            !index : integer = fstPair {integer} {list data} (unConstrData d)
          in
          ifThenElse
            {unit -> Bool}
            (equalsInteger 1 index)
            (\(ds : unit) -> True)
            (\(ds : unit) ->
               ifThenElse
                 {unit -> Bool}
                 (equalsInteger 0 index)
                 (\(ds : unit) -> False)
                 (\(ds : unit) ->
                    let
                      !x : Unit = trace {Unit} reconstructCaseError Unit
                    in
                    error {Bool})
                 unitval)
            unitval
    data (Extended :: * -> *) a | Extended_match where
      Finite : a -> Extended a
      NegInf : Extended a
      PosInf : Extended a
    !`$fUnsafeFromDataExtended_$cunsafeFromBuiltinData` :
       all a. (\a -> data -> a) a -> data -> Extended a
      = /\a ->
          \(`$dUnsafeFromData` : (\a -> data -> a) a) (d : data) ->
            let
              !tup : pair integer (list data) = unConstrData d
              !index : integer = fstPair {integer} {list data} tup
            in
            ifThenElse
              {unit -> Extended a}
              (equalsInteger 2 index)
              (\(ds : unit) -> PosInf {a})
              (\(ds : unit) ->
                 ifThenElse
                   {unit -> Extended a}
                   (equalsInteger 1 index)
                   (\(ds : unit) ->
                      let
                        !arg : data
                          = headList {data} (sndPair {integer} {list data} tup)
                      in
                      Finite {a} (`$dUnsafeFromData` arg))
                   (\(ds : unit) ->
                      ifThenElse
                        {unit -> Extended a}
                        (equalsInteger 0 index)
                        (\(ds : unit) -> NegInf {a})
                        (\(ds : unit) ->
                           let
                             !x : Unit = trace {Unit} reconstructCaseError Unit
                           in
                           error {Extended a})
                        unitval)
                   unitval)
              unitval
    !`$fUnsafeFromDataTxId_$cunsafeFromBuiltinData` : data -> bytestring
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
          in
          ifThenElse
            {unit -> bytestring}
            (equalsInteger 0 (fstPair {integer} {list data} tup))
            (\(ds : unit) ->
               unBData (headList {data} (sndPair {integer} {list data} tup)))
            (\(ds : unit) ->
               let
                 !x : Unit = trace {Unit} reconstructCaseError Unit
               in
               error {bytestring})
            unitval
    data GovernanceActionId | GovernanceActionId_match where
      GovernanceActionId : bytestring -> integer -> GovernanceActionId
    !`$fUnsafeFromDataGovernanceAction_$cunsafeFromBuiltinData` :
       data -> GovernanceActionId
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
          in
          ifThenElse
            {unit -> GovernanceActionId}
            (equalsInteger 0 (fstPair {integer} {list data} tup))
            (\(ds : unit) ->
               let
                 !t : list data = sndPair {integer} {list data} tup
                 !arg : data = headList {data} t
                 !arg : data = headList {data} (tailList {data} t)
               in
               GovernanceActionId
                 (`$fUnsafeFromDataTxId_$cunsafeFromBuiltinData` arg)
                 (unIData arg))
            (\(ds : unit) ->
               let
                 !x : Unit = trace {Unit} reconstructCaseError Unit
               in
               error {GovernanceActionId})
            unitval
    data TxOutRef | TxOutRef_match where
      TxOutRef : bytestring -> integer -> TxOutRef
    !`$fUnsafeFromDataTxOutRef_$cunsafeFromBuiltinData` : data -> TxOutRef
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
          in
          ifThenElse
            {unit -> TxOutRef}
            (equalsInteger 0 (fstPair {integer} {list data} tup))
            (\(ds : unit) ->
               let
                 !t : list data = sndPair {integer} {list data} tup
                 !arg : data = headList {data} t
                 !arg : data = headList {data} (tailList {data} t)
               in
               TxOutRef
                 (`$fUnsafeFromDataTxId_$cunsafeFromBuiltinData` arg)
                 (unIData arg))
            (\(ds : unit) ->
               let
                 !x : Unit = trace {Unit} reconstructCaseError Unit
               in
               error {TxOutRef})
            unitval
    data Credential | Credential_match where
      PubKeyCredential : bytestring -> Credential
      ScriptCredential : bytestring -> Credential
    !`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData` : data -> Credential
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
          in
          ifThenElse
            {unit -> Credential}
            (equalsInteger 1 index)
            (\(ds : unit) ->
               ScriptCredential
                 (unBData
                    (headList {data} (sndPair {integer} {list data} tup))))
            (\(ds : unit) ->
               ifThenElse
                 {unit -> Credential}
                 (equalsInteger 0 index)
                 (\(ds : unit) ->
                    PubKeyCredential
                      (unBData
                         (headList {data} (sndPair {integer} {list data} tup))))
                 (\(ds : unit) ->
                    let
                      !x : Unit = trace {Unit} reconstructCaseError Unit
                    in
                    error {Credential})
                 unitval)
            unitval
    data DRep | DRep_match where
      DRep : Credential -> DRep
      DRepAlwaysAbstain : DRep
      DRepAlwaysNoConfidence : DRep
    !`$fUnsafeFromDataDRep_$cunsafeFromBuiltinData` : data -> DRep
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
          in
          ifThenElse
            {unit -> DRep}
            (equalsInteger 2 index)
            (\(ds : unit) -> DRepAlwaysNoConfidence)
            (\(ds : unit) ->
               ifThenElse
                 {unit -> DRep}
                 (equalsInteger 1 index)
                 (\(ds : unit) -> DRepAlwaysAbstain)
                 (\(ds : unit) ->
                    ifThenElse
                      {unit -> DRep}
                      (equalsInteger 0 index)
                      (\(ds : unit) ->
                         DRep
                           (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                              (headList
                                 {data}
                                 (sndPair {integer} {list data} tup))))
                      (\(ds : unit) ->
                         let
                           !x : Unit = trace {Unit} reconstructCaseError Unit
                         in
                         error {DRep})
                      unitval)
                 unitval)
            unitval
    data Delegatee | Delegatee_match where
      DelegStake : bytestring -> Delegatee
      DelegStakeVote : bytestring -> DRep -> Delegatee
      DelegVote : DRep -> Delegatee
    !`$fUnsafeFromDataDelegatee_$cunsafeFromBuiltinData` : data -> Delegatee
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
          in
          ifThenElse
            {unit -> Delegatee}
            (equalsInteger 2 index)
            (\(ds : unit) ->
               let
                 !t : list data = sndPair {integer} {list data} tup
                 !arg : data = headList {data} t
                 !arg : data = headList {data} (tailList {data} t)
               in
               DelegStakeVote
                 (unBData arg)
                 (`$fUnsafeFromDataDRep_$cunsafeFromBuiltinData` arg))
            (\(ds : unit) ->
               ifThenElse
                 {unit -> Delegatee}
                 (equalsInteger 1 index)
                 (\(ds : unit) ->
                    DelegVote
                      (`$fUnsafeFromDataDRep_$cunsafeFromBuiltinData`
                         (headList {data} (sndPair {integer} {list data} tup))))
                 (\(ds : unit) ->
                    ifThenElse
                      {unit -> Delegatee}
                      (equalsInteger 0 index)
                      (\(ds : unit) ->
                         DelegStake
                           (unBData
                              (headList
                                 {data}
                                 (sndPair {integer} {list data} tup))))
                      (\(ds : unit) ->
                         let
                           !x : Unit = trace {Unit} reconstructCaseError Unit
                         in
                         error {Delegatee})
                      unitval)
                 unitval)
            unitval
    data (Maybe :: * -> *) a | Maybe_match where
      Just : a -> Maybe a
      Nothing : Maybe a
    !`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData` :
       all a. (\a -> data -> a) a -> data -> Maybe a
      = /\a ->
          \(`$dUnsafeFromData` : (\a -> data -> a) a) (d : data) ->
            let
              !tup : pair integer (list data) = unConstrData d
              !index : integer = fstPair {integer} {list data} tup
            in
            ifThenElse
              {unit -> Maybe a}
              (equalsInteger 0 index)
              (\(ds : unit) ->
                 let
                   !arg : data
                     = headList {data} (sndPair {integer} {list data} tup)
                 in
                 Just {a} (`$dUnsafeFromData` arg))
              (\(ds : unit) ->
                 ifThenElse
                   {unit -> Maybe a}
                   (equalsInteger 1 index)
                   (\(ds : unit) -> Nothing {a})
                   (\(ds : unit) ->
                      let
                        !x : Unit = trace {Unit} reconstructCaseError Unit
                      in
                      error {Maybe a})
                   unitval)
              unitval
    data (Tuple2 :: * -> * -> *) a b | Tuple2_match where
      Tuple2 : a -> b -> Tuple2 a b
  in
  letrec
    data (List :: * -> *) a | List_match where
      Nil : List a
      Cons : a -> List a -> List a
  in
  let
    !`$fUnsafeFromDataMap_$cunsafeFromBuiltinData` :
       all k v.
         (\a -> data -> a) k ->
         (\a -> data -> a) v ->
         data ->
         (\k v -> List (Tuple2 k v)) k v
      = /\k v ->
          \(`$dUnsafeFromData` : (\a -> data -> a) k)
           (`$dUnsafeFromData` : (\a -> data -> a) v) ->
            letrec
              !go : list (pair data data) -> List (Tuple2 k v)
                = \(l : list (pair data data)) ->
                    chooseList
                      {pair data data}
                      {Unit -> List (Tuple2 k v)}
                      l
                      (\(ds : Unit) -> Nil {Tuple2 k v})
                      (\(ds : Unit) ->
                         let
                           !tup : pair data data = headList {pair data data} l
                         in
                         Cons
                           {Tuple2 k v}
                           (Tuple2
                              {k}
                              {v}
                              (`$dUnsafeFromData` (fstPair {data} {data} tup))
                              (`$dUnsafeFromData` (sndPair {data} {data} tup)))
                           (go (tailList {pair data data} l)))
                      Unit
            in
            \(d : data) -> go (unMapData d)
    ~`$fUnsafeFromDataValue` :
       data -> (\k v -> List (Tuple2 k v)) bytestring integer
      = `$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
          {bytestring}
          {integer}
          unBData
          unIData
    ~`$fUnsafeFromDataValue` :
       data ->
       (\k v -> List (Tuple2 k v))
         bytestring
         ((\k v -> List (Tuple2 k v)) bytestring integer)
      = `$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
          {bytestring}
          {(\k v -> List (Tuple2 k v)) bytestring integer}
          unBData
          `$fUnsafeFromDataValue`
    data TxCert | TxCert_match where
      TxCertAuthHotCommittee : Credential -> Credential -> TxCert
      TxCertDelegStaking : Credential -> Delegatee -> TxCert
      TxCertRegDRep :
        Credential ->
        (\k v -> List (Tuple2 k v))
          bytestring
          ((\k v -> List (Tuple2 k v)) bytestring integer) ->
        TxCert
      TxCertRegDeleg :
        Credential ->
        Delegatee ->
        (\k v -> List (Tuple2 k v))
          bytestring
          ((\k v -> List (Tuple2 k v)) bytestring integer) ->
        TxCert
      TxCertRegStaking :
        Credential ->
        Maybe
          ((\k v -> List (Tuple2 k v))
             bytestring
             ((\k v -> List (Tuple2 k v)) bytestring integer)) ->
        TxCert
      TxCertResignColdCommittee : Credential -> TxCert
      TxCertUnRegDRep :
        Credential ->
        (\k v -> List (Tuple2 k v))
          bytestring
          ((\k v -> List (Tuple2 k v)) bytestring integer) ->
        TxCert
      TxCertUnRegStaking :
        Credential ->
        Maybe
          ((\k v -> List (Tuple2 k v))
             bytestring
             ((\k v -> List (Tuple2 k v)) bytestring integer)) ->
        TxCert
      TxCertUpdateDRep : Credential -> TxCert
    !`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData` :
       data -> TxCert
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
          in
          ifThenElse
            {unit -> TxCert}
            (equalsInteger 8 index)
            (\(ds : unit) ->
               TxCertResignColdCommittee
                 (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                    (headList {data} (sndPair {integer} {list data} tup))))
            (\(ds : unit) ->
               ifThenElse
                 {unit -> TxCert}
                 (equalsInteger 7 index)
                 (\(ds : unit) ->
                    let
                      !t : list data = sndPair {integer} {list data} tup
                      !arg : data = headList {data} t
                      !arg : data = headList {data} (tailList {data} t)
                    in
                    TxCertAuthHotCommittee
                      (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData` arg)
                      (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                         arg))
                 (\(ds : unit) ->
                    ifThenElse
                      {unit -> TxCert}
                      (equalsInteger 6 index)
                      (\(ds : unit) ->
                         let
                           !t : list data = sndPair {integer} {list data} tup
                           !arg : data = headList {data} t
                           !arg : data = headList {data} (tailList {data} t)
                         in
                         TxCertUnRegDRep
                           (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                              arg)
                           (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                              {bytestring}
                              {(\k v -> List (Tuple2 k v)) bytestring integer}
                              unBData
                              `$fUnsafeFromDataValue`
                              arg))
                      (\(ds : unit) ->
                         ifThenElse
                           {unit -> TxCert}
                           (equalsInteger 5 index)
                           (\(ds : unit) ->
                              TxCertUpdateDRep
                                (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                   (headList
                                      {data}
                                      (sndPair {integer} {list data} tup))))
                           (\(ds : unit) ->
                              ifThenElse
                                {unit -> TxCert}
                                (equalsInteger 4 index)
                                (\(ds : unit) ->
                                   let
                                     !t : list data
                                       = sndPair {integer} {list data} tup
                                     !arg : data = headList {data} t
                                     !arg : data
                                       = headList {data} (tailList {data} t)
                                   in
                                   TxCertRegDRep
                                     (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                        arg)
                                     (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                                        {bytestring}
                                        {(\k v -> List (Tuple2 k v))
                                           bytestring
                                           integer}
                                        unBData
                                        `$fUnsafeFromDataValue`
                                        arg))
                                (\(ds : unit) ->
                                   ifThenElse
                                     {unit -> TxCert}
                                     (equalsInteger 3 index)
                                     (\(ds : unit) ->
                                        let
                                          !t : list data
                                            = sndPair {integer} {list data} tup
                                          !arg : data = headList {data} t
                                          !t : list data = tailList {data} t
                                          !arg : data = headList {data} t
                                          !arg : data
                                            = headList
                                                {data}
                                                (tailList {data} t)
                                        in
                                        TxCertRegDeleg
                                          (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                             arg)
                                          (`$fUnsafeFromDataDelegatee_$cunsafeFromBuiltinData`
                                             arg)
                                          (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                                             {bytestring}
                                             {(\k v -> List (Tuple2 k v))
                                                bytestring
                                                integer}
                                             unBData
                                             `$fUnsafeFromDataValue`
                                             arg))
                                     (\(ds : unit) ->
                                        ifThenElse
                                          {unit -> TxCert}
                                          (equalsInteger 2 index)
                                          (\(ds : unit) ->
                                             let
                                               !t : list data
                                                 = sndPair
                                                     {integer}
                                                     {list data}
                                                     tup
                                               !arg : data = headList {data} t
                                               !arg : data
                                                 = headList
                                                     {data}
                                                     (tailList {data} t)
                                             in
                                             TxCertDelegStaking
                                               (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                                  arg)
                                               (`$fUnsafeFromDataDelegatee_$cunsafeFromBuiltinData`
                                                  arg))
                                          (\(ds : unit) ->
                                             ifThenElse
                                               {unit -> TxCert}
                                               (equalsInteger 1 index)
                                               (\(ds : unit) ->
                                                  let
                                                    !t : list data
                                                      = sndPair
                                                          {integer}
                                                          {list data}
                                                          tup
                                                    !arg : data
                                                      = headList {data} t
                                                    !arg : data
                                                      = headList
                                                          {data}
                                                          (tailList {data} t)
                                                  in
                                                  TxCertUnRegStaking
                                                    (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                                       arg)
                                                    (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                                                       {(\k v ->
                                                           List (Tuple2 k v))
                                                          bytestring
                                                          ((\k v ->
                                                              List (Tuple2 k v))
                                                             bytestring
                                                             integer)}
                                                       `$fUnsafeFromDataValue`
                                                       arg))
                                               (\(ds : unit) ->
                                                  ifThenElse
                                                    {unit -> TxCert}
                                                    (equalsInteger 0 index)
                                                    (\(ds : unit) ->
                                                       let
                                                         !t : list data
                                                           = sndPair
                                                               {integer}
                                                               {list data}
                                                               tup
                                                         !arg : data
                                                           = headList {data} t
                                                         !arg : data
                                                           = headList
                                                               {data}
                                                               (tailList
                                                                  {data}
                                                                  t)
                                                       in
                                                       TxCertRegStaking
                                                         (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                                            arg)
                                                         (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                                                            {(\k v ->
                                                                List
                                                                  (Tuple2 k v))
                                                               bytestring
                                                               ((\k v ->
                                                                   List
                                                                     (Tuple2
                                                                        k
                                                                        v))
                                                                  bytestring
                                                                  integer)}
                                                            `$fUnsafeFromDataValue`
                                                            arg))
                                                    (\(ds : unit) ->
                                                       let
                                                         !x :
                                                            Unit
                                                           = trace
                                                               {Unit}
                                                               reconstructCaseError
                                                               Unit
                                                       in
                                                       error {TxCert})
                                                    unitval)
                                               unitval)
                                          unitval)
                                     unitval)
                                unitval)
                           unitval)
                      unitval)
                 unitval)
            unitval
    data Voter | Voter_match where
      CommitteeVoter : Credential -> Voter
      DRepVoter : Credential -> Voter
      StakePoolVoter : bytestring -> Voter
    !`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData` : data -> Voter
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
          in
          ifThenElse
            {unit -> Voter}
            (equalsInteger 2 index)
            (\(ds : unit) ->
               StakePoolVoter
                 (unBData
                    (headList {data} (sndPair {integer} {list data} tup))))
            (\(ds : unit) ->
               ifThenElse
                 {unit -> Voter}
                 (equalsInteger 1 index)
                 (\(ds : unit) ->
                    DRepVoter
                      (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                         (headList {data} (sndPair {integer} {list data} tup))))
                 (\(ds : unit) ->
                    ifThenElse
                      {unit -> Voter}
                      (equalsInteger 0 index)
                      (\(ds : unit) ->
                         CommitteeVoter
                           (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                              (headList
                                 {data}
                                 (sndPair {integer} {list data} tup))))
                      (\(ds : unit) ->
                         let
                           !x : Unit = trace {Unit} reconstructCaseError Unit
                         in
                         error {Voter})
                      unitval)
                 unitval)
            unitval
    data ScriptPurpose | ScriptPurpose_match where
      Certifying : TxCert -> ScriptPurpose
      Minting : bytestring -> ScriptPurpose
      Proposing : integer -> ScriptPurpose
      Rewarding : Credential -> ScriptPurpose
      Spending : TxOutRef -> ScriptPurpose
      Voting : Voter -> GovernanceActionId -> ScriptPurpose
    !`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData` :
       data -> ScriptPurpose
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
          in
          ifThenElse
            {unit -> ScriptPurpose}
            (equalsInteger 5 index)
            (\(ds : unit) ->
               Proposing
                 (unIData
                    (headList {data} (sndPair {integer} {list data} tup))))
            (\(ds : unit) ->
               ifThenElse
                 {unit -> ScriptPurpose}
                 (equalsInteger 4 index)
                 (\(ds : unit) ->
                    let
                      !t : list data = sndPair {integer} {list data} tup
                      !arg : data = headList {data} t
                      !arg : data = headList {data} (tailList {data} t)
                    in
                    Voting
                      (`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData`
                         arg)
                      (`$fUnsafeFromDataGovernanceAction_$cunsafeFromBuiltinData`
                         arg))
                 (\(ds : unit) ->
                    ifThenElse
                      {unit -> ScriptPurpose}
                      (equalsInteger 3 index)
                      (\(ds : unit) ->
                         Certifying
                           (`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData`
                              (headList
                                 {data}
                                 (sndPair {integer} {list data} tup))))
                      (\(ds : unit) ->
                         ifThenElse
                           {unit -> ScriptPurpose}
                           (equalsInteger 2 index)
                           (\(ds : unit) ->
                              Rewarding
                                (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                   (headList
                                      {data}
                                      (sndPair {integer} {list data} tup))))
                           (\(ds : unit) ->
                              ifThenElse
                                {unit -> ScriptPurpose}
                                (equalsInteger 1 index)
                                (\(ds : unit) ->
                                   Spending
                                     (`$fUnsafeFromDataTxOutRef_$cunsafeFromBuiltinData`
                                        (headList
                                           {data}
                                           (sndPair
                                              {integer}
                                              {list data}
                                              tup))))
                                (\(ds : unit) ->
                                   ifThenElse
                                     {unit -> ScriptPurpose}
                                     (equalsInteger 0 index)
                                     (\(ds : unit) ->
                                        Minting
                                          (unBData
                                             (headList
                                                {data}
                                                (sndPair
                                                   {integer}
                                                   {list data}
                                                   tup))))
                                     (\(ds : unit) ->
                                        let
                                          !x : Unit
                                            = trace
                                                {Unit}
                                                reconstructCaseError
                                                Unit
                                        in
                                        error {ScriptPurpose})
                                     unitval)
                                unitval)
                           unitval)
                      unitval)
                 unitval)
            unitval
    data StakingCredential | StakingCredential_match where
      StakingHash : Credential -> StakingCredential
      StakingPtr : integer -> integer -> integer -> StakingCredential
    data Address | Address_match where
      Address : Credential -> Maybe StakingCredential -> Address
    data OutputDatum | OutputDatum_match where
      NoOutputDatum : OutputDatum
      OutputDatum : data -> OutputDatum
      OutputDatumHash : bytestring -> OutputDatum
    data TxOut | TxOut_match where
      TxOut :
        Address ->
        (\k v -> List (Tuple2 k v))
          bytestring
          ((\k v -> List (Tuple2 k v)) bytestring integer) ->
        OutputDatum ->
        Maybe bytestring ->
        TxOut
    !`$fUnsafeFromDataTxOut_$cunsafeFromBuiltinData` :
       data -> TxOut
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
          in
          ifThenElse
            {unit -> TxOut}
            (equalsInteger 0 (fstPair {integer} {list data} tup))
            (\(ds : unit) ->
               let
                 !t : list data = sndPair {integer} {list data} tup
                 !arg : data = headList {data} t
                 !t : list data = tailList {data} t
                 !arg : data = headList {data} t
                 !t : list data = tailList {data} t
                 !arg : data = headList {data} t
                 !arg : data = headList {data} (tailList {data} t)
               in
               TxOut
                 (let
                   !tup : pair integer (list data) = unConstrData arg
                 in
                 ifThenElse
                   {unit -> Address}
                   (equalsInteger 0 (fstPair {integer} {list data} tup))
                   (\(ds : unit) ->
                      let
                        !t : list data = sndPair {integer} {list data} tup
                        !arg : data = headList {data} t
                        !arg : data = headList {data} (tailList {data} t)
                      in
                      Address
                        (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                           arg)
                        (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                           {StakingCredential}
                           (\(d : data) ->
                              let
                                !tup : pair integer (list data) = unConstrData d
                                !index : integer
                                  = fstPair {integer} {list data} tup
                              in
                              ifThenElse
                                {unit -> StakingCredential}
                                (equalsInteger 1 index)
                                (\(ds : unit) ->
                                   let
                                     !t : list data
                                       = sndPair {integer} {list data} tup
                                     !arg : data = headList {data} t
                                     !t : list data = tailList {data} t
                                     !arg : data = headList {data} t
                                     !arg : data
                                       = headList {data} (tailList {data} t)
                                   in
                                   StakingPtr
                                     (unIData arg)
                                     (unIData arg)
                                     (unIData arg))
                                (\(ds : unit) ->
                                   ifThenElse
                                     {unit -> StakingCredential}
                                     (equalsInteger 0 index)
                                     (\(ds : unit) ->
                                        StakingHash
                                          (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                             (headList
                                                {data}
                                                (sndPair
                                                   {integer}
                                                   {list data}
                                                   tup))))
                                     (\(ds : unit) ->
                                        let
                                          !x : Unit
                                            = trace
                                                {Unit}
                                                reconstructCaseError
                                                Unit
                                        in
                                        error {StakingCredential})
                                     unitval)
                                unitval)
                           arg))
                   (\(ds : unit) ->
                      let
                        !x : Unit = trace {Unit} reconstructCaseError Unit
                      in
                      error {Address})
                   unitval)
                 (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                    {bytestring}
                    {(\k v -> List (Tuple2 k v)) bytestring integer}
                    unBData
                    `$fUnsafeFromDataValue`
                    arg)
                 (let
                   !tup : pair integer (list data) = unConstrData arg
                   !index : integer = fstPair {integer} {list data} tup
                 in
                 ifThenElse
                   {unit -> OutputDatum}
                   (equalsInteger 2 index)
                   (\(ds : unit) ->
                      OutputDatum
                        (headList {data} (sndPair {integer} {list data} tup)))
                   (\(ds : unit) ->
                      ifThenElse
                        {unit -> OutputDatum}
                        (equalsInteger 1 index)
                        (\(ds : unit) ->
                           OutputDatumHash
                             (unBData
                                (headList
                                   {data}
                                   (sndPair {integer} {list data} tup))))
                        (\(ds : unit) ->
                           ifThenElse
                             {unit -> OutputDatum}
                             (equalsInteger 0 index)
                             (\(ds : unit) -> NoOutputDatum)
                             (\(ds : unit) ->
                                let
                                  !x : Unit
                                    = trace {Unit} reconstructCaseError Unit
                                in
                                error {OutputDatum})
                             unitval)
                        unitval)
                   unitval)
                 (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                    {bytestring}
                    unBData
                    arg))
            (\(ds : unit) ->
               let
                 !x : Unit = trace {Unit} reconstructCaseError Unit
               in
               error {TxOut})
            unitval
    data TxInInfo | TxInInfo_match where
      TxInInfo : TxOutRef -> TxOut -> TxInInfo
    !`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData` : data -> TxInInfo
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
          in
          ifThenElse
            {unit -> TxInInfo}
            (equalsInteger 0 (fstPair {integer} {list data} tup))
            (\(ds : unit) ->
               let
                 !t : list data = sndPair {integer} {list data} tup
                 !arg : data = headList {data} t
                 !arg : data = headList {data} (tailList {data} t)
               in
               TxInInfo
                 (`$fUnsafeFromDataTxOutRef_$cunsafeFromBuiltinData` arg)
                 (`$fUnsafeFromDataTxOut_$cunsafeFromBuiltinData` arg))
            (\(ds : unit) ->
               let
                 !x : Unit = trace {Unit} reconstructCaseError Unit
               in
               error {TxInInfo})
            unitval
    !`$fUnsafeFromDataNil_$cunsafeFromBuiltinData` :
       all a. (\a -> data -> a) a -> data -> List a
      = /\a ->
          \(`$dUnsafeFromData` : (\a -> data -> a) a) ->
            letrec
              !go : list data -> List a
                = \(l : list data) ->
                    chooseList
                      {data}
                      {Unit -> List a}
                      l
                      (\(ds : Unit) -> Nil {a})
                      (\(ds : Unit) ->
                         Cons
                           {a}
                           (`$dUnsafeFromData` (headList {data} l))
                           (go (tailList {data} l)))
                      Unit
            in
            \(d : data) -> go (unListData d)
    data (LowerBound :: * -> *) a | LowerBound_match where
      LowerBound : Extended a -> Bool -> LowerBound a
    data (UpperBound :: * -> *) a | UpperBound_match where
      UpperBound : Extended a -> Bool -> UpperBound a
    data (Interval :: * -> *) a | Interval_match where
      Interval : LowerBound a -> UpperBound a -> Interval a
    data Rational | Rational_match where
      Rational : integer -> integer -> Rational
    data Committee | Committee_match where
      Committee :
        (\k v -> List (Tuple2 k v)) Credential integer -> Rational -> Committee
    data ProtocolVersion | ProtocolVersion_match where
      ProtocolVersion : integer -> integer -> ProtocolVersion
    data GovernanceAction | GovernanceAction_match where
      HardForkInitiation :
        Maybe GovernanceActionId -> ProtocolVersion -> GovernanceAction
      InfoAction : GovernanceAction
      NewCommittee :
        Maybe GovernanceActionId ->
        List Credential ->
        Committee ->
        GovernanceAction
      NewConstitution :
        Maybe GovernanceActionId -> Maybe bytestring -> GovernanceAction
      NoConfidence : Maybe GovernanceActionId -> GovernanceAction
      ParameterChange : Maybe GovernanceActionId -> data -> GovernanceAction
      TreasuryWithdrawals :
        (\k v -> List (Tuple2 k v))
          Credential
          ((\k v -> List (Tuple2 k v))
             bytestring
             ((\k v -> List (Tuple2 k v)) bytestring integer)) ->
        GovernanceAction
    data ProposalProcedure | ProposalProcedure_match where
      ProposalProcedure :
        (\k v -> List (Tuple2 k v))
          bytestring
          ((\k v -> List (Tuple2 k v)) bytestring integer) ->
        Credential ->
        GovernanceAction ->
        ProposalProcedure
    data Vote | Vote_match where
      Abstain : Vote
      VoteNo : Vote
      VoteYes : Vote
    data TxInfo | TxInfo_match where
      TxInfo :
        List TxInInfo ->
        List TxInInfo ->
        List TxOut ->
        (\k v -> List (Tuple2 k v))
          bytestring
          ((\k v -> List (Tuple2 k v)) bytestring integer) ->
        (\k v -> List (Tuple2 k v))
          bytestring
          ((\k v -> List (Tuple2 k v)) bytestring integer) ->
        List TxCert ->
        (\k v -> List (Tuple2 k v)) Credential integer ->
        Interval integer ->
        List bytestring ->
        (\k v -> List (Tuple2 k v)) ScriptPurpose data ->
        (\k v -> List (Tuple2 k v)) bytestring data ->
        bytestring ->
        (\k v -> List (Tuple2 k v))
          Voter
          ((\k v -> List (Tuple2 k v)) GovernanceActionId Vote) ->
        List ProposalProcedure ->
        Maybe
          ((\k v -> List (Tuple2 k v))
             bytestring
             ((\k v -> List (Tuple2 k v)) bytestring integer)) ->
        Maybe
          ((\k v -> List (Tuple2 k v))
             bytestring
             ((\k v -> List (Tuple2 k v)) bytestring integer)) ->
        TxInfo
    data ScriptContext | ScriptContext_match where
      ScriptContext : TxInfo -> ScriptPurpose -> ScriptContext
    !`$fAdditiveMonoidInteger_$czero` : integer = 0
  in
  letrec
    !euclid : integer -> integer -> integer
      = \(x : integer) (y : integer) ->
          Bool_match
            (ifThenElse
               {Bool}
               (equalsInteger y `$fAdditiveMonoidInteger_$czero`)
               True
               False)
            {all dead. integer}
            (/\dead -> x)
            (/\dead -> euclid y (modInteger x y))
            {all dead. dead}
  in
  letrec
    !unsafeRatio : integer -> integer -> Rational
      = \(n : integer) (d : integer) ->
          Bool_match
            (ifThenElse
               {Bool}
               (equalsInteger d `$fAdditiveMonoidInteger_$czero`)
               True
               False)
            {all dead. Rational}
            (/\dead -> error {Rational})
            (/\dead ->
               Bool_match
                 (ifThenElse
                    {Bool}
                    (lessThanInteger d `$fAdditiveMonoidInteger_$czero`)
                    True
                    False)
                 {all dead. Rational}
                 (/\dead ->
                    unsafeRatio
                      (subtractInteger `$fAdditiveMonoidInteger_$czero` n)
                      (subtractInteger `$fAdditiveMonoidInteger_$czero` d))
                 (/\dead ->
                    let
                      !gcd' : integer = euclid n d
                      !dt : integer = quotientInteger d gcd'
                    in
                    Rational (quotientInteger n gcd') dt)
                 {all dead. dead})
            {all dead. dead}
  in
  \(d : data) ->
    ScriptContext_match
      (let
        !tup : pair integer (list data) = unConstrData d
      in
      ifThenElse
        {unit -> ScriptContext}
        (equalsInteger 0 (fstPair {integer} {list data} tup))
        (\(ds : unit) ->
           let
             !t : list data = sndPair {integer} {list data} tup
             !arg : data = headList {data} t
             !arg : data = headList {data} (tailList {data} t)
           in
           ScriptContext
             (let
               !tup : pair integer (list data) = unConstrData arg
             in
             ifThenElse
               {unit -> TxInfo}
               (equalsInteger 0 (fstPair {integer} {list data} tup))
               (\(ds : unit) ->
                  let
                    !t : list data = sndPair {integer} {list data} tup
                    !arg : data = headList {data} t
                    !t : list data = tailList {data} t
                    !arg : data = headList {data} t
                    !t : list data = tailList {data} t
                    !arg : data = headList {data} t
                    !t : list data = tailList {data} t
                    !arg : data = headList {data} t
                    !t : list data = tailList {data} t
                    !arg : data = headList {data} t
                    !t : list data = tailList {data} t
                    !arg : data = headList {data} t
                    !t : list data = tailList {data} t
                    !arg : data = headList {data} t
                    !t : list data = tailList {data} t
                    !arg : data = headList {data} t
                    !t : list data = tailList {data} t
                    !arg : data = headList {data} t
                    !t : list data = tailList {data} t
                    !arg : data = headList {data} t
                    !t : list data = tailList {data} t
                    !arg : data = headList {data} t
                    !t : list data = tailList {data} t
                    !arg : data = headList {data} t
                    !t : list data = tailList {data} t
                    !arg : data = headList {data} t
                    !t : list data = tailList {data} t
                    !arg : data = headList {data} t
                    !t : list data = tailList {data} t
                    !arg : data = headList {data} t
                    !arg : data = headList {data} (tailList {data} t)
                  in
                  TxInfo
                    (`$fUnsafeFromDataNil_$cunsafeFromBuiltinData`
                       {TxInInfo}
                       `$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData`
                       arg)
                    (`$fUnsafeFromDataNil_$cunsafeFromBuiltinData`
                       {TxInInfo}
                       `$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData`
                       arg)
                    (`$fUnsafeFromDataNil_$cunsafeFromBuiltinData`
                       {TxOut}
                       `$fUnsafeFromDataTxOut_$cunsafeFromBuiltinData`
                       arg)
                    (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                       {bytestring}
                       {(\k v -> List (Tuple2 k v)) bytestring integer}
                       unBData
                       `$fUnsafeFromDataValue`
                       arg)
                    (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                       {bytestring}
                       {(\k v -> List (Tuple2 k v)) bytestring integer}
                       unBData
                       `$fUnsafeFromDataValue`
                       arg)
                    (`$fUnsafeFromDataNil_$cunsafeFromBuiltinData`
                       {TxCert}
                       `$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData`
                       arg)
                    (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                       {Credential}
                       {integer}
                       `$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                       unIData
                       arg)
                    (let
                      !tup : pair integer (list data) = unConstrData arg
                    in
                    ifThenElse
                      {unit -> Interval integer}
                      (equalsInteger 0 (fstPair {integer} {list data} tup))
                      (\(ds : unit) ->
                         let
                           !t : list data = sndPair {integer} {list data} tup
                           !arg : data = headList {data} t
                           !arg : data = headList {data} (tailList {data} t)
                         in
                         Interval
                           {integer}
                           (let
                             !tup : pair integer (list data) = unConstrData arg
                           in
                           ifThenElse
                             {unit -> LowerBound integer}
                             (equalsInteger
                                0
                                (fstPair {integer} {list data} tup))
                             (\(ds : unit) ->
                                let
                                  !t : list data
                                    = sndPair {integer} {list data} tup
                                  !arg : data = headList {data} t
                                  !arg : data
                                    = headList {data} (tailList {data} t)
                                in
                                LowerBound
                                  {integer}
                                  (`$fUnsafeFromDataExtended_$cunsafeFromBuiltinData`
                                     {integer}
                                     unIData
                                     arg)
                                  (`$fUnsafeFromDataBool_$cunsafeFromBuiltinData`
                                     arg))
                             (\(ds : unit) ->
                                let
                                  !x : Unit
                                    = trace {Unit} reconstructCaseError Unit
                                in
                                error {LowerBound integer})
                             unitval)
                           (let
                             !tup : pair integer (list data) = unConstrData arg
                           in
                           ifThenElse
                             {unit -> UpperBound integer}
                             (equalsInteger
                                0
                                (fstPair {integer} {list data} tup))
                             (\(ds : unit) ->
                                let
                                  !t : list data
                                    = sndPair {integer} {list data} tup
                                  !arg : data = headList {data} t
                                  !arg : data
                                    = headList {data} (tailList {data} t)
                                in
                                UpperBound
                                  {integer}
                                  (`$fUnsafeFromDataExtended_$cunsafeFromBuiltinData`
                                     {integer}
                                     unIData
                                     arg)
                                  (`$fUnsafeFromDataBool_$cunsafeFromBuiltinData`
                                     arg))
                             (\(ds : unit) ->
                                let
                                  !x : Unit
                                    = trace {Unit} reconstructCaseError Unit
                                in
                                error {UpperBound integer})
                             unitval))
                      (\(ds : unit) ->
                         let
                           !x : Unit = trace {Unit} reconstructCaseError Unit
                         in
                         error {Interval integer})
                      unitval)
                    (`$fUnsafeFromDataNil_$cunsafeFromBuiltinData`
                       {bytestring}
                       unBData
                       arg)
                    (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                       {ScriptPurpose}
                       {data}
                       `$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData`
                       `$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData`
                       arg)
                    (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                       {bytestring}
                       {data}
                       unBData
                       `$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData`
                       arg)
                    (`$fUnsafeFromDataTxId_$cunsafeFromBuiltinData` arg)
                    (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                       {Voter}
                       {(\k v -> List (Tuple2 k v)) GovernanceActionId Vote}
                       `$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData`
                       (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                          {GovernanceActionId}
                          {Vote}
                          `$fUnsafeFromDataGovernanceAction_$cunsafeFromBuiltinData`
                          (\(d : data) ->
                             let
                               !index : integer
                                 = fstPair
                                     {integer}
                                     {list data}
                                     (unConstrData d)
                             in
                             ifThenElse
                               {unit -> Vote}
                               (equalsInteger 2 index)
                               (\(ds : unit) -> Abstain)
                               (\(ds : unit) ->
                                  ifThenElse
                                    {unit -> Vote}
                                    (equalsInteger 1 index)
                                    (\(ds : unit) -> VoteYes)
                                    (\(ds : unit) ->
                                       ifThenElse
                                         {unit -> Vote}
                                         (equalsInteger 0 index)
                                         (\(ds : unit) -> VoteNo)
                                         (\(ds : unit) ->
                                            let
                                              !x : Unit
                                                = trace
                                                    {Unit}
                                                    reconstructCaseError
                                                    Unit
                                            in
                                            error {Vote})
                                         unitval)
                                    unitval)
                               unitval))
                       arg)
                    (`$fUnsafeFromDataNil_$cunsafeFromBuiltinData`
                       {ProposalProcedure}
                       (\(d : data) ->
                          let
                            !tup : pair integer (list data) = unConstrData d
                          in
                          ifThenElse
                            {unit -> ProposalProcedure}
                            (equalsInteger
                               0
                               (fstPair {integer} {list data} tup))
                            (\(ds : unit) ->
                               let
                                 !t : list data
                                   = sndPair {integer} {list data} tup
                                 !arg : data = headList {data} t
                                 !t : list data = tailList {data} t
                                 !arg : data = headList {data} t
                                 !arg : data
                                   = headList {data} (tailList {data} t)
                               in
                               ProposalProcedure
                                 (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                                    {bytestring}
                                    {(\k v -> List (Tuple2 k v))
                                       bytestring
                                       integer}
                                    unBData
                                    `$fUnsafeFromDataValue`
                                    arg)
                                 (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                    arg)
                                 (let
                                   !tup : pair integer (list data)
                                     = unConstrData arg
                                   !index : integer
                                     = fstPair {integer} {list data} tup
                                 in
                                 ifThenElse
                                   {unit -> GovernanceAction}
                                   (equalsInteger 6 index)
                                   (\(ds : unit) -> InfoAction)
                                   (\(ds : unit) ->
                                      ifThenElse
                                        {unit -> GovernanceAction}
                                        (equalsInteger 5 index)
                                        (\(ds : unit) ->
                                           let
                                             !t : list data
                                               = sndPair
                                                   {integer}
                                                   {list data}
                                                   tup
                                             !arg : data = headList {data} t
                                             !arg : data
                                               = headList
                                                   {data}
                                                   (tailList {data} t)
                                           in
                                           NewConstitution
                                             (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                                                {GovernanceActionId}
                                                `$fUnsafeFromDataGovernanceAction_$cunsafeFromBuiltinData`
                                                arg)
                                             (let
                                               !tup : pair integer (list data)
                                                 = unConstrData arg
                                             in
                                             ifThenElse
                                               {unit -> Maybe bytestring}
                                               (equalsInteger
                                                  0
                                                  (fstPair
                                                     {integer}
                                                     {list data}
                                                     tup))
                                               (\(ds : unit) ->
                                                  let
                                                    !arg : data
                                                      = headList
                                                          {data}
                                                          (sndPair
                                                             {integer}
                                                             {list data}
                                                             tup)
                                                  in
                                                  `$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                                                    {bytestring}
                                                    unBData
                                                    arg)
                                               (\(ds : unit) ->
                                                  let
                                                    !x : Unit
                                                      = trace
                                                          {Unit}
                                                          reconstructCaseError
                                                          Unit
                                                  in
                                                  error {Maybe bytestring})
                                               unitval))
                                        (\(ds : unit) ->
                                           ifThenElse
                                             {unit -> GovernanceAction}
                                             (equalsInteger 4 index)
                                             (\(ds : unit) ->
                                                let
                                                  !t : list data
                                                    = sndPair
                                                        {integer}
                                                        {list data}
                                                        tup
                                                  !arg : data
                                                    = headList {data} t
                                                  !t : list data
                                                    = tailList {data} t
                                                  !arg : data
                                                    = headList {data} t
                                                  !arg : data
                                                    = headList
                                                        {data}
                                                        (tailList {data} t)
                                                in
                                                NewCommittee
                                                  (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                                                     {GovernanceActionId}
                                                     `$fUnsafeFromDataGovernanceAction_$cunsafeFromBuiltinData`
                                                     arg)
                                                  (`$fUnsafeFromDataNil_$cunsafeFromBuiltinData`
                                                     {Credential}
                                                     `$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                                     arg)
                                                  (let
                                                    !tup :
                                                       pair integer (list data)
                                                      = unConstrData arg
                                                  in
                                                  ifThenElse
                                                    {unit -> Committee}
                                                    (equalsInteger
                                                       0
                                                       (fstPair
                                                          {integer}
                                                          {list data}
                                                          tup))
                                                    (\(ds : unit) ->
                                                       let
                                                         !t : list data
                                                           = sndPair
                                                               {integer}
                                                               {list data}
                                                               tup
                                                         !arg : data
                                                           = headList {data} t
                                                         !arg : data
                                                           = headList
                                                               {data}
                                                               (tailList
                                                                  {data}
                                                                  t)
                                                       in
                                                       Committee
                                                         (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                                                            {Credential}
                                                            {integer}
                                                            `$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                                            unIData
                                                            arg)
                                                         (Tuple2_match
                                                            {integer}
                                                            {integer}
                                                            (let
                                                              !tup :
                                                                 pair
                                                                   integer
                                                                   (list data)
                                                                = unConstrData
                                                                    arg
                                                            in
                                                            ifThenElse
                                                              {unit ->
                                                               Tuple2
                                                                 integer
                                                                 integer}
                                                              (equalsInteger
                                                                 0
                                                                 (fstPair
                                                                    {integer}
                                                                    {list data}
                                                                    tup))
                                                              (\(ds : unit) ->
                                                                 let
                                                                   !t :
                                                                      list data
                                                                     = sndPair
                                                                         {integer}
                                                                         {list
                                                                            data}
                                                                         tup
                                                                   !arg : data
                                                                     = headList
                                                                         {data}
                                                                         t
                                                                   !arg :
                                                                      data
                                                                     = headList
                                                                         {data}
                                                                         (tailList
                                                                            {data}
                                                                            t)
                                                                 in
                                                                 Tuple2
                                                                   {integer}
                                                                   {integer}
                                                                   (unIData arg)
                                                                   (unIData
                                                                      arg))
                                                              (\(ds : unit) ->
                                                                 let
                                                                   !x :
                                                                      Unit
                                                                     = trace
                                                                         {Unit}
                                                                         reconstructCaseError
                                                                         Unit
                                                                 in
                                                                 error
                                                                   {Tuple2
                                                                      integer
                                                                      integer})
                                                              unitval)
                                                            {Rational}
                                                            (\(a : integer)
                                                              (b : integer) ->
                                                               unsafeRatio
                                                                 a
                                                                 b)))
                                                    (\(ds : unit) ->
                                                       let
                                                         !x :
                                                            Unit
                                                           = trace
                                                               {Unit}
                                                               reconstructCaseError
                                                               Unit
                                                       in
                                                       error {Committee})
                                                    unitval))
                                             (\(ds : unit) ->
                                                ifThenElse
                                                  {unit -> GovernanceAction}
                                                  (equalsInteger 3 index)
                                                  (\(ds : unit) ->
                                                     let
                                                       !arg : data
                                                         = headList
                                                             {data}
                                                             (sndPair
                                                                {integer}
                                                                {list data}
                                                                tup)
                                                     in
                                                     NoConfidence
                                                       (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                                                          {GovernanceActionId}
                                                          `$fUnsafeFromDataGovernanceAction_$cunsafeFromBuiltinData`
                                                          arg))
                                                  (\(ds : unit) ->
                                                     ifThenElse
                                                       {unit ->
                                                        GovernanceAction}
                                                       (equalsInteger 2 index)
                                                       (\(ds : unit) ->
                                                          let
                                                            !arg : data
                                                              = headList
                                                                  {data}
                                                                  (sndPair
                                                                     {integer}
                                                                     {list data}
                                                                     tup)
                                                          in
                                                          TreasuryWithdrawals
                                                            (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                                                               {Credential}
                                                               {(\k v ->
                                                                   List
                                                                     (Tuple2
                                                                        k
                                                                        v))
                                                                  bytestring
                                                                  ((\k v ->
                                                                      List
                                                                        (Tuple2
                                                                           k
                                                                           v))
                                                                     bytestring
                                                                     integer)}
                                                               `$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                                               `$fUnsafeFromDataValue`
                                                               arg))
                                                       (\(ds : unit) ->
                                                          ifThenElse
                                                            {unit ->
                                                             GovernanceAction}
                                                            (equalsInteger
                                                               1
                                                               index)
                                                            (\(ds : unit) ->
                                                               let
                                                                 !t : list data
                                                                   = sndPair
                                                                       {integer}
                                                                       {list
                                                                          data}
                                                                       tup
                                                                 !arg : data
                                                                   = headList
                                                                       {data}
                                                                       t
                                                                 !arg : data
                                                                   = headList
                                                                       {data}
                                                                       (tailList
                                                                          {data}
                                                                          t)
                                                               in
                                                               HardForkInitiation
                                                                 (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                                                                    {GovernanceActionId}
                                                                    `$fUnsafeFromDataGovernanceAction_$cunsafeFromBuiltinData`
                                                                    arg)
                                                                 (let
                                                                   !tup :
                                                                      pair
                                                                        integer
                                                                        (list
                                                                           data)
                                                                     = unConstrData
                                                                         arg
                                                                 in
                                                                 ifThenElse
                                                                   {unit ->
                                                                    ProtocolVersion}
                                                                   (equalsInteger
                                                                      0
                                                                      (fstPair
                                                                         {integer}
                                                                         {list
                                                                            data}
                                                                         tup))
                                                                   (\(ds :
                                                                        unit) ->
                                                                      let
                                                                        !t :
                                                                           list
                                                                             data
                                                                          = sndPair
                                                                              {integer}
                                                                              {list
                                                                                 data}
                                                                              tup
                                                                        !arg :
                                                                           data
                                                                          = headList
                                                                              {data}
                                                                              t
                                                                        !arg :
                                                                           data
                                                                          = headList
                                                                              {data}
                                                                              (tailList
                                                                                 {data}
                                                                                 t)
                                                                      in
                                                                      ProtocolVersion
                                                                        (unIData
                                                                           arg)
                                                                        (unIData
                                                                           arg))
                                                                   (\(ds :
                                                                        unit) ->
                                                                      let
                                                                        !x :
                                                                           Unit
                                                                          = trace
                                                                              {Unit}
                                                                              reconstructCaseError
                                                                              Unit
                                                                      in
                                                                      error
                                                                        {ProtocolVersion})
                                                                   unitval))
                                                            (\(ds : unit) ->
                                                               ifThenElse
                                                                 {unit ->
                                                                  GovernanceAction}
                                                                 (equalsInteger
                                                                    0
                                                                    index)
                                                                 (\(ds :
                                                                      unit) ->
                                                                    let
                                                                      !t :
                                                                         list
                                                                           data
                                                                        = sndPair
                                                                            {integer}
                                                                            {list
                                                                               data}
                                                                            tup
                                                                      !arg :
                                                                         data
                                                                        = headList
                                                                            {data}
                                                                            t
                                                                      !arg :
                                                                         data
                                                                        = headList
                                                                            {data}
                                                                            (tailList
                                                                               {data}
                                                                               t)
                                                                    in
                                                                    ParameterChange
                                                                      (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                                                                         {GovernanceActionId}
                                                                         `$fUnsafeFromDataGovernanceAction_$cunsafeFromBuiltinData`
                                                                         arg)
                                                                      arg)
                                                                 (\(ds :
                                                                      unit) ->
                                                                    let
                                                                      !x :
                                                                         Unit
                                                                        = trace
                                                                            {Unit}
                                                                            reconstructCaseError
                                                                            Unit
                                                                    in
                                                                    error
                                                                      {GovernanceAction})
                                                                 unitval)
                                                            unitval)
                                                       unitval)
                                                  unitval)
                                             unitval)
                                        unitval)
                                   unitval))
                            (\(ds : unit) ->
                               let
                                 !x : Unit
                                   = trace {Unit} reconstructCaseError Unit
                               in
                               error {ProposalProcedure})
                            unitval)
                       arg)
                    (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                       {(\k v -> List (Tuple2 k v))
                          bytestring
                          ((\k v -> List (Tuple2 k v)) bytestring integer)}
                       `$fUnsafeFromDataValue`
                       arg)
                    (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                       {(\k v -> List (Tuple2 k v))
                          bytestring
                          ((\k v -> List (Tuple2 k v)) bytestring integer)}
                       `$fUnsafeFromDataValue`
                       arg))
               (\(ds : unit) ->
                  let
                    !x : Unit = trace {Unit} reconstructCaseError Unit
                  in
                  error {TxInfo})
               unitval)
             (`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData` arg))
        (\(ds : unit) ->
           let
             !x : Unit = trace {Unit} reconstructCaseError Unit
           in
           error {ScriptContext})
        unitval)
      {Unit}
      (\(txi : TxInfo) (ds : ScriptPurpose) ->
         Bool_match
           (ifThenElse
              {Bool}
              (equalsInteger
                 0
                 (modInteger
                    (let
                      !eta : List TxOut
                        = TxInfo_match
                            txi
                            {List TxOut}
                            (\(ds : List TxInInfo)
                              (ds : List TxInInfo)
                              (ds : List TxOut)
                              (ds :
                                 (\k v -> List (Tuple2 k v))
                                   bytestring
                                   ((\k v -> List (Tuple2 k v))
                                      bytestring
                                      integer))
                              (ds :
                                 (\k v -> List (Tuple2 k v))
                                   bytestring
                                   ((\k v -> List (Tuple2 k v))
                                      bytestring
                                      integer))
                              (ds : List TxCert)
                              (ds :
                                 (\k v -> List (Tuple2 k v)) Credential integer)
                              (ds : Interval integer)
                              (ds : List bytestring)
                              (ds :
                                 (\k v -> List (Tuple2 k v)) ScriptPurpose data)
                              (ds : (\k v -> List (Tuple2 k v)) bytestring data)
                              (ds : bytestring)
                              (ds :
                                 (\k v -> List (Tuple2 k v))
                                   Voter
                                   ((\k v -> List (Tuple2 k v))
                                      GovernanceActionId
                                      Vote))
                              (ds : List ProposalProcedure)
                              (ds :
                                 Maybe
                                   ((\k v -> List (Tuple2 k v))
                                      bytestring
                                      ((\k v -> List (Tuple2 k v))
                                         bytestring
                                         integer)))
                              (ds :
                                 Maybe
                                   ((\k v -> List (Tuple2 k v))
                                      bytestring
                                      ((\k v -> List (Tuple2 k v))
                                         bytestring
                                         integer))) ->
                               ds)
                    in
                    (let
                        b = integer -> integer
                      in
                      \(f : TxOut -> b -> b) (z : b) ->
                        letrec
                          !go : List TxOut -> b
                            = \(ds : List TxOut) ->
                                List_match
                                  {TxOut}
                                  ds
                                  {all dead. b}
                                  (/\dead -> z)
                                  (\(x : TxOut) (xs : List TxOut) ->
                                     /\dead -> f x (go xs))
                                  {all dead. dead}
                        in
                        \(eta : List TxOut) -> go eta)
                      (\(a : TxOut) (g : integer -> integer) (b : integer) ->
                         g (addInteger 1 b))
                      (\(x : integer) -> x)
                      eta
                      0)
                    2))
              True
              False)
           {all dead. Unit}
           (/\dead -> Unit)
           (/\dead -> error {Unit})
           {all dead. dead}))
  (Constr 0
     [ Constr 0
         [ List []
         , List []
         , List
             [ Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 1)])]
                 , Constr 0 []
                 , Constr 1 [] ] ]
         , Map []
         , Map []
         , List []
         , Map []
         , Constr 0
             [ Constr 0 [Constr 0 [], Constr 1 []]
             , Constr 0 [Constr 2 [], Constr 1 []] ]
         , List []
         , Map []
         , Map []
         , Constr 0 [B #]
         , Map []
         , List []
         , Constr 1 []
         , Constr 1 [] ]
     , Constr 1 [Constr 0 [Constr 0 [B #], I 0]] ])