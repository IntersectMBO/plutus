(letrec
    ~go : list data -> integer -> integer
      = (let
            r = integer -> integer
          in
          \(z : r) (f : data -> list data -> r) (xs : list data) ->
            chooseList
              {data}
              {all dead. r}
              xs
              (/\dead -> z)
              (/\dead -> f (headList {data} xs) (tailList {data} xs))
              {r})
          (\(x : integer) -> x)
          (\(ds : data) (t : list data) (eta : integer) ->
             addInteger 1 (go t eta))
  in
  let
    data Bool | Bool_match where
      True : Bool
      False : Bool
    data Unit | Unit_match where
      Unit : Unit
    !traceError : all a. string -> a
      = /\a ->
          \(str : string) -> let !x : Unit = trace {Unit} str Unit in error {a}
    !`$fUnsafeFromDataBool_$cunsafeFromBuiltinData` : data -> Bool
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          Bool_match
            (ifThenElse {Bool} (equalsInteger 0 index) True False)
            {all dead. Bool}
            (/\dead -> False)
            (/\dead ->
               Bool_match
                 (ifThenElse {Bool} (equalsInteger 1 index) True False)
                 {all dead. Bool}
                 (/\dead -> True)
                 (/\dead -> traceError {Bool} "PT1")
                 {all dead. dead})
            {all dead. dead}
    data (Extended :: * -> *) a | Extended_match where
      Finite : a -> Extended a
      NegInf : Extended a
      PosInf : Extended a
    !`$fUnsafeFromDataExtended_$cunsafeFromBuiltinData` :
       all a. (\a -> data -> a) a -> data -> Extended a
      = /\a ->
          \(`$dUnsafeFromData` : (\a -> data -> a) a) (d : data) ->
            let
              !tup : pair integer (list data) = unConstrData d
              !index : integer = fstPair {integer} {list data} tup
              !args : list data = sndPair {integer} {list data} tup
            in
            Bool_match
              (ifThenElse {Bool} (equalsInteger 0 index) True False)
              {all dead. Extended a}
              (/\dead -> NegInf {a})
              (/\dead ->
                 Bool_match
                   (ifThenElse {Bool} (equalsInteger 1 index) True False)
                   {all dead. Extended a}
                   (/\dead ->
                      Finite {a} (`$dUnsafeFromData` (headList {data} args)))
                   (/\dead ->
                      Bool_match
                        (ifThenElse {Bool} (equalsInteger 2 index) True False)
                        {all dead. Extended a}
                        (/\dead -> PosInf {a})
                        (/\dead -> traceError {Extended a} "PT1")
                        {all dead. dead})
                   {all dead. dead})
              {all dead. dead}
    data (Maybe :: * -> *) a | Maybe_match where
      Just : a -> Maybe a
      Nothing : Maybe a
    !`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData` :
       all a. (\a -> data -> a) a -> data -> Maybe a
      = /\a ->
          \(`$dUnsafeFromData` : (\a -> data -> a) a) (d : data) ->
            let
              !tup : pair integer (list data) = unConstrData d
              !index : integer = fstPair {integer} {list data} tup
              !args : list data = sndPair {integer} {list data} tup
            in
            Bool_match
              (ifThenElse {Bool} (equalsInteger 1 index) True False)
              {all dead. Maybe a}
              (/\dead -> Nothing {a})
              (/\dead ->
                 Bool_match
                   (ifThenElse {Bool} (equalsInteger 0 index) True False)
                   {all dead. Maybe a}
                   (/\dead ->
                      Just {a} (`$dUnsafeFromData` (headList {data} args)))
                   (/\dead -> traceError {Maybe a} "PT1")
                   {all dead. dead})
              {all dead. dead}
    data (Solo :: * -> *) a | Solo_match where
      MkSolo : a -> Solo a
    data (LowerBound :: * -> *) a | LowerBound_match where
      LowerBound : Extended a -> Bool -> LowerBound a
    data (UpperBound :: * -> *) a | UpperBound_match where
      UpperBound : Extended a -> Bool -> UpperBound a
    data (Interval :: * -> *) a | Interval_match where
      Interval : LowerBound a -> UpperBound a -> Interval a
    Credential = all a. a -> a
    Voter = all a. a -> a
    Vote = all a. a -> a
    TxOut = all a. a -> a
    TxInInfo = all a. a -> a
    GovernanceActionId = all a. a -> a
    ProposalProcedure = all a. a -> a
    ScriptPurpose = all a. a -> a
  in
  \(d : data) ->
    Solo_match
      {data}
      ((let
           r = Solo data
         in
         \(scrut : data)
          (cont : data -> data -> data -> r)
          (fail : unit -> r) ->
           let
             !tup : pair integer (list data) = unConstrData scrut
           in
           Bool_match
             (ifThenElse
                {Bool}
                (equalsInteger 0 (fstPair {integer} {list data} tup))
                True
                False)
             {all dead. r}
             (/\dead ->
                let
                  !l : list data = sndPair {integer} {list data} tup
                  !l : list data = tailList {data} l
                in
                cont
                  (headList {data} l)
                  (headList {data} l)
                  (headList {data} (tailList {data} l)))
             (/\dead -> fail ())
             {all dead. dead})
         d
         (\(txi : data) (ds : data) (ds : data) -> MkSolo {data} txi)
         (\(void : unit) ->
            Unit_match (error {Unit}) {Solo data} (error {Solo data})))
      {Unit}
      (\(ipv : data) ->
         Bool_match
           (ifThenElse
              {Bool}
              (equalsInteger
                 0
                 (modInteger
                    (let
                      !ds :
                         (\a -> list data) TxOut
                        = (let
                              r = (\a -> list data) TxOut
                            in
                            \(scrut : data)
                             (cont :
                                (\a -> list data) TxInInfo ->
                                (\a -> list data) TxInInfo ->
                                (\a -> list data) TxOut ->
                                integer ->
                                (\k a -> list (pair data data))
                                  bytestring
                                  ((\k a -> list (pair data data))
                                     bytestring
                                     integer) ->
                                (\a -> list data) data ->
                                (\k a -> list (pair data data))
                                  Credential
                                  integer ->
                                Interval integer ->
                                (\a -> list data) bytestring ->
                                (\k a -> list (pair data data))
                                  ScriptPurpose
                                  data ->
                                (\k a -> list (pair data data))
                                  bytestring
                                  data ->
                                bytestring ->
                                (\k a -> list (pair data data))
                                  Voter
                                  ((\k a -> list (pair data data))
                                     GovernanceActionId
                                     Vote) ->
                                (\a -> list data) ProposalProcedure ->
                                Maybe integer ->
                                Maybe integer ->
                                r)
                             (fail : unit -> r) ->
                              let
                                !tup : pair integer (list data)
                                  = unConstrData scrut
                              in
                              Bool_match
                                (ifThenElse
                                   {Bool}
                                   (equalsInteger
                                      0
                                      (fstPair {integer} {list data} tup))
                                   True
                                   False)
                                {all dead. r}
                                (/\dead ->
                                   let
                                     !l : list data
                                       = sndPair {integer} {list data} tup
                                     !l : list data = tailList {data} l
                                     !l : list data = tailList {data} l
                                     !l : list data = tailList {data} l
                                     !l : list data = tailList {data} l
                                     !l : list data = tailList {data} l
                                     !l : list data = tailList {data} l
                                     !l : list data = tailList {data} l
                                     !l : list data = tailList {data} l
                                     !l : list data = tailList {data} l
                                     !l : list data = tailList {data} l
                                     !l : list data = tailList {data} l
                                     !l : list data = tailList {data} l
                                     !l : list data = tailList {data} l
                                     !l : list data = tailList {data} l
                                   in
                                   cont
                                     (unListData (headList {data} l))
                                     (unListData (headList {data} l))
                                     (unListData (headList {data} l))
                                     (unIData (headList {data} l))
                                     (unMapData (headList {data} l))
                                     (unListData (headList {data} l))
                                     (unMapData (headList {data} l))
                                     (let
                                       !tup : pair integer (list data)
                                         = unConstrData (headList {data} l)
                                       !index : integer
                                         = fstPair {integer} {list data} tup
                                       !args : list data
                                         = sndPair {integer} {list data} tup
                                     in
                                     Bool_match
                                       (ifThenElse
                                          {Bool}
                                          (equalsInteger 0 index)
                                          True
                                          False)
                                       {all dead. Interval integer}
                                       (/\dead ->
                                          Interval
                                            {integer}
                                            (let
                                              !tup : pair integer (list data)
                                                = unConstrData
                                                    (headList {data} args)
                                              !index : integer
                                                = fstPair
                                                    {integer}
                                                    {list data}
                                                    tup
                                              !args : list data
                                                = sndPair
                                                    {integer}
                                                    {list data}
                                                    tup
                                            in
                                            Bool_match
                                              (ifThenElse
                                                 {Bool}
                                                 (equalsInteger 0 index)
                                                 True
                                                 False)
                                              {all dead. LowerBound integer}
                                              (/\dead ->
                                                 LowerBound
                                                   {integer}
                                                   (`$fUnsafeFromDataExtended_$cunsafeFromBuiltinData`
                                                      {integer}
                                                      unIData
                                                      (headList {data} args))
                                                   (`$fUnsafeFromDataBool_$cunsafeFromBuiltinData`
                                                      (headList
                                                         {data}
                                                         (tailList
                                                            {data}
                                                            args))))
                                              (/\dead ->
                                                 traceError
                                                   {LowerBound integer}
                                                   "PT1")
                                              {all dead. dead})
                                            (let
                                              !tup : pair integer (list data)
                                                = unConstrData
                                                    (headList
                                                       {data}
                                                       (tailList {data} args))
                                              !index : integer
                                                = fstPair
                                                    {integer}
                                                    {list data}
                                                    tup
                                              !args : list data
                                                = sndPair
                                                    {integer}
                                                    {list data}
                                                    tup
                                            in
                                            Bool_match
                                              (ifThenElse
                                                 {Bool}
                                                 (equalsInteger 0 index)
                                                 True
                                                 False)
                                              {all dead. UpperBound integer}
                                              (/\dead ->
                                                 UpperBound
                                                   {integer}
                                                   (`$fUnsafeFromDataExtended_$cunsafeFromBuiltinData`
                                                      {integer}
                                                      unIData
                                                      (headList {data} args))
                                                   (`$fUnsafeFromDataBool_$cunsafeFromBuiltinData`
                                                      (headList
                                                         {data}
                                                         (tailList
                                                            {data}
                                                            args))))
                                              (/\dead ->
                                                 traceError
                                                   {UpperBound integer}
                                                   "PT1")
                                              {all dead. dead}))
                                       (/\dead ->
                                          traceError {Interval integer} "PT1")
                                       {all dead. dead})
                                     (unListData (headList {data} l))
                                     (unMapData (headList {data} l))
                                     (unMapData (headList {data} l))
                                     (unBData (headList {data} l))
                                     (unMapData (headList {data} l))
                                     (unListData (headList {data} l))
                                     (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                                        {integer}
                                        unIData
                                        (headList {data} l))
                                     (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                                        {integer}
                                        unIData
                                        (headList {data} (tailList {data} l))))
                                (/\dead -> fail ())
                                {all dead. dead})
                            ipv
                            (\(ds : (\a -> list data) TxInInfo)
                              (ds : (\a -> list data) TxInInfo)
                              (ds : (\a -> list data) TxOut)
                              (ds : integer)
                              (ds :
                                 (\k a -> list (pair data data))
                                   bytestring
                                   ((\k a -> list (pair data data))
                                      bytestring
                                      integer))
                              (ds : (\a -> list data) data)
                              (ds :
                                 (\k a -> list (pair data data))
                                   Credential
                                   integer)
                              (ds : Interval integer)
                              (ds : (\a -> list data) bytestring)
                              (ds :
                                 (\k a -> list (pair data data))
                                   ScriptPurpose
                                   data)
                              (ds :
                                 (\k a -> list (pair data data))
                                   bytestring
                                   data)
                              (ds : bytestring)
                              (ds :
                                 (\k a -> list (pair data data))
                                   Voter
                                   ((\k a -> list (pair data data))
                                      GovernanceActionId
                                      Vote))
                              (ds : (\a -> list data) ProposalProcedure)
                              (ds : Maybe integer)
                              (ds : Maybe integer) ->
                               ds)
                            (\(void : unit) -> error {(\a -> list data) TxOut})
                    in
                    go ds 0)
                    2))
              True
              False)
           {all dead. Unit}
           (/\dead -> Unit)
           (/\dead -> error {Unit})
           {all dead. dead}))
  (Constr 0
     [ Constr 0
         [ List []
         , List []
         , List
             [ Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 1)])]
                 , Constr 0 []
                 , Constr 1 [] ] ]
         , I 10000
         , Map []
         , List []
         , Map []
         , Constr 0
             [ Constr 0 [Constr 0 [], Constr 1 []]
             , Constr 0 [Constr 2 [], Constr 1 []] ]
         , List []
         , Map []
         , Map []
         , B #
         , Map []
         , List []
         , Constr 1 []
         , Constr 1 [] ]
     , I 1
     , Constr 1 [Constr 0 [B #, I 0], Constr 1 []] ])