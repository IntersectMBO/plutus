(let
    !`$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData` : data -> data
      = \(d : data) -> d
    !reconstructCaseError : string = "PT1"
    data Unit | Unit_match where
      Unit : Unit
    !traceError : all a. string -> a
      = /\a ->
          \(str : string) -> let !x : Unit = trace {Unit} str Unit in error {a}
    data Bool | Bool_match where
      True : Bool
      False : Bool
    !`$fUnsafeFromDataBool_$cunsafeFromBuiltinData` : data -> Bool
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          ifThenElse
            {all dead. Bool}
            (equalsInteger 0 index)
            (/\dead -> False)
            (/\dead ->
               ifThenElse
                 {all dead. Bool}
                 (equalsInteger 1 index)
                 (/\dead -> True)
                 (/\dead -> traceError {Bool} reconstructCaseError)
                 {all dead. dead})
            {all dead. dead}
    data (Extended :: * -> *) a | Extended_match where
      Finite : a -> Extended a
      NegInf : Extended a
      PosInf : Extended a
    !`$fUnsafeFromDataExtended_$cunsafeFromBuiltinData` :
       all a. (\a -> data -> a) a -> data -> Extended a
      = /\a ->
          \(`$dUnsafeFromData` : (\a -> data -> a) a) (d : data) ->
            let
              !tup : pair integer (list data) = unConstrData d
              !index : integer = fstPair {integer} {list data} tup
              !args : list data = sndPair {integer} {list data} tup
            in
            ifThenElse
              {all dead. Extended a}
              (equalsInteger 0 index)
              (/\dead -> NegInf {a})
              (/\dead ->
                 ifThenElse
                   {all dead. Extended a}
                   (equalsInteger 1 index)
                   (/\dead ->
                      Finite {a} (`$dUnsafeFromData` (headList {data} args)))
                   (/\dead ->
                      ifThenElse
                        {all dead. Extended a}
                        (equalsInteger 2 index)
                        (/\dead -> PosInf {a})
                        (/\dead -> traceError {Extended a} reconstructCaseError)
                        {all dead. dead})
                   {all dead. dead})
              {all dead. dead}
  in
  letrec
    data (List :: * -> *) a | List_match where
      Nil : List a
      Cons : a -> List a -> List a
  in
  let
    !`$fUnsafeFromDataList_$cunsafeFromBuiltinData` :
       all a. (\a -> data -> a) a -> data -> List a
      = /\a ->
          \(`$dUnsafeFromData` : (\a -> data -> a) a) ->
            letrec
              !go : list data -> List a
                = \(l : list data) ->
                    chooseList
                      {data}
                      {Unit -> List a}
                      l
                      (\(ds : Unit) -> Nil {a})
                      (\(ds : Unit) ->
                         Cons
                           {a}
                           (`$dUnsafeFromData` (headList {data} l))
                           (go (tailList {data} l)))
                      Unit
            in
            \(d : data) -> go (unListData d)
    data (Tuple2 :: * -> * -> *) a b | Tuple2_match where
      Tuple2 : a -> b -> Tuple2 a b
    !`$fUnsafeFromDataMap_$cunsafeFromBuiltinData` :
       all k v.
         (\a -> data -> a) k ->
         (\a -> data -> a) v ->
         data ->
         (\k v -> List (Tuple2 k v)) k v
      = /\k v ->
          \(`$dUnsafeFromData` : (\a -> data -> a) k)
           (`$dUnsafeFromData` : (\a -> data -> a) v) ->
            letrec
              !go : list (pair data data) -> List (Tuple2 k v)
                = \(l : list (pair data data)) ->
                    chooseList
                      {pair data data}
                      {Unit -> List (Tuple2 k v)}
                      l
                      (\(ds : Unit) -> Nil {Tuple2 k v})
                      (\(ds : Unit) ->
                         let
                           !tup : pair data data = headList {pair data data} l
                         in
                         Cons
                           {Tuple2 k v}
                           (Tuple2
                              {k}
                              {v}
                              (`$dUnsafeFromData` (fstPair {data} {data} tup))
                              (`$dUnsafeFromData` (sndPair {data} {data} tup)))
                           (go (tailList {pair data data} l)))
                      Unit
            in
            \(d : data) -> go (unMapData d)
    !`$fUnsafeFromDataTxId_$cunsafeFromBuiltinData` : data -> bytestring
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          ifThenElse
            {all dead. bytestring}
            (equalsInteger 0 index)
            (/\dead -> unBData (headList {data} args))
            (/\dead -> traceError {bytestring} reconstructCaseError)
            {all dead. dead}
    data GovernanceActionId | GovernanceActionId_match where
      GovernanceActionId : bytestring -> integer -> GovernanceActionId
    !`$fUnsafeFromDataGovernanceAction_$cunsafeFromBuiltinData` :
       data -> GovernanceActionId
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          ifThenElse
            {all dead. GovernanceActionId}
            (equalsInteger 0 index)
            (/\dead ->
               GovernanceActionId
                 (`$fUnsafeFromDataTxId_$cunsafeFromBuiltinData`
                    (headList {data} args))
                 (unIData (headList {data} (tailList {data} args))))
            (/\dead -> traceError {GovernanceActionId} reconstructCaseError)
            {all dead. dead}
    data TxOutRef | TxOutRef_match where
      TxOutRef : bytestring -> integer -> TxOutRef
    !`$fUnsafeFromDataTxOutRef_$cunsafeFromBuiltinData` : data -> TxOutRef
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          ifThenElse
            {all dead. TxOutRef}
            (equalsInteger 0 index)
            (/\dead ->
               TxOutRef
                 (`$fUnsafeFromDataTxId_$cunsafeFromBuiltinData`
                    (headList {data} args))
                 (unIData (headList {data} (tailList {data} args))))
            (/\dead -> traceError {TxOutRef} reconstructCaseError)
            {all dead. dead}
    data Credential | Credential_match where
      PubKeyCredential : bytestring -> Credential
      ScriptCredential : bytestring -> Credential
    !`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData` : data -> Credential
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          ifThenElse
            {all dead. Credential}
            (equalsInteger 0 index)
            (/\dead -> PubKeyCredential (unBData (headList {data} args)))
            (/\dead ->
               ifThenElse
                 {all dead. Credential}
                 (equalsInteger 1 index)
                 (/\dead -> ScriptCredential (unBData (headList {data} args)))
                 (/\dead -> traceError {Credential} reconstructCaseError)
                 {all dead. dead})
            {all dead. dead}
    data DRep | DRep_match where
      DRep : Credential -> DRep
      DRepAlwaysAbstain : DRep
      DRepAlwaysNoConfidence : DRep
    !`$fUnsafeFromDataDRep_$cunsafeFromBuiltinData` : data -> DRep
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          ifThenElse
            {all dead. DRep}
            (equalsInteger 0 index)
            (/\dead ->
               DRep
                 (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                    (headList {data} args)))
            (/\dead ->
               ifThenElse
                 {all dead. DRep}
                 (equalsInteger 1 index)
                 (/\dead -> DRepAlwaysAbstain)
                 (/\dead ->
                    ifThenElse
                      {all dead. DRep}
                      (equalsInteger 2 index)
                      (/\dead -> DRepAlwaysNoConfidence)
                      (/\dead -> traceError {DRep} reconstructCaseError)
                      {all dead. dead})
                 {all dead. dead})
            {all dead. dead}
    data Delegatee | Delegatee_match where
      DelegStake : bytestring -> Delegatee
      DelegStakeVote : bytestring -> DRep -> Delegatee
      DelegVote : DRep -> Delegatee
    !`$fUnsafeFromDataDelegatee_$cunsafeFromBuiltinData` : data -> Delegatee
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          ifThenElse
            {all dead. Delegatee}
            (equalsInteger 0 index)
            (/\dead -> DelegStake (unBData (headList {data} args)))
            (/\dead ->
               ifThenElse
                 {all dead. Delegatee}
                 (equalsInteger 1 index)
                 (/\dead ->
                    DelegVote
                      (`$fUnsafeFromDataDRep_$cunsafeFromBuiltinData`
                         (headList {data} args)))
                 (/\dead ->
                    ifThenElse
                      {all dead. Delegatee}
                      (equalsInteger 2 index)
                      (/\dead ->
                         DelegStakeVote
                           (unBData (headList {data} args))
                           (`$fUnsafeFromDataDRep_$cunsafeFromBuiltinData`
                              (headList {data} (tailList {data} args))))
                      (/\dead -> traceError {Delegatee} reconstructCaseError)
                      {all dead. dead})
                 {all dead. dead})
            {all dead. dead}
    data Ordering | Ordering_match where
      EQ : Ordering
      GT : Ordering
      LT : Ordering
    !`$fOrdBuiltinByteString_$ccompare` : bytestring -> bytestring -> Ordering
      = \(eta : bytestring) (eta : bytestring) ->
          ifThenElse
            {all dead. Ordering}
            (equalsByteString eta eta)
            (/\dead -> EQ)
            (/\dead ->
               ifThenElse
                 {all dead. Ordering}
                 (lessThanEqualsByteString eta eta)
                 (/\dead -> LT)
                 (/\dead -> GT)
                 {all dead. dead})
            {all dead. dead}
    !`$fOrdBuiltinByteString_$cmax` : bytestring -> bytestring -> bytestring
      = \(x : bytestring) (y : bytestring) ->
          ifThenElse
            {all dead. bytestring}
            (lessThanEqualsByteString x y)
            (/\dead -> y)
            (/\dead -> x)
            {all dead. dead}
    !`$fOrdBuiltinByteString_$cmin` : bytestring -> bytestring -> bytestring
      = \(x : bytestring) (y : bytestring) ->
          ifThenElse
            {all dead. bytestring}
            (lessThanEqualsByteString x y)
            (/\dead -> x)
            (/\dead -> y)
            {all dead. dead}
    !equalsByteString : bytestring -> bytestring -> Bool
      = \(x : bytestring) (y : bytestring) ->
          ifThenElse {Bool} (equalsByteString x y) True False
    !greaterThanByteString : bytestring -> bytestring -> Bool
      = \(x : bytestring) (y : bytestring) ->
          ifThenElse {Bool} (lessThanEqualsByteString x y) False True
    !greaterThanEqualsByteString : bytestring -> bytestring -> Bool
      = \(x : bytestring) (y : bytestring) ->
          ifThenElse {Bool} (lessThanByteString x y) False True
    data (Ord :: * -> *) a | Ord_match where
      CConsOrd :
        (\a -> a -> a -> Bool) a ->
        (a -> a -> Ordering) ->
        (a -> a -> Bool) ->
        (a -> a -> Bool) ->
        (a -> a -> Bool) ->
        (a -> a -> Bool) ->
        (a -> a -> a) ->
        (a -> a -> a) ->
        Ord a
    !lessThanByteString : bytestring -> bytestring -> Bool
      = \(x : bytestring) (y : bytestring) ->
          ifThenElse {Bool} (lessThanByteString x y) True False
    !lessThanEqualsByteString : bytestring -> bytestring -> Bool
      = \(x : bytestring) (y : bytestring) ->
          ifThenElse {Bool} (lessThanEqualsByteString x y) True False
    !`$fOrdCurrencySymbol` : Ord bytestring
      = CConsOrd
          {bytestring}
          equalsByteString
          `$fOrdBuiltinByteString_$ccompare`
          lessThanByteString
          lessThanEqualsByteString
          greaterThanByteString
          greaterThanEqualsByteString
          `$fOrdBuiltinByteString_$cmax`
          `$fOrdBuiltinByteString_$cmin`
    data Color | Color_match where
      B : Color
      R : Color
  in
  letrec
    data (RBTree :: * -> * -> *) k v | RBTree_match where
      Branch :
        Color -> integer -> RBTree k v -> k -> v -> RBTree k v -> RBTree k v
      Leaf : RBTree k v
  in
  let
    !compare : all a. Ord a -> a -> a -> Ordering
      = /\a ->
          \(v : Ord a) ->
            Ord_match
              {a}
              v
              {a -> a -> Ordering}
              (\(v : (\a -> a -> a -> Bool) a)
                (v : a -> a -> Ordering)
                (v : a -> a -> Bool)
                (v : a -> a -> Bool)
                (v : a -> a -> Bool)
                (v : a -> a -> Bool)
                (v : a -> a -> a)
                (v : a -> a -> a) ->
                 v)
    !`$fUnsafeFromDataRBTree_$cunsafeFromBuiltinData` :
       all k v.
         Ord k ->
         (\a -> data -> a) k ->
         (\a -> data -> a) v ->
         data ->
         RBTree k v
      = /\k v ->
          \(`$dOrd` : Ord k)
           (`$dUnsafeFromData` : (\a -> data -> a) k)
           (`$dUnsafeFromData` : (\a -> data -> a) v) ->
            letrec
              !go :
                 RBTree k v -> list (pair data data) -> RBTree k v
                = \(acc : RBTree k v)
                   (l : list (pair data data)) ->
                    chooseList
                      {pair data data}
                      {Unit -> RBTree k v}
                      l
                      (\(ds : Unit) -> acc)
                      (\(ds : Unit) ->
                         let
                           !h : pair data data = headList {pair data data} l
                           !t : list (pair data data)
                             = tailList {pair data data} l
                         in
                         go
                           (let
                             !k : k
                               = `$dUnsafeFromData` (fstPair {data} {data} h)
                             !v : v
                               = `$dUnsafeFromData` (sndPair {data} {data} h)
                           in
                           letrec
                             !go :
                                RBTree k v -> RBTree k v
                               = \(ds : RBTree k v) ->
                                   RBTree_match
                                     {k}
                                     {v}
                                     ds
                                     {all dead. RBTree k v}
                                     (\(ds : Color)
                                       (h : integer)
                                       (l : RBTree k v)
                                       (k' : k)
                                       (v' : v)
                                       (r : RBTree k v) ->
                                        /\dead ->
                                          Color_match
                                            ds
                                            {all dead. RBTree k v}
                                            (/\dead ->
                                               Ordering_match
                                                 (compare {k} `$dOrd` k k')
                                                 {all dead. RBTree k v}
                                                 (/\dead ->
                                                    Branch {k} {v} B h l k' v r)
                                                 (/\dead ->
                                                    let
                                                      !t : RBTree k v
                                                        = Branch
                                                            {k}
                                                            {v}
                                                            B
                                                            h
                                                            l
                                                            k'
                                                            v'
                                                            (go r)
                                                    in
                                                    RBTree_match
                                                      {k}
                                                      {v}
                                                      t
                                                      {all dead. RBTree k v}
                                                      (\(ds : Color)
                                                        (h : integer)
                                                        (t : RBTree k v)
                                                        (k : k)
                                                        (v : v)
                                                        (toSplit :
                                                           RBTree k v) ->
                                                         /\dead ->
                                                           Color_match
                                                             ds
                                                             {all dead.
                                                                RBTree k v}
                                                             (/\dead ->
                                                                RBTree_match
                                                                  {k}
                                                                  {v}
                                                                  toSplit
                                                                  {all dead.
                                                                     RBTree k v}
                                                                  (\(ds : Color)
                                                                    (ds :
                                                                       integer)
                                                                    (t :
                                                                       RBTree
                                                                         k
                                                                         v)
                                                                    (k : k)
                                                                    (v : v)
                                                                    (ds :
                                                                       RBTree
                                                                         k
                                                                         v) ->
                                                                     let
                                                                       !fail :
                                                                          unit ->
                                                                          RBTree
                                                                            k
                                                                            v
                                                                         = \(ds :
                                                                               unit) ->
                                                                             RBTree_match
                                                                               {k}
                                                                               {v}
                                                                               t
                                                                               {all dead.
                                                                                  RBTree
                                                                                    k
                                                                                    v}
                                                                               (\(ds :
                                                                                    Color)
                                                                                 (ds :
                                                                                    integer)
                                                                                 (t :
                                                                                    RBTree
                                                                                      k
                                                                                      v)
                                                                                 (k :
                                                                                    k)
                                                                                 (v :
                                                                                    v)
                                                                                 (t :
                                                                                    RBTree
                                                                                      k
                                                                                      v) ->
                                                                                  /\dead ->
                                                                                    Color_match
                                                                                      ds
                                                                                      {all dead.
                                                                                         RBTree
                                                                                           k
                                                                                           v}
                                                                                      (/\dead ->
                                                                                         t)
                                                                                      (/\dead ->
                                                                                         Branch
                                                                                           {k}
                                                                                           {v}
                                                                                           R
                                                                                           (addInteger
                                                                                              1
                                                                                              h)
                                                                                           (Branch
                                                                                              {k}
                                                                                              {v}
                                                                                              B
                                                                                              h
                                                                                              t
                                                                                              k
                                                                                              v
                                                                                              t)
                                                                                           k
                                                                                           v
                                                                                           (Branch
                                                                                              {k}
                                                                                              {v}
                                                                                              B
                                                                                              h
                                                                                              t
                                                                                              k
                                                                                              v
                                                                                              ds))
                                                                                      {all dead.
                                                                                         dead})
                                                                               (/\dead ->
                                                                                  t)
                                                                               {all dead.
                                                                                  dead}
                                                                     in
                                                                     /\dead ->
                                                                       Color_match
                                                                         ds
                                                                         {all dead.
                                                                            RBTree
                                                                              k
                                                                              v}
                                                                         (/\dead ->
                                                                            t)
                                                                         (/\dead ->
                                                                            RBTree_match
                                                                              {k}
                                                                              {v}
                                                                              ds
                                                                              {all dead.
                                                                                 RBTree
                                                                                   k
                                                                                   v}
                                                                              (\(ds :
                                                                                   Color)
                                                                                (ds :
                                                                                   integer)
                                                                                (t :
                                                                                   RBTree
                                                                                     k
                                                                                     v)
                                                                                (k :
                                                                                   k)
                                                                                (v :
                                                                                   v)
                                                                                (t :
                                                                                   RBTree
                                                                                     k
                                                                                     v) ->
                                                                                 /\dead ->
                                                                                   Color_match
                                                                                     ds
                                                                                     {all dead.
                                                                                        RBTree
                                                                                          k
                                                                                          v}
                                                                                     (/\dead ->
                                                                                        fail
                                                                                          ())
                                                                                     (/\dead ->
                                                                                        Branch
                                                                                          {k}
                                                                                          {v}
                                                                                          R
                                                                                          (addInteger
                                                                                             1
                                                                                             h)
                                                                                          (Branch
                                                                                             {k}
                                                                                             {v}
                                                                                             B
                                                                                             h
                                                                                             t
                                                                                             k
                                                                                             v
                                                                                             t)
                                                                                          k
                                                                                          v
                                                                                          (Branch
                                                                                             {k}
                                                                                             {v}
                                                                                             B
                                                                                             h
                                                                                             t
                                                                                             k
                                                                                             v
                                                                                             t))
                                                                                     {all dead.
                                                                                        dead})
                                                                              (/\dead ->
                                                                                 fail
                                                                                   ())
                                                                              {all dead.
                                                                                 dead})
                                                                         {all dead.
                                                                            dead})
                                                                  (/\dead -> t)
                                                                  {all dead.
                                                                     dead})
                                                             (/\dead -> t)
                                                             {all dead. dead})
                                                      (/\dead -> Leaf {k} {v})
                                                      {all dead. dead})
                                                 (/\dead ->
                                                    let
                                                      !t : RBTree k v
                                                        = Branch
                                                            {k}
                                                            {v}
                                                            B
                                                            h
                                                            (go l)
                                                            k'
                                                            v'
                                                            r
                                                    in
                                                    RBTree_match
                                                      {k}
                                                      {v}
                                                      t
                                                      {all dead. RBTree k v}
                                                      (\(ds : Color)
                                                        (h : integer)
                                                        (toSplit : RBTree k v)
                                                        (k : k)
                                                        (v : v)
                                                        (t : RBTree k v) ->
                                                         /\dead ->
                                                           Color_match
                                                             ds
                                                             {all dead.
                                                                RBTree k v}
                                                             (/\dead ->
                                                                RBTree_match
                                                                  {k}
                                                                  {v}
                                                                  toSplit
                                                                  {all dead.
                                                                     RBTree k v}
                                                                  (\(ds : Color)
                                                                    (ds :
                                                                       integer)
                                                                    (ds :
                                                                       RBTree
                                                                         k
                                                                         v)
                                                                    (k : k)
                                                                    (v : v)
                                                                    (t :
                                                                       RBTree
                                                                         k
                                                                         v) ->
                                                                     let
                                                                       !fail :
                                                                          unit ->
                                                                          RBTree
                                                                            k
                                                                            v
                                                                         = \(ds :
                                                                               unit) ->
                                                                             RBTree_match
                                                                               {k}
                                                                               {v}
                                                                               t
                                                                               {all dead.
                                                                                  RBTree
                                                                                    k
                                                                                    v}
                                                                               (\(ds :
                                                                                    Color)
                                                                                 (ds :
                                                                                    integer)
                                                                                 (t :
                                                                                    RBTree
                                                                                      k
                                                                                      v)
                                                                                 (k :
                                                                                    k)
                                                                                 (v :
                                                                                    v)
                                                                                 (t :
                                                                                    RBTree
                                                                                      k
                                                                                      v) ->
                                                                                  /\dead ->
                                                                                    Color_match
                                                                                      ds
                                                                                      {all dead.
                                                                                         RBTree
                                                                                           k
                                                                                           v}
                                                                                      (/\dead ->
                                                                                         t)
                                                                                      (/\dead ->
                                                                                         Branch
                                                                                           {k}
                                                                                           {v}
                                                                                           R
                                                                                           (addInteger
                                                                                              1
                                                                                              h)
                                                                                           (Branch
                                                                                              {k}
                                                                                              {v}
                                                                                              B
                                                                                              h
                                                                                              ds
                                                                                              k
                                                                                              v
                                                                                              t)
                                                                                           k
                                                                                           v
                                                                                           (Branch
                                                                                              {k}
                                                                                              {v}
                                                                                              B
                                                                                              h
                                                                                              t
                                                                                              k
                                                                                              v
                                                                                              t))
                                                                                      {all dead.
                                                                                         dead})
                                                                               (/\dead ->
                                                                                  t)
                                                                               {all dead.
                                                                                  dead}
                                                                     in
                                                                     /\dead ->
                                                                       Color_match
                                                                         ds
                                                                         {all dead.
                                                                            RBTree
                                                                              k
                                                                              v}
                                                                         (/\dead ->
                                                                            t)
                                                                         (/\dead ->
                                                                            RBTree_match
                                                                              {k}
                                                                              {v}
                                                                              ds
                                                                              {all dead.
                                                                                 RBTree
                                                                                   k
                                                                                   v}
                                                                              (\(ds :
                                                                                   Color)
                                                                                (ds :
                                                                                   integer)
                                                                                (t :
                                                                                   RBTree
                                                                                     k
                                                                                     v)
                                                                                (k :
                                                                                   k)
                                                                                (v :
                                                                                   v)
                                                                                (t :
                                                                                   RBTree
                                                                                     k
                                                                                     v) ->
                                                                                 /\dead ->
                                                                                   Color_match
                                                                                     ds
                                                                                     {all dead.
                                                                                        RBTree
                                                                                          k
                                                                                          v}
                                                                                     (/\dead ->
                                                                                        fail
                                                                                          ())
                                                                                     (/\dead ->
                                                                                        Branch
                                                                                          {k}
                                                                                          {v}
                                                                                          R
                                                                                          (addInteger
                                                                                             1
                                                                                             h)
                                                                                          (Branch
                                                                                             {k}
                                                                                             {v}
                                                                                             B
                                                                                             h
                                                                                             t
                                                                                             k
                                                                                             v
                                                                                             t)
                                                                                          k
                                                                                          v
                                                                                          (Branch
                                                                                             {k}
                                                                                             {v}
                                                                                             B
                                                                                             h
                                                                                             t
                                                                                             k
                                                                                             v
                                                                                             t))
                                                                                     {all dead.
                                                                                        dead})
                                                                              (/\dead ->
                                                                                 fail
                                                                                   ())
                                                                              {all dead.
                                                                                 dead})
                                                                         {all dead.
                                                                            dead})
                                                                  (/\dead -> t)
                                                                  {all dead.
                                                                     dead})
                                                             (/\dead -> t)
                                                             {all dead. dead})
                                                      (/\dead -> Leaf {k} {v})
                                                      {all dead. dead})
                                                 {all dead. dead})
                                            (/\dead ->
                                               Ordering_match
                                                 (compare {k} `$dOrd` k k')
                                                 {all dead. RBTree k v}
                                                 (/\dead ->
                                                    Branch {k} {v} R h l k' v r)
                                                 (/\dead ->
                                                    Branch
                                                      {k}
                                                      {v}
                                                      R
                                                      h
                                                      l
                                                      k'
                                                      v'
                                                      (go r))
                                                 (/\dead ->
                                                    Branch
                                                      {k}
                                                      {v}
                                                      R
                                                      h
                                                      (go l)
                                                      k'
                                                      v'
                                                      r)
                                                 {all dead. dead})
                                            {all dead. dead})
                                     (/\dead ->
                                        Branch
                                          {k}
                                          {v}
                                          R
                                          1
                                          (Leaf {k} {v})
                                          k
                                          v
                                          (Leaf {k} {v}))
                                     {all dead. dead}
                           in
                           RBTree_match
                             {k}
                             {v}
                             (go acc)
                             {all dead. RBTree k v}
                             (\(ds : Color)
                               (h : integer)
                               (l : RBTree k v)
                               (k : k)
                               (v : v)
                               (r : RBTree k v) ->
                                /\dead -> Branch {k} {v} B h l k v r)
                             (/\dead -> Leaf {k} {v})
                             {all dead. dead})
                           t)
                      Unit
            in
            \(d : data) -> go (Leaf {k} {v}) (unMapData d)
    ~`$fUnsafeFromDataValue` : data -> RBTree bytestring integer
      = `$fUnsafeFromDataRBTree_$cunsafeFromBuiltinData`
          {bytestring}
          {integer}
          (CConsOrd
             {bytestring}
             equalsByteString
             `$fOrdBuiltinByteString_$ccompare`
             lessThanByteString
             lessThanEqualsByteString
             greaterThanByteString
             greaterThanEqualsByteString
             `$fOrdBuiltinByteString_$cmax`
             `$fOrdBuiltinByteString_$cmin`)
          unBData
          unIData
    ~`$fUnsafeFromDataValue` :
       data -> RBTree bytestring (RBTree bytestring integer)
      = `$fUnsafeFromDataRBTree_$cunsafeFromBuiltinData`
          {bytestring}
          {RBTree bytestring integer}
          `$fOrdCurrencySymbol`
          unBData
          `$fUnsafeFromDataValue`
    data (Maybe :: * -> *) a | Maybe_match where
      Just : a -> Maybe a
      Nothing : Maybe a
    !`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData` :
       all a. (\a -> data -> a) a -> data -> Maybe a
      = /\a ->
          \(`$dUnsafeFromData` : (\a -> data -> a) a) (d : data) ->
            let
              !tup : pair integer (list data) = unConstrData d
              !index : integer = fstPair {integer} {list data} tup
              !args : list data = sndPair {integer} {list data} tup
            in
            ifThenElse
              {all dead. Maybe a}
              (equalsInteger 1 index)
              (/\dead -> Nothing {a})
              (/\dead ->
                 ifThenElse
                   {all dead. Maybe a}
                   (equalsInteger 0 index)
                   (/\dead ->
                      Just {a} (`$dUnsafeFromData` (headList {data} args)))
                   (/\dead -> traceError {Maybe a} reconstructCaseError)
                   {all dead. dead})
              {all dead. dead}
    data TxCert | TxCert_match where
      TxCertAuthHotCommittee : Credential -> Credential -> TxCert
      TxCertDelegStaking : Credential -> Delegatee -> TxCert
      TxCertPoolRegister : bytestring -> bytestring -> TxCert
      TxCertPoolRetire : bytestring -> integer -> TxCert
      TxCertRegDRep :
        Credential -> RBTree bytestring (RBTree bytestring integer) -> TxCert
      TxCertRegDeleg :
        Credential ->
        Delegatee ->
        RBTree bytestring (RBTree bytestring integer) ->
        TxCert
      TxCertRegStaking :
        Credential ->
        Maybe (RBTree bytestring (RBTree bytestring integer)) ->
        TxCert
      TxCertResignColdCommittee : Credential -> TxCert
      TxCertUnRegDRep :
        Credential -> RBTree bytestring (RBTree bytestring integer) -> TxCert
      TxCertUnRegStaking :
        Credential ->
        Maybe (RBTree bytestring (RBTree bytestring integer)) ->
        TxCert
      TxCertUpdateDRep : Credential -> TxCert
    !`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData` :
       data -> TxCert
      = \(eta : data) ->
          let
            !tup : pair integer (list data) = unConstrData eta
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          ifThenElse
            {all dead. TxCert}
            (equalsInteger 0 index)
            (/\dead ->
               TxCertRegStaking
                 (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                    (headList {data} args))
                 (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                    {RBTree bytestring (RBTree bytestring integer)}
                    `$fUnsafeFromDataValue`
                    (headList {data} (tailList {data} args))))
            (/\dead ->
               ifThenElse
                 {all dead. TxCert}
                 (equalsInteger 1 index)
                 (/\dead ->
                    TxCertUnRegStaking
                      (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                         (headList {data} args))
                      (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                         {RBTree bytestring (RBTree bytestring integer)}
                         `$fUnsafeFromDataValue`
                         (headList {data} (tailList {data} args))))
                 (/\dead ->
                    ifThenElse
                      {all dead. TxCert}
                      (equalsInteger 2 index)
                      (/\dead ->
                         TxCertDelegStaking
                           (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                              (headList {data} args))
                           (`$fUnsafeFromDataDelegatee_$cunsafeFromBuiltinData`
                              (headList {data} (tailList {data} args))))
                      (/\dead ->
                         ifThenElse
                           {all dead. TxCert}
                           (equalsInteger 3 index)
                           (/\dead ->
                              let
                                !l : list data = tailList {data} args
                              in
                              TxCertRegDeleg
                                (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                   (headList {data} args))
                                (`$fUnsafeFromDataDelegatee_$cunsafeFromBuiltinData`
                                   (headList {data} l))
                                (`$fUnsafeFromDataRBTree_$cunsafeFromBuiltinData`
                                   {bytestring}
                                   {RBTree bytestring integer}
                                   `$fOrdCurrencySymbol`
                                   unBData
                                   `$fUnsafeFromDataValue`
                                   (headList {data} (tailList {data} l))))
                           (/\dead ->
                              ifThenElse
                                {all dead. TxCert}
                                (equalsInteger 4 index)
                                (/\dead ->
                                   TxCertRegDRep
                                     (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                        (headList {data} args))
                                     (`$fUnsafeFromDataRBTree_$cunsafeFromBuiltinData`
                                        {bytestring}
                                        {RBTree bytestring integer}
                                        `$fOrdCurrencySymbol`
                                        unBData
                                        `$fUnsafeFromDataValue`
                                        (headList
                                           {data}
                                           (tailList {data} args))))
                                (/\dead ->
                                   ifThenElse
                                     {all dead. TxCert}
                                     (equalsInteger 5 index)
                                     (/\dead ->
                                        TxCertUpdateDRep
                                          (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                             (headList {data} args)))
                                     (/\dead ->
                                        ifThenElse
                                          {all dead. TxCert}
                                          (equalsInteger 6 index)
                                          (/\dead ->
                                             TxCertUnRegDRep
                                               (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                                  (headList {data} args))
                                               (`$fUnsafeFromDataRBTree_$cunsafeFromBuiltinData`
                                                  {bytestring}
                                                  {RBTree bytestring integer}
                                                  `$fOrdCurrencySymbol`
                                                  unBData
                                                  `$fUnsafeFromDataValue`
                                                  (headList
                                                     {data}
                                                     (tailList {data} args))))
                                          (/\dead ->
                                             ifThenElse
                                               {all dead. TxCert}
                                               (equalsInteger 7 index)
                                               (/\dead ->
                                                  TxCertPoolRegister
                                                    (unBData
                                                       (headList {data} args))
                                                    (unBData
                                                       (headList
                                                          {data}
                                                          (tailList
                                                             {data}
                                                             args))))
                                               (/\dead ->
                                                  ifThenElse
                                                    {all dead. TxCert}
                                                    (equalsInteger 8 index)
                                                    (/\dead ->
                                                       TxCertPoolRetire
                                                         (unBData
                                                            (headList
                                                               {data}
                                                               args))
                                                         (unIData
                                                            (headList
                                                               {data}
                                                               (tailList
                                                                  {data}
                                                                  args))))
                                                    (/\dead ->
                                                       ifThenElse
                                                         {all dead. TxCert}
                                                         (equalsInteger 9 index)
                                                         (/\dead ->
                                                            TxCertAuthHotCommittee
                                                              (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                                                 (headList
                                                                    {data}
                                                                    args))
                                                              (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                                                 (headList
                                                                    {data}
                                                                    (tailList
                                                                       {data}
                                                                       args))))
                                                         (/\dead ->
                                                            ifThenElse
                                                              {all dead. TxCert}
                                                              (equalsInteger
                                                                 10
                                                                 index)
                                                              (/\dead ->
                                                                 TxCertResignColdCommittee
                                                                   (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                                                      (headList
                                                                         {data}
                                                                         args)))
                                                              (/\dead ->
                                                                 traceError
                                                                   {TxCert}
                                                                   reconstructCaseError)
                                                              {all dead. dead})
                                                         {all dead. dead})
                                                    {all dead. dead})
                                               {all dead. dead})
                                          {all dead. dead})
                                     {all dead. dead})
                                {all dead. dead})
                           {all dead. dead})
                      {all dead. dead})
                 {all dead. dead})
            {all dead. dead}
    data Voter | Voter_match where
      CommitteeVoter : Credential -> Voter
      DRepVoter : Credential -> Voter
      StakePoolVoter : bytestring -> Voter
    !`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData` : data -> Voter
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          ifThenElse
            {all dead. Voter}
            (equalsInteger 0 index)
            (/\dead ->
               CommitteeVoter
                 (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                    (headList {data} args)))
            (/\dead ->
               ifThenElse
                 {all dead. Voter}
                 (equalsInteger 1 index)
                 (/\dead ->
                    DRepVoter
                      (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                         (headList {data} args)))
                 (/\dead ->
                    ifThenElse
                      {all dead. Voter}
                      (equalsInteger 2 index)
                      (/\dead ->
                         StakePoolVoter (unBData (headList {data} args)))
                      (/\dead -> traceError {Voter} reconstructCaseError)
                      {all dead. dead})
                 {all dead. dead})
            {all dead. dead}
    data ScriptPurpose | ScriptPurpose_match where
      Certifying : TxCert -> ScriptPurpose
      Minting : bytestring -> ScriptPurpose
      Proposing : integer -> ScriptPurpose
      Rewarding : Credential -> ScriptPurpose
      Spending : TxOutRef -> ScriptPurpose
      Voting : Voter -> GovernanceActionId -> ScriptPurpose
    !`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData` :
       data -> ScriptPurpose
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          ifThenElse
            {all dead. ScriptPurpose}
            (equalsInteger 0 index)
            (/\dead -> Minting (unBData (headList {data} args)))
            (/\dead ->
               ifThenElse
                 {all dead. ScriptPurpose}
                 (equalsInteger 1 index)
                 (/\dead ->
                    Spending
                      (`$fUnsafeFromDataTxOutRef_$cunsafeFromBuiltinData`
                         (headList {data} args)))
                 (/\dead ->
                    ifThenElse
                      {all dead. ScriptPurpose}
                      (equalsInteger 2 index)
                      (/\dead ->
                         Rewarding
                           (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                              (headList {data} args)))
                      (/\dead ->
                         ifThenElse
                           {all dead. ScriptPurpose}
                           (equalsInteger 3 index)
                           (/\dead ->
                              Certifying
                                (`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData`
                                   (headList {data} args)))
                           (/\dead ->
                              ifThenElse
                                {all dead. ScriptPurpose}
                                (equalsInteger 4 index)
                                (/\dead ->
                                   Voting
                                     (`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData`
                                        (headList {data} args))
                                     (`$fUnsafeFromDataGovernanceAction_$cunsafeFromBuiltinData`
                                        (headList
                                           {data}
                                           (tailList {data} args))))
                                (/\dead ->
                                   ifThenElse
                                     {all dead. ScriptPurpose}
                                     (equalsInteger 5 index)
                                     (/\dead ->
                                        Proposing
                                          (unIData (headList {data} args)))
                                     (/\dead ->
                                        traceError
                                          {ScriptPurpose}
                                          reconstructCaseError)
                                     {all dead. dead})
                                {all dead. dead})
                           {all dead. dead})
                      {all dead. dead})
                 {all dead. dead})
            {all dead. dead}
    data StakingCredential | StakingCredential_match where
      StakingHash : Credential -> StakingCredential
      StakingPtr : integer -> integer -> integer -> StakingCredential
    data Address | Address_match where
      Address : Credential -> Maybe StakingCredential -> Address
    data OutputDatum | OutputDatum_match where
      NoOutputDatum : OutputDatum
      OutputDatum : data -> OutputDatum
      OutputDatumHash : bytestring -> OutputDatum
    data TxOut | TxOut_match where
      TxOut :
        Address ->
        RBTree bytestring (RBTree bytestring integer) ->
        OutputDatum ->
        Maybe bytestring ->
        TxOut
    !`$fUnsafeFromDataTxOut_$cunsafeFromBuiltinData` :
       data -> TxOut
      = \(eta : data) ->
          let
            !tup : pair integer (list data) = unConstrData eta
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          ifThenElse
            {all dead. TxOut}
            (equalsInteger 0 index)
            (/\dead ->
               let
                 !l : list data = tailList {data} args
                 !l : list data = tailList {data} l
               in
               TxOut
                 (let
                   !tup : pair integer (list data)
                     = unConstrData (headList {data} args)
                   !index : integer = fstPair {integer} {list data} tup
                   !args : list data = sndPair {integer} {list data} tup
                 in
                 ifThenElse
                   {all dead. Address}
                   (equalsInteger 0 index)
                   (/\dead ->
                      Address
                        (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                           (headList {data} args))
                        (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                           {StakingCredential}
                           (\(d : data) ->
                              let
                                !tup : pair integer (list data) = unConstrData d
                                !index : integer
                                  = fstPair {integer} {list data} tup
                                !args : list data
                                  = sndPair {integer} {list data} tup
                              in
                              ifThenElse
                                {all dead. StakingCredential}
                                (equalsInteger 0 index)
                                (/\dead ->
                                   StakingHash
                                     (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                        (headList {data} args)))
                                (/\dead ->
                                   ifThenElse
                                     {all dead. StakingCredential}
                                     (equalsInteger 1 index)
                                     (/\dead ->
                                        let
                                          !l : list data = tailList {data} args
                                        in
                                        StakingPtr
                                          (unIData (headList {data} args))
                                          (unIData (headList {data} l))
                                          (unIData
                                             (headList
                                                {data}
                                                (tailList {data} l))))
                                     (/\dead ->
                                        traceError
                                          {StakingCredential}
                                          reconstructCaseError)
                                     {all dead. dead})
                                {all dead. dead})
                           (headList {data} (tailList {data} args))))
                   (/\dead -> traceError {Address} reconstructCaseError)
                   {all dead. dead})
                 (`$fUnsafeFromDataRBTree_$cunsafeFromBuiltinData`
                    {bytestring}
                    {RBTree bytestring integer}
                    `$fOrdCurrencySymbol`
                    unBData
                    `$fUnsafeFromDataValue`
                    (headList {data} l))
                 (let
                   !tup : pair integer (list data)
                     = unConstrData (headList {data} l)
                   !index : integer = fstPair {integer} {list data} tup
                   !args : list data = sndPair {integer} {list data} tup
                 in
                 ifThenElse
                   {all dead. OutputDatum}
                   (equalsInteger 0 index)
                   (/\dead -> NoOutputDatum)
                   (/\dead ->
                      ifThenElse
                        {all dead. OutputDatum}
                        (equalsInteger 1 index)
                        (/\dead ->
                           OutputDatumHash (unBData (headList {data} args)))
                        (/\dead ->
                           ifThenElse
                             {all dead. OutputDatum}
                             (equalsInteger 2 index)
                             (/\dead -> OutputDatum (headList {data} args))
                             (/\dead ->
                                traceError {OutputDatum} reconstructCaseError)
                             {all dead. dead})
                        {all dead. dead})
                   {all dead. dead})
                 (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                    {bytestring}
                    unBData
                    (headList {data} (tailList {data} l))))
            (/\dead -> traceError {TxOut} reconstructCaseError)
            {all dead. dead}
    data TxInInfo | TxInInfo_match where
      TxInInfo : TxOutRef -> TxOut -> TxInInfo
    !`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData` : data -> TxInInfo
      = \(d : data) ->
          let
            !tup : pair integer (list data) = unConstrData d
            !index : integer = fstPair {integer} {list data} tup
            !args : list data = sndPair {integer} {list data} tup
          in
          ifThenElse
            {all dead. TxInInfo}
            (equalsInteger 0 index)
            (/\dead ->
               TxInInfo
                 (`$fUnsafeFromDataTxOutRef_$cunsafeFromBuiltinData`
                    (headList {data} args))
                 (`$fUnsafeFromDataTxOut_$cunsafeFromBuiltinData`
                    (headList {data} (tailList {data} args))))
            (/\dead -> traceError {TxInInfo} reconstructCaseError)
            {all dead. dead}
    data (LowerBound :: * -> *) a | LowerBound_match where
      LowerBound : Extended a -> Bool -> LowerBound a
    data (UpperBound :: * -> *) a | UpperBound_match where
      UpperBound : Extended a -> Bool -> UpperBound a
    data (Interval :: * -> *) a | Interval_match where
      Interval : LowerBound a -> UpperBound a -> Interval a
    data Rational | Rational_match where
      Rational : integer -> integer -> Rational
    data Committee | Committee_match where
      Committee :
        (\k v -> List (Tuple2 k v)) Credential integer -> Rational -> Committee
    data ProtocolVersion | ProtocolVersion_match where
      ProtocolVersion : integer -> integer -> ProtocolVersion
    data GovernanceAction | GovernanceAction_match where
      HardForkInitiation :
        Maybe GovernanceActionId -> ProtocolVersion -> GovernanceAction
      InfoAction : GovernanceAction
      NewCommittee :
        Maybe GovernanceActionId ->
        List Credential ->
        Committee ->
        GovernanceAction
      NewConstitution :
        Maybe GovernanceActionId -> Maybe bytestring -> GovernanceAction
      NoConfidence : Maybe GovernanceActionId -> GovernanceAction
      ParameterChange :
        Maybe GovernanceActionId -> data -> Maybe bytestring -> GovernanceAction
      TreasuryWithdrawals :
        (\k v -> List (Tuple2 k v))
          Credential
          (RBTree bytestring (RBTree bytestring integer)) ->
        Maybe bytestring ->
        GovernanceAction
    data ProposalProcedure | ProposalProcedure_match where
      ProposalProcedure :
        RBTree bytestring (RBTree bytestring integer) ->
        Credential ->
        GovernanceAction ->
        ProposalProcedure
    data Vote | Vote_match where
      Abstain : Vote
      VoteNo : Vote
      VoteYes : Vote
    data TxInfo | TxInfo_match where
      TxInfo :
        List TxInInfo ->
        List TxInInfo ->
        List TxOut ->
        integer ->
        RBTree bytestring (RBTree bytestring integer) ->
        List TxCert ->
        (\k v -> List (Tuple2 k v)) Credential integer ->
        Interval integer ->
        List bytestring ->
        (\k v -> List (Tuple2 k v)) ScriptPurpose data ->
        (\k v -> List (Tuple2 k v)) bytestring data ->
        bytestring ->
        (\k v -> List (Tuple2 k v))
          Voter
          ((\k v -> List (Tuple2 k v)) GovernanceActionId Vote) ->
        List ProposalProcedure ->
        Maybe integer ->
        Maybe integer ->
        TxInfo
    data ScriptContext | ScriptContext_match where
      ScriptContext : TxInfo -> ScriptPurpose -> ScriptContext
    !`$fAdditiveMonoidInteger_$czero` : integer = 0
  in
  letrec
    !euclid : integer -> integer -> integer
      = \(x : integer) (y : integer) ->
          ifThenElse
            {all dead. integer}
            (equalsInteger y `$fAdditiveMonoidInteger_$czero`)
            (/\dead -> x)
            (/\dead -> euclid y (modInteger x y))
            {all dead. dead}
  in
  letrec
    !unsafeRatio : integer -> integer -> Rational
      = \(n : integer) (d : integer) ->
          ifThenElse
            {all dead. Rational}
            (equalsInteger d `$fAdditiveMonoidInteger_$czero`)
            (/\dead -> error {Rational})
            (/\dead ->
               ifThenElse
                 {all dead. Rational}
                 (lessThanInteger d `$fAdditiveMonoidInteger_$czero`)
                 (/\dead ->
                    unsafeRatio
                      (subtractInteger `$fAdditiveMonoidInteger_$czero` n)
                      (subtractInteger `$fAdditiveMonoidInteger_$czero` d))
                 (/\dead ->
                    let
                      !gcd' : integer = euclid n d
                    in
                    Rational (quotientInteger n gcd') (quotientInteger d gcd'))
                 {all dead. dead})
            {all dead. dead}
  in
  \(d : data) ->
    let
      !ds :
         ScriptContext
        = let
          !tup : pair integer (list data) = unConstrData d
          !index : integer = fstPair {integer} {list data} tup
          !args : list data = sndPair {integer} {list data} tup
        in
        ifThenElse
          {all dead. ScriptContext}
          (equalsInteger 0 index)
          (/\dead ->
             ScriptContext
               (let
                 !tup : pair integer (list data)
                   = unConstrData (headList {data} args)
                 !index : integer = fstPair {integer} {list data} tup
                 !args : list data = sndPair {integer} {list data} tup
               in
               ifThenElse
                 {all dead. TxInfo}
                 (equalsInteger 0 index)
                 (/\dead ->
                    let
                      !l : list data = tailList {data} args
                      !l : list data = tailList {data} l
                      !l : list data = tailList {data} l
                      !l : list data = tailList {data} l
                      !l : list data = tailList {data} l
                      !l : list data = tailList {data} l
                      !l : list data = tailList {data} l
                      !l : list data = tailList {data} l
                      !l : list data = tailList {data} l
                      !l : list data = tailList {data} l
                      !l : list data = tailList {data} l
                      !l : list data = tailList {data} l
                      !l : list data = tailList {data} l
                      !l : list data = tailList {data} l
                    in
                    TxInfo
                      (`$fUnsafeFromDataList_$cunsafeFromBuiltinData`
                         {TxInInfo}
                         `$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData`
                         (headList {data} args))
                      (`$fUnsafeFromDataList_$cunsafeFromBuiltinData`
                         {TxInInfo}
                         `$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData`
                         (headList {data} l))
                      (`$fUnsafeFromDataList_$cunsafeFromBuiltinData`
                         {TxOut}
                         `$fUnsafeFromDataTxOut_$cunsafeFromBuiltinData`
                         (headList {data} l))
                      (unIData (headList {data} l))
                      (`$fUnsafeFromDataRBTree_$cunsafeFromBuiltinData`
                         {bytestring}
                         {RBTree bytestring integer}
                         `$fOrdCurrencySymbol`
                         unBData
                         `$fUnsafeFromDataValue`
                         (headList {data} l))
                      (`$fUnsafeFromDataList_$cunsafeFromBuiltinData`
                         {TxCert}
                         `$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData`
                         (headList {data} l))
                      (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                         {Credential}
                         {integer}
                         `$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                         unIData
                         (headList {data} l))
                      (let
                        !tup : pair integer (list data)
                          = unConstrData (headList {data} l)
                        !index : integer = fstPair {integer} {list data} tup
                        !args : list data = sndPair {integer} {list data} tup
                      in
                      ifThenElse
                        {all dead. Interval integer}
                        (equalsInteger 0 index)
                        (/\dead ->
                           Interval
                             {integer}
                             (let
                               !tup : pair integer (list data)
                                 = unConstrData (headList {data} args)
                               !index : integer
                                 = fstPair {integer} {list data} tup
                               !args : list data
                                 = sndPair {integer} {list data} tup
                             in
                             ifThenElse
                               {all dead. LowerBound integer}
                               (equalsInteger 0 index)
                               (/\dead ->
                                  LowerBound
                                    {integer}
                                    (`$fUnsafeFromDataExtended_$cunsafeFromBuiltinData`
                                       {integer}
                                       unIData
                                       (headList {data} args))
                                    (`$fUnsafeFromDataBool_$cunsafeFromBuiltinData`
                                       (headList
                                          {data}
                                          (tailList {data} args))))
                               (/\dead ->
                                  traceError
                                    {LowerBound integer}
                                    reconstructCaseError)
                               {all dead. dead})
                             (let
                               !tup : pair integer (list data)
                                 = unConstrData
                                     (headList {data} (tailList {data} args))
                               !index : integer
                                 = fstPair {integer} {list data} tup
                               !args : list data
                                 = sndPair {integer} {list data} tup
                             in
                             ifThenElse
                               {all dead. UpperBound integer}
                               (equalsInteger 0 index)
                               (/\dead ->
                                  UpperBound
                                    {integer}
                                    (`$fUnsafeFromDataExtended_$cunsafeFromBuiltinData`
                                       {integer}
                                       unIData
                                       (headList {data} args))
                                    (`$fUnsafeFromDataBool_$cunsafeFromBuiltinData`
                                       (headList
                                          {data}
                                          (tailList {data} args))))
                               (/\dead ->
                                  traceError
                                    {UpperBound integer}
                                    reconstructCaseError)
                               {all dead. dead}))
                        (/\dead ->
                           traceError {Interval integer} reconstructCaseError)
                        {all dead. dead})
                      (`$fUnsafeFromDataList_$cunsafeFromBuiltinData`
                         {bytestring}
                         unBData
                         (headList {data} l))
                      (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                         {ScriptPurpose}
                         {data}
                         `$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData`
                         `$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData`
                         (headList {data} l))
                      (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                         {bytestring}
                         {data}
                         unBData
                         `$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData`
                         (headList {data} l))
                      (`$fUnsafeFromDataTxId_$cunsafeFromBuiltinData`
                         (headList {data} l))
                      (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                         {Voter}
                         {(\k v -> List (Tuple2 k v)) GovernanceActionId Vote}
                         `$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData`
                         (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                            {GovernanceActionId}
                            {Vote}
                            `$fUnsafeFromDataGovernanceAction_$cunsafeFromBuiltinData`
                            (\(d : data) ->
                               let
                                 !tup : pair integer (list data)
                                   = unConstrData d
                                 !index : integer
                                   = fstPair {integer} {list data} tup
                                 !args : list data
                                   = sndPair {integer} {list data} tup
                               in
                               ifThenElse
                                 {all dead. Vote}
                                 (equalsInteger 0 index)
                                 (/\dead -> VoteNo)
                                 (/\dead ->
                                    ifThenElse
                                      {all dead. Vote}
                                      (equalsInteger 1 index)
                                      (/\dead -> VoteYes)
                                      (/\dead ->
                                         ifThenElse
                                           {all dead. Vote}
                                           (equalsInteger 2 index)
                                           (/\dead -> Abstain)
                                           (/\dead ->
                                              traceError
                                                {Vote}
                                                reconstructCaseError)
                                           {all dead. dead})
                                      {all dead. dead})
                                 {all dead. dead}))
                         (headList {data} l))
                      (`$fUnsafeFromDataList_$cunsafeFromBuiltinData`
                         {ProposalProcedure}
                         (\(d : data) ->
                            let
                              !tup : pair integer (list data) = unConstrData d
                              !index : integer
                                = fstPair {integer} {list data} tup
                              !args : list data
                                = sndPair {integer} {list data} tup
                            in
                            ifThenElse
                              {all dead. ProposalProcedure}
                              (equalsInteger 0 index)
                              (/\dead ->
                                 let
                                   !l : list data = tailList {data} args
                                 in
                                 ProposalProcedure
                                   (`$fUnsafeFromDataRBTree_$cunsafeFromBuiltinData`
                                      {bytestring}
                                      {RBTree bytestring integer}
                                      `$fOrdCurrencySymbol`
                                      unBData
                                      `$fUnsafeFromDataValue`
                                      (headList {data} args))
                                   (`$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                      (headList {data} l))
                                   (let
                                     !tup : pair integer (list data)
                                       = unConstrData
                                           (headList {data} (tailList {data} l))
                                     !index : integer
                                       = fstPair {integer} {list data} tup
                                     !args : list data
                                       = sndPair {integer} {list data} tup
                                   in
                                   ifThenElse
                                     {all dead. GovernanceAction}
                                     (equalsInteger 0 index)
                                     (/\dead ->
                                        let
                                          !l : list data = tailList {data} args
                                        in
                                        ParameterChange
                                          (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                                             {GovernanceActionId}
                                             `$fUnsafeFromDataGovernanceAction_$cunsafeFromBuiltinData`
                                             (headList {data} args))
                                          (headList {data} l)
                                          (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                                             {bytestring}
                                             unBData
                                             (headList
                                                {data}
                                                (tailList {data} l))))
                                     (/\dead ->
                                        ifThenElse
                                          {all dead. GovernanceAction}
                                          (equalsInteger 1 index)
                                          (/\dead ->
                                             HardForkInitiation
                                               (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                                                  {GovernanceActionId}
                                                  `$fUnsafeFromDataGovernanceAction_$cunsafeFromBuiltinData`
                                                  (headList {data} args))
                                               (let
                                                 !tup : pair integer (list data)
                                                   = unConstrData
                                                       (headList
                                                          {data}
                                                          (tailList
                                                             {data}
                                                             args))
                                                 !index : integer
                                                   = fstPair
                                                       {integer}
                                                       {list data}
                                                       tup
                                                 !args : list data
                                                   = sndPair
                                                       {integer}
                                                       {list data}
                                                       tup
                                               in
                                               ifThenElse
                                                 {all dead. ProtocolVersion}
                                                 (equalsInteger 0 index)
                                                 (/\dead ->
                                                    ProtocolVersion
                                                      (unIData
                                                         (headList {data} args))
                                                      (unIData
                                                         (headList
                                                            {data}
                                                            (tailList
                                                               {data}
                                                               args))))
                                                 (/\dead ->
                                                    traceError
                                                      {ProtocolVersion}
                                                      reconstructCaseError)
                                                 {all dead. dead}))
                                          (/\dead ->
                                             ifThenElse
                                               {all dead. GovernanceAction}
                                               (equalsInteger 2 index)
                                               (/\dead ->
                                                  TreasuryWithdrawals
                                                    (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                                                       {Credential}
                                                       {RBTree
                                                          bytestring
                                                          (RBTree
                                                             bytestring
                                                             integer)}
                                                       `$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                                       `$fUnsafeFromDataValue`
                                                       (headList {data} args))
                                                    (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                                                       {bytestring}
                                                       unBData
                                                       (headList
                                                          {data}
                                                          (tailList
                                                             {data}
                                                             args))))
                                               (/\dead ->
                                                  ifThenElse
                                                    {all dead. GovernanceAction}
                                                    (equalsInteger 3 index)
                                                    (/\dead ->
                                                       NoConfidence
                                                         (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                                                            {GovernanceActionId}
                                                            `$fUnsafeFromDataGovernanceAction_$cunsafeFromBuiltinData`
                                                            (headList
                                                               {data}
                                                               args)))
                                                    (/\dead ->
                                                       ifThenElse
                                                         {all dead.
                                                            GovernanceAction}
                                                         (equalsInteger 4 index)
                                                         (/\dead ->
                                                            let
                                                              !l : list data
                                                                = tailList
                                                                    {data}
                                                                    args
                                                            in
                                                            NewCommittee
                                                              (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                                                                 {GovernanceActionId}
                                                                 `$fUnsafeFromDataGovernanceAction_$cunsafeFromBuiltinData`
                                                                 (headList
                                                                    {data}
                                                                    args))
                                                              (`$fUnsafeFromDataList_$cunsafeFromBuiltinData`
                                                                 {Credential}
                                                                 `$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                                                 (headList
                                                                    {data}
                                                                    l))
                                                              (let
                                                                !tup :
                                                                   pair
                                                                     integer
                                                                     (list data)
                                                                  = unConstrData
                                                                      (headList
                                                                         {data}
                                                                         (tailList
                                                                            {data}
                                                                            l))
                                                                !index : integer
                                                                  = fstPair
                                                                      {integer}
                                                                      {list
                                                                         data}
                                                                      tup
                                                                !args :
                                                                   list data
                                                                  = sndPair
                                                                      {integer}
                                                                      {list
                                                                         data}
                                                                      tup
                                                              in
                                                              ifThenElse
                                                                {all dead.
                                                                   Committee}
                                                                (equalsInteger
                                                                   0
                                                                   index)
                                                                (/\dead ->
                                                                   Committee
                                                                     (`$fUnsafeFromDataMap_$cunsafeFromBuiltinData`
                                                                        {Credential}
                                                                        {integer}
                                                                        `$fUnsafeFromDataCredential_$cunsafeFromBuiltinData`
                                                                        unIData
                                                                        (headList
                                                                           {data}
                                                                           args))
                                                                     (let
                                                                       !x :
                                                                          data
                                                                         = headList
                                                                             {data}
                                                                             (tailList
                                                                                {data}
                                                                                args)
                                                                     in
                                                                     Tuple2_match
                                                                       {integer}
                                                                       {integer}
                                                                       (let
                                                                         !tup :
                                                                            pair
                                                                              integer
                                                                              (list
                                                                                 data)
                                                                           = unConstrData
                                                                               x
                                                                         !index :
                                                                            integer
                                                                           = fstPair
                                                                               {integer}
                                                                               {list
                                                                                  data}
                                                                               tup
                                                                         !args :
                                                                            list
                                                                              data
                                                                           = sndPair
                                                                               {integer}
                                                                               {list
                                                                                  data}
                                                                               tup
                                                                       in
                                                                       ifThenElse
                                                                         {all dead.
                                                                            Tuple2
                                                                              integer
                                                                              integer}
                                                                         (equalsInteger
                                                                            0
                                                                            index)
                                                                         (/\dead ->
                                                                            Tuple2
                                                                              {integer}
                                                                              {integer}
                                                                              (unIData
                                                                                 (headList
                                                                                    {data}
                                                                                    args))
                                                                              (unIData
                                                                                 (headList
                                                                                    {data}
                                                                                    (tailList
                                                                                       {data}
                                                                                       args))))
                                                                         (/\dead ->
                                                                            traceError
                                                                              {Tuple2
                                                                                 integer
                                                                                 integer}
                                                                              reconstructCaseError)
                                                                         {all dead.
                                                                            dead})
                                                                       {Rational}
                                                                       (\(a :
                                                                            integer)
                                                                         (b :
                                                                            integer) ->
                                                                          unsafeRatio
                                                                            a
                                                                            b)))
                                                                (/\dead ->
                                                                   traceError
                                                                     {Committee}
                                                                     reconstructCaseError)
                                                                {all dead.
                                                                   dead}))
                                                         (/\dead ->
                                                            ifThenElse
                                                              {all dead.
                                                                 GovernanceAction}
                                                              (equalsInteger
                                                                 5
                                                                 index)
                                                              (/\dead ->
                                                                 NewConstitution
                                                                   (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                                                                      {GovernanceActionId}
                                                                      `$fUnsafeFromDataGovernanceAction_$cunsafeFromBuiltinData`
                                                                      (headList
                                                                         {data}
                                                                         args))
                                                                   (let
                                                                     !tup :
                                                                        pair
                                                                          integer
                                                                          (list
                                                                             data)
                                                                       = unConstrData
                                                                           (headList
                                                                              {data}
                                                                              (tailList
                                                                                 {data}
                                                                                 args))
                                                                     !index :
                                                                        integer
                                                                       = fstPair
                                                                           {integer}
                                                                           {list
                                                                              data}
                                                                           tup
                                                                     !args :
                                                                        list
                                                                          data
                                                                       = sndPair
                                                                           {integer}
                                                                           {list
                                                                              data}
                                                                           tup
                                                                   in
                                                                   ifThenElse
                                                                     {all dead.
                                                                        Maybe
                                                                          bytestring}
                                                                     (equalsInteger
                                                                        0
                                                                        index)
                                                                     (/\dead ->
                                                                        `$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                                                                          {bytestring}
                                                                          unBData
                                                                          (headList
                                                                             {data}
                                                                             args))
                                                                     (/\dead ->
                                                                        traceError
                                                                          {Maybe
                                                                             bytestring}
                                                                          reconstructCaseError)
                                                                     {all dead.
                                                                        dead}))
                                                              (/\dead ->
                                                                 ifThenElse
                                                                   {all dead.
                                                                      GovernanceAction}
                                                                   (equalsInteger
                                                                      6
                                                                      index)
                                                                   (/\dead ->
                                                                      InfoAction)
                                                                   (/\dead ->
                                                                      traceError
                                                                        {GovernanceAction}
                                                                        reconstructCaseError)
                                                                   {all dead.
                                                                      dead})
                                                              {all dead. dead})
                                                         {all dead. dead})
                                                    {all dead. dead})
                                               {all dead. dead})
                                          {all dead. dead})
                                     {all dead. dead}))
                              (/\dead ->
                                 traceError
                                   {ProposalProcedure}
                                   reconstructCaseError)
                              {all dead. dead})
                         (headList {data} l))
                      (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                         {integer}
                         unIData
                         (headList {data} l))
                      (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                         {integer}
                         unIData
                         (headList {data} (tailList {data} l))))
                 (/\dead -> traceError {TxInfo} reconstructCaseError)
                 {all dead. dead})
               (`$fUnsafeFromDataScriptContext_$cunsafeFromBuiltinData`
                  (headList {data} (tailList {data} args))))
          (/\dead -> traceError {ScriptContext} reconstructCaseError)
          {all dead. dead}
    in
    Unit)
  (Constr 0
     [ Constr 0
         [ List []
         , List []
         , List
             [ Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Map [(B #, Map [(B #, I 1)])]
                 , Constr 0 []
                 , Constr 1 [] ] ]
         , I 10000
         , Map []
         , List []
         , Map []
         , Constr 0
             [ Constr 0 [Constr 0 [], Constr 1 []]
             , Constr 0 [Constr 2 [], Constr 1 []] ]
         , List []
         , Map []
         , Map []
         , Constr 0 [B #]
         , Map []
         , List []
         , Constr 1 []
         , Constr 1 [] ]
     , Constr 1 [Constr 0 [Constr 0 [B #], I 0]] ])