(let
    data Unit | Unit_match where
      Unit : Unit
    data (Tuple2 :: * -> * -> *) a b | Tuple2_match where
      Tuple2 : a -> b -> Tuple2 a b
    !fail : unit -> Tuple2 data data
      = \(ds : unit) ->
          let
            !defaultBody : Tuple2 data data = error {Tuple2 data data}
          in
          Unit_match (error {Unit}) {Tuple2 data data} defaultBody
    !divCeil : integer -> integer -> integer
      = \(x : integer) (y : integer) ->
          addInteger 1 (divideInteger (subtractInteger x 1) y)
    !fail : unit -> Tuple2 data data
      = \(ds : unit) ->
          let
            !defaultBody : Tuple2 data data = error {Tuple2 data data}
          in
          Unit_match (error {Unit}) {Tuple2 data data} defaultBody
    data VestingRedeemer | VestingRedeemer_match where
      FullUnlock : VestingRedeemer
      PartialUnlock : VestingRedeemer
    !`$bPubKeyCredential` : integer = 0
    !`$bScriptCredential` : integer = 1
    data Bool | Bool_match where
      True : Bool
      False : Bool
    !`$fEqCredential_$c==` : data -> data -> Bool
      = \(ds : data) (ds : data) ->
          let
            !fail : unit -> Bool
              = \(ds : unit) ->
                  let
                    !tup : pair integer (list data) = unConstrData ds
                  in
                  Bool_match
                    (case
                       Bool
                       (equalsInteger
                          `$bScriptCredential`
                          (fstPair {integer} {list data} tup))
                       [False, True])
                    {all dead. Bool}
                    (/\dead ->
                       let
                         !tup : pair integer (list data) = unConstrData ds
                       in
                       Bool_match
                         (case
                            Bool
                            (equalsInteger
                               `$bScriptCredential`
                               (fstPair {integer} {list data} tup))
                            [False, True])
                         {all dead. Bool}
                         (/\dead ->
                            case
                              Bool
                              (equalsByteString
                                 (unBData
                                    (headList
                                       {data}
                                       (sndPair {integer} {list data} tup)))
                                 (unBData
                                    (headList
                                       {data}
                                       (sndPair {integer} {list data} tup))))
                              [False, True])
                         (/\dead -> False)
                         {all dead. dead})
                    (/\dead -> False)
                    {all dead. dead}
            !tup : pair integer (list data) = unConstrData ds
          in
          Bool_match
            (case
               Bool
               (equalsInteger
                  `$bPubKeyCredential`
                  (fstPair {integer} {list data} tup))
               [False, True])
            {all dead. Bool}
            (/\dead ->
               let
                 !tup : pair integer (list data) = unConstrData ds
               in
               Bool_match
                 (case
                    Bool
                    (equalsInteger
                       `$bPubKeyCredential`
                       (fstPair {integer} {list data} tup))
                    [False, True])
                 {all dead. Bool}
                 (/\dead ->
                    case
                      Bool
                      (equalsByteString
                         (unBData
                            (headList
                               {data}
                               (sndPair {integer} {list data} tup)))
                         (unBData
                            (headList
                               {data}
                               (sndPair {integer} {list data} tup))))
                      [False, True])
                 (/\dead -> fail ())
                 {all dead. dead})
            (/\dead -> fail ())
            {all dead. dead}
    !`$mStakingPtr` :
       all r. data -> (integer -> integer -> integer -> r) -> (unit -> r) -> r
      = /\r ->
          \(scrut : data)
           (cont : integer -> integer -> integer -> r)
           (fail : unit -> r) ->
            let
              !tup : pair integer (list data) = unConstrData scrut
            in
            Bool_match
              (case
                 Bool
                 (equalsInteger
                    `$bScriptCredential`
                    (fstPair {integer} {list data} tup))
                 [False, True])
              {all dead. r}
              (/\dead ->
                 let
                   !l : list data = sndPair {integer} {list data} tup
                   !l : list data = tailList {data} l
                 in
                 cont
                   (unIData (headList {data} l))
                   (unIData (headList {data} l))
                   (unIData (headList {data} (tailList {data} l))))
              (/\dead -> fail ())
              {all dead. dead}
    !`$bNoOutputDatum` : integer = 0
    !`$bOutputDatum` : integer = 2
    !`$bOutputDatumHash` : integer = 1
    !txOutRefId : data -> bytestring
      = \(ds : data) ->
          unBData
            (headList {data} (sndPair {integer} {list data} (unConstrData ds)))
    !txOutRefIdx : data -> integer
      = \(ds : data) ->
          unIData
            (headList
               {data}
               (tailList
                  {data}
                  (sndPair {integer} {list data} (unConstrData ds))))
    !`$mPubKeyCredential` : all r. data -> (bytestring -> r) -> (unit -> r) -> r
      = /\r ->
          \(scrut : data) (cont : bytestring -> r) (fail : unit -> r) ->
            let
              !tup : pair integer (list data) = unConstrData scrut
            in
            Bool_match
              (case
                 Bool
                 (equalsInteger
                    `$bPubKeyCredential`
                    (fstPair {integer} {list data} tup))
                 [False, True])
              {all dead. r}
              (/\dead ->
                 cont
                   (unBData
                      (headList {data} (sndPair {integer} {list data} tup))))
              (/\dead -> fail ())
              {all dead. dead}
    !`$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData` : data -> data
      = \(d : data) -> d
    !reconstructCaseError : string = "PT1"
    !traceError : all a. string -> a
      = /\a ->
          \(str : string) -> let !x : Unit = trace {Unit} str Unit in error {a}
    data (Maybe :: * -> *) a | Maybe_match where
      Just : a -> Maybe a
      Nothing : Maybe a
    !`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData` :
       all a. (\a -> data -> a) a -> data -> Maybe a
      = /\a ->
          \(`$dUnsafeFromData` : (\a -> data -> a) a) (d : data) ->
            let
              !tup : pair integer (list data) = unConstrData d
              !index : integer = fstPair {integer} {list data} tup
              !args : list data = sndPair {integer} {list data} tup
            in
            Bool_match
              (case Bool (equalsInteger 1 index) [False, True])
              {all dead. Maybe a}
              (/\dead -> Nothing {a})
              (/\dead ->
                 Bool_match
                   (case Bool (equalsInteger 0 index) [False, True])
                   {all dead. Maybe a}
                   (/\dead ->
                      Just {a} (`$dUnsafeFromData` (headList {data} args)))
                   (/\dead -> traceError {Maybe a} reconstructCaseError)
                   {all dead. dead})
              {all dead. dead}
    !`$mSpendingScript` :
       all r. data -> (data -> Maybe data -> r) -> (unit -> r) -> r
      = /\r ->
          \(scrut : data) (cont : data -> Maybe data -> r) (fail : unit -> r) ->
            let
              !tup : pair integer (list data) = unConstrData scrut
            in
            Bool_match
              (case
                 Bool
                 (equalsInteger 1 (fstPair {integer} {list data} tup))
                 [False, True])
              {all dead. r}
              (/\dead ->
                 let
                   !l : list data = sndPair {integer} {list data} tup
                 in
                 cont
                   (headList {data} l)
                   (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                      {data}
                      `$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData`
                      (headList {data} (tailList {data} l))))
              (/\dead -> fail ())
              {all dead. dead}
    !`/=` : all a. (\a -> a -> a -> Bool) a -> a -> a -> Bool
      = /\a ->
          \(`$dEq` : (\a -> a -> a -> Bool) a) (x : a) (y : a) ->
            Bool_match
              (`$dEq` x y)
              {all dead. Bool}
              (/\dead -> False)
              (/\dead -> True)
              {all dead. dead}
    data (Solo :: * -> *) a | Solo_match where
      MkSolo : a -> Solo a
    !lookup' : data -> list (pair data data) -> Maybe data
      = \(k : data) ->
          letrec
            !go : list (pair data data) -> Maybe data
              = \(xs : list (pair data data)) ->
                  case
                    (Maybe data)
                    xs
                    [ (Nothing {data})
                    , (\(hd : pair data data) ->
                         Bool_match
                           (case
                              Bool
                              (equalsData k (fstPair {data} {data} hd))
                              [False, True])
                           {all dead. list (pair data data) -> Maybe data}
                           (/\dead ->
                              \(ds : list (pair data data)) ->
                                Just {data} (sndPair {data} {data} hd))
                           (/\dead -> go)
                           {all dead. dead}) ]
          in
          \(m : list (pair data data)) -> go m
    !assetClassValueOf :
       (\k a -> list (pair data data))
         bytestring
         ((\k a -> list (pair data data)) bytestring integer) ->
       Tuple2 bytestring bytestring ->
       integer
      = \(v :
            (\k a -> list (pair data data))
              bytestring
              ((\k a -> list (pair data data)) bytestring integer))
         (ds : Tuple2 bytestring bytestring) ->
          Tuple2_match
            {bytestring}
            {bytestring}
            ds
            {integer}
            (\(c : bytestring) (t : bytestring) ->
               Maybe_match
                 {data}
                 (lookup' (bData c) v)
                 {integer}
                 (\(a : data) ->
                    let
                      !m : list (pair data data) = unMapData a
                    in
                    Maybe_match
                      {data}
                      (lookup' (bData t) m)
                      {integer}
                      (\(a : data) -> unIData a)
                      0)
                 0)
    data VestingDatum | VestingDatum_match where
      VestingDatum :
        data ->
        Tuple2 bytestring bytestring ->
        integer ->
        integer ->
        integer ->
        integer ->
        integer ->
        VestingDatum
    !beneficiary : VestingDatum -> data
      = \(ds : VestingDatum) ->
          VestingDatum_match
            ds
            {data}
            (\(ds : data)
              (ds : Tuple2 bytestring bytestring)
              (ds : integer)
              (ds : integer)
              (ds : integer)
              (ds : integer)
              (ds : integer) ->
               ds)
    !`$mScriptCredential` : all r. data -> (bytestring -> r) -> (unit -> r) -> r
      = /\r ->
          \(scrut : data) (cont : bytestring -> r) (fail : unit -> r) ->
            let
              !tup : pair integer (list data) = unConstrData scrut
            in
            Bool_match
              (case
                 Bool
                 (equalsInteger
                    `$bScriptCredential`
                    (fstPair {integer} {list data} tup))
                 [False, True])
              {all dead. r}
              (/\dead ->
                 cont
                   (unBData
                      (headList {data} (sndPair {integer} {list data} tup))))
              (/\dead -> fail ())
              {all dead. dead}
    !addressCredential : data -> data
      = \(ds : data) ->
          headList {data} (sndPair {integer} {list data} (unConstrData ds))
    !getLowerInclusiveTimeRange : (\a -> data) integer -> integer
      = \(ds : (\a -> data) integer) ->
          let
            !l : list data
              = sndPair
                  {integer}
                  {list data}
                  (unConstrData
                     (headList
                        {data}
                        (sndPair {integer} {list data} (unConstrData ds))))
            !tup : pair integer (list data) = unConstrData (headList {data} l)
          in
          Bool_match
            (case
               Bool
               (equalsInteger 1 (fstPair {integer} {list data} tup))
               [False, True])
            {all dead. integer}
            (/\dead ->
               let
                 !posixTime : integer
                   = unIData
                       (headList {data} (sndPair {integer} {list data} tup))
               in
               Bool_match
                 (let
                   !tup : pair integer (list data)
                     = unConstrData (headList {data} (tailList {data} l))
                   !index : integer = fstPair {integer} {list data} tup
                   !args : list data = sndPair {integer} {list data} tup
                 in
                 Bool_match
                   (case Bool (equalsInteger 0 index) [False, True])
                   {all dead. Bool}
                   (/\dead -> False)
                   (/\dead ->
                      Bool_match
                        (case Bool (equalsInteger 1 index) [False, True])
                        {all dead. Bool}
                        (/\dead -> True)
                        (/\dead -> traceError {Bool} reconstructCaseError)
                        {all dead. dead})
                   {all dead. dead})
                 {all dead. integer}
                 (/\dead -> posixTime)
                 (/\dead -> addInteger 1 posixTime)
                 {all dead. dead})
            (/\dead -> traceError {integer} "Time range not Finite")
            {all dead. dead}
    !greaterThanEqualsInteger : integer -> integer -> Bool
      = \(x : integer) (y : integer) ->
          case Bool (lessThanInteger x y) [True, False]
    !not : Bool -> Bool
      = \(a : Bool) ->
          Bool_match
            a
            {all dead. Bool}
            (/\dead -> False)
            (/\dead -> True)
            {all dead. dead}
    !`$mScriptContext` :
       all r. data -> (data -> data -> data -> r) -> (unit -> r) -> r
      = /\r ->
          \(scrut : data)
           (cont : data -> data -> data -> r)
           (fail : unit -> r) ->
            let
              !l : list data
                = sndPair {integer} {list data} (unConstrData scrut)
              !l : list data = tailList {data} l
            in
            cont
              (headList {data} l)
              (headList {data} l)
              (headList {data} (tailList {data} l))
    !scriptContextScriptInfo : data -> data
      = \(ds : data) ->
          `$mScriptContext`
            {data}
            ds
            (\(ds : data) (ds : data) (ds : data) -> ds)
            (\(void : unit) -> error {data})
    !scriptContextTxInfo : data -> data
      = \(ds : data) ->
          `$mScriptContext`
            {data}
            ds
            (\(ds : data) (ds : data) (ds : data) -> ds)
            (\(void : unit) -> error {data})
    !subtractInteger : integer -> integer -> integer
      = \(x : integer) (y : integer) -> subtractInteger x y
    !totalInstallments : VestingDatum -> integer
      = \(ds : VestingDatum) ->
          VestingDatum_match
            ds
            {integer}
            (\(ds : data)
              (ds : Tuple2 bytestring bytestring)
              (ds : integer)
              (ds : integer)
              (ds : integer)
              (ds : integer)
              (ds : integer) ->
               ds)
    !txInInfoResolved : data -> data
      = \(ds : data) ->
          headList
            {data}
            (tailList {data} (sndPair {integer} {list data} (unConstrData ds)))
    !`$mTxInfo` :
       all r.
         data ->
         ((\a -> list data) data ->
          (\a -> list data) data ->
          (\a -> list data) data ->
          integer ->
          (\k a -> list (pair data data))
            bytestring
            ((\k a -> list (pair data data)) bytestring integer) ->
          (\a -> list data) data ->
          (\k a -> list (pair data data)) data integer ->
          (\a -> data) integer ->
          (\a -> list data) bytestring ->
          (\k a -> list (pair data data)) data data ->
          (\k a -> list (pair data data)) bytestring data ->
          bytestring ->
          (\k a -> list (pair data data))
            data
            ((\k a -> list (pair data data)) data data) ->
          (\a -> list data) data ->
          Maybe integer ->
          Maybe integer ->
          r) ->
         (unit -> r) ->
         r
      = /\r ->
          \(scrut : data)
           (cont :
              (\a -> list data) data ->
              (\a -> list data) data ->
              (\a -> list data) data ->
              integer ->
              (\k a -> list (pair data data))
                bytestring
                ((\k a -> list (pair data data)) bytestring integer) ->
              (\a -> list data) data ->
              (\k a -> list (pair data data)) data integer ->
              (\a -> data) integer ->
              (\a -> list data) bytestring ->
              (\k a -> list (pair data data)) data data ->
              (\k a -> list (pair data data)) bytestring data ->
              bytestring ->
              (\k a -> list (pair data data))
                data
                ((\k a -> list (pair data data)) data data) ->
              (\a -> list data) data ->
              Maybe integer ->
              Maybe integer ->
              r)
           (fail : unit -> r) ->
            let
              !l : list data
                = sndPair {integer} {list data} (unConstrData scrut)
              !l : list data = tailList {data} l
              !l : list data = tailList {data} l
              !l : list data = tailList {data} l
              !l : list data = tailList {data} l
              !l : list data = tailList {data} l
              !l : list data = tailList {data} l
              !l : list data = tailList {data} l
              !l : list data = tailList {data} l
              !l : list data = tailList {data} l
              !l : list data = tailList {data} l
              !l : list data = tailList {data} l
              !l : list data = tailList {data} l
              !l : list data = tailList {data} l
              !l : list data = tailList {data} l
            in
            cont
              (unListData (headList {data} l))
              (unListData (headList {data} l))
              (unListData (headList {data} l))
              (unIData (headList {data} l))
              (unMapData (headList {data} l))
              (unListData (headList {data} l))
              (unMapData (headList {data} l))
              (headList {data} l)
              (unListData (headList {data} l))
              (unMapData (headList {data} l))
              (unMapData (headList {data} l))
              (unBData (headList {data} l))
              (unMapData (headList {data} l))
              (unListData (headList {data} l))
              (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                 {integer}
                 unIData
                 (headList {data} l))
              (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                 {integer}
                 unIData
                 (headList {data} (tailList {data} l)))
    !txInfoValidRange : data -> (\a -> data) integer
      = \(ds : data) ->
          `$mTxInfo`
            {(\a -> data) integer}
            ds
            (\(ds : (\a -> list data) data)
              (ds : (\a -> list data) data)
              (ds : (\a -> list data) data)
              (ds : integer)
              (ds :
                 (\k a -> list (pair data data))
                   bytestring
                   ((\k a -> list (pair data data)) bytestring integer))
              (ds : (\a -> list data) data)
              (ds : (\k a -> list (pair data data)) data integer)
              (ds : (\a -> data) integer)
              (ds : (\a -> list data) bytestring)
              (ds : (\k a -> list (pair data data)) data data)
              (ds : (\k a -> list (pair data data)) bytestring data)
              (ds : bytestring)
              (ds :
                 (\k a -> list (pair data data))
                   data
                   ((\k a -> list (pair data data)) data data))
              (ds : (\a -> list data) data)
              (ds : Maybe integer)
              (ds : Maybe integer) ->
               ds)
            (\(void : unit) -> error {(\a -> data) integer})
    !`$mTxOut` :
       all r.
         data ->
         (data ->
          (\k a -> list (pair data data))
            bytestring
            ((\k a -> list (pair data data)) bytestring integer) ->
          data ->
          Maybe bytestring ->
          r) ->
         (unit -> r) ->
         r
      = /\r ->
          \(scrut : data)
           (cont :
              data ->
              (\k a -> list (pair data data))
                bytestring
                ((\k a -> list (pair data data)) bytestring integer) ->
              data ->
              Maybe bytestring ->
              r)
           (fail : unit -> r) ->
            let
              !l : list data
                = sndPair {integer} {list data} (unConstrData scrut)
              !l : list data = tailList {data} l
              !l : list data = tailList {data} l
            in
            cont
              (headList {data} l)
              (unMapData (headList {data} l))
              (headList {data} l)
              (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                 {bytestring}
                 unBData
                 (headList {data} (tailList {data} l)))
    !txOutAddress : data -> data
      = \(ds : data) ->
          `$mTxOut`
            {data}
            ds
            (\(ds : data)
              (ds :
                 (\k a -> list (pair data data))
                   bytestring
                   ((\k a -> list (pair data data)) bytestring integer))
              (ds : data)
              (ds : Maybe bytestring) ->
               ds)
            (\(void : unit) -> error {data})
    !txOutDatum : data -> data
      = \(ds : data) ->
          `$mTxOut`
            {data}
            ds
            (\(ds : data)
              (ds :
                 (\k a -> list (pair data data))
                   bytestring
                   ((\k a -> list (pair data data)) bytestring integer))
              (ds : data)
              (ds : Maybe bytestring) ->
               ds)
            (\(void : unit) -> error {data})
    !txOutValue :
       data ->
       (\k a -> list (pair data data))
         bytestring
         ((\k a -> list (pair data data)) bytestring integer)
      = \(ds : data) ->
          unMapData
            (headList
               {data}
               (tailList
                  {data}
                  (sndPair {integer} {list data} (unConstrData ds))))
    !find :
       all a.
         (\a -> data -> a) a -> (a -> Bool) -> (\a -> list data) a -> Maybe a
      = /\a ->
          \(`$dUnsafeFromData` : (\a -> data -> a) a) (pred' : a -> Bool) ->
            letrec
              !go : (\a -> list data) a -> Maybe a
                = \(ds : (\a -> list data) a) ->
                    case
                      (Maybe a)
                      ds
                      [ (Nothing {a})
                      , (\(x : data) (eta : list data) ->
                           let
                             !h : a = `$dUnsafeFromData` x
                           in
                           Bool_match
                             (pred' h)
                             {all dead. Maybe a}
                             (/\dead -> Just {a} h)
                             (/\dead -> go eta)
                             {all dead. dead}) ]
            in
            \(eta : (\a -> list data) a) -> go eta
    !txSignedBy : data -> bytestring -> Bool
      = \(ds : data) (k : bytestring) ->
          `$mTxInfo`
            {Bool}
            ds
            (\(ds : (\a -> list data) data)
              (ds : (\a -> list data) data)
              (ds : (\a -> list data) data)
              (ds : integer)
              (ds :
                 (\k a -> list (pair data data))
                   bytestring
                   ((\k a -> list (pair data data)) bytestring integer))
              (ds : (\a -> list data) data)
              (ds : (\k a -> list (pair data data)) data integer)
              (ds : (\a -> data) integer)
              (ds : (\a -> list data) bytestring)
              (ds : (\k a -> list (pair data data)) data data)
              (ds : (\k a -> list (pair data data)) bytestring data)
              (ds : bytestring)
              (ds :
                 (\k a -> list (pair data data))
                   data
                   ((\k a -> list (pair data data)) data data))
              (ds : (\a -> list data) data)
              (ds : Maybe integer)
              (ds : Maybe integer) ->
               Maybe_match
                 {bytestring}
                 (find
                    {bytestring}
                    unBData
                    (\(y : bytestring) ->
                       case Bool (equalsByteString k y) [False, True])
                    ds)
                 {all dead. Bool}
                 (\(ds : bytestring) -> /\dead -> True)
                 (/\dead -> False)
                 {all dead. dead})
            (\(void : unit) ->
               let
                 !defaultBody : Bool = error {Bool}
               in
               Unit_match (error {Unit}) {Bool} defaultBody)
    !vestingPeriodEnd : VestingDatum -> integer
      = \(ds : VestingDatum) ->
          VestingDatum_match
            ds
            {integer}
            (\(ds : data)
              (ds : Tuple2 bytestring bytestring)
              (ds : integer)
              (ds : integer)
              (ds : integer)
              (ds : integer)
              (ds : integer) ->
               ds)
  in
  \(scriptContextData : data) ->
    Maybe_match
      {data}
      (trace
         {Maybe data}
         "Parsing ScriptContext..."
         (Just {data} scriptContextData))
      {all dead. unit}
      (\(ctx : data) ->
         /\dead ->
           Bool_match
             (let
               !context : data = trace {data} "Parsed ScriptContext" ctx
             in
             trace
               {Bool}
               "Validation completed"
               (VestingRedeemer_match
                  (Maybe_match
                     {VestingRedeemer}
                     (let
                       !d : data
                         = `$mScriptContext`
                             {data}
                             context
                             (\(ds : data) (ds : data) (ds : data) -> ds)
                             (\(void : unit) -> error {data})
                     in
                     chooseData
                       {Unit -> Maybe VestingRedeemer}
                       d
                       (\(ds : Unit) ->
                          let
                            !tup : pair integer (list data) = unConstrData d
                            !index : integer = fstPair {integer} {list data} tup
                            !args : list data
                              = sndPair {integer} {list data} tup
                          in
                          Bool_match
                            (case Bool (equalsInteger 0 index) [False, True])
                            {all dead. Maybe VestingRedeemer}
                            (/\dead -> Just {VestingRedeemer} PartialUnlock)
                            (/\dead ->
                               Bool_match
                                 (case
                                    Bool
                                    (equalsInteger 1 index)
                                    [False, True])
                                 {all dead. Maybe VestingRedeemer}
                                 (/\dead -> Just {VestingRedeemer} FullUnlock)
                                 (/\dead -> Nothing {VestingRedeemer})
                                 {all dead. dead})
                            {all dead. dead})
                       (\(ds : Unit) -> Nothing {VestingRedeemer})
                       (\(ds : Unit) -> Nothing {VestingRedeemer})
                       (\(ds : Unit) -> Nothing {VestingRedeemer})
                       (\(ds : Unit) -> Nothing {VestingRedeemer})
                       Unit)
                     {all dead. VestingRedeemer}
                     (\(r : VestingRedeemer) ->
                        /\dead -> trace {VestingRedeemer} "Parsed Redeemer" r)
                     (/\dead ->
                        let
                          !x : Unit
                            = trace {Unit} "Failed to parse Redeemer" Unit
                        in
                        error {VestingRedeemer})
                     {all dead. dead})
                  {all dead. Bool}
                  (/\dead ->
                     let
                       !ctx : data
                         = trace {data} "Full unlock requested" context
                     in
                     Tuple2_match
                       {data}
                       {data}
                       (let
                         !nt : data = scriptContextScriptInfo ctx
                       in
                       `$mSpendingScript`
                         {Tuple2 data data}
                         nt
                         (\(_ownRef : data) (ds : Maybe data) ->
                            Maybe_match
                              {data}
                              ds
                              {all dead. Tuple2 data data}
                              (\(ds : data) ->
                                 /\dead -> Tuple2 {data} {data} _ownRef ds)
                              (/\dead -> fail ())
                              {all dead. dead})
                         (\(void : unit) -> fail ()))
                       {Bool}
                       (\(ipv : data)
                         (ipv : data) ->
                          let
                            !ds : Solo VestingDatum
                              = MkSolo
                                  {VestingDatum}
                                  (let
                                    !tup : pair integer (list data)
                                      = unConstrData ipv
                                    !index : integer
                                      = fstPair {integer} {list data} tup
                                    !args : list data
                                      = sndPair {integer} {list data} tup
                                  in
                                  Bool_match
                                    (case
                                       Bool
                                       (equalsInteger 0 index)
                                       [False, True])
                                    {all dead. VestingDatum}
                                    (/\dead ->
                                       let
                                         !l : list data = tailList {data} args
                                         !l : list data = tailList {data} l
                                         !l : list data = tailList {data} l
                                         !l : list data = tailList {data} l
                                         !l : list data = tailList {data} l
                                       in
                                       VestingDatum
                                         (headList {data} args)
                                         (let
                                           !tup : pair integer (list data)
                                             = unConstrData (headList {data} l)
                                           !index : integer
                                             = fstPair {integer} {list data} tup
                                           !args : list data
                                             = sndPair {integer} {list data} tup
                                         in
                                         Bool_match
                                           (case
                                              Bool
                                              (equalsInteger 0 index)
                                              [False, True])
                                           {all dead.
                                              Tuple2 bytestring bytestring}
                                           (/\dead ->
                                              Tuple2
                                                {bytestring}
                                                {bytestring}
                                                (unBData (headList {data} args))
                                                (unBData
                                                   (headList
                                                      {data}
                                                      (tailList {data} args))))
                                           (/\dead ->
                                              traceError
                                                {Tuple2 bytestring bytestring}
                                                reconstructCaseError)
                                           {all dead. dead})
                                         (unIData (headList {data} l))
                                         (unIData (headList {data} l))
                                         (unIData (headList {data} l))
                                         (unIData (headList {data} l))
                                         (unIData
                                            (headList
                                               {data}
                                               (tailList {data} l))))
                                    (/\dead ->
                                       traceError
                                         {VestingDatum}
                                         reconstructCaseError)
                                    {all dead. dead})
                            !vestingDatum : VestingDatum
                              = Solo_match
                                  {VestingDatum}
                                  ds
                                  {VestingDatum}
                                  (\(vestingDatum : VestingDatum) ->
                                     vestingDatum)
                          in
                          Solo_match
                            {bytestring}
                            (let
                              !nt : data
                                = addressCredential (beneficiary vestingDatum)
                            in
                            `$mPubKeyCredential`
                              {Solo bytestring}
                              nt
                              (\(beneficiaryKey : bytestring) ->
                                 MkSolo {bytestring} beneficiaryKey)
                              (\(void : unit) ->
                                 let
                                   !defaultBody : Solo bytestring
                                     = error {Solo bytestring}
                                 in
                                 Unit_match
                                   (error {Unit})
                                   {Solo bytestring}
                                   defaultBody))
                            {Bool}
                            (\(ipv : bytestring) ->
                               let
                                 !ds : Solo data
                                   = MkSolo {data} (scriptContextTxInfo ctx)
                                 !txInfo : data
                                   = Solo_match
                                       {data}
                                       ds
                                       {data}
                                       (\(txInfo : data) -> txInfo)
                                 !ds : integer
                                   = getLowerInclusiveTimeRange
                                       (txInfoValidRange txInfo)
                               in
                               Bool_match
                                 (not (txSignedBy txInfo ipv))
                                 {all dead. Bool}
                                 (/\dead ->
                                    traceError
                                      {Bool}
                                      "Missing beneficiary signature")
                                 (/\dead ->
                                    Bool_match
                                      (greaterThanEqualsInteger
                                         (vestingPeriodEnd vestingDatum)
                                         ds)
                                      {all dead. Bool}
                                      (/\dead ->
                                         traceError
                                           {Bool}
                                           "Unlock not permitted until vestingPeriodEnd time")
                                      (/\dead -> True)
                                      {all dead. dead})
                                 {all dead. dead})))
                  (/\dead ->
                     let
                       !ctx : data
                         = trace {data} "Partial unlock requested" context
                     in
                     Tuple2_match
                       {data}
                       {data}
                       (let
                         !nt : data = scriptContextScriptInfo ctx
                       in
                       `$mSpendingScript`
                         {Tuple2 data data}
                         nt
                         (\(ownRef : data) (ds : Maybe data) ->
                            Maybe_match
                              {data}
                              ds
                              {all dead. Tuple2 data data}
                              (\(ds : data) ->
                                 /\dead -> Tuple2 {data} {data} ownRef ds)
                              (/\dead -> fail ())
                              {all dead. dead})
                         (\(void : unit) -> fail ()))
                       {Bool}
                       (\(ipv : data)
                         (ipv : data) ->
                          let
                            !ds : Solo VestingDatum
                              = MkSolo
                                  {VestingDatum}
                                  (let
                                    !tup : pair integer (list data)
                                      = unConstrData ipv
                                    !index : integer
                                      = fstPair {integer} {list data} tup
                                    !args : list data
                                      = sndPair {integer} {list data} tup
                                  in
                                  Bool_match
                                    (case
                                       Bool
                                       (equalsInteger 0 index)
                                       [False, True])
                                    {all dead. VestingDatum}
                                    (/\dead ->
                                       let
                                         !l : list data = tailList {data} args
                                         !l : list data = tailList {data} l
                                         !l : list data = tailList {data} l
                                         !l : list data = tailList {data} l
                                         !l : list data = tailList {data} l
                                       in
                                       VestingDatum
                                         (headList {data} args)
                                         (let
                                           !tup : pair integer (list data)
                                             = unConstrData (headList {data} l)
                                           !index : integer
                                             = fstPair {integer} {list data} tup
                                           !args : list data
                                             = sndPair {integer} {list data} tup
                                         in
                                         Bool_match
                                           (case
                                              Bool
                                              (equalsInteger 0 index)
                                              [False, True])
                                           {all dead.
                                              Tuple2 bytestring bytestring}
                                           (/\dead ->
                                              Tuple2
                                                {bytestring}
                                                {bytestring}
                                                (unBData (headList {data} args))
                                                (unBData
                                                   (headList
                                                      {data}
                                                      (tailList {data} args))))
                                           (/\dead ->
                                              traceError
                                                {Tuple2 bytestring bytestring}
                                                reconstructCaseError)
                                           {all dead. dead})
                                         (unIData (headList {data} l))
                                         (unIData (headList {data} l))
                                         (unIData (headList {data} l))
                                         (unIData (headList {data} l))
                                         (unIData
                                            (headList
                                               {data}
                                               (tailList {data} l))))
                                    (/\dead ->
                                       traceError
                                         {VestingDatum}
                                         reconstructCaseError)
                                    {all dead. dead})
                            !vestingDatum : VestingDatum
                              = Solo_match
                                  {VestingDatum}
                                  ds
                                  {VestingDatum}
                                  (\(vestingDatum : VestingDatum) ->
                                     vestingDatum)
                            !ds : Solo (Tuple2 bytestring bytestring)
                              = MkSolo
                                  {Tuple2 bytestring bytestring}
                                  (VestingDatum_match
                                     vestingDatum
                                     {Tuple2 bytestring bytestring}
                                     (\(ds : data)
                                       (ds : Tuple2 bytestring bytestring)
                                       (ds : integer)
                                       (ds : integer)
                                       (ds : integer)
                                       (ds : integer)
                                       (ds : integer) ->
                                        ds))
                            ~asset : Tuple2 bytestring bytestring
                              = Solo_match
                                  {Tuple2 bytestring bytestring}
                                  ds
                                  {Tuple2 bytestring bytestring}
                                  (\(asset : Tuple2 bytestring bytestring) ->
                                     asset)
                            !ds : integer
                              = divCeil
                                  (subtractInteger
                                     (vestingPeriodEnd vestingDatum)
                                     (VestingDatum_match
                                        vestingDatum
                                        {integer}
                                        (\(ds : data)
                                          (ds : Tuple2 bytestring bytestring)
                                          (ds : integer)
                                          (ds : integer)
                                          (ds : integer)
                                          (ds : integer)
                                          (ds : integer) ->
                                           ds)))
                                  (totalInstallments vestingDatum)
                          in
                          Solo_match
                            {bytestring}
                            (let
                              !nt : data
                                = addressCredential (beneficiary vestingDatum)
                            in
                            `$mPubKeyCredential`
                              {Solo bytestring}
                              nt
                              (\(beneficiaryHash : bytestring) ->
                                 MkSolo {bytestring} beneficiaryHash)
                              (\(void : unit) ->
                                 let
                                   !defaultBody : Solo bytestring
                                     = error {Solo bytestring}
                                 in
                                 Unit_match
                                   (error {Unit})
                                   {Solo bytestring}
                                   defaultBody))
                            {Bool}
                            (\(ipv : bytestring) ->
                               let
                                 !ds : Solo data
                                   = MkSolo {data} (scriptContextTxInfo ctx)
                                 !txInfo : data
                                   = Solo_match
                                       {data}
                                       ds
                                       {data}
                                       (\(txInfo : data) -> txInfo)
                                 !nt : list data
                                   = `$mTxInfo`
                                       {(\a -> list data) data}
                                       txInfo
                                       (\(ds : (\a -> list data) data)
                                         (ds : (\a -> list data) data)
                                         (ds : (\a -> list data) data)
                                         (ds : integer)
                                         (ds :
                                            (\k a -> list (pair data data))
                                              bytestring
                                              ((\k a -> list (pair data data))
                                                 bytestring
                                                 integer))
                                         (ds : (\a -> list data) data)
                                         (ds :
                                            (\k a -> list (pair data data))
                                              data
                                              integer)
                                         (ds : (\a -> data) integer)
                                         (ds : (\a -> list data) bytestring)
                                         (ds :
                                            (\k a -> list (pair data data))
                                              data
                                              data)
                                         (ds :
                                            (\k a -> list (pair data data))
                                              bytestring
                                              data)
                                         (ds : bytestring)
                                         (ds :
                                            (\k a -> list (pair data data))
                                              data
                                              ((\k a -> list (pair data data))
                                                 data
                                                 data))
                                         (ds : (\a -> list data) data)
                                         (ds : Maybe integer)
                                         (ds : Maybe integer) ->
                                          ds)
                                       (\(void : unit) ->
                                          error {(\a -> list data) data})
                                 !ds :
                                    Solo data
                                   = Maybe_match
                                       {data}
                                       (find
                                          {data}
                                          `$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData`
                                          (\(eta : data) ->
                                             let
                                               !l : data
                                                 = headList
                                                     {data}
                                                     (sndPair
                                                        {integer}
                                                        {list data}
                                                        (unConstrData eta))
                                             in
                                             Bool_match
                                               (case
                                                  Bool
                                                  (equalsByteString
                                                     (txOutRefId l)
                                                     (txOutRefId ipv))
                                                  [False, True])
                                               {all dead. Bool}
                                               (/\dead ->
                                                  case
                                                    Bool
                                                    (equalsInteger
                                                       (txOutRefIdx l)
                                                       (txOutRefIdx ipv))
                                                    [False, True])
                                               (/\dead -> False)
                                               {all dead. dead})
                                          nt)
                                       {all dead. Solo data}
                                       (\(ownVestingInput : data) ->
                                          /\dead ->
                                            MkSolo {data} ownVestingInput)
                                       (/\dead ->
                                          let
                                            !defaultBody : Solo data
                                              = error {Solo data}
                                          in
                                          Unit_match
                                            (error {Unit})
                                            {Solo data}
                                            defaultBody)
                                       {all dead. dead}
                               in
                               Solo_match
                                 {data}
                                 ds
                                 {Bool}
                                 (\(ipv : data) ->
                                    let
                                      !nt : data = txInInfoResolved ipv
                                      !nt : data = txOutAddress nt
                                    in
                                    Solo_match
                                      {bytestring}
                                      (let
                                        !nt : data = addressCredential nt
                                      in
                                      `$mScriptCredential`
                                        {Solo bytestring}
                                        nt
                                        (\(scriptHash : bytestring) ->
                                           MkSolo {bytestring} scriptHash)
                                        (\(void : unit) ->
                                           let
                                             !defaultBody : Solo bytestring
                                               = error {Solo bytestring}
                                           in
                                           Unit_match
                                             (error {Unit})
                                             {Solo bytestring}
                                             defaultBody))
                                      {Bool}
                                      (\(ipv : bytestring) ->
                                         letrec
                                           !go :
                                              integer ->
                                              (\a -> list data) data ->
                                              integer
                                             = \(n : integer)
                                                (ds : (\a -> list data) data) ->
                                                 case
                                                   integer
                                                   ds
                                                   [ n
                                                   , (\(x : data)
                                                       (eta : list data) ->
                                                        let
                                                          !nt :
                                                             data
                                                            = addressCredential
                                                                (txOutAddress
                                                                   (txInInfoResolved
                                                                      x))
                                                        in
                                                        `$mScriptCredential`
                                                          {integer}
                                                          nt
                                                          (\(vh : bytestring) ->
                                                             Bool_match
                                                               (case
                                                                  Bool
                                                                  (equalsByteString
                                                                     vh
                                                                     ipv)
                                                                  [False, True])
                                                               {all dead.
                                                                  integer}
                                                               (/\dead ->
                                                                  go
                                                                    (addInteger
                                                                       1
                                                                       n)
                                                                    eta)
                                                               (/\dead ->
                                                                  go n eta)
                                                               {all dead. dead})
                                                          (\(void : unit) ->
                                                             go n eta)) ]
                                         in
                                         let
                                           !ds : integer
                                             = assetClassValueOf
                                                 (txOutValue nt)
                                                 asset
                                           !ds :
                                              Solo data
                                             = Maybe_match
                                                 {data}
                                                 (find
                                                    {data}
                                                    `$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData`
                                                    (\(eta : data) ->
                                                       let
                                                         !l : list data
                                                           = sndPair
                                                               {integer}
                                                               {list data}
                                                               (unConstrData
                                                                  (txOutAddress
                                                                     eta))
                                                         !l : list data
                                                           = sndPair
                                                               {integer}
                                                               {list data}
                                                               (unConstrData nt)
                                                       in
                                                       Bool_match
                                                         (`$fEqCredential_$c==`
                                                            (headList {data} l)
                                                            (headList {data} l))
                                                         {all dead. Bool}
                                                         (/\dead ->
                                                            Maybe_match
                                                              {data}
                                                              (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                                                                 {data}
                                                                 `$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData`
                                                                 (headList
                                                                    {data}
                                                                    (tailList
                                                                       {data}
                                                                       l)))
                                                              {all dead. Bool}
                                                              (\(a : data) ->
                                                                 /\dead ->
                                                                   Maybe_match
                                                                     {data}
                                                                     (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                                                                        {data}
                                                                        `$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData`
                                                                        (headList
                                                                           {data}
                                                                           (tailList
                                                                              {data}
                                                                              l)))
                                                                     {all dead.
                                                                        Bool}
                                                                     (\(a :
                                                                          data) ->
                                                                        let
                                                                          !fail :
                                                                             unit ->
                                                                             Bool
                                                                            = \(ds :
                                                                                  unit) ->
                                                                                `$mStakingPtr`
                                                                                  {Bool}
                                                                                  a
                                                                                  (\(a :
                                                                                       integer)
                                                                                    (b :
                                                                                       integer)
                                                                                    (c :
                                                                                       integer) ->
                                                                                     `$mStakingPtr`
                                                                                       {Bool}
                                                                                       a
                                                                                       (\(a' :
                                                                                            integer)
                                                                                         (b' :
                                                                                            integer)
                                                                                         (c' :
                                                                                            integer) ->
                                                                                          Bool_match
                                                                                            (case
                                                                                               Bool
                                                                                               (equalsInteger
                                                                                                  a
                                                                                                  a')
                                                                                               [ False
                                                                                               , True ])
                                                                                            {all dead.
                                                                                               Bool}
                                                                                            (/\dead ->
                                                                                               Bool_match
                                                                                                 (case
                                                                                                    Bool
                                                                                                    (equalsInteger
                                                                                                       b
                                                                                                       b')
                                                                                                    [ False
                                                                                                    , True ])
                                                                                                 {all dead.
                                                                                                    Bool}
                                                                                                 (/\dead ->
                                                                                                    case
                                                                                                      Bool
                                                                                                      (equalsInteger
                                                                                                         c
                                                                                                         c')
                                                                                                      [ False
                                                                                                      , True ])
                                                                                                 (/\dead ->
                                                                                                    False)
                                                                                                 {all dead.
                                                                                                    dead})
                                                                                            (/\dead ->
                                                                                               False)
                                                                                            {all dead.
                                                                                               dead})
                                                                                       (\(void :
                                                                                            unit) ->
                                                                                          False))
                                                                                  (\(void :
                                                                                       unit) ->
                                                                                     False)
                                                                        in
                                                                        /\dead ->
                                                                          let
                                                                            !tup :
                                                                               pair
                                                                                 integer
                                                                                 (list
                                                                                    data)
                                                                              = unConstrData
                                                                                  a
                                                                          in
                                                                          Bool_match
                                                                            (case
                                                                               Bool
                                                                               (equalsInteger
                                                                                  `$bPubKeyCredential`
                                                                                  (fstPair
                                                                                     {integer}
                                                                                     {list
                                                                                        data}
                                                                                     tup))
                                                                               [ False
                                                                               , True ])
                                                                            {all dead.
                                                                               Bool}
                                                                            (/\dead ->
                                                                               let
                                                                                 !tup :
                                                                                    pair
                                                                                      integer
                                                                                      (list
                                                                                         data)
                                                                                   = unConstrData
                                                                                       a
                                                                               in
                                                                               Bool_match
                                                                                 (case
                                                                                    Bool
                                                                                    (equalsInteger
                                                                                       `$bPubKeyCredential`
                                                                                       (fstPair
                                                                                          {integer}
                                                                                          {list
                                                                                             data}
                                                                                          tup))
                                                                                    [ False
                                                                                    , True ])
                                                                                 {all dead.
                                                                                    Bool}
                                                                                 (/\dead ->
                                                                                    `$fEqCredential_$c==`
                                                                                      (headList
                                                                                         {data}
                                                                                         (sndPair
                                                                                            {integer}
                                                                                            {list
                                                                                               data}
                                                                                            tup))
                                                                                      (headList
                                                                                         {data}
                                                                                         (sndPair
                                                                                            {integer}
                                                                                            {list
                                                                                               data}
                                                                                            tup)))
                                                                                 (/\dead ->
                                                                                    fail
                                                                                      ())
                                                                                 {all dead.
                                                                                    dead})
                                                                            (/\dead ->
                                                                               fail
                                                                                 ())
                                                                            {all dead.
                                                                               dead})
                                                                     (/\dead ->
                                                                        False)
                                                                     {all dead.
                                                                        dead})
                                                              (/\dead ->
                                                                 Maybe_match
                                                                   {data}
                                                                   (`$fUnsafeFromDataMaybe_$cunsafeFromBuiltinData`
                                                                      {data}
                                                                      `$fUnsafeFromDataBuiltinData_$cunsafeFromBuiltinData`
                                                                      (headList
                                                                         {data}
                                                                         (tailList
                                                                            {data}
                                                                            l)))
                                                                   {all dead.
                                                                      Bool}
                                                                   (\(ipv :
                                                                        data) ->
                                                                      /\dead ->
                                                                        False)
                                                                   (/\dead ->
                                                                      True)
                                                                   {all dead.
                                                                      dead})
                                                              {all dead. dead})
                                                         (/\dead -> False)
                                                         {all dead. dead})
                                                    (`$mTxInfo`
                                                       {(\a -> list data) data}
                                                       txInfo
                                                       (\(ds :
                                                            (\a -> list data)
                                                              data)
                                                         (ds :
                                                            (\a -> list data)
                                                              data)
                                                         (ds :
                                                            (\a -> list data)
                                                              data)
                                                         (ds : integer)
                                                         (ds :
                                                            (\k a ->
                                                               list
                                                                 (pair
                                                                    data
                                                                    data))
                                                              bytestring
                                                              ((\k a ->
                                                                  list
                                                                    (pair
                                                                       data
                                                                       data))
                                                                 bytestring
                                                                 integer))
                                                         (ds :
                                                            (\a -> list data)
                                                              data)
                                                         (ds :
                                                            (\k a ->
                                                               list
                                                                 (pair
                                                                    data
                                                                    data))
                                                              data
                                                              integer)
                                                         (ds :
                                                            (\a -> data)
                                                              integer)
                                                         (ds :
                                                            (\a -> list data)
                                                              bytestring)
                                                         (ds :
                                                            (\k a ->
                                                               list
                                                                 (pair
                                                                    data
                                                                    data))
                                                              data
                                                              data)
                                                         (ds :
                                                            (\k a ->
                                                               list
                                                                 (pair
                                                                    data
                                                                    data))
                                                              bytestring
                                                              data)
                                                         (ds : bytestring)
                                                         (ds :
                                                            (\k a ->
                                                               list
                                                                 (pair
                                                                    data
                                                                    data))
                                                              data
                                                              ((\k a ->
                                                                  list
                                                                    (pair
                                                                       data
                                                                       data))
                                                                 data
                                                                 data))
                                                         (ds :
                                                            (\a -> list data)
                                                              data)
                                                         (ds : Maybe integer)
                                                         (ds : Maybe integer) ->
                                                          ds)
                                                       (\(void : unit) ->
                                                          error
                                                            {(\a -> list data)
                                                               data})))
                                                 {all dead. Solo data}
                                                 (\(ownVestingOutput : data) ->
                                                    /\dead ->
                                                      MkSolo
                                                        {data}
                                                        ownVestingOutput)
                                                 (/\dead ->
                                                    let
                                                      !defaultBody : Solo data
                                                        = error {Solo data}
                                                    in
                                                    Unit_match
                                                      (error {Unit})
                                                      {Solo data}
                                                      defaultBody)
                                                 {all dead. dead}
                                           !ownVestingOutput : data
                                             = Solo_match
                                                 {data}
                                                 ds
                                                 {data}
                                                 (\(ownVestingOutput : data) ->
                                                    ownVestingOutput)
                                           !nt : data
                                             = txOutDatum ownVestingOutput
                                           !ds : Solo integer
                                             = MkSolo
                                                 {integer}
                                                 (assetClassValueOf
                                                    (txOutValue
                                                       ownVestingOutput)
                                                    asset)
                                           ~newRemainingQty : integer
                                             = Solo_match
                                                 {integer}
                                                 ds
                                                 {integer}
                                                 (\(newRemainingQty :
                                                      integer) ->
                                                    newRemainingQty)
                                           !ds : Solo integer
                                             = MkSolo
                                                 {integer}
                                                 (getLowerInclusiveTimeRange
                                                    (txInfoValidRange txInfo))
                                           !currentTimeApproximation : integer
                                             = Solo_match
                                                 {integer}
                                                 ds
                                                 {integer}
                                                 (\(currentTimeApproximation :
                                                      integer) ->
                                                    currentTimeApproximation)
                                           !ds :
                                              integer
                                             = divCeil
                                                 (multiplyInteger
                                                    (divCeil
                                                       (subtractInteger
                                                          (vestingPeriodEnd
                                                             vestingDatum)
                                                          currentTimeApproximation)
                                                       ds)
                                                    (VestingDatum_match
                                                       vestingDatum
                                                       {integer}
                                                       (\(ds : data)
                                                         (ds :
                                                            Tuple2
                                                              bytestring
                                                              bytestring)
                                                         (ds : integer)
                                                         (ds : integer)
                                                         (ds : integer)
                                                         (ds : integer)
                                                         (ds : integer) ->
                                                          ds)))
                                                 (totalInstallments
                                                    vestingDatum)
                                         in
                                         Bool_match
                                           (not (txSignedBy txInfo ipv))
                                           {all dead. Bool}
                                           (/\dead ->
                                              traceError
                                                {Bool}
                                                "Missing beneficiary signature")
                                           (/\dead ->
                                              Bool_match
                                                (greaterThanEqualsInteger
                                                   (VestingDatum_match
                                                      vestingDatum
                                                      {integer}
                                                      (\(ds : data)
                                                        (ds :
                                                           Tuple2
                                                             bytestring
                                                             bytestring)
                                                        (ds : integer)
                                                        (ds : integer)
                                                        (ds : integer)
                                                        (ds : integer)
                                                        (ds : integer) ->
                                                         ds))
                                                   currentTimeApproximation)
                                                {all dead. Bool}
                                                (/\dead ->
                                                   traceError
                                                     {Bool}
                                                     "Unlock not permitted until firstUnlockPossibleAfter time")
                                                (/\dead ->
                                                   Bool_match
                                                     (case
                                                        Bool
                                                        (lessThanEqualsInteger
                                                           newRemainingQty
                                                           0)
                                                        [False, True])
                                                     {all dead. Bool}
                                                     (/\dead ->
                                                        traceError
                                                          {Bool}
                                                          "Zero remaining assets not allowed")
                                                     (/\dead ->
                                                        Bool_match
                                                          (greaterThanEqualsInteger
                                                             newRemainingQty
                                                             ds)
                                                          {all dead. Bool}
                                                          (/\dead ->
                                                             traceError
                                                               {Bool}
                                                               "Remaining asset is not decreasing")
                                                          (/\dead ->
                                                             Bool_match
                                                               (`/=`
                                                                  {integer}
                                                                  (\(x :
                                                                       integer)
                                                                    (y :
                                                                       integer) ->
                                                                     case
                                                                       Bool
                                                                       (equalsInteger
                                                                          x
                                                                          y)
                                                                       [ False
                                                                       , True ])
                                                                  ds
                                                                  newRemainingQty)
                                                               {all dead. Bool}
                                                               (/\dead ->
                                                                  traceError
                                                                    {Bool}
                                                                    "Mismatched remaining asset")
                                                               (/\dead ->
                                                                  Bool_match
                                                                    (`/=`
                                                                       {data}
                                                                       (\(ds :
                                                                            data)
                                                                         (ds :
                                                                            data) ->
                                                                          let
                                                                            !fail :
                                                                               unit ->
                                                                               Bool
                                                                              = \(ds :
                                                                                    unit) ->
                                                                                  let
                                                                                    !tup :
                                                                                       pair
                                                                                         integer
                                                                                         (list
                                                                                            data)
                                                                                      = unConstrData
                                                                                          ds
                                                                                  in
                                                                                  Bool_match
                                                                                    (case
                                                                                       Bool
                                                                                       (equalsInteger
                                                                                          `$bOutputDatum`
                                                                                          (fstPair
                                                                                             {integer}
                                                                                             {list
                                                                                                data}
                                                                                             tup))
                                                                                       [ False
                                                                                       , True ])
                                                                                    {all dead.
                                                                                       Bool}
                                                                                    (/\dead ->
                                                                                       let
                                                                                         !tup :
                                                                                            pair
                                                                                              integer
                                                                                              (list
                                                                                                 data)
                                                                                           = unConstrData
                                                                                               ds
                                                                                       in
                                                                                       Bool_match
                                                                                         (case
                                                                                            Bool
                                                                                            (equalsInteger
                                                                                               `$bOutputDatum`
                                                                                               (fstPair
                                                                                                  {integer}
                                                                                                  {list
                                                                                                     data}
                                                                                                  tup))
                                                                                            [ False
                                                                                            , True ])
                                                                                         {all dead.
                                                                                            Bool}
                                                                                         (/\dead ->
                                                                                            case
                                                                                              Bool
                                                                                              (equalsData
                                                                                                 (headList
                                                                                                    {data}
                                                                                                    (sndPair
                                                                                                       {integer}
                                                                                                       {list
                                                                                                          data}
                                                                                                       tup))
                                                                                                 (headList
                                                                                                    {data}
                                                                                                    (sndPair
                                                                                                       {integer}
                                                                                                       {list
                                                                                                          data}
                                                                                                       tup)))
                                                                                              [ False
                                                                                              , True ])
                                                                                         (/\dead ->
                                                                                            False)
                                                                                         {all dead.
                                                                                            dead})
                                                                                    (/\dead ->
                                                                                       False)
                                                                                    {all dead.
                                                                                       dead}
                                                                            !fail :
                                                                               unit ->
                                                                               Bool
                                                                              = \(ds :
                                                                                    unit) ->
                                                                                  let
                                                                                    !tup :
                                                                                       pair
                                                                                         integer
                                                                                         (list
                                                                                            data)
                                                                                      = unConstrData
                                                                                          ds
                                                                                  in
                                                                                  Bool_match
                                                                                    (case
                                                                                       Bool
                                                                                       (equalsInteger
                                                                                          `$bOutputDatumHash`
                                                                                          (fstPair
                                                                                             {integer}
                                                                                             {list
                                                                                                data}
                                                                                             tup))
                                                                                       [ False
                                                                                       , True ])
                                                                                    {all dead.
                                                                                       Bool}
                                                                                    (/\dead ->
                                                                                       let
                                                                                         !tup :
                                                                                            pair
                                                                                              integer
                                                                                              (list
                                                                                                 data)
                                                                                           = unConstrData
                                                                                               ds
                                                                                       in
                                                                                       Bool_match
                                                                                         (case
                                                                                            Bool
                                                                                            (equalsInteger
                                                                                               `$bOutputDatumHash`
                                                                                               (fstPair
                                                                                                  {integer}
                                                                                                  {list
                                                                                                     data}
                                                                                                  tup))
                                                                                            [ False
                                                                                            , True ])
                                                                                         {all dead.
                                                                                            Bool}
                                                                                         (/\dead ->
                                                                                            case
                                                                                              Bool
                                                                                              (equalsByteString
                                                                                                 (unBData
                                                                                                    (headList
                                                                                                       {data}
                                                                                                       (sndPair
                                                                                                          {integer}
                                                                                                          {list
                                                                                                             data}
                                                                                                          tup)))
                                                                                                 (unBData
                                                                                                    (headList
                                                                                                       {data}
                                                                                                       (sndPair
                                                                                                          {integer}
                                                                                                          {list
                                                                                                             data}
                                                                                                          tup))))
                                                                                              [ False
                                                                                              , True ])
                                                                                         (/\dead ->
                                                                                            fail
                                                                                              ())
                                                                                         {all dead.
                                                                                            dead})
                                                                                    (/\dead ->
                                                                                       fail
                                                                                         ())
                                                                                    {all dead.
                                                                                       dead}
                                                                          in
                                                                          Bool_match
                                                                            (case
                                                                               Bool
                                                                               (equalsInteger
                                                                                  `$bNoOutputDatum`
                                                                                  (fstPair
                                                                                     {integer}
                                                                                     {list
                                                                                        data}
                                                                                     (unConstrData
                                                                                        ds)))
                                                                               [ False
                                                                               , True ])
                                                                            {all dead.
                                                                               Bool}
                                                                            (/\dead ->
                                                                               Bool_match
                                                                                 (case
                                                                                    Bool
                                                                                    (equalsInteger
                                                                                       `$bNoOutputDatum`
                                                                                       (fstPair
                                                                                          {integer}
                                                                                          {list
                                                                                             data}
                                                                                          (unConstrData
                                                                                             ds)))
                                                                                    [ False
                                                                                    , True ])
                                                                                 {all dead.
                                                                                    Bool}
                                                                                 (/\dead ->
                                                                                    True)
                                                                                 (/\dead ->
                                                                                    fail
                                                                                      ())
                                                                                 {all dead.
                                                                                    dead})
                                                                            (/\dead ->
                                                                               fail
                                                                                 ())
                                                                            {all dead.
                                                                               dead})
                                                                       (txOutDatum
                                                                          nt)
                                                                       nt)
                                                                    {all dead.
                                                                       Bool}
                                                                    (/\dead ->
                                                                       traceError
                                                                         {Bool}
                                                                         "Datum Modification Prohibited")
                                                                    (/\dead ->
                                                                       Bool_match
                                                                         (`/=`
                                                                            {integer}
                                                                            (\(x :
                                                                                 integer)
                                                                              (y :
                                                                                 integer) ->
                                                                               case
                                                                                 Bool
                                                                                 (equalsInteger
                                                                                    x
                                                                                    y)
                                                                                 [ False
                                                                                 , True ])
                                                                            (go
                                                                               0
                                                                               nt)
                                                                            1)
                                                                         {all dead.
                                                                            Bool}
                                                                         (/\dead ->
                                                                            traceError
                                                                              {Bool}
                                                                              "Double satisfaction")
                                                                         (/\dead ->
                                                                            True)
                                                                         {all dead.
                                                                            dead})
                                                                    {all dead.
                                                                       dead})
                                                               {all dead. dead})
                                                          {all dead. dead})
                                                     {all dead. dead})
                                                {all dead. dead})
                                           {all dead. dead})))))
                  {all dead. dead}))
             {all dead. unit}
             (/\dead -> ())
             (/\dead -> traceError {unit} "PT5")
             {all dead. dead})
      (/\dead ->
         let
           !x : Unit = trace {Unit} "Failed to parse ScriptContext" Unit
         in
         error {unit})
      {all dead. dead})
  (Constr 0
     [ Constr 0
         [ List []
         , List []
         , List []
         , I 0
         , Map []
         , List []
         , Map []
         , Constr 0
             [ Constr 0 [Constr 1 [I 110], Constr 1 []]
             , Constr 0 [Constr 1 [I 1100], Constr 1 []] ]
         , List [B #]
         , Map []
         , Map []
         , B #058fdca70be67c74151cea3846be7f73342d92c0090b62c1052e6790ad83f145
         , Map []
         , List []
         , Constr 1 []
         , Constr 1 [] ]
     , Constr 1 []
     , Constr 1
         [ Constr 0
             [ B #058fdca70be67c74151cea3846be7f73342d92c0090b62c1052e6790ad83f145
             , I 0 ]
         , Constr 0
             [ Constr 0
                 [ Constr 0 [Constr 0 [B #], Constr 1 []]
                 , Constr 0 [B #24, B #746573742d6173736574]
                 , I 1000
                 , I 0
                 , I 100
                 , I 10
                 , I 10 ] ] ] ])