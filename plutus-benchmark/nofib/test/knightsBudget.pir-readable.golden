(let
    data Bool | Bool_match where
      True : Bool
      False : Bool
    data (Maybe :: * -> *) a | Maybe_match where
      Just : a -> Maybe a
      Nothing : Maybe a
    data (Tuple2 :: * -> * -> *) a b | Tuple2_match where
      Tuple2 : a -> b -> Tuple2 a b
  in
  letrec
    data (List :: * -> *) a | List_match where
      Nil : List a
      Cons : a -> List a -> List a
  in
  let
    data ChessSet | ChessSet_match where
      Board :
        integer ->
        integer ->
        Maybe (Tuple2 integer integer) ->
        List (Tuple2 integer integer) ->
        ChessSet
    !`$fEqChessSet_$c==` : ChessSet -> ChessSet -> Bool
      = \(ds : ChessSet) (ds : ChessSet) -> True
    data Ordering | Ordering_match where
      EQ : Ordering
      GT : Ordering
      LT : Ordering
    data (Ord :: * -> *) a | Ord_match where
      CConsOrd :
        (\a -> a -> a -> Bool) a ->
        (a -> a -> Ordering) ->
        (a -> a -> Bool) ->
        (a -> a -> Bool) ->
        (a -> a -> Bool) ->
        (a -> a -> Bool) ->
        (a -> a -> a) ->
        (a -> a -> a) ->
        Ord a
    !v : Ord ChessSet
      = CConsOrd
          {ChessSet}
          `$fEqChessSet_$c==`
          (\(eta : ChessSet) (eta : ChessSet) -> EQ)
          (\(x : ChessSet) (y : ChessSet) -> False)
          `$fEqChessSet_$c==`
          (\(x : ChessSet) (y : ChessSet) -> False)
          `$fEqChessSet_$c==`
          (\(x : ChessSet) (y : ChessSet) -> y)
          (\(x : ChessSet) (y : ChessSet) -> x)
    !equalsInteger : integer -> integer -> Bool
      = \(x : integer) (y : integer) ->
          ifThenElse {Bool} (equalsInteger x y) True False
    !v : Ord integer
      = CConsOrd
          {integer}
          equalsInteger
          (\(eta : integer) (eta : integer) ->
             Bool_match
               (ifThenElse {Bool} (equalsInteger eta eta) True False)
               {all dead. Ordering}
               (/\dead -> EQ)
               (/\dead ->
                  Bool_match
                    (ifThenElse
                       {Bool}
                       (lessThanEqualsInteger eta eta)
                       True
                       False)
                    {all dead. Ordering}
                    (/\dead -> LT)
                    (/\dead -> GT)
                    {all dead. dead})
               {all dead. dead})
          (\(x : integer) (y : integer) ->
             ifThenElse {Bool} (lessThanInteger x y) True False)
          (\(x : integer) (y : integer) ->
             ifThenElse {Bool} (lessThanEqualsInteger x y) True False)
          (\(x : integer) (y : integer) ->
             ifThenElse {Bool} (lessThanEqualsInteger x y) False True)
          (\(x : integer) (y : integer) ->
             ifThenElse {Bool} (lessThanInteger x y) False True)
          (\(x : integer) (y : integer) ->
             Bool_match
               (ifThenElse {Bool} (lessThanEqualsInteger x y) True False)
               {all dead. integer}
               (/\dead -> y)
               (/\dead -> x)
               {all dead. dead})
          (\(x : integer) (y : integer) ->
             Bool_match
               (ifThenElse {Bool} (lessThanEqualsInteger x y) True False)
               {all dead. integer}
               (/\dead -> x)
               (/\dead -> y)
               {all dead. dead})
  in
  letrec
    !go : List (Tuple2 integer ChessSet) -> List ChessSet
      = \(ds : List (Tuple2 integer ChessSet)) ->
          List_match
            {Tuple2 integer ChessSet}
            ds
            {all dead. List ChessSet}
            (/\dead -> Nil {ChessSet})
            (\(x : Tuple2 integer ChessSet)
              (xs : List (Tuple2 integer ChessSet)) ->
               /\dead ->
                 Cons
                   {ChessSet}
                   (Tuple2_match
                      {integer}
                      {ChessSet}
                      x
                      {ChessSet}
                      (\(ds : integer) (b : ChessSet) -> b))
                   (go xs))
            {all dead. dead}
  in
  letrec
    !go : List (Tuple2 integer ChessSet) -> List (Tuple2 integer ChessSet)
      = \(ds : List (Tuple2 integer ChessSet)) ->
          List_match
            {Tuple2 integer ChessSet}
            ds
            {all dead. List (Tuple2 integer ChessSet)}
            (/\dead -> Nil {Tuple2 integer ChessSet})
            (\(x : Tuple2 integer ChessSet)
              (xs : List (Tuple2 integer ChessSet)) ->
               /\dead -> Cons {Tuple2 integer ChessSet} x (go xs))
            {all dead. dead}
  in
  letrec
    !depthSearch :
       all a.
         (\a -> a -> a -> Bool) a ->
         integer ->
         List a ->
         (a -> List a) ->
         (a -> Bool) ->
         List a
      = /\a ->
          \(`$dEq` : (\a -> a -> a -> Bool) a)
           (depth : integer)
           (q : List a)
           (growFn : a -> List a)
           (finFn : a -> Bool) ->
            Bool_match
              (ifThenElse {Bool} (equalsInteger 0 depth) True False)
              {all dead. List a}
              (/\dead -> Nil {a})
              (/\dead ->
                 Bool_match
                   (List_match
                      {a}
                      q
                      {all dead. Bool}
                      (/\dead -> True)
                      (\(ipv : a) (ipv : List a) -> /\dead -> False)
                      {all dead. dead})
                   {all dead. List a}
                   (/\dead -> Nil {a})
                   (/\dead ->
                      Bool_match
                        (finFn
                           (List_match
                              {a}
                              q
                              {all dead. a}
                              (/\dead -> error {a})
                              (\(h : a) (ds : List a) -> /\dead -> h)
                              {all dead. dead}))
                        {all dead. List a}
                        (/\dead ->
                           Cons
                             {a}
                             (List_match
                                {a}
                                q
                                {all dead. a}
                                (/\dead -> error {a})
                                (\(h : a) (ds : List a) -> /\dead -> h)
                                {all dead. dead})
                             (depthSearch
                                {a}
                                `$dEq`
                                (subtractInteger depth 1)
                                (List_match
                                   {a}
                                   q
                                   {all dead. List a}
                                   (/\dead -> error {List a})
                                   (\(ds : a) (t : List a) -> /\dead -> t)
                                   {all dead. dead})
                                growFn
                                finFn))
                        (/\dead ->
                           depthSearch
                             {a}
                             `$dEq`
                             (subtractInteger depth 1)
                             (let
                               !list : List a
                                 = growFn
                                     (List_match
                                        {a}
                                        q
                                        {all dead. a}
                                        (/\dead -> error {a})
                                        (\(h : a) (ds : List a) -> /\dead -> h)
                                        {all dead. dead})
                               !q : List a
                                 = List_match
                                     {a}
                                     q
                                     {all dead. List a}
                                     (/\dead -> error {List a})
                                     (\(ds : a) (t : List a) -> /\dead -> t)
                                     {all dead. dead}
                             in
                             letrec
                               !go : List a -> List a
                                 = \(ds : List a) ->
                                     List_match
                                       {a}
                                       ds
                                       {all dead. List a}
                                       (/\dead -> q)
                                       (\(x : a) (xs : List a) ->
                                          /\dead -> Cons {a} x (go xs))
                                       {all dead. dead}
                             in
                             go list)
                             growFn
                             finFn)
                        {all dead. dead})
                   {all dead. dead})
              {all dead. dead}
  in
  let
    !`$p1Ord` : all a. Ord a -> (\a -> a -> a -> Bool) a
      = /\a ->
          \(v : Ord a) ->
            Ord_match
              {a}
              v
              {(\a -> a -> a -> Bool) a}
              (\(v : (\a -> a -> a -> Bool) a)
                (v : a -> a -> Ordering)
                (v : a -> a -> Bool)
                (v : a -> a -> Bool)
                (v : a -> a -> Bool)
                (v : a -> a -> Bool)
                (v : a -> a -> a)
                (v : a -> a -> a) ->
                 v)
    !compare : all a. Ord a -> a -> a -> Ordering
      = /\a ->
          \(v : Ord a) ->
            Ord_match
              {a}
              v
              {a -> a -> Ordering}
              (\(v : (\a -> a -> a -> Bool) a)
                (v : a -> a -> Ordering)
                (v : a -> a -> Bool)
                (v : a -> a -> Bool)
                (v : a -> a -> Bool)
                (v : a -> a -> Bool)
                (v : a -> a -> a)
                (v : a -> a -> a) ->
                 v)
  in
  letrec
    !quickSort : all a. Ord a -> List a -> List a
      = /\a ->
          \(`$dOrd` : Ord a) (ds : List a) ->
            List_match
              {a}
              ds
              {all dead. List a}
              (/\dead -> Nil {a})
              (\(x : a) (xs : List a) ->
                 /\dead ->
                   let
                     !xs : List a
                       = let
                         !xs : List a
                           = quickSort
                               {a}
                               `$dOrd`
                               ((let
                                    a = List a
                                  in
                                  \(c : a -> a -> a) (n : a) ->
                                    letrec
                                      !go : List a -> a
                                        = \(ds : List a) ->
                                            List_match
                                              {a}
                                              ds
                                              {all dead. a}
                                              (/\dead -> n)
                                              (\(y : a) (ys : List a) ->
                                                 /\dead ->
                                                   let
                                                     !ds : a = go ys
                                                   in
                                                   Bool_match
                                                     (Ord_match
                                                        {a}
                                                        `$dOrd`
                                                        {a -> a -> Bool}
                                                        (\(v :
                                                             (\a ->
                                                                a -> a -> Bool)
                                                               a)
                                                          (v :
                                                             a -> a -> Ordering)
                                                          (v : a -> a -> Bool)
                                                          (v : a -> a -> Bool)
                                                          (v : a -> a -> Bool)
                                                          (v : a -> a -> Bool)
                                                          (v : a -> a -> a)
                                                          (v : a -> a -> a) ->
                                                           v)
                                                        y
                                                        x)
                                                     {all dead. a}
                                                     (/\dead -> c y ds)
                                                     (/\dead -> ds)
                                                     {all dead. dead})
                                              {all dead. dead}
                                    in
                                    go xs)
                                  (\(ds : a) (ds : List a) -> Cons {a} ds ds)
                                  (Nil {a}))
                       in
                       (let
                           b = List a
                         in
                         \(c : a -> b -> b) (n : b) -> c x n)
                         (\(ds : a) (ds : List a) -> Cons {a} ds ds)
                         xs
                   in
                   (let
                       b = List a
                     in
                     \(c : a -> b -> b) (n : b) ->
                       letrec
                         !go : List a -> b
                           = \(ds : List a) ->
                               List_match
                                 {a}
                                 ds
                                 {all dead. b}
                                 (/\dead -> n)
                                 (\(y : a) (ys : List a) ->
                                    /\dead -> c y (go ys))
                                 {all dead. dead}
                       in
                       let
                         !eta : List a
                           = quickSort
                               {a}
                               `$dOrd`
                               ((let
                                    a = List a
                                  in
                                  \(c : a -> a -> a) (n : a) ->
                                    letrec
                                      !go : List a -> a
                                        = \(ds : List a) ->
                                            List_match
                                              {a}
                                              ds
                                              {all dead. a}
                                              (/\dead -> n)
                                              (\(y : a) (ys : List a) ->
                                                 /\dead ->
                                                   let
                                                     !ds : a = go ys
                                                   in
                                                   Bool_match
                                                     (Ord_match
                                                        {a}
                                                        `$dOrd`
                                                        {a -> a -> Bool}
                                                        (\(v :
                                                             (\a ->
                                                                a -> a -> Bool)
                                                               a)
                                                          (v :
                                                             a -> a -> Ordering)
                                                          (v : a -> a -> Bool)
                                                          (v : a -> a -> Bool)
                                                          (v : a -> a -> Bool)
                                                          (v : a -> a -> Bool)
                                                          (v : a -> a -> a)
                                                          (v : a -> a -> a) ->
                                                           v)
                                                        y
                                                        x)
                                                     {all dead. a}
                                                     (/\dead -> c y ds)
                                                     (/\dead -> ds)
                                                     {all dead. dead})
                                              {all dead. dead}
                                    in
                                    go xs)
                                  (\(ds : a) (ds : List a) -> Cons {a} ds ds)
                                  (Nil {a}))
                       in
                       go eta)
                     (\(ds : a) (ds : List a) -> Cons {a} ds ds)
                     xs)
              {all dead. dead}
  in
  let
    !interval : integer -> integer -> List integer
      = \(a : integer) (b : integer) ->
          letrec
            !go : integer -> List integer
              = \(a : integer) ->
                  Bool_match
                    (ifThenElse {Bool} (lessThanEqualsInteger a b) False True)
                    {all dead. List integer}
                    (/\dead -> Nil {integer})
                    (/\dead -> Cons {integer} a (go (addInteger 1 a)))
                    {all dead. dead}
          in
          go a
    !`$fFoldableNil_$cfoldr` : all a b. (a -> b -> b) -> b -> List a -> b
      = /\a b ->
          \(f : a -> b -> b) (z : b) ->
            letrec
              !go : List a -> b
                = \(ds : List a) ->
                    List_match
                      {a}
                      ds
                      {all dead. b}
                      (/\dead -> z)
                      (\(x : a) (xs : List a) -> /\dead -> f x (go xs))
                      {all dead. dead}
            in
            \(eta : List a) -> go eta
    !addPiece : Tuple2 integer integer -> ChessSet -> ChessSet
      = \(t : Tuple2 integer integer) (ds : ChessSet) ->
          ChessSet_match
            ds
            {ChessSet}
            (\(s : integer)
              (n : integer)
              (f : Maybe (Tuple2 integer integer))
              (ts : List (Tuple2 integer integer)) ->
               Board s (addInteger 1 n) f (Cons {Tuple2 integer integer} t ts))
    !length :
       all (t :: * -> *) a.
         (\(t :: * -> *) -> all a b. (a -> b -> b) -> b -> t a -> b) t ->
         t a ->
         integer
      = /\(t :: * -> *) a ->
          \(`$dFoldable` :
              (\(t :: * -> *) -> all a b. (a -> b -> b) -> b -> t a -> b) t) ->
            `$dFoldable`
              {a}
              {integer}
              (\(ds : a) (acc : integer) -> addInteger 1 acc)
              0
    data Direction | Direction_match where
      DL : Direction
      DR : Direction
      LD : Direction
      LU : Direction
      RD : Direction
      RU : Direction
      UL : Direction
      UR : Direction
    !move : Direction -> Tuple2 integer integer -> Tuple2 integer integer
      = \(ds : Direction) (ds : Tuple2 integer integer) ->
          Direction_match
            ds
            {all dead. Tuple2 integer integer}
            (/\dead ->
               Tuple2_match
                 {integer}
                 {integer}
                 ds
                 {Tuple2 integer integer}
                 (\(x : integer) (y : integer) ->
                    Tuple2
                      {integer}
                      {integer}
                      (subtractInteger x 1)
                      (addInteger 2 y)))
            (/\dead ->
               Tuple2_match
                 {integer}
                 {integer}
                 ds
                 {Tuple2 integer integer}
                 (\(x : integer) (y : integer) ->
                    Tuple2
                      {integer}
                      {integer}
                      (addInteger 1 x)
                      (addInteger 2 y)))
            (/\dead ->
               Tuple2_match
                 {integer}
                 {integer}
                 ds
                 {Tuple2 integer integer}
                 (\(x : integer) (y : integer) ->
                    Tuple2
                      {integer}
                      {integer}
                      (subtractInteger x 2)
                      (addInteger 1 y)))
            (/\dead ->
               Tuple2_match
                 {integer}
                 {integer}
                 ds
                 {Tuple2 integer integer}
                 (\(x : integer) (y : integer) ->
                    Tuple2
                      {integer}
                      {integer}
                      (subtractInteger x 2)
                      (subtractInteger y 1)))
            (/\dead ->
               Tuple2_match
                 {integer}
                 {integer}
                 ds
                 {Tuple2 integer integer}
                 (\(x : integer) (y : integer) ->
                    Tuple2
                      {integer}
                      {integer}
                      (addInteger 2 x)
                      (addInteger 1 y)))
            (/\dead ->
               Tuple2_match
                 {integer}
                 {integer}
                 ds
                 {Tuple2 integer integer}
                 (\(x : integer) (y : integer) ->
                    Tuple2
                      {integer}
                      {integer}
                      (addInteger 2 x)
                      (subtractInteger y 1)))
            (/\dead ->
               Tuple2_match
                 {integer}
                 {integer}
                 ds
                 {Tuple2 integer integer}
                 (\(x : integer) (y : integer) ->
                    Tuple2
                      {integer}
                      {integer}
                      (subtractInteger x 1)
                      (subtractInteger y 2)))
            (/\dead ->
               Tuple2_match
                 {integer}
                 {integer}
                 ds
                 {Tuple2 integer integer}
                 (\(x : integer) (y : integer) ->
                    Tuple2
                      {integer}
                      {integer}
                      (addInteger 1 x)
                      (subtractInteger y 2)))
            {all dead. dead}
  in
  letrec
    !notIn : all a. (\a -> a -> a -> Bool) a -> a -> List a -> Bool
      = /\a ->
          \(`$dEq` : (\a -> a -> a -> Bool) a) (ds : a) (ds : List a) ->
            List_match
              {a}
              ds
              {all dead. Bool}
              (/\dead -> True)
              (\(a : a) (as : List a) ->
                 /\dead ->
                   Bool_match
                     (`$dEq` ds a)
                     {all dead. Bool}
                     (/\dead -> False)
                     (/\dead -> notIn {a} `$dEq` ds as)
                     {all dead. dead})
              {all dead. dead}
  in
  let
    !canMoveTo : Tuple2 integer integer -> ChessSet -> Bool
      = \(t : Tuple2 integer integer) (board : ChessSet) ->
          Tuple2_match
            {integer}
            {integer}
            t
            {Bool}
            (\(x : integer) (y : integer) ->
               ChessSet_match
                 board
                 {Bool}
                 (\(ipv : integer)
                   (ipv : integer)
                   (ipv : Maybe (Tuple2 integer integer))
                   (ipv : List (Tuple2 integer integer)) ->
                    Bool_match
                      (ifThenElse {Bool} (lessThanInteger x 1) False True)
                      {all dead. Bool}
                      (/\dead ->
                         Bool_match
                           (ifThenElse
                              {Bool}
                              (lessThanEqualsInteger x ipv)
                              True
                              False)
                           {all dead. Bool}
                           (/\dead ->
                              Bool_match
                                (ifThenElse
                                   {Bool}
                                   (lessThanInteger y 1)
                                   False
                                   True)
                                {all dead. Bool}
                                (/\dead ->
                                   Bool_match
                                     (ifThenElse
                                        {Bool}
                                        (lessThanEqualsInteger y ipv)
                                        True
                                        False)
                                     {all dead. Bool}
                                     (/\dead ->
                                        notIn
                                          {Tuple2 integer integer}
                                          (\(ds : Tuple2 integer integer)
                                            (ds : Tuple2 integer integer) ->
                                             Tuple2_match
                                               {integer}
                                               {integer}
                                               ds
                                               {Bool}
                                               (\(a : integer) (b : integer) ->
                                                  Tuple2_match
                                                    {integer}
                                                    {integer}
                                                    ds
                                                    {Bool}
                                                    (\(a' : integer)
                                                      (b' : integer) ->
                                                       Bool_match
                                                         (ifThenElse
                                                            {Bool}
                                                            (equalsInteger a a')
                                                            True
                                                            False)
                                                         {all dead. Bool}
                                                         (/\dead ->
                                                            equalsInteger b b')
                                                         (/\dead -> False)
                                                         {all dead. dead})))
                                          t
                                          ipv)
                                     (/\dead -> False)
                                     {all dead. dead})
                                (/\dead -> False)
                                {all dead. dead})
                           (/\dead -> False)
                           {all dead. dead})
                      (/\dead -> False)
                      {all dead. dead}))
    !possibleMoves : ChessSet -> List Direction
      = \(board : ChessSet) ->
          ChessSet_match
            board
            {List Direction}
            (\(ipv : integer)
              (ipv : integer)
              (ipv : Maybe (Tuple2 integer integer))
              (ipv : List (Tuple2 integer integer)) ->
               (let
                   a = List Direction
                 in
                 \(c : Direction -> a -> a) ->
                   let
                     !c : Direction -> a -> a
                       = \(ds : Direction) (ds : a) ->
                           Bool_match
                             (canMoveTo
                                (move
                                   ds
                                   (List_match
                                      {Tuple2 integer integer}
                                      ipv
                                      {all dead. Tuple2 integer integer}
                                      (/\dead -> error {Tuple2 integer integer})
                                      (\(t : Tuple2 integer integer)
                                        (ds : List (Tuple2 integer integer)) ->
                                         /\dead -> t)
                                      {all dead. dead}))
                                board)
                             {all dead. a}
                             (/\dead -> c ds ds)
                             (/\dead -> ds)
                             {all dead. dead}
                   in
                   \(n : a) ->
                     c UL (c UR (c DL (c DR (c LU (c LD (c RU (c RD n))))))))
                 (\(ds : Direction) (ds : List Direction) ->
                    Cons {Direction} ds ds)
                 (Nil {Direction}))
    !deleteFirst : ChessSet -> ChessSet
      = \(ds : ChessSet) ->
          ChessSet_match
            ds
            {ChessSet}
            (\(s : integer)
              (n : integer)
              (ds : Maybe (Tuple2 integer integer))
              (ts : List (Tuple2 integer integer)) ->
               let
                 !f' : Maybe (Tuple2 integer integer)
                   = (let
                         a = Tuple2 integer integer
                       in
                       letrec
                         !rev : List a -> List a -> Maybe a
                           = \(ds : List a) (a : List a) ->
                               List_match
                                 {a}
                                 ds
                                 {all dead. Maybe a}
                                 (/\dead ->
                                    List_match
                                      {a}
                                      a
                                      {all dead. Maybe a}
                                      (/\dead -> error {Maybe a})
                                      (\(ds : a) (ds : List a) ->
                                         /\dead ->
                                           List_match
                                             {a}
                                             ds
                                             {all dead. Maybe a}
                                             (/\dead -> Nothing {a})
                                             (\(a : a) (ds : List a) ->
                                                /\dead -> Just {a} a)
                                             {all dead. dead})
                                      {all dead. dead})
                                 (\(x : a) (xs : List a) ->
                                    /\dead -> rev xs (Cons {a} x a))
                                 {all dead. dead}
                       in
                       \(l : List a) -> rev l (Nil {a}))
                       ts
                 !`$j` : List (Tuple2 integer integer) -> ChessSet
                   = \(ts' : List (Tuple2 integer integer)) ->
                       Board s (subtractInteger n 1) f' ts'
               in
               letrec
                 !rev :
                    List (Tuple2 integer integer) ->
                    List (Tuple2 integer integer) ->
                    ChessSet
                   = \(ds : List (Tuple2 integer integer))
                      (a : List (Tuple2 integer integer)) ->
                       List_match
                         {Tuple2 integer integer}
                         ds
                         {all dead. ChessSet}
                         (/\dead -> `$j` a)
                         (\(x : Tuple2 integer integer)
                           (xs : List (Tuple2 integer integer)) ->
                            /\dead ->
                              rev xs (Cons {Tuple2 integer integer} x a))
                         {all dead. dead}
               in
               letrec
                 !rev :
                    List (Tuple2 integer integer) ->
                    List (Tuple2 integer integer) ->
                    ChessSet
                   = \(ds : List (Tuple2 integer integer))
                      (a : List (Tuple2 integer integer)) ->
                       List_match
                         {Tuple2 integer integer}
                         ds
                         {all dead. ChessSet}
                         (/\dead ->
                            List_match
                              {Tuple2 integer integer}
                              a
                              {all dead. ChessSet}
                              (/\dead ->
                                 `$j` (error {List (Tuple2 integer integer)}))
                              (\(ds : Tuple2 integer integer)
                                (as : List (Tuple2 integer integer)) ->
                                 /\dead ->
                                   rev as (Nil {Tuple2 integer integer}))
                              {all dead. dead})
                         (\(x : Tuple2 integer integer)
                           (xs : List (Tuple2 integer integer)) ->
                            /\dead ->
                              rev xs (Cons {Tuple2 integer integer} x a))
                         {all dead. dead}
               in
               rev ts (Nil {Tuple2 integer integer}))
    !descAndNo : ChessSet -> List (Tuple2 integer ChessSet)
      = \(board : ChessSet) ->
          (let
              a = Tuple2 integer ChessSet
            in
            \(g : all b. (a -> b -> b) -> b -> b) ->
              g {List a} (\(ds : a) (ds : List a) -> Cons {a} ds ds) (Nil {a}))
            (/\a ->
               \(c : Tuple2 integer ChessSet -> a -> a) (n : a) ->
                 letrec
                   !go : List ChessSet -> a
                     = \(ds : List ChessSet) ->
                         List_match
                           {ChessSet}
                           ds
                           {all dead. a}
                           (/\dead -> n)
                           (\(y : ChessSet) (ys : List ChessSet) ->
                              /\dead ->
                                let
                                  !ds : a = go ys
                                in
                                c
                                  (Tuple2
                                     {integer}
                                     {ChessSet}
                                     (length
                                        {List}
                                        {Direction}
                                        `$fFoldableNil_$cfoldr`
                                        (possibleMoves (deleteFirst y)))
                                     y)
                                  ds)
                           {all dead. dead}
                 in
                 let
                   !eta : List ChessSet
                     = ChessSet_match
                         board
                         {List ChessSet}
                         (\(ipv : integer)
                           (ipv : integer)
                           (ipv : Maybe (Tuple2 integer integer))
                           (ipv : List (Tuple2 integer integer)) ->
                            letrec
                              !go : List Direction -> List ChessSet
                                = \(ds : List Direction) ->
                                    List_match
                                      {Direction}
                                      ds
                                      {all dead. List ChessSet}
                                      (/\dead -> Nil {ChessSet})
                                      (\(x : Direction) (xs : List Direction) ->
                                         /\dead ->
                                           Cons
                                             {ChessSet}
                                             (addPiece
                                                (move
                                                   x
                                                   (List_match
                                                      {Tuple2 integer integer}
                                                      ipv
                                                      {all dead.
                                                         Tuple2 integer integer}
                                                      (/\dead ->
                                                         error
                                                           {Tuple2
                                                              integer
                                                              integer})
                                                      (\(t :
                                                           Tuple2
                                                             integer
                                                             integer)
                                                        (ds :
                                                           List
                                                             (Tuple2
                                                                integer
                                                                integer)) ->
                                                         /\dead -> t)
                                                      {all dead. dead}))
                                                board)
                                             (go xs))
                                      {all dead. dead}
                            in
                            go (possibleMoves board))
                 in
                 go eta)
  in
  letrec
    !zip : all a b. List a -> List b -> List (Tuple2 a b)
      = /\a b ->
          \(ds : List a) (_bs : List b) ->
            List_match
              {a}
              ds
              {all dead. List (Tuple2 a b)}
              (/\dead -> Nil {Tuple2 a b})
              (\(ipv : a) (ipv : List a) ->
                 /\dead ->
                   List_match
                     {b}
                     _bs
                     {all dead. List (Tuple2 a b)}
                     (/\dead -> Nil {Tuple2 a b})
                     (\(ipv : b) (ipv : List b) ->
                        /\dead ->
                          Cons
                            {Tuple2 a b}
                            (Tuple2 {a} {b} ipv ipv)
                            (zip {a} {b} ipv ipv))
                     {all dead. dead})
              {all dead. dead}
  in
  \(depth : integer)
   (boardSize : integer) ->
    depthSearch
      {Tuple2 integer ChessSet}
      (\(ds : Tuple2 integer ChessSet) (ds : Tuple2 integer ChessSet) ->
         Tuple2_match
           {integer}
           {ChessSet}
           ds
           {Bool}
           (\(a : integer) (b : ChessSet) ->
              Tuple2_match
                {integer}
                {ChessSet}
                ds
                {Bool}
                (\(a' : integer) (b' : ChessSet) ->
                   Bool_match
                     (equalsInteger a a')
                     {all dead. Bool}
                     (/\dead -> True)
                     (/\dead -> False)
                     {all dead. dead})))
      depth
      (let
        !list :
           List (Tuple2 integer ChessSet)
          = let
            !l :
               List ChessSet
              = (let
                    a = List ChessSet
                  in
                  \(c : ChessSet -> a -> a)
                   (n : a) ->
                    letrec
                      !go :
                         List integer -> a
                        = \(ds : List integer) ->
                            List_match
                              {integer}
                              ds
                              {all dead. a}
                              (/\dead -> n)
                              (\(y : integer)
                                (ys : List integer) ->
                                 /\dead ->
                                   let
                                     !ds : a = go ys
                                   in
                                   letrec
                                     !go :
                                        List integer -> a
                                       = \(ds : List integer) ->
                                           List_match
                                             {integer}
                                             ds
                                             {all dead. a}
                                             (/\dead -> ds)
                                             (\(y : integer) ->
                                                let
                                                  !t : Tuple2 integer integer
                                                    = Tuple2
                                                        {integer}
                                                        {integer}
                                                        y
                                                        y
                                                in
                                                \(ys : List integer) ->
                                                  /\dead ->
                                                    let
                                                      !ds : a = go ys
                                                    in
                                                    c
                                                      (Bool_match
                                                         (ifThenElse
                                                            {Bool}
                                                            (equalsInteger
                                                               0
                                                               (remainderInteger
                                                                  boardSize
                                                                  2))
                                                            True
                                                            False)
                                                         {all dead. ChessSet}
                                                         (/\dead ->
                                                            Board
                                                              boardSize
                                                              1
                                                              (Just
                                                                 {Tuple2
                                                                    integer
                                                                    integer}
                                                                 t)
                                                              ((let
                                                                   a
                                                                     = Tuple2
                                                                         integer
                                                                         integer
                                                                 in
                                                                 \(g :
                                                                     all b.
                                                                       (a ->
                                                                        b ->
                                                                        b) ->
                                                                       b ->
                                                                       b) ->
                                                                   g
                                                                     {List a}
                                                                     (\(ds : a)
                                                                       (ds :
                                                                          List
                                                                            a) ->
                                                                        Cons
                                                                          {a}
                                                                          ds
                                                                          ds)
                                                                     (Nil {a}))
                                                                 (/\a ->
                                                                    \(c :
                                                                        Tuple2
                                                                          integer
                                                                          integer ->
                                                                        a ->
                                                                        a)
                                                                     (n : a) ->
                                                                      c t n)))
                                                         (/\dead ->
                                                            error {ChessSet})
                                                         {all dead. dead})
                                                      ds)
                                             {all dead. dead}
                                   in
                                   let
                                     !eta : List integer = interval 1 boardSize
                                   in
                                   go eta)
                              {all dead. dead}
                    in
                    let
                      !eta : List integer = interval 1 boardSize
                    in
                    go eta)
                  (\(ds : ChessSet) (ds : List ChessSet) ->
                     Cons {ChessSet} ds ds)
                  (Nil {ChessSet})
            !numStarts : integer
              = length {List} {ChessSet} `$fFoldableNil_$cfoldr` l
          in
          zip
            {integer}
            {ChessSet}
            (let
              !x : integer = subtractInteger 1 numStarts
            in
            letrec
              !go : integer -> List integer
                = \(n : integer) ->
                    Bool_match
                      (ifThenElse {Bool} (lessThanEqualsInteger n 0) True False)
                      {all dead. List integer}
                      (/\dead -> Nil {integer})
                      (/\dead -> Cons {integer} x (go (subtractInteger n 1)))
                      {all dead. dead}
            in
            go numStarts)
            l
      in
      go list)
      (\(ds : Tuple2 integer ChessSet) ->
         Tuple2_match
           {integer}
           {ChessSet}
           ds
           {List (Tuple2 integer ChessSet)}
           (\(x : integer) (y : ChessSet) ->
              (let
                  !a : integer = addInteger 1 x
                in
                letrec
                  !go : List ChessSet -> List (Tuple2 integer ChessSet)
                    = \(ds : List ChessSet) ->
                        List_match
                          {ChessSet}
                          ds
                          {all dead. List (Tuple2 integer ChessSet)}
                          (/\dead -> Nil {Tuple2 integer ChessSet})
                          (\(x : ChessSet) (xs : List ChessSet) ->
                             /\dead ->
                               Cons
                                 {Tuple2 integer ChessSet}
                                 (Tuple2 {integer} {ChessSet} a x)
                                 (go xs))
                          {all dead. dead}
                in
                \(eta : List ChessSet) -> go eta)
                (ChessSet_match
                   y
                   {List ChessSet}
                   (\(ipv : integer)
                     (ipv : integer)
                     (ipv : Maybe (Tuple2 integer integer))
                     (ipv : List (Tuple2 integer integer)) ->
                      let
                        !singles : List ChessSet
                          = (let
                                a = List ChessSet
                              in
                              \(c : ChessSet -> a -> a) (n : a) ->
                                (let
                                    a = Tuple2 integer ChessSet
                                  in
                                  /\b ->
                                    \(k : a -> b -> b) (z : b) ->
                                      letrec
                                        !go : List a -> b
                                          = \(ds : List a) ->
                                              List_match
                                                {a}
                                                ds
                                                {all dead. b}
                                                (/\dead -> z)
                                                (\(y : a) (ys : List a) ->
                                                   /\dead -> k y (go ys))
                                                {all dead. dead}
                                      in
                                      \(eta : List a) -> go eta)
                                  {a}
                                  (\(ds : Tuple2 integer ChessSet) (ds : a) ->
                                     Tuple2_match
                                       {integer}
                                       {ChessSet}
                                       ds
                                       {a}
                                       (\(y : integer) (x : ChessSet) ->
                                          Bool_match
                                            (ifThenElse
                                               {Bool}
                                               (equalsInteger 1 y)
                                               True
                                               False)
                                            {all dead. a}
                                            (/\dead -> c x ds)
                                            (/\dead -> ds)
                                            {all dead. dead}))
                                  n
                                  (descAndNo y))
                              (\(ds : ChessSet) (ds : List ChessSet) ->
                                 Cons {ChessSet} ds ds)
                              (Nil {ChessSet})
                        ~`$j` : List ChessSet
                          = let
                            !l : integer
                              = length
                                  {List}
                                  {ChessSet}
                                  `$fFoldableNil_$cfoldr`
                                  singles
                          in
                          Bool_match
                            (ifThenElse {Bool} (equalsInteger 0 l) True False)
                            {all dead. List ChessSet}
                            (/\dead ->
                               go
                                 (quickSort
                                    {Tuple2 integer ChessSet}
                                    (CConsOrd
                                       {Tuple2 integer ChessSet}
                                       (\(eta : Tuple2 integer ChessSet)
                                         (eta : Tuple2 integer ChessSet) ->
                                          Tuple2_match
                                            {integer}
                                            {ChessSet}
                                            eta
                                            {Bool}
                                            (\(a : integer) (b : ChessSet) ->
                                               Tuple2_match
                                                 {integer}
                                                 {ChessSet}
                                                 eta
                                                 {Bool}
                                                 (\(a' : integer)
                                                   (b' : ChessSet) ->
                                                    Bool_match
                                                      (`$p1Ord`
                                                         {integer}
                                                         v
                                                         a
                                                         a')
                                                      {all dead. Bool}
                                                      (/\dead ->
                                                         `$p1Ord`
                                                           {ChessSet}
                                                           v
                                                           b
                                                           b')
                                                      (/\dead -> False)
                                                      {all dead. dead})))
                                       (\(ds : Tuple2 integer ChessSet)
                                         (ds : Tuple2 integer ChessSet) ->
                                          Tuple2_match
                                            {integer}
                                            {ChessSet}
                                            ds
                                            {Ordering}
                                            (\(a : integer) (b : ChessSet) ->
                                               Tuple2_match
                                                 {integer}
                                                 {ChessSet}
                                                 ds
                                                 {Ordering}
                                                 (\(a' : integer) ->
                                                    let
                                                      ~defaultBody : Ordering
                                                        = compare
                                                            {integer}
                                                            v
                                                            a
                                                            a'
                                                    in
                                                    \(b' : ChessSet) ->
                                                      Ordering_match
                                                        (compare
                                                           {integer}
                                                           v
                                                           a
                                                           a')
                                                        {all dead. Ordering}
                                                        (/\dead ->
                                                           compare
                                                             {ChessSet}
                                                             v
                                                             b
                                                             b')
                                                        (/\dead -> defaultBody)
                                                        (/\dead -> defaultBody)
                                                        {all dead. dead})))
                                       (\(x : Tuple2 integer ChessSet)
                                         (y : Tuple2 integer ChessSet) ->
                                          Tuple2_match
                                            {integer}
                                            {ChessSet}
                                            x
                                            {Bool}
                                            (\(ipv : integer)
                                              (ipv : ChessSet) ->
                                               Tuple2_match
                                                 {integer}
                                                 {ChessSet}
                                                 y
                                                 {Bool}
                                                 (\(ipv : integer)
                                                   (ipv : ChessSet) ->
                                                    Ordering_match
                                                      (compare
                                                         {integer}
                                                         v
                                                         ipv
                                                         ipv)
                                                      {all dead. Bool}
                                                      (/\dead ->
                                                         Ordering_match
                                                           (compare
                                                              {ChessSet}
                                                              v
                                                              ipv
                                                              ipv)
                                                           {all dead. Bool}
                                                           (/\dead -> False)
                                                           (/\dead -> False)
                                                           (/\dead -> True)
                                                           {all dead. dead})
                                                      (/\dead -> False)
                                                      (/\dead -> True)
                                                      {all dead. dead})))
                                       (\(x : Tuple2 integer ChessSet)
                                         (y : Tuple2 integer ChessSet) ->
                                          Tuple2_match
                                            {integer}
                                            {ChessSet}
                                            x
                                            {Bool}
                                            (\(ipv : integer)
                                              (ipv : ChessSet) ->
                                               Tuple2_match
                                                 {integer}
                                                 {ChessSet}
                                                 y
                                                 {Bool}
                                                 (\(ipv : integer)
                                                   (ipv : ChessSet) ->
                                                    Ordering_match
                                                      (compare
                                                         {integer}
                                                         v
                                                         ipv
                                                         ipv)
                                                      {all dead. Bool}
                                                      (/\dead ->
                                                         Ordering_match
                                                           (compare
                                                              {ChessSet}
                                                              v
                                                              ipv
                                                              ipv)
                                                           {all dead. Bool}
                                                           (/\dead -> True)
                                                           (/\dead -> False)
                                                           (/\dead -> True)
                                                           {all dead. dead})
                                                      (/\dead -> False)
                                                      (/\dead -> True)
                                                      {all dead. dead})))
                                       (\(x : Tuple2 integer ChessSet)
                                         (y : Tuple2 integer ChessSet) ->
                                          Tuple2_match
                                            {integer}
                                            {ChessSet}
                                            x
                                            {Bool}
                                            (\(ipv : integer)
                                              (ipv : ChessSet) ->
                                               Tuple2_match
                                                 {integer}
                                                 {ChessSet}
                                                 y
                                                 {Bool}
                                                 (\(ipv : integer)
                                                   (ipv : ChessSet) ->
                                                    Ordering_match
                                                      (compare
                                                         {integer}
                                                         v
                                                         ipv
                                                         ipv)
                                                      {all dead. Bool}
                                                      (/\dead ->
                                                         Ordering_match
                                                           (compare
                                                              {ChessSet}
                                                              v
                                                              ipv
                                                              ipv)
                                                           {all dead. Bool}
                                                           (/\dead -> False)
                                                           (/\dead -> True)
                                                           (/\dead -> False)
                                                           {all dead. dead})
                                                      (/\dead -> True)
                                                      (/\dead -> False)
                                                      {all dead. dead})))
                                       (\(x : Tuple2 integer ChessSet)
                                         (y : Tuple2 integer ChessSet) ->
                                          Tuple2_match
                                            {integer}
                                            {ChessSet}
                                            x
                                            {Bool}
                                            (\(ipv : integer)
                                              (ipv : ChessSet) ->
                                               Tuple2_match
                                                 {integer}
                                                 {ChessSet}
                                                 y
                                                 {Bool}
                                                 (\(ipv : integer)
                                                   (ipv : ChessSet) ->
                                                    Ordering_match
                                                      (compare
                                                         {integer}
                                                         v
                                                         ipv
                                                         ipv)
                                                      {all dead. Bool}
                                                      (/\dead ->
                                                         Ordering_match
                                                           (compare
                                                              {ChessSet}
                                                              v
                                                              ipv
                                                              ipv)
                                                           {all dead. Bool}
                                                           (/\dead -> True)
                                                           (/\dead -> True)
                                                           (/\dead -> False)
                                                           {all dead. dead})
                                                      (/\dead -> True)
                                                      (/\dead -> False)
                                                      {all dead. dead})))
                                       (\(x : Tuple2 integer ChessSet)
                                         (y : Tuple2 integer ChessSet) ->
                                          Tuple2_match
                                            {integer}
                                            {ChessSet}
                                            x
                                            {Tuple2 integer ChessSet}
                                            (\(ipv : integer)
                                              (ipv : ChessSet) ->
                                               Tuple2_match
                                                 {integer}
                                                 {ChessSet}
                                                 y
                                                 {Tuple2 integer ChessSet}
                                                 (\(ipv : integer)
                                                   (ipv : ChessSet) ->
                                                    Ordering_match
                                                      (compare
                                                         {integer}
                                                         v
                                                         ipv
                                                         ipv)
                                                      {all dead.
                                                         Tuple2
                                                           integer
                                                           ChessSet}
                                                      (/\dead ->
                                                         Ordering_match
                                                           (compare
                                                              {ChessSet}
                                                              v
                                                              ipv
                                                              ipv)
                                                           {all dead.
                                                              Tuple2
                                                                integer
                                                                ChessSet}
                                                           (/\dead -> y)
                                                           (/\dead -> x)
                                                           (/\dead -> y)
                                                           {all dead. dead})
                                                      (/\dead -> x)
                                                      (/\dead -> y)
                                                      {all dead. dead})))
                                       (\(x : Tuple2 integer ChessSet)
                                         (y : Tuple2 integer ChessSet) ->
                                          Tuple2_match
                                            {integer}
                                            {ChessSet}
                                            x
                                            {Tuple2 integer ChessSet}
                                            (\(ipv : integer)
                                              (ipv : ChessSet) ->
                                               Tuple2_match
                                                 {integer}
                                                 {ChessSet}
                                                 y
                                                 {Tuple2 integer ChessSet}
                                                 (\(ipv : integer)
                                                   (ipv : ChessSet) ->
                                                    Ordering_match
                                                      (compare
                                                         {integer}
                                                         v
                                                         ipv
                                                         ipv)
                                                      {all dead.
                                                         Tuple2
                                                           integer
                                                           ChessSet}
                                                      (/\dead ->
                                                         Ordering_match
                                                           (compare
                                                              {ChessSet}
                                                              v
                                                              ipv
                                                              ipv)
                                                           {all dead.
                                                              Tuple2
                                                                integer
                                                                ChessSet}
                                                           (/\dead -> x)
                                                           (/\dead -> y)
                                                           (/\dead -> x)
                                                           {all dead. dead})
                                                      (/\dead -> y)
                                                      (/\dead -> x)
                                                      {all dead. dead}))))
                                    (descAndNo y)))
                            (/\dead ->
                               Bool_match
                                 (ifThenElse
                                    {Bool}
                                    (equalsInteger 1 l)
                                    True
                                    False)
                                 {all dead. List ChessSet}
                                 (/\dead -> singles)
                                 (/\dead -> Nil {ChessSet})
                                 {all dead. dead})
                            {all dead. dead}
                      in
                      Bool_match
                        (canMoveTo
                           (Maybe_match
                              {Tuple2 integer integer}
                              ipv
                              {all dead. Tuple2 integer integer}
                              (\(tile : Tuple2 integer integer) ->
                                 /\dead -> tile)
                              (/\dead -> error {Tuple2 integer integer})
                              {all dead. dead})
                           (deleteFirst y))
                        {all dead. List ChessSet}
                        (/\dead ->
                           Bool_match
                             (let
                               !board : ChessSet
                                 = addPiece
                                     (Maybe_match
                                        {Tuple2 integer integer}
                                        ipv
                                        {all dead. Tuple2 integer integer}
                                        (\(tile : Tuple2 integer integer) ->
                                           /\dead -> tile)
                                        (/\dead ->
                                           error {Tuple2 integer integer})
                                        {all dead. dead})
                                     y
                             in
                             ifThenElse
                               {Bool}
                               (equalsInteger
                                  0
                                  (length
                                     {List}
                                     {Direction}
                                     `$fFoldableNil_$cfoldr`
                                     (possibleMoves board)))
                               True
                               False)
                             {all dead. List ChessSet}
                             (/\dead -> Nil {ChessSet})
                             (/\dead -> `$j`)
                             {all dead. dead})
                        (/\dead -> `$j`)
                        {all dead. dead}))))
      (\(ds : Tuple2 integer ChessSet) ->
         Tuple2_match
           {integer}
           {ChessSet}
           ds
           {Bool}
           (\(ds : integer) (y : ChessSet) ->
              ChessSet_match
                y
                {Bool}
                (\(ipv : integer)
                  (ipv : integer)
                  (ipv : Maybe (Tuple2 integer integer))
                  (ipv : List (Tuple2 integer integer)) ->
                   Bool_match
                     (ifThenElse
                        {Bool}
                        (equalsInteger ipv (multiplyInteger ipv ipv))
                        True
                        False)
                     {all dead. Bool}
                     (/\dead ->
                        canMoveTo
                          (Maybe_match
                             {Tuple2 integer integer}
                             ipv
                             {all dead. Tuple2 integer integer}
                             (\(tile : Tuple2 integer integer) ->
                                /\dead -> tile)
                             (/\dead -> error {Tuple2 integer integer})
                             {all dead. dead})
                          (deleteFirst y))
                     (/\dead -> False)
                     {all dead. dead}))))
  10
  4