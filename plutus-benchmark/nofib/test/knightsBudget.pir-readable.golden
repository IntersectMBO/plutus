(letrec
    data (List :: * -> *) a | Nil_match where
      Nil : List a
      Cons : a -> List a -> List a
  in
  letrec
    !foldr : all a b. (a -> b -> b) -> b -> List a -> b
      = /\a b ->
          \(f : a -> b -> b) (acc : b) (l : List a) ->
            Nil_match
              {a}
              l
              {all dead. b}
              (/\dead -> acc)
              (\(x : a) (xs : List a) -> /\dead -> f x (foldr {a} {b} f acc xs))
              {all dead. dead}
  in
  let
    data Bool | Bool_match where
      True : Bool
      False : Bool
  in
  letrec
    !depthSearch :
       all a.
         (\a -> a -> a -> Bool) a ->
         integer ->
         List a ->
         (a -> List a) ->
         (a -> Bool) ->
         List a
      = /\a ->
          \(`$dEq` : (\a -> a -> a -> Bool) a)
           (depth : integer)
           (q : List a)
           (growFn : a -> List a)
           (finFn : a -> Bool) ->
            Bool_match
              (ifThenElse {Bool} (equalsInteger 0 depth) True False)
              {all dead. List a}
              (/\dead -> Nil {a})
              (/\dead ->
                 Bool_match
                   (Nil_match
                      {a}
                      q
                      {all dead. Bool}
                      (/\dead -> True)
                      (\(ipv : a) (ipv : List a) -> /\dead -> False)
                      {all dead. dead})
                   {all dead. List a}
                   (/\dead -> Nil {a})
                   (/\dead ->
                      Bool_match
                        (finFn
                           (Nil_match
                              {a}
                              q
                              {all dead. a}
                              (/\dead -> error {a})
                              (\(h : a) (ds : List a) -> /\dead -> h)
                              {all dead. dead}))
                        {all dead. List a}
                        (/\dead ->
                           Cons
                             {a}
                             (Nil_match
                                {a}
                                q
                                {all dead. a}
                                (/\dead -> error {a})
                                (\(h : a) (ds : List a) -> /\dead -> h)
                                {all dead. dead})
                             (depthSearch
                                {a}
                                `$dEq`
                                (subtractInteger depth 1)
                                (Nil_match
                                   {a}
                                   q
                                   {all dead. List a}
                                   (/\dead -> error {List a})
                                   (\(ds : a) (t : List a) -> /\dead -> t)
                                   {all dead. dead})
                                growFn
                                finFn))
                        (/\dead ->
                           depthSearch
                             {a}
                             `$dEq`
                             (subtractInteger depth 1)
                             (let
                               !list : List a
                                 = growFn
                                     (Nil_match
                                        {a}
                                        q
                                        {all dead. a}
                                        (/\dead -> error {a})
                                        (\(h : a) (ds : List a) -> /\dead -> h)
                                        {all dead. dead})
                               !q : List a
                                 = Nil_match
                                     {a}
                                     q
                                     {all dead. List a}
                                     (/\dead -> error {List a})
                                     (\(ds : a) (t : List a) -> /\dead -> t)
                                     {all dead. dead}
                             in
                             foldr
                               {a}
                               {List a}
                               (\(ds : a) (ds : List a) -> Cons {a} ds ds)
                               q
                               list)
                             growFn
                             finFn)
                        {all dead. dead})
                   {all dead. dead})
              {all dead. dead}
  in
  let
    data Ordering | Ordering_match where
      EQ : Ordering
      GT : Ordering
      LT : Ordering
    data (Ord :: * -> *) a | Ord_match where
      CConsOrd :
        (\a -> a -> a -> Bool) a ->
        (a -> a -> Ordering) ->
        (a -> a -> Bool) ->
        (a -> a -> Bool) ->
        (a -> a -> Bool) ->
        (a -> a -> Bool) ->
        (a -> a -> a) ->
        (a -> a -> a) ->
        Ord a
    !`$p1Ord` : all a. Ord a -> (\a -> a -> a -> Bool) a
      = /\a ->
          \(v : Ord a) ->
            Ord_match
              {a}
              v
              {(\a -> a -> a -> Bool) a}
              (\(v : (\a -> a -> a -> Bool) a)
                (v : a -> a -> Ordering)
                (v : a -> a -> Bool)
                (v : a -> a -> Bool)
                (v : a -> a -> Bool)
                (v : a -> a -> Bool)
                (v : a -> a -> a)
                (v : a -> a -> a) ->
                 v)
    !compare : all a. Ord a -> a -> a -> Ordering
      = /\a ->
          \(v : Ord a) ->
            Ord_match
              {a}
              v
              {a -> a -> Ordering}
              (\(v : (\a -> a -> a -> Bool) a)
                (v : a -> a -> Ordering)
                (v : a -> a -> Bool)
                (v : a -> a -> Bool)
                (v : a -> a -> Bool)
                (v : a -> a -> Bool)
                (v : a -> a -> a)
                (v : a -> a -> a) ->
                 v)
    data (Maybe :: * -> *) a | Maybe_match where
      Just : a -> Maybe a
      Nothing : Maybe a
    data (Tuple2 :: * -> * -> *) a b | Tuple2_match where
      Tuple2 : a -> b -> Tuple2 a b
    data ChessSet | ChessSet_match where
      Board :
        integer ->
        integer ->
        Maybe (Tuple2 integer integer) ->
        List (Tuple2 integer integer) ->
        ChessSet
    !`$fEqChessSet_$c==` : ChessSet -> ChessSet -> Bool
      = \(ds : ChessSet) (ds : ChessSet) -> True
  in
  letrec
    !quickSort : all a. Ord a -> List a -> List a
      = /\a ->
          \(`$dOrd` : Ord a) (ds : List a) ->
            Nil_match
              {a}
              ds
              {all dead. List a}
              (/\dead -> Nil {a})
              (\(x : a) (xs : List a) ->
                 /\dead ->
                   (let
                       b = List a
                     in
                     \(c : a -> b -> b) (n : b) ->
                       letrec
                         !go : List a -> b
                           = \(ds : List a) ->
                               Nil_match
                                 {a}
                                 ds
                                 {all dead. b}
                                 (/\dead -> n)
                                 (\(y : a) (ys : List a) ->
                                    /\dead -> c y (go ys))
                                 {all dead. dead}
                       in
                       let
                         !eta : List a
                           = quickSort
                               {a}
                               `$dOrd`
                               ((let
                                    a = List a
                                  in
                                  \(c : a -> a -> a) (n : a) ->
                                    letrec
                                      !go : List a -> a
                                        = \(ds : List a) ->
                                            Nil_match
                                              {a}
                                              ds
                                              {all dead. a}
                                              (/\dead -> n)
                                              (\(y : a) (ys : List a) ->
                                                 /\dead ->
                                                   let
                                                     !ds : a = go ys
                                                   in
                                                   Bool_match
                                                     (Ord_match
                                                        {a}
                                                        `$dOrd`
                                                        {a -> a -> Bool}
                                                        (\(v :
                                                             (\a ->
                                                                a -> a -> Bool)
                                                               a)
                                                          (v :
                                                             a -> a -> Ordering)
                                                          (v : a -> a -> Bool)
                                                          (v : a -> a -> Bool)
                                                          (v : a -> a -> Bool)
                                                          (v : a -> a -> Bool)
                                                          (v : a -> a -> a)
                                                          (v : a -> a -> a) ->
                                                           v)
                                                        y
                                                        x)
                                                     {all dead. a}
                                                     (/\dead -> c y ds)
                                                     (/\dead -> ds)
                                                     {all dead. dead})
                                              {all dead. dead}
                                    in
                                    go xs)
                                  (\(ds : a) (ds : List a) -> Cons {a} ds ds)
                                  (Nil {a}))
                       in
                       go eta)
                     (\(ds : a) (ds : List a) -> Cons {a} ds ds)
                     ((let
                          b = List a
                        in
                        \(c : a -> b -> b) (n : b) -> c x n)
                        (\(ds : a) (ds : List a) -> Cons {a} ds ds)
                        (quickSort
                           {a}
                           `$dOrd`
                           ((let
                                a = List a
                              in
                              \(c : a -> a -> a) (n : a) ->
                                letrec
                                  !go : List a -> a
                                    = \(ds : List a) ->
                                        Nil_match
                                          {a}
                                          ds
                                          {all dead. a}
                                          (/\dead -> n)
                                          (\(y : a) (ys : List a) ->
                                             /\dead ->
                                               let
                                                 !ds : a = go ys
                                               in
                                               Bool_match
                                                 (Ord_match
                                                    {a}
                                                    `$dOrd`
                                                    {a -> a -> Bool}
                                                    (\(v :
                                                         (\a -> a -> a -> Bool)
                                                           a)
                                                      (v : a -> a -> Ordering)
                                                      (v : a -> a -> Bool)
                                                      (v : a -> a -> Bool)
                                                      (v : a -> a -> Bool)
                                                      (v : a -> a -> Bool)
                                                      (v : a -> a -> a)
                                                      (v : a -> a -> a) ->
                                                       v)
                                                    y
                                                    x)
                                                 {all dead. a}
                                                 (/\dead -> c y ds)
                                                 (/\dead -> ds)
                                                 {all dead. dead})
                                          {all dead. dead}
                                in
                                go xs)
                              (\(ds : a) (ds : List a) -> Cons {a} ds ds)
                              (Nil {a})))))
              {all dead. dead}
  in
  letrec
    !interval : integer -> integer -> List integer
      = \(a : integer) (b : integer) ->
          Bool_match
            (ifThenElse {Bool} (lessThanEqualsInteger a b) False True)
            {all dead. List integer}
            (/\dead -> Nil {integer})
            (/\dead -> Cons {integer} a (interval (addInteger 1 a) b))
            {all dead. dead}
  in
  letrec
    !repl : integer -> integer -> List integer
      = \(n : integer) (a : integer) ->
          Bool_match
            (ifThenElse {Bool} (equalsInteger 0 n) True False)
            {all dead. List integer}
            (/\dead -> Nil {integer})
            (/\dead -> Cons {integer} a (repl (subtractInteger n 1) a))
            {all dead. dead}
  in
  let
    !`$fFoldableNil_$cfoldr` : all a b. (a -> b -> b) -> b -> List a -> b
      = /\a b ->
          \(f : a -> b -> b) (z : b) ->
            letrec
              !go : List a -> b
                = \(ds : List a) ->
                    Nil_match
                      {a}
                      ds
                      {all dead. b}
                      (/\dead -> z)
                      (\(x : a) (xs : List a) -> /\dead -> f x (go xs))
                      {all dead. dead}
            in
            \(eta : List a) -> go eta
    !addPiece : Tuple2 integer integer -> ChessSet -> ChessSet
      = \(t : Tuple2 integer integer) (ds : ChessSet) ->
          ChessSet_match
            ds
            {ChessSet}
            (\(s : integer)
              (n : integer)
              (f : Maybe (Tuple2 integer integer))
              (ts : List (Tuple2 integer integer)) ->
               let
                 !dt : integer = addInteger 1 n
                 !dt : List (Tuple2 integer integer)
                   = Cons {Tuple2 integer integer} t ts
               in
               Board s dt f dt)
  in
  letrec
    !map : all a b. (a -> b) -> List a -> List b
      = /\a b ->
          \(f : a -> b) (l : List a) ->
            Nil_match
              {a}
              l
              {all dead. List b}
              (/\dead -> Nil {b})
              (\(x : a) (xs : List a) ->
                 /\dead -> Cons {b} (f x) (map {a} {b} f xs))
              {all dead. dead}
  in
  let
    !length :
       all (t :: * -> *) a.
         (\(t :: * -> *) -> all a b. (a -> b -> b) -> b -> t a -> b) t ->
         t a ->
         integer
      = /\(t :: * -> *) a ->
          \(`$dFoldable` :
              (\(t :: * -> *) -> all a b. (a -> b -> b) -> b -> t a -> b) t)
           (eta : t a) ->
            `$dFoldable`
              {a}
              {integer -> integer}
              (\(a : a) (g : integer -> integer) (b : integer) ->
                 g (addInteger 1 b))
              (\(x : integer) -> x)
              eta
              0
    data Direction | Direction_match where
      DL : Direction
      DR : Direction
      LD : Direction
      LU : Direction
      RD : Direction
      RU : Direction
      UL : Direction
      UR : Direction
    !move : Direction -> Tuple2 integer integer -> Tuple2 integer integer
      = \(ds : Direction) (ds : Tuple2 integer integer) ->
          Direction_match
            ds
            {all dead. Tuple2 integer integer}
            (/\dead ->
               Tuple2_match
                 {integer}
                 {integer}
                 ds
                 {Tuple2 integer integer}
                 (\(x : integer) (y : integer) ->
                    Tuple2
                      {integer}
                      {integer}
                      (subtractInteger x 1)
                      (addInteger 2 y)))
            (/\dead ->
               Tuple2_match
                 {integer}
                 {integer}
                 ds
                 {Tuple2 integer integer}
                 (\(x : integer) (y : integer) ->
                    Tuple2
                      {integer}
                      {integer}
                      (addInteger 1 x)
                      (addInteger 2 y)))
            (/\dead ->
               Tuple2_match
                 {integer}
                 {integer}
                 ds
                 {Tuple2 integer integer}
                 (\(x : integer) (y : integer) ->
                    Tuple2
                      {integer}
                      {integer}
                      (subtractInteger x 2)
                      (addInteger 1 y)))
            (/\dead ->
               Tuple2_match
                 {integer}
                 {integer}
                 ds
                 {Tuple2 integer integer}
                 (\(x : integer) (y : integer) ->
                    Tuple2
                      {integer}
                      {integer}
                      (subtractInteger x 2)
                      (subtractInteger y 1)))
            (/\dead ->
               Tuple2_match
                 {integer}
                 {integer}
                 ds
                 {Tuple2 integer integer}
                 (\(x : integer) (y : integer) ->
                    Tuple2
                      {integer}
                      {integer}
                      (addInteger 2 x)
                      (addInteger 1 y)))
            (/\dead ->
               Tuple2_match
                 {integer}
                 {integer}
                 ds
                 {Tuple2 integer integer}
                 (\(x : integer) (y : integer) ->
                    Tuple2
                      {integer}
                      {integer}
                      (addInteger 2 x)
                      (subtractInteger y 1)))
            (/\dead ->
               Tuple2_match
                 {integer}
                 {integer}
                 ds
                 {Tuple2 integer integer}
                 (\(x : integer) (y : integer) ->
                    Tuple2
                      {integer}
                      {integer}
                      (subtractInteger x 1)
                      (subtractInteger y 2)))
            (/\dead ->
               Tuple2_match
                 {integer}
                 {integer}
                 ds
                 {Tuple2 integer integer}
                 (\(x : integer) (y : integer) ->
                    Tuple2
                      {integer}
                      {integer}
                      (addInteger 1 x)
                      (subtractInteger y 2)))
            {all dead. dead}
    !equalsInteger : integer -> integer -> Bool
      = \(x : integer) (y : integer) ->
          ifThenElse {Bool} (equalsInteger x y) True False
  in
  letrec
    !notIn : all a. (\a -> a -> a -> Bool) a -> a -> List a -> Bool
      = /\a ->
          \(`$dEq` : (\a -> a -> a -> Bool) a) (ds : a) (ds : List a) ->
            Nil_match
              {a}
              ds
              {all dead. Bool}
              (/\dead -> True)
              (\(a : a) (as : List a) ->
                 /\dead ->
                   Bool_match
                     (`$dEq` ds a)
                     {all dead. Bool}
                     (/\dead -> False)
                     (/\dead -> notIn {a} `$dEq` ds as)
                     {all dead. dead})
              {all dead. dead}
  in
  let
    !canMoveTo : Tuple2 integer integer -> ChessSet -> Bool
      = \(t : Tuple2 integer integer) (board : ChessSet) ->
          Tuple2_match
            {integer}
            {integer}
            t
            {Bool}
            (\(x : integer) (y : integer) ->
               ChessSet_match
                 board
                 {Bool}
                 (\(ipv : integer)
                   (ipv : integer)
                   (ipv : Maybe (Tuple2 integer integer))
                   (ipv : List (Tuple2 integer integer)) ->
                    Bool_match
                      (ifThenElse {Bool} (lessThanInteger x 1) False True)
                      {all dead. Bool}
                      (/\dead ->
                         let
                           !b : bool = lessThanEqualsInteger x ipv
                         in
                         Bool_match
                           (ifThenElse {Bool} b True False)
                           {all dead. Bool}
                           (/\dead ->
                              Bool_match
                                (ifThenElse
                                   {Bool}
                                   (lessThanInteger y 1)
                                   False
                                   True)
                                {all dead. Bool}
                                (/\dead ->
                                   let
                                     !b : bool = lessThanEqualsInteger y ipv
                                   in
                                   Bool_match
                                     (ifThenElse {Bool} b True False)
                                     {all dead. Bool}
                                     (/\dead ->
                                        notIn
                                          {Tuple2 integer integer}
                                          (\(ds : Tuple2 integer integer)
                                            (ds : Tuple2 integer integer) ->
                                             Tuple2_match
                                               {integer}
                                               {integer}
                                               ds
                                               {Bool}
                                               (\(a : integer) (b : integer) ->
                                                  Tuple2_match
                                                    {integer}
                                                    {integer}
                                                    ds
                                                    {Bool}
                                                    (\(a' : integer)
                                                      (b' : integer) ->
                                                       let
                                                         !b : bool
                                                           = equalsInteger a a'
                                                       in
                                                       Bool_match
                                                         (ifThenElse
                                                            {Bool}
                                                            b
                                                            True
                                                            False)
                                                         {all dead. Bool}
                                                         (/\dead ->
                                                            equalsInteger b b')
                                                         (/\dead -> False)
                                                         {all dead. dead})))
                                          t
                                          ipv)
                                     (/\dead -> False)
                                     {all dead. dead})
                                (/\dead -> False)
                                {all dead. dead})
                           (/\dead -> False)
                           {all dead. dead})
                      (/\dead -> False)
                      {all dead. dead}))
    !possibleMoves : ChessSet -> List Direction
      = \(board : ChessSet) ->
          ChessSet_match
            board
            {List Direction}
            (\(ipv : integer)
              (ipv : integer)
              (ipv : Maybe (Tuple2 integer integer))
              (ipv : List (Tuple2 integer integer)) ->
               (let
                   a = List Direction
                 in
                 \(c : Direction -> a -> a) ->
                   let
                     !c : Direction -> a -> a
                       = \(ds : Direction) (ds : a) ->
                           Bool_match
                             (canMoveTo
                                (move
                                   ds
                                   (Nil_match
                                      {Tuple2 integer integer}
                                      ipv
                                      {all dead. Tuple2 integer integer}
                                      (/\dead -> error {Tuple2 integer integer})
                                      (\(t : Tuple2 integer integer)
                                        (ds : List (Tuple2 integer integer)) ->
                                         /\dead -> t)
                                      {all dead. dead}))
                                board)
                             {all dead. a}
                             (/\dead -> c ds ds)
                             (/\dead -> ds)
                             {all dead. dead}
                   in
                   \(n : a) ->
                     c UL (c UR (c DL (c DR (c LU (c LD (c RU (c RD n))))))))
                 (\(ds : Direction) (ds : List Direction) ->
                    Cons {Direction} ds ds)
                 (Nil {Direction}))
    !deleteFirst : ChessSet -> ChessSet
      = \(ds : ChessSet) ->
          ChessSet_match
            ds
            {ChessSet}
            (\(s : integer)
              (n : integer)
              (ds : Maybe (Tuple2 integer integer))
              (ts : List (Tuple2 integer integer)) ->
               let
                 !f' : Maybe (Tuple2 integer integer)
                   = (let
                         a = Tuple2 integer integer
                       in
                       letrec
                         !rev : List a -> List a -> Maybe a
                           = \(ds : List a) (a : List a) ->
                               Nil_match
                                 {a}
                                 ds
                                 {all dead. Maybe a}
                                 (/\dead ->
                                    Nil_match
                                      {a}
                                      a
                                      {all dead. Maybe a}
                                      (/\dead -> error {Maybe a})
                                      (\(ds : a) (ds : List a) ->
                                         /\dead ->
                                           Nil_match
                                             {a}
                                             ds
                                             {all dead. Maybe a}
                                             (/\dead -> Nothing {a})
                                             (\(a : a) (ds : List a) ->
                                                /\dead -> Just {a} a)
                                             {all dead. dead})
                                      {all dead. dead})
                                 (\(x : a) (xs : List a) ->
                                    /\dead -> rev xs (Cons {a} x a))
                                 {all dead. dead}
                       in
                       \(l : List a) -> rev l (Nil {a}))
                       ts
                 !`$j` : List (Tuple2 integer integer) -> ChessSet
                   = \(ts' : List (Tuple2 integer integer)) ->
                       let
                         !dt : integer = subtractInteger n 1
                       in
                       Board s dt f' ts'
               in
               letrec
                 !rev :
                    List (Tuple2 integer integer) ->
                    List (Tuple2 integer integer) ->
                    ChessSet
                   = \(ds : List (Tuple2 integer integer))
                      (a : List (Tuple2 integer integer)) ->
                       Nil_match
                         {Tuple2 integer integer}
                         ds
                         {all dead. ChessSet}
                         (/\dead -> `$j` a)
                         (\(x : Tuple2 integer integer)
                           (xs : List (Tuple2 integer integer)) ->
                            /\dead ->
                              rev xs (Cons {Tuple2 integer integer} x a))
                         {all dead. dead}
               in
               letrec
                 !rev :
                    List (Tuple2 integer integer) ->
                    List (Tuple2 integer integer) ->
                    ChessSet
                   = \(ds : List (Tuple2 integer integer))
                      (a : List (Tuple2 integer integer)) ->
                       Nil_match
                         {Tuple2 integer integer}
                         ds
                         {all dead. ChessSet}
                         (/\dead ->
                            Nil_match
                              {Tuple2 integer integer}
                              a
                              {all dead. ChessSet}
                              (/\dead ->
                                 let
                                   !ts' : List (Tuple2 integer integer)
                                     = error {List (Tuple2 integer integer)}
                                 in
                                 `$j` ts')
                              (\(ds : Tuple2 integer integer)
                                (as : List (Tuple2 integer integer)) ->
                                 /\dead ->
                                   rev as (Nil {Tuple2 integer integer}))
                              {all dead. dead})
                         (\(x : Tuple2 integer integer)
                           (xs : List (Tuple2 integer integer)) ->
                            /\dead ->
                              rev xs (Cons {Tuple2 integer integer} x a))
                         {all dead. dead}
               in
               rev ts (Nil {Tuple2 integer integer}))
    !descAndNo : ChessSet -> List (Tuple2 integer ChessSet)
      = \(board : ChessSet) ->
          (let
              a = Tuple2 integer ChessSet
            in
            \(g : all b. (a -> b -> b) -> b -> b) ->
              g {List a} (\(ds : a) (ds : List a) -> Cons {a} ds ds) (Nil {a}))
            (/\a ->
               \(c : Tuple2 integer ChessSet -> a -> a) (n : a) ->
                 letrec
                   !go : List ChessSet -> a
                     = \(ds : List ChessSet) ->
                         Nil_match
                           {ChessSet}
                           ds
                           {all dead. a}
                           (/\dead -> n)
                           (\(y : ChessSet) (ys : List ChessSet) ->
                              /\dead ->
                                let
                                  !ds : a = go ys
                                in
                                c
                                  (Tuple2
                                     {integer}
                                     {ChessSet}
                                     (length
                                        {List}
                                        {Direction}
                                        `$fFoldableNil_$cfoldr`
                                        (possibleMoves (deleteFirst y)))
                                     y)
                                  ds)
                           {all dead. dead}
                 in
                 let
                   !eta : List ChessSet
                     = ChessSet_match
                         board
                         {List ChessSet}
                         (\(ipv : integer)
                           (ipv : integer)
                           (ipv : Maybe (Tuple2 integer integer))
                           (ipv : List (Tuple2 integer integer)) ->
                            map
                              {Direction}
                              {ChessSet}
                              (\(dir : Direction) ->
                                 addPiece
                                   (move
                                      dir
                                      (Nil_match
                                         {Tuple2 integer integer}
                                         ipv
                                         {all dead. Tuple2 integer integer}
                                         (/\dead ->
                                            error {Tuple2 integer integer})
                                         (\(t : Tuple2 integer integer)
                                           (ds :
                                              List (Tuple2 integer integer)) ->
                                            /\dead -> t)
                                         {all dead. dead}))
                                   board)
                              (possibleMoves board))
                 in
                 go eta)
  in
  letrec
    !zip : all a b. List a -> List b -> List (Tuple2 a b)
      = /\a b ->
          \(ds : List a) (_bs : List b) ->
            Nil_match
              {a}
              ds
              {all dead. List (Tuple2 a b)}
              (/\dead -> Nil {Tuple2 a b})
              (\(ipv : a) (ipv : List a) ->
                 /\dead ->
                   Nil_match
                     {b}
                     _bs
                     {all dead. List (Tuple2 a b)}
                     (/\dead -> Nil {Tuple2 a b})
                     (\(ipv : b) (ipv : List b) ->
                        /\dead ->
                          Cons
                            {Tuple2 a b}
                            (Tuple2 {a} {b} ipv ipv)
                            (zip {a} {b} ipv ipv))
                     {all dead. dead})
              {all dead. dead}
  in
  letrec
    !zipConst : all a b. a -> List b -> List (Tuple2 a b)
      = /\a b ->
          \(ds : a) (ds : List b) ->
            Nil_match
              {b}
              ds
              {all dead. List (Tuple2 a b)}
              (/\dead -> Nil {Tuple2 a b})
              (\(b : b) (bs : List b) ->
                 /\dead ->
                   Cons
                     {Tuple2 a b}
                     (Tuple2 {a} {b} ds b)
                     (zipConst {a} {b} ds bs))
              {all dead. dead}
  in
  \(depth : integer)
   (boardSize : integer) ->
    depthSearch
      {Tuple2 integer ChessSet}
      (\(ds : Tuple2 integer ChessSet) (ds : Tuple2 integer ChessSet) ->
         Tuple2_match
           {integer}
           {ChessSet}
           ds
           {Bool}
           (\(a : integer) (b : ChessSet) ->
              Tuple2_match
                {integer}
                {ChessSet}
                ds
                {Bool}
                (\(a' : integer) (b' : ChessSet) ->
                   Bool_match
                     (equalsInteger a a')
                     {all dead. Bool}
                     (/\dead -> True)
                     (/\dead -> False)
                     {all dead. dead})))
      depth
      (let
        !list :
           List (Tuple2 integer ChessSet)
          = let
            !l :
               List ChessSet
              = (let
                    a = List ChessSet
                  in
                  \(c : ChessSet -> a -> a)
                   (n : a) ->
                    letrec
                      !go :
                         List integer -> a
                        = \(ds : List integer) ->
                            Nil_match
                              {integer}
                              ds
                              {all dead. a}
                              (/\dead -> n)
                              (\(y : integer)
                                (ys : List integer) ->
                                 /\dead ->
                                   let
                                     !ds : a = go ys
                                   in
                                   letrec
                                     !go :
                                        List integer -> a
                                       = \(ds : List integer) ->
                                           Nil_match
                                             {integer}
                                             ds
                                             {all dead. a}
                                             (/\dead -> ds)
                                             (\(y : integer)
                                               (ys : List integer) ->
                                                /\dead ->
                                                  let
                                                    !ds : a = go ys
                                                  in
                                                  c
                                                    (let
                                                      !st :
                                                         Tuple2 integer integer
                                                        = Tuple2
                                                            {integer}
                                                            {integer}
                                                            y
                                                            y
                                                      !b : bool
                                                        = equalsInteger
                                                            0
                                                            (remainderInteger
                                                               boardSize
                                                               2)
                                                    in
                                                    Bool_match
                                                      (ifThenElse
                                                         {Bool}
                                                         b
                                                         True
                                                         False)
                                                      {all dead. ChessSet}
                                                      (/\dead ->
                                                         let
                                                           !dt :
                                                              Maybe
                                                                (Tuple2
                                                                   integer
                                                                   integer)
                                                             = Just
                                                                 {Tuple2
                                                                    integer
                                                                    integer}
                                                                 st
                                                           !dt :
                                                              List
                                                                (Tuple2
                                                                   integer
                                                                   integer)
                                                             = (let
                                                                   a
                                                                     = Tuple2
                                                                         integer
                                                                         integer
                                                                 in
                                                                 \(g :
                                                                     all b.
                                                                       (a ->
                                                                        b ->
                                                                        b) ->
                                                                       b ->
                                                                       b) ->
                                                                   g
                                                                     {List a}
                                                                     (\(ds : a)
                                                                       (ds :
                                                                          List
                                                                            a) ->
                                                                        Cons
                                                                          {a}
                                                                          ds
                                                                          ds)
                                                                     (Nil {a}))
                                                                 (/\a ->
                                                                    \(c :
                                                                        Tuple2
                                                                          integer
                                                                          integer ->
                                                                        a ->
                                                                        a)
                                                                     (n : a) ->
                                                                      c st n)
                                                         in
                                                         Board
                                                           boardSize
                                                           1
                                                           dt
                                                           dt)
                                                      (/\dead ->
                                                         error {ChessSet})
                                                      {all dead. dead})
                                                    ds)
                                             {all dead. dead}
                                   in
                                   let
                                     !eta : List integer = interval 1 boardSize
                                   in
                                   go eta)
                              {all dead. dead}
                    in
                    let
                      !eta : List integer = interval 1 boardSize
                    in
                    go eta)
                  (\(ds : ChessSet) (ds : List ChessSet) ->
                     Cons {ChessSet} ds ds)
                  (Nil {ChessSet})
            !numStarts : integer
              = length {List} {ChessSet} `$fFoldableNil_$cfoldr` l
          in
          zip
            {integer}
            {ChessSet}
            (repl numStarts (subtractInteger 1 numStarts))
            l
      in
      foldr
        {Tuple2 integer ChessSet}
        {List (Tuple2 integer ChessSet)}
        (\(ds : Tuple2 integer ChessSet)
          (ds : List (Tuple2 integer ChessSet)) ->
           Cons {Tuple2 integer ChessSet} ds ds)
        (Nil {Tuple2 integer ChessSet})
        list)
      (\(ds : Tuple2 integer ChessSet) ->
         Tuple2_match
           {integer}
           {ChessSet}
           ds
           {List (Tuple2 integer ChessSet)}
           (\(x : integer) (y : ChessSet) ->
              zipConst
                {integer}
                {ChessSet}
                (addInteger 1 x)
                (ChessSet_match
                   y
                   {List ChessSet}
                   (\(ipv : integer)
                     (ipv : integer)
                     (ipv : Maybe (Tuple2 integer integer))
                     (ipv : List (Tuple2 integer integer)) ->
                      let
                        !singles : List ChessSet
                          = (let
                                a = List ChessSet
                              in
                              \(c : ChessSet -> a -> a) (n : a) ->
                                (let
                                    a = Tuple2 integer ChessSet
                                  in
                                  /\b ->
                                    \(k : a -> b -> b) (z : b) ->
                                      letrec
                                        !go : List a -> b
                                          = \(ds : List a) ->
                                              Nil_match
                                                {a}
                                                ds
                                                {all dead. b}
                                                (/\dead -> z)
                                                (\(y : a) (ys : List a) ->
                                                   /\dead -> k y (go ys))
                                                {all dead. dead}
                                      in
                                      \(eta : List a) -> go eta)
                                  {a}
                                  (\(ds : Tuple2 integer ChessSet) (ds : a) ->
                                     Tuple2_match
                                       {integer}
                                       {ChessSet}
                                       ds
                                       {a}
                                       (\(y : integer) (x : ChessSet) ->
                                          let
                                            !b : bool = equalsInteger 1 y
                                          in
                                          Bool_match
                                            (ifThenElse {Bool} b True False)
                                            {all dead. a}
                                            (/\dead -> c x ds)
                                            (/\dead -> ds)
                                            {all dead. dead}))
                                  n
                                  (descAndNo y))
                              (\(ds : ChessSet) (ds : List ChessSet) ->
                                 Cons {ChessSet} ds ds)
                              (Nil {ChessSet})
                        ~`$j` : List ChessSet
                          = let
                            !l : integer
                              = length
                                  {List}
                                  {ChessSet}
                                  `$fFoldableNil_$cfoldr`
                                  singles
                            !b : bool = equalsInteger 0 l
                          in
                          Bool_match
                            (ifThenElse {Bool} b True False)
                            {all dead. List ChessSet}
                            (/\dead ->
                               map
                                 {Tuple2 integer ChessSet}
                                 {ChessSet}
                                 (\(ds : Tuple2 integer ChessSet) ->
                                    Tuple2_match
                                      {integer}
                                      {ChessSet}
                                      ds
                                      {ChessSet}
                                      (\(ds : integer) (b : ChessSet) -> b))
                                 (quickSort
                                    {Tuple2 integer ChessSet}
                                    (let
                                      !v : Ord integer
                                        = CConsOrd
                                            {integer}
                                            equalsInteger
                                            (\(eta : integer) (eta : integer) ->
                                               let
                                                 !b : bool
                                                   = equalsInteger eta eta
                                               in
                                               Bool_match
                                                 (ifThenElse
                                                    {Bool}
                                                    b
                                                    True
                                                    False)
                                                 {all dead. Ordering}
                                                 (/\dead -> EQ)
                                                 (/\dead ->
                                                    let
                                                      !b : bool
                                                        = lessThanEqualsInteger
                                                            eta
                                                            eta
                                                    in
                                                    Bool_match
                                                      (ifThenElse
                                                         {Bool}
                                                         b
                                                         True
                                                         False)
                                                      {all dead. Ordering}
                                                      (/\dead -> LT)
                                                      (/\dead -> GT)
                                                      {all dead. dead})
                                                 {all dead. dead})
                                            (\(x : integer) (y : integer) ->
                                               ifThenElse
                                                 {Bool}
                                                 (lessThanInteger x y)
                                                 True
                                                 False)
                                            (\(x : integer) (y : integer) ->
                                               ifThenElse
                                                 {Bool}
                                                 (lessThanEqualsInteger x y)
                                                 True
                                                 False)
                                            (\(x : integer) (y : integer) ->
                                               ifThenElse
                                                 {Bool}
                                                 (lessThanEqualsInteger x y)
                                                 False
                                                 True)
                                            (\(x : integer) (y : integer) ->
                                               ifThenElse
                                                 {Bool}
                                                 (lessThanInteger x y)
                                                 False
                                                 True)
                                            (\(x : integer) (y : integer) ->
                                               let
                                                 !b : bool
                                                   = lessThanEqualsInteger x y
                                               in
                                               Bool_match
                                                 (ifThenElse
                                                    {Bool}
                                                    b
                                                    True
                                                    False)
                                                 {all dead. integer}
                                                 (/\dead -> y)
                                                 (/\dead -> x)
                                                 {all dead. dead})
                                            (\(x : integer) (y : integer) ->
                                               let
                                                 !b : bool
                                                   = lessThanEqualsInteger x y
                                               in
                                               Bool_match
                                                 (ifThenElse
                                                    {Bool}
                                                    b
                                                    True
                                                    False)
                                                 {all dead. integer}
                                                 (/\dead -> x)
                                                 (/\dead -> y)
                                                 {all dead. dead})
                                      !v : Ord ChessSet
                                        = CConsOrd
                                            {ChessSet}
                                            `$fEqChessSet_$c==`
                                            (\(eta : ChessSet)
                                              (eta : ChessSet) ->
                                               EQ)
                                            (\(x : ChessSet) (y : ChessSet) ->
                                               False)
                                            `$fEqChessSet_$c==`
                                            (\(x : ChessSet) (y : ChessSet) ->
                                               False)
                                            `$fEqChessSet_$c==`
                                            (\(x : ChessSet) (y : ChessSet) ->
                                               y)
                                            (\(x : ChessSet) (y : ChessSet) ->
                                               x)
                                    in
                                    CConsOrd
                                      {Tuple2 integer ChessSet}
                                      (\(eta : Tuple2 integer ChessSet)
                                        (eta : Tuple2 integer ChessSet) ->
                                         Tuple2_match
                                           {integer}
                                           {ChessSet}
                                           eta
                                           {Bool}
                                           (\(a : integer) (b : ChessSet) ->
                                              Tuple2_match
                                                {integer}
                                                {ChessSet}
                                                eta
                                                {Bool}
                                                (\(a' : integer)
                                                  (b' : ChessSet) ->
                                                   Bool_match
                                                     (`$p1Ord` {integer} v a a')
                                                     {all dead. Bool}
                                                     (/\dead ->
                                                        `$p1Ord`
                                                          {ChessSet}
                                                          v
                                                          b
                                                          b')
                                                     (/\dead -> False)
                                                     {all dead. dead})))
                                      (\(ds : Tuple2 integer ChessSet)
                                        (ds : Tuple2 integer ChessSet) ->
                                         Tuple2_match
                                           {integer}
                                           {ChessSet}
                                           ds
                                           {Ordering}
                                           (\(a : integer) (b : ChessSet) ->
                                              Tuple2_match
                                                {integer}
                                                {ChessSet}
                                                ds
                                                {Ordering}
                                                (\(a' : integer) ->
                                                   let
                                                     ~defaultBody : Ordering
                                                       = compare
                                                           {integer}
                                                           v
                                                           a
                                                           a'
                                                   in
                                                   \(b' : ChessSet) ->
                                                     Ordering_match
                                                       (compare
                                                          {integer}
                                                          v
                                                          a
                                                          a')
                                                       {all dead. Ordering}
                                                       (/\dead ->
                                                          compare
                                                            {ChessSet}
                                                            v
                                                            b
                                                            b')
                                                       (/\dead -> defaultBody)
                                                       (/\dead -> defaultBody)
                                                       {all dead. dead})))
                                      (\(x : Tuple2 integer ChessSet)
                                        (y : Tuple2 integer ChessSet) ->
                                         Tuple2_match
                                           {integer}
                                           {ChessSet}
                                           x
                                           {Bool}
                                           (\(ipv : integer) (ipv : ChessSet) ->
                                              Tuple2_match
                                                {integer}
                                                {ChessSet}
                                                y
                                                {Bool}
                                                (\(ipv : integer)
                                                  (ipv : ChessSet) ->
                                                   Ordering_match
                                                     (compare
                                                        {integer}
                                                        v
                                                        ipv
                                                        ipv)
                                                     {all dead. Bool}
                                                     (/\dead ->
                                                        Ordering_match
                                                          (compare
                                                             {ChessSet}
                                                             v
                                                             ipv
                                                             ipv)
                                                          {all dead. Bool}
                                                          (/\dead -> False)
                                                          (/\dead -> False)
                                                          (/\dead -> True)
                                                          {all dead. dead})
                                                     (/\dead -> False)
                                                     (/\dead -> True)
                                                     {all dead. dead})))
                                      (\(x : Tuple2 integer ChessSet)
                                        (y : Tuple2 integer ChessSet) ->
                                         Tuple2_match
                                           {integer}
                                           {ChessSet}
                                           x
                                           {Bool}
                                           (\(ipv : integer) (ipv : ChessSet) ->
                                              Tuple2_match
                                                {integer}
                                                {ChessSet}
                                                y
                                                {Bool}
                                                (\(ipv : integer)
                                                  (ipv : ChessSet) ->
                                                   Ordering_match
                                                     (compare
                                                        {integer}
                                                        v
                                                        ipv
                                                        ipv)
                                                     {all dead. Bool}
                                                     (/\dead ->
                                                        Ordering_match
                                                          (compare
                                                             {ChessSet}
                                                             v
                                                             ipv
                                                             ipv)
                                                          {all dead. Bool}
                                                          (/\dead -> True)
                                                          (/\dead -> False)
                                                          (/\dead -> True)
                                                          {all dead. dead})
                                                     (/\dead -> False)
                                                     (/\dead -> True)
                                                     {all dead. dead})))
                                      (\(x : Tuple2 integer ChessSet)
                                        (y : Tuple2 integer ChessSet) ->
                                         Tuple2_match
                                           {integer}
                                           {ChessSet}
                                           x
                                           {Bool}
                                           (\(ipv : integer) (ipv : ChessSet) ->
                                              Tuple2_match
                                                {integer}
                                                {ChessSet}
                                                y
                                                {Bool}
                                                (\(ipv : integer)
                                                  (ipv : ChessSet) ->
                                                   Ordering_match
                                                     (compare
                                                        {integer}
                                                        v
                                                        ipv
                                                        ipv)
                                                     {all dead. Bool}
                                                     (/\dead ->
                                                        Ordering_match
                                                          (compare
                                                             {ChessSet}
                                                             v
                                                             ipv
                                                             ipv)
                                                          {all dead. Bool}
                                                          (/\dead -> False)
                                                          (/\dead -> True)
                                                          (/\dead -> False)
                                                          {all dead. dead})
                                                     (/\dead -> True)
                                                     (/\dead -> False)
                                                     {all dead. dead})))
                                      (\(x : Tuple2 integer ChessSet)
                                        (y : Tuple2 integer ChessSet) ->
                                         Tuple2_match
                                           {integer}
                                           {ChessSet}
                                           x
                                           {Bool}
                                           (\(ipv : integer) (ipv : ChessSet) ->
                                              Tuple2_match
                                                {integer}
                                                {ChessSet}
                                                y
                                                {Bool}
                                                (\(ipv : integer)
                                                  (ipv : ChessSet) ->
                                                   Ordering_match
                                                     (compare
                                                        {integer}
                                                        v
                                                        ipv
                                                        ipv)
                                                     {all dead. Bool}
                                                     (/\dead ->
                                                        Ordering_match
                                                          (compare
                                                             {ChessSet}
                                                             v
                                                             ipv
                                                             ipv)
                                                          {all dead. Bool}
                                                          (/\dead -> True)
                                                          (/\dead -> True)
                                                          (/\dead -> False)
                                                          {all dead. dead})
                                                     (/\dead -> True)
                                                     (/\dead -> False)
                                                     {all dead. dead})))
                                      (\(x : Tuple2 integer ChessSet)
                                        (y : Tuple2 integer ChessSet) ->
                                         Tuple2_match
                                           {integer}
                                           {ChessSet}
                                           x
                                           {Tuple2 integer ChessSet}
                                           (\(ipv : integer) (ipv : ChessSet) ->
                                              Tuple2_match
                                                {integer}
                                                {ChessSet}
                                                y
                                                {Tuple2 integer ChessSet}
                                                (\(ipv : integer)
                                                  (ipv : ChessSet) ->
                                                   Ordering_match
                                                     (compare
                                                        {integer}
                                                        v
                                                        ipv
                                                        ipv)
                                                     {all dead.
                                                        Tuple2 integer ChessSet}
                                                     (/\dead ->
                                                        Ordering_match
                                                          (compare
                                                             {ChessSet}
                                                             v
                                                             ipv
                                                             ipv)
                                                          {all dead.
                                                             Tuple2
                                                               integer
                                                               ChessSet}
                                                          (/\dead -> y)
                                                          (/\dead -> x)
                                                          (/\dead -> y)
                                                          {all dead. dead})
                                                     (/\dead -> x)
                                                     (/\dead -> y)
                                                     {all dead. dead})))
                                      (\(x : Tuple2 integer ChessSet)
                                        (y : Tuple2 integer ChessSet) ->
                                         Tuple2_match
                                           {integer}
                                           {ChessSet}
                                           x
                                           {Tuple2 integer ChessSet}
                                           (\(ipv : integer) (ipv : ChessSet) ->
                                              Tuple2_match
                                                {integer}
                                                {ChessSet}
                                                y
                                                {Tuple2 integer ChessSet}
                                                (\(ipv : integer)
                                                  (ipv : ChessSet) ->
                                                   Ordering_match
                                                     (compare
                                                        {integer}
                                                        v
                                                        ipv
                                                        ipv)
                                                     {all dead.
                                                        Tuple2 integer ChessSet}
                                                     (/\dead ->
                                                        Ordering_match
                                                          (compare
                                                             {ChessSet}
                                                             v
                                                             ipv
                                                             ipv)
                                                          {all dead.
                                                             Tuple2
                                                               integer
                                                               ChessSet}
                                                          (/\dead -> x)
                                                          (/\dead -> y)
                                                          (/\dead -> x)
                                                          {all dead. dead})
                                                     (/\dead -> y)
                                                     (/\dead -> x)
                                                     {all dead. dead}))))
                                    (descAndNo y)))
                            (/\dead ->
                               let
                                 !b : bool = equalsInteger 1 l
                               in
                               Bool_match
                                 (ifThenElse {Bool} b True False)
                                 {all dead. List ChessSet}
                                 (/\dead -> singles)
                                 (/\dead -> Nil {ChessSet})
                                 {all dead. dead})
                            {all dead. dead}
                      in
                      Bool_match
                        (canMoveTo
                           (Maybe_match
                              {Tuple2 integer integer}
                              ipv
                              {all dead. Tuple2 integer integer}
                              (\(tile : Tuple2 integer integer) ->
                                 /\dead -> tile)
                              (/\dead -> error {Tuple2 integer integer})
                              {all dead. dead})
                           (deleteFirst y))
                        {all dead. List ChessSet}
                        (/\dead ->
                           Bool_match
                             (let
                               !board : ChessSet
                                 = addPiece
                                     (Maybe_match
                                        {Tuple2 integer integer}
                                        ipv
                                        {all dead. Tuple2 integer integer}
                                        (\(tile : Tuple2 integer integer) ->
                                           /\dead -> tile)
                                        (/\dead ->
                                           error {Tuple2 integer integer})
                                        {all dead. dead})
                                     y
                             in
                             ifThenElse
                               {Bool}
                               (equalsInteger
                                  0
                                  (length
                                     {List}
                                     {Direction}
                                     `$fFoldableNil_$cfoldr`
                                     (possibleMoves board)))
                               True
                               False)
                             {all dead. List ChessSet}
                             (/\dead -> Nil {ChessSet})
                             (/\dead -> `$j`)
                             {all dead. dead})
                        (/\dead -> `$j`)
                        {all dead. dead}))))
      (\(ds : Tuple2 integer ChessSet) ->
         Tuple2_match
           {integer}
           {ChessSet}
           ds
           {Bool}
           (\(ds : integer) (y : ChessSet) ->
              ChessSet_match
                y
                {Bool}
                (\(ipv : integer)
                  (ipv : integer)
                  (ipv : Maybe (Tuple2 integer integer))
                  (ipv : List (Tuple2 integer integer)) ->
                   let
                     !y : integer = multiplyInteger ipv ipv
                     !b : bool = equalsInteger ipv y
                   in
                   Bool_match
                     (ifThenElse {Bool} b True False)
                     {all dead. Bool}
                     (/\dead ->
                        canMoveTo
                          (Maybe_match
                             {Tuple2 integer integer}
                             ipv
                             {all dead. Tuple2 integer integer}
                             (\(tile : Tuple2 integer integer) ->
                                /\dead -> tile)
                             (/\dead -> error {Tuple2 integer integer})
                             {all dead. dead})
                          (deleteFirst y))
                     (/\dead -> False)
                     {all dead. dead}))))
  10
  4