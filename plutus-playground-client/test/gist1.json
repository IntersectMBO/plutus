{
  "_gistTruncated": false,
  "_gistOwner": {
    "_ownerHtmlUrl": "https://github.com/krisajenkins",
    "_ownerLogin": "krisajenkins"
  },
  "_gistHtmlUrl": "https://gist.github.com/13799c35dd4d038bcd3982929f011ae3",
  "_gistFiles": [
    {
      "_gistFileTruncated": false,
      "_gistFileContent": "\n-- Crowdfunding contract implemented using the [[Plutus]] interface.\n-- This is the fully parallel version that collects all contributions\n-- in a single transaction.\n--\n-- Note [Transactions in the crowdfunding campaign] explains the structure of\n-- this contract on the blockchain.\n\nimport qualified Language.PlutusTx         as PlutusTx\nimport           Language.PlutusTx.Prelude\nimport           Ledger                    (Address, DataScript (DataScript), PendingTx, PubKey,\n                                            RedeemerScript (RedeemerScript), TxId, ValidatorScript (ValidatorScript),\n                                            applyScript, compileScript, hashTx, lifted, pendingTxValidRange,\n                                            scriptAddress, valueSpent)\nimport qualified Ledger.Interval           as Interval\nimport           Ledger.Slot               (Slot, SlotRange)\nimport qualified Ledger.Validation         as V\nimport           Ledger.Value              (Value)\nimport qualified Ledger.Value              as Value\nimport           Playground.Contract\nimport           Wallet                    (EventHandler (EventHandler), EventTrigger, MonadWallet, andT,\n                                            collectFromScript, collectFromScriptTxn, fundsAtAddressGeqT, logMsg,\n                                            ownPubKey, payToScript, register, slotRangeT)\nimport qualified Wallet                    as W\nimport           Wallet.Emulator           (Wallet)\nimport qualified Wallet.Emulator           as EM\n\n-- | A crowdfunding campaign.\ndata Campaign = Campaign\n    { campaignDeadline           :: Slot\n    -- ^ The date by which the campaign target has to be met\n    , campaignTarget             :: Value\n    -- ^ Target amount of funds\n    , campaignCollectionDeadline :: Slot\n    -- ^ The date by which the campaign owner has to collect the funds\n    , campaignOwner              :: PubKey\n    -- ^ Public key of the campaign owner. This key is entitled to retrieve the\n    --   funds if the campaign is successful.\n    } deriving (Generic, ToJSON, FromJSON, ToSchema)\n\nPlutusTx.makeLift ''Campaign\n\n-- | Construct a 'Campaign' value from the campaign parameters,\n--   using the wallet's public key.\nmkCampaign :: Slot -> Value -> Slot -> Wallet -> Campaign\nmkCampaign ddl target collectionDdl ownerWallet =\n    Campaign\n        { campaignDeadline = ddl\n        , campaignTarget   = target\n        , campaignCollectionDeadline = collectionDdl\n        , campaignOwner = EM.walletPubKey ownerWallet\n        }\n\n-- | The 'SlotRange' during which the funds can be collected\ncollectionRange :: Campaign -> SlotRange\ncollectionRange cmp =\n    W.interval (campaignDeadline cmp) (campaignCollectionDeadline cmp)\n\n-- | The 'SlotRange' during which a refund may be claimed\nrefundRange :: Campaign -> SlotRange\nrefundRange cmp =\n    W.intervalFrom (campaignCollectionDeadline cmp)\n\n-- | Action that can be taken by the participants in this contract. A value of\n--   `CampaignAction` is provided as the redeemer. The validator script then\n--   checks if the conditions for performing this action are met.\n--\ndata CampaignAction = Collect | Refund\n    deriving (Generic, ToJSON, FromJSON, ToSchema)\n\nPlutusTx.makeLift ''CampaignAction\n\n-- | The validator script is a function of three arguments:\n-- 1. A 'PubKey'. This is the data script. It is provided by the producing\n--    transaction (the contribution)\n--\n-- 2. A 'CampaignAction'. This is the redeemer script. It is provided by the\n--    redeeming transaction.\n--\n-- 3. A 'PendingTx value. It contains information about the current transaction\n--    and is provided by the slot leader.\n--    See note [PendingTx]\ntype CrowdfundingValidator = PubKey -> CampaignAction -> PendingTx -> Bool\n\nvalidRefund :: Campaign -> PubKey -> PendingTx -> Bool\nvalidRefund campaign contributor ptx =\n    -- Check that the transaction falls in the refund range of the campaign\n    Interval.contains (refundRange campaign) (pendingTxValidRange ptx)\n    -- Check that the transaction is signed by the contributor\n    && (ptx `V.txSignedBy` contributor)\n\nvalidCollection :: Campaign -> PendingTx -> Bool\nvalidCollection campaign p =\n    -- Check that the transaction falls in the collection range of the campaign\n    (collectionRange campaign `Interval.contains` pendingTxValidRange p)\n    -- Check that the transaction is trying to spend more money than the campaign\n    -- target (and hence the target was reached)\n    && (valueSpent p `Value.geq` campaignTarget campaign)\n    -- Check that the transaction is signed by the campaign owner\n    && (p `V.txSignedBy` campaignOwner campaign)\n\n-- | The validator script is of type 'CrowdfundingValidator', and is\n-- additionally parameterized by a 'Campaign' definition. This argument is\n-- provided by the Plutus client, using 'Ledger.applyScript'.\n-- As a result, the 'Campaign' definition is part of the script address,\n-- and different campaigns have different addresses. The Campaign{..} syntax\n-- means that all fields of the 'Campaign' value are in scope\n-- (for example 'campaignDeadline' in l. 70).\nmkValidator :: Campaign -> CrowdfundingValidator\nmkValidator c con act p = case act of\n    -- the \"refund\" branch\n    Refund -> validRefund c con p\n    -- the \"collection\" branch\n    Collect -> validCollection c p\n\n-- | The validator script that determines whether the campaign owner can\n--   retrieve the funds or the contributors can claim a refund.\n--\ncontributionScript :: Campaign -> ValidatorScript\ncontributionScript cmp  = ValidatorScript $\n    $$(Ledger.compileScript [|| mkValidator ||])\n        `Ledger.applyScript`\n            Ledger.lifted cmp\n\n-- | The address of a [[Campaign]]\ncampaignAddress :: Campaign -> Ledger.Address\ncampaignAddress = Ledger.scriptAddress . contributionScript\n\n-- | Contribute funds to the campaign (contributor)\n--\ncontribute :: MonadWallet m => Slot -> Value -> Slot -> Wallet -> Value -> m ()\ncontribute deadline target collectionDeadline ownerWallet value = do\n    let cmp = mkCampaign deadline target collectionDeadline ownerWallet\n    ownPK <- ownPubKey\n    let ds = DataScript (Ledger.lifted ownPK)\n        range = W.interval 1 (campaignDeadline cmp)\n\n    -- `payToScript` is a function of the wallet API. It takes a campaign\n    -- address, value, and data script, and generates a transaction that\n    -- pays the value to the script. `tx` is bound to this transaction. We need\n    -- to hold on to it because we are going to use it in the refund handler.\n    -- If we were not interested in the transaction produced by `payToScript`\n    -- we could have used `payeToScript_`, which has the same effect but\n    -- discards the result.\n    tx <- payToScript range (campaignAddress cmp) value ds\n\n    logMsg \"Submitted contribution\"\n\n    -- `register` adds a blockchain event handler on the `refundTrigger`\n    -- event. It instructs the wallet to start watching the addresses mentioned\n    -- in the trigger definition and run the handler when the refund condition\n    -- is true.\n    register (refundTrigger value cmp) (refundHandler (Ledger.hashTx tx) cmp)\n\n    logMsg \"Registered refund trigger\"\n\n-- | Register a [[EventHandler]] to collect all the funds of a campaign\n--\nscheduleCollection :: MonadWallet m => Slot -> Value -> Slot -> Wallet -> m ()\nscheduleCollection deadline target collectionDeadline ownerWallet = do\n    let cmp = mkCampaign deadline target collectionDeadline ownerWallet\n    register (collectFundsTrigger cmp) (EventHandler (\\_ -> do\n        logMsg \"Collecting funds\"\n        let redeemerScript = Ledger.RedeemerScript (Ledger.lifted Collect)\n            range = collectionRange cmp\n        collectFromScript range (contributionScript cmp) redeemerScript))\n\n-- | An event trigger that fires when a refund of campaign contributions\n-- can be claimed\nrefundTrigger :: Value -> Campaign -> EventTrigger\nrefundTrigger vl c = andT\n    (fundsAtAddressGeqT (campaignAddress c) vl)\n    (slotRangeT (refundRange c))\n\n-- | An event trigger that fires when the funds for a campaign can be collected\ncollectFundsTrigger :: Campaign -> EventTrigger\ncollectFundsTrigger c = andT\n    (fundsAtAddressGeqT (campaignAddress c) (campaignTarget c))\n    (slotRangeT (collectionRange c))\n\n-- | Claim a refund of our campaign contribution\nrefundHandler :: MonadWallet m => TxId -> Campaign -> EventHandler m\nrefundHandler txid cmp = EventHandler (\\_ -> do\n    logMsg \"Claiming refund\"\n    let validatorScript = contributionScript cmp\n        redeemerScript  = Ledger.RedeemerScript (Ledger.lifted Refund)\n\n    -- `collectFromScriptTxn` generates a transaction that spends the unspent\n    -- transaction outputs at the address of the validator scripts, *but* only\n    -- those outputs that were produced by the transaction `txid`. We use it\n    -- here to ensure that we don't attempt to claim back other contributors'\n    -- funds (if we did that, the validator script would fail and the entire\n    -- transaction would be invalid).\n    collectFromScriptTxn (refundRange cmp) validatorScript redeemerScript txid)\n\n$(mkFunctions ['scheduleCollection, 'contribute])\n$(mkIotsDefinitions ['scheduleCollection, 'contribute])\n\n{- note [Transactions in the crowdfunding campaign]\n\nAssume there is a campaign `c :: Campaign` with two contributors\n(identified by public key `pc_1` and `pc_2`) and one campaign owner (pco).\nEach contributor creates a transaction, `t_1` and `t_2`, whose outputs are\nlocked by the scripts `contributionScript c pc_1` and `contributionScript\nc pc_1` respectively.\n\nThere are two outcomes for the campaign.\n\n1. Campaign owner collects the funds from both contributors. In this case\n   the owner creates a single transaction with two inputs, referring to\n   `t_1` and `t_2`. Each input contains the script `contributionScript c`\n   specialised to a contributor. The redeemer script of this transaction\n   contains the value `Collect`, prompting the validator script to check the\n   branch for `Collect`.\n\n2. Refund. In this case each contributor creates a transaction with a\n   single input claiming back their part of the funds. This case is\n   covered by the `Refund` branch, and its redeemer script is the\n   `Refund` action.\n\nIn both cases, the validator script is run twice. In the first case\nthere is a single transaction consuming both inputs. In the second case there\nare two different transactions that may happen at different times.\n\n-}\n\n{- note [RecordWildCards]\n\nWe can use the syntax \"Campaign{..}\" here because the 'RecordWildCards'\nextension is enabled automatically by the Playground backend.\n\nThe extension is documented here:\n* https://downloads.haskell.org/~ghc/7.2.1/docs/html/users_guide/syntax-extns.html\n\nA list of extensions that are enabled by default for the Playground can be\nfound here:\n* https://github.com/input-output-hk/plutus/blob/b0f49a0cc657cd1a4eaa4af72a6d69996b16d07a/plutus-playground/plutus-playground-server/src/Playground/Interpreter.hs#L44\n\n-}\n\n{- note [PendingTx]\n\nThis part of the API (the PendingTx argument) is experimental and subject\nto change.\n\n-}\n\nmyCurrency :: KnownCurrency\nmyCurrency = KnownCurrency \"b0b0\" \"MyCurrency\" ( \"USDToken\" :| [\"EURToken\"])\n$(mkKnownCurrencies ['myCurrency])\n",
      "_gistFileLanguage": "Haskell",
      "_gistFileType": "text/plain",
      "_gistFileFilename": "Playground.hs"
    },
    {
      "_gistFileTruncated": false,
      "_gistFileContent": "[0,[{\"wallets\":[{\"simulatorWalletWallet\":{\"getWallet\":1},\"simulatorWalletBalance\":{\"getValue\":[[{\"unCurrencySymbol\":\"\"},[[{\"unTokenName\":\"\"},10]]],[{\"unCurrencySymbol\":\"b0b0\"},[[{\"unTokenName\":\"EURToken\"},10],[{\"unTokenName\":\"USDToken\"},10]]]]}},{\"simulatorWalletWallet\":{\"getWallet\":2},\"simulatorWalletBalance\":{\"getValue\":[[{\"unCurrencySymbol\":\"\"},[[{\"unTokenName\":\"\"},10]]],[{\"unCurrencySymbol\":\"b0b0\"},[[{\"unTokenName\":\"EURToken\"},10],[{\"unTokenName\":\"USDToken\"},10]]]]}}],\"signatures\":[{\"functionName\":\"scheduleCollection\",\"argumentSchema\":[{\"contents\":[[\"getSlot\",{\"tag\":\"FormSchemaInt\"}]],\"tag\":\"FormSchemaObject\"},{\"tag\":\"FormSchemaValue\"},{\"contents\":[[\"getSlot\",{\"tag\":\"FormSchemaInt\"}]],\"tag\":\"FormSchemaObject\"},{\"contents\":[[\"getWallet\",{\"tag\":\"FormSchemaInt\"}]],\"tag\":\"FormSchemaObject\"}]},{\"functionName\":\"contribute\",\"argumentSchema\":[{\"contents\":[[\"getSlot\",{\"tag\":\"FormSchemaInt\"}]],\"tag\":\"FormSchemaObject\"},{\"tag\":\"FormSchemaValue\"},{\"contents\":[[\"getSlot\",{\"tag\":\"FormSchemaInt\"}]],\"tag\":\"FormSchemaObject\"},{\"contents\":[[\"getWallet\",{\"tag\":\"FormSchemaInt\"}]],\"tag\":\"FormSchemaObject\"},{\"tag\":\"FormSchemaValue\"}]},{\"functionName\":\"payToWallet_\",\"argumentSchema\":[{\"tag\":\"FormSchemaValue\"},{\"contents\":[[\"getWallet\",{\"tag\":\"FormSchemaInt\"}]],\"tag\":\"FormSchemaObject\"}]}],\"currencies\":[{\"knownTokens\":[{\"unTokenName\":\"\"}],\"hash\":\"\",\"friendlyName\":\"Ada\"},{\"knownTokens\":[{\"unTokenName\":\"USDToken\"},{\"unTokenName\":\"EURToken\"}],\"hash\":\"b0b0\",\"friendlyName\":\"MyCurrency\"}],\"actions\":[]}]]",
      "_gistFileLanguage": "JSON",
      "_gistFileType": "application/json",
      "_gistFileFilename": "Simulation.json"
    }
  ],
  "_gistId": "13799c35dd4d038bcd3982929f011ae3",
  "_gistGitPushUrl": "https://gist.github.com/13799c35dd4d038bcd3982929f011ae3.git"
}
