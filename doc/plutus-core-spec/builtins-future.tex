\newcounter{notenumberC}
\renewcommand{\note}[1]{
  \bigskip
  \refstepcounter{notenumberC}
  \noindent\textbf{Note \thenotenumberC. #1}
}

\newpage

\section{Future Built-in Types and Functions}
\label{appendix:default-builtins-future}
A future release will add support for BLS12-381 elliptic curve pairing
operations.  This involves adding three new types and seventeen new built-in
functions.  The description of the semantics of these types and functions is
quite complex and requires a considerable amount of notation, most of which is
local to this section.

\subsection{Built-in types}
\label{sec:future-built-in-types}
Tables~\ref{table:future-built-in-types} describes three new built-in
types.

\newcommand{\MlResult}{H}
\newcommand{\Fq}{\mathbb{F}_q}
\newcommand{\Fqq}{\mathbb{F}_{q^2}}
\newcommand{\FF}{\mathbb{F}_{q^{12}}}

\begin{table}[H]
  \centering
    \begin{tabular}{|l|p{2cm}|l|}
        \hline
        Type & Denotation & Concrete Syntax\\
        \hline
        $\ty{bls12\_381\_G1\_element}$ &   $G_1$ & \texttt{0x[0-9A-Fa-f]\{96\}} \text{(see Note~\ref{note:bls-syntax})}\\
        $\ty{bls12\_381\_G2\_element}$ &   $G_2$ & \texttt{0x[0-9A-Fa-f]\{192\}} \text{(see Note~\ref{note:bls-syntax})}\\
        $\ty{bls12\_381\_MlResult}$    &   $\MlResult$  &  None (see Note~\ref{note:bls-syntax})\\
        \hline
    \end{tabular}
    \caption{Atomic Types}
    \label{table:future-built-in-types}
\end{table}


%% \paragraph{$G_1$ and $G_2$}.
\noindent $G_1$ and  $G_2$ are both cyclic groups of prime order $r$, where 
$$
r = \mathtt{0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001}
$$


\noindent The groups are all defined in terms of the finite field $\Fq$ where
\begin{align*}
q = \mathtt{0x}&\mathtt{1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf}\\
              &\mathtt{6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab}\\
\end{align*}

\noindent which is a 381-bit prime. The field $\Fq$ is isomorphic to $\Z_q$, the ring of
integers modulo $q$, and hence there is a natural epimorphism
$\pi:\Z \rightarrow \Fq$.  Given $x \in \Fq$, we denote by $\tilde{x}$ the
smallest non-negative integer $n$ with $\pi(n) = x$ and we will write the
integer $\tilde{x}$ to represent an element $x \in \Fq$.  We also make use of
the field $\Fqq = \Fq[x]/(x^2+1)$; we may regard $\Fqq$ as the set $\{a+bu:
a,b \in \Fq\}$ where $u^2=-1$.

\medskip\noindent There are elliptic curves $E_1$ defined over $\Fq$,

$$
E_1: y^2 = x^3 + 4
$$

\noindent and $E_2$ defined over $\Fqq$:
$$
E_2: y^2 = x^3 + 4(u+1)
$$


\red{ORDERING}
\medskip

\noindent $E_1(\Fq)$ and  $E_2(\Fqq)$  are abelian groups under the
usual elliptic curve addition operations as described
in~\cite[III.2]{Silverman-Arithmetic-EC} or~\cite[2.1]{Costello-pairings}.
$G_1$ is a subgroup of $E_1(\Fq)$ and $G_2$ is a subgroup of $E_2(\Fqq)$;
explicit generators for $G_1$ and $G_2$ are given
in~\cite[4.2.1]{IETF-pairing-friendly-curves}.  We denote the identity element
(the point at infinity) in $G_1$ by $\mathcal{O}_{G_1}$ and that in $G_2$ by
$\mathcal{O}_{G_2}$.

\bigskip
\noindent Values of the \texttt{bls12\_381\_MlResult} type are completely
opaque and can only be obtained as a result of \texttt{millerLoop} or by
multiplying two existing elements of type \texttt{bls12\_381\_MlResult}.  We
provide neither a serialisation format nor a concrete syntax for values of this
type: they exist only ephemerally during computation.  We do not
specify $\MlResult$, the denotation of \texttt{bls12\_381\_MlResult}, precisely,
but it must be an abelian group. See Note~\ref{note:pairing} for more on this.

\subsection{Built-in functions}
\label{sec:future-built-in-functions}

\newcommand{\hash}{\mathsf{hash}}
\newcommand{\compress}{\mathsf{compress}}
\newcommand{\uncompress}{\mathsf{uncompress}}

\setlength{\LTleft}{-18mm} % Shift the table left a bit to centre it on the page
\begin{longtable}[H]{|l|p{5cm}|p{5cm}|c|c|}
    \hline \text{Function} & \text{Signature} & \text{Denotation} & \text{Can}
    & \text{Note} \\ & & & Fail?
    & \\ \hline \endfirsthead \hline \text{Function} & \text{Type}
    & \text{Denotation} & \text{Can} & \text{Note}\\ & & & Fail?
    & \\ \hline \endhead \hline \caption{Built-in Functions}
    % This caption goes on every page of the table except the last.  Ideally it
    % would appear only on the first page and all the rest would say
    % (continued). Unfortunately it doesn't seem to be easy to do that in a
    % longtable.
    \endfoot
    \caption[]{Built-in Functions (continued)}
    \label{table:future-built-in-functions}
    \endlastfoot
%% G1
    \TT{bls12\_381\_G1\_add}  &
    $[ \ty{bls12\_381\_G1\_element}$,
      \text{\; $\ty{bls12\_381\_G1\_element} ]$}
      \text{\: $ \to \ty{bls12\_381\_G1\_element}$} & Group addition &  No & \\
    \TT{bls12\_381\_G1\_neg}  &
      $ [ \ty{bls12\_381\_G1\_element} ]$  \text{\;\; $\to \ty{bls12\_381\_G1\_element}$} & Group inverse  & No & \\
    \TT{bls12\_381\_G1\_scalarMul}  &
    $[ \ty{integer}$,
      \text{\; $\ty{bls12\_381\_G1\_element} ]$}
      \text{\: $ \to \ty{bls12\_381\_G1\_element}$} & $(n,a) \mapsto na$ &  No & \\
    \TT{bls12\_381\_G1\_equal}  &
    $[ \ty{bls12\_381\_G1\_element}$,
      \text{\; $\ty{bls12\_381\_G1\_element} ]$}
      \text{\: $ \to \ty{bool}$} & $=$ &  No & \\
    \TT{bls12\_381\_G1\_hashToGroup}  &
    $[ \ty{bytestring}, \ty{bytestring}]$
      \text{\: $ \to \ty{bls12\_381\_G1\_element}$} & $\hash_{G_1}$ &  Yes & \ref{note:hashing-into-group}\\
    \TT{bls12\_381\_G1\_compress}  &
    $[\ty{bls12\_381\_G1\_element}]$
      \text{\: $ \to \ty{bytestring}$} & $\compress_{G_1}$  &  No & \ref{note:group-compression}\\
    \TT{bls12\_381\_G1\_uncompress}  &
    $[ \ty{bytestring}]$
      \text{\: $ \to \ty{bls12\_381\_G1\_element}$} & $\uncompress_{G_1}$  &  Yes & \ref{note:group-compression}\\
    \hline 
%% G2
    \TT{bls12\_381\_G2\_add}  &
    $[ \ty{bls12\_381\_G2\_element}$,
      \text{\; $\ty{bls12\_381\_G2\_element} ]$}
      \text{\: $ \to \ty{bls12\_381\_G2\_element}$} & $(a,b) \mapsto a+b$ &  No & \\
    \TT{bls12\_381\_G2\_neg}  &
      $ [ \ty{bls12\_381\_G2\_element} ]$  \text{\;\; $\to \ty{bls12\_381\_G2\_element}$} & $a \mapsto -a$  & No & \\
    \TT{bls12\_381\_G2\_scalarMul}  &
    $[ \ty{integer}$,
      \text{\; $\ty{bls12\_381\_G2\_element} ]$}
      \text{\: $ \to \ty{bls12\_381\_G2\_element}$} & $(n,a) \mapsto na$ &  No & \\
    \TT{bls12\_381\_G2\_equal}  &
    $[ \ty{bls12\_381\_G2\_element}$,
      \text{\; $\ty{bls12\_381\_G2\_element} ]$}
      \text{\: $ \to \ty{bool}$} & $=$ &  No & \\
    \TT{bls12\_381\_G2\_hashToGroup}  &
    $[ \ty{bytestring}, \ty{bytestring}]$
      \text{\: $ \to \ty{bls12\_381\_G2\_element}$} & $\hash_{G_2}$  &  Yes & \ref{note:hashing-into-group}\\
    \TT{bls12\_381\_G2\_compress}  &
    $[\ty{bls12\_381\_G2\_element}]$
      \text{\: $ \to \ty{bytestring}$} & $\compress_{G_2}$  &  No & \ref{note:group-compression}\\
    \TT{bls12\_381\_G2\_uncompress}  &
    $[ \ty{bytestring}]$
      \text{\: $ \to \ty{bls12\_381\_G2\_element}$} & $\uncompress_{G_2}$  &  Yes & \ref{note:group-compression}\\
    \hline 
    \TT{bls12\_381\_millerLoop}  &
    $[ \ty{bls12\_381\_G1\_element}$,
      \text{\; $\ty{bls12\_381\_G2\_element} ]$}
    \text{\: $ \to \ty{\MlResult}$} & $e$ &  No & \ref{note:pairing}\\
    \TT{bls12\_381\_mulMlResult}  &
    $[ \ty{\MlResult}, \ty{\MlResult}] \to \ty{\MlResult}$ & Group multiplication & No & \ref{note:pairing}\\
    \TT{bls12\_381\_finalVerify}  &
    $[ \ty{\MlResult}, \ty{\MlResult}] \to \ty{bool}$ & $\phi$ & No & \ref{note:pairing}\\
    \hline
\end{longtable}

\note{Hashing into $G_1$ and $G_2$.}
\label{note:hashing-into-group}

The denotations $\hash_{G_1}$ and $\hash_{G_2}$
of \texttt{bls12\_381\_G1\_hashToGroup} and
\texttt{bls12\_381\_G2\_hashToGroup} both take an arbitrary bytestring $b$ (the
\textit{message}) and a (possibly empty) bytestring of length at most 255 known as a \textit{domain
separation tag} (DST)~\cite[2.2.5]{IETF-hash-to-curve} and hash them to obtain a
point in $G_1$ or $G_2$ respectively.  The details of the hashing process are
described in~\cite{IETF-hash-to-curve} (see specifically Section 8.8), except
that
\textbf{we do not support DSTs of length greater than 255}: an attempt to use a
longer DST directly will cause an error.  If a longer DST is required then it
should be hashed to obtain a short DST as described
in~\cite[5.3.3]{IETF-hash-to-curve}, and then this should be supplied as the
second argument to the appropriate \texttt{hashToGroup} function.  Some hashing
implementations also allow a third argument (an ``augmentation string''), but we
do not support this since the same effect can be obtained by appending
(prepending?) the augmentation string to the message before hashing.

\note{Compression and uncompression for group elements.} 
\label{note:group-compression}
Points in $G_1$ and $G_2$ are encoded as bytestrings in a ``compressed'' format
where only the $x$-coordinate of a point is encoded and some metadata is used to
indicate which of two possible $y$-coordinates the point has.  The encoding
format is based on the Zcash encoding for BLS12-381 points:
see~\cite{Zcash-serialisation} or~\cite[``Serialization'']{blst-library}.  In
detail,
\begin{itemize}

\item Given an element $x$ of $\Fq$, $\tilde{x}$ can be written as a 381-bit
binary number: $\tilde{x} = \sum_{i=0}^{380}b_i2^i$ with $b_i \in \{0,1\}$.  We
define $\mathsf{bits}(x)$ to be the string $b_{380}\cdots b_0$.

\item A nonzero element of $G_1$ can be written in the form $(x,y)$ with $x,y\in\Fq$,
and for every valid $x$ coordinate there are in fact two valid $y$ coordinates.

\item For $a = (x,y) \in G_1\backslash \mathcal{O}$ we define
$$
\compress_{G_1} (x,y) = \begin{cases}
\mathsf{1}\mathsf{0}\mathsf{1}\cdot\mathsf{bits}(x) & \text{if $y$ is the larger of the two possible $y$-coordinates}\\
\mathsf{1}\mathsf{0}\mathsf{0}\cdot\mathsf{bits}(x) & \text{otherwise}\\
\end{cases}
$$
\item We encode the identity element of $G_1$ using
$$
\compress{G_1}(\mathcal{O}_{G_1}) = \mathsf{1}\mathsf{1}\mathsf{0}\cdot\mathsf{0}^{381},
$$
\noindent where $\mathsf{0}^{381}$ denotes a string of 381 $\mathsf{0}$ bits.
Thus in all cases the encoding of an element of $G_1$ requires exactly 384 bits,
or 48 bytes.

Similarly, every non-identity element of $G_2$ can be written
in the form $(x,y)$ with $x,y \in \Fqq$.

$$
\compress_{G_2} (a+bu,y) = \begin{cases}
\mathsf{1}\mathsf{0}\mathsf{1}\cdot\mathsf{bits}(b)\cdot\mathsf{0}\mathsf{0}\mathsf{0}\cdot\mathsf{bits}(a)
& \text{if $y$ is the larger!!! of the two possible $y$-coordinates}\\
\mathsf{1}\mathsf{0}\mathsf{0}\cdot\mathsf{bits}(b)\cdot\mathsf{0}\mathsf{0}\mathsf{0}\cdot\mathsf{bits}(a) &
 \text{otherwise}\\
\end{cases}
$$
and
$$
\compress_{G_2}(\mathcal{O}_{G_2}) = \mathsf{1}\mathsf{1}\mathsf{0}\cdot\mathsf{0}^{765},
$$
The encoding of an element of $G_2$ requires exactly 768 bits, or 96 bytes.
\end{itemize}

Note that in both cases the most significant bit of a compressed point is 1.
In the Zcash serialisation scheme this indicates that the point is compressed;
Zcash also supports a serialisation format where both the $x$ and $y$
coordinates of a point are encoded, and in that case the leading bit of the
encoded point is 0.  We do not support this format.


The two $\uncompress$ functions are obtained by inverting the process above.

\paragraph{$G_1$ uncompression.}  Given a bytestring $b$, it is checked that
$b$ contains exactly 48 bytes.  If not $\uncompress(b) = \errorX$ (ie,
uncompression fails).  If the length is equal to 48 bytes, write $b$ as a
sequence of bits: $b = b_{383} \cdots b_0$.
\begin{itemize}
\item If $b_{383} \neq 1$, then $\uncompress_{G_1}(b) = \errorX$.
\item If $b_{382} = 1$ then $\uncompress_{G_1}(b) =
\begin{cases}
\mathcal{O}_{G_1} & \text{if $b_{381} = b_{380} = \cdots = b_0 = 0$}\\
\errorX & \text{otherwise}.
\end{cases}$
\item If $b_{382}=0$, set $c=\sum_{i=0}^{381}b_i2^i \in \N$.
\begin{itemize}
\item If $c \geq q$, $\uncompress_{G_1}(b) = \errorX$.
\item Otherwise, let $x = \pi(c) \in \Fq$ and let $z = x^3+4$. If $z$ is not a square in $\Fq$, $\uncompress_{G_1}(b) = \errorX$.
\item If $x$ is a square then let $y$ be the larger or smaller square root of $z$ according to
whether $b_{381}$ is 0 or 1 (so $(x,y)$ lies on the curve $E_1$).
\item Then $\uncompress_{G_1}(b) = \begin{cases}
(x,y) & \text{if $(x,y) \in G_1$}\\
\errorX & \text{otherwise}.
\end{cases}$
\end{itemize}
\end{itemize}


\paragraph{$G_2$ uncompression.}  Given a bytestring $b$, it is checked that
$b$ contains exactly 96 bytes.  If not $\uncompress(b) = \errorX$ (ie,
uncompression fails).  If the length is equal to 96 bytes, write $b$ as a
sequence of bits: $b = b_{767} \cdots b_0$.
\begin{itemize}
\item If $b_{767} \neq 1$, then $\uncompress_{G_2}(b) = \errorX$.
\item If $b_{766} = 1$ then $\uncompress_{G_2}(b) =
\begin{cases}
\mathcal{O}_{G_1} & \text{if $b_{765} = b_{764} = \cdots = b_0 = 0$}\\
\errorX & \text{otherwise}.
\end{cases}$
\item If $b_{766} = 0$, set $c=\sum_{i=0}^{383}b_i2^i$ and $d=\sum_{i=384}^{765}b_i2^{i-384} \in \N$.
\begin{itemize}
\item If $c \geq q$ or $d \geq q$, $\uncompress_{G_2}(b) = \errorX$.
\item Otherwise, let $x = \pi(c)+\pi(d)u \in \Fqq$ and let $z = x^3+4(u+1)$.
If $z$ is not a square in $\Fqq$, $\uncompress_{G_2}(b) = \errorX$.
\item If $x$ is a square then let $y$ be the larger or smaller square root of $z$ according to
whether $b_{765}$ is 0 or 1 (so $(x,y)$ lies on the curve $E_2$).
\item Then $\uncompress_{G_s}(b) = \begin{cases}
(x,y) & \text{if $(x,y) \in G_2$}\\
\errorX & \text{otherwise}.
\end{cases}$
\end{itemize}
\end{itemize}


For $G_1$ a 48-byte bytestring $b$ is expected. If every bit of $b$ is zero
apart from the second most significant then $\uncompress_{G_1}(b)
= \mathcal{O}_{G_1}$.  Otherwise, it is checked that the first bit is set and
the second bit is clear, and then the final 381 bits are converted into an
element $x\in\Fq$ (assuming that they represent an integer less than $q$ and it
is checked whether $x^3+4$ has a square root in $\Fq$; if so then a point
$p=(x,y) \in E_1(\Fq)$ is obtained, where $y$ is the larger square root of
$x^3+4$ if the second bit of $b$ is set and the smaller square root otherwise.
It is then checked whether $p$ lies in the subgroup $G_1$ and if so we have
$\uncompress_{G_1}(b)=p$.

\medskip
\noindent The $\uncompress_{G_2}$ function is defined similarly. There are 3 spare bits
between the two components of the $\Fqq$ element and these must be equal to zero.

\medskip\noindent The uncompression process can fail in a number of ways:
\begin{itemize}
\item The encoding is malformed in some way; for example it has the wrong length or it does
not obey the conditions described above.
\item The encoded field element is not a square, so there is no point on the curve with that $x$-coordinate.
\item The encoded element is a square,  so that there is a point on the curve with that $x$ coordinate,
but the point does not lie in the relevant group.
\end{itemize}

\note{Concrete syntax for BLS12-381 types.}
\label{note:bls-syntax}
Concrete syntax for the $\ty{bls12\_381\_G1\_element}$ and
$\ty{bls12\_381\_G2\_element}$ types is provided via the compression and
decompression functions defined in Note~\ref{note:group-compression}.  Specifically, a
value of type $\ty{bls12\_381\_G1\_element}$ is denoted by a term of the
form \texttt{(con bls12\_381\_G1\_element 0x...)} where \texttt{...} consists of
96 hexadecimal digits representing the 48-byte compressed form of the relevant
point.  Similarly, a value of type $\ty{bls12\_381\_G2\_element}$ is denoted by
a term of the form \texttt{(con bls12\_381\_G2\_element 0x...)}
where \texttt{...} consists of 192 hexadecimal digits representing the 96-byte
compressed form of the relevant point.

No syntax is provided for values of type $\ty{bls12\_381\_mlresult}$. It is not
possible to parse such values, and they will appear as \texttt{(con
bls12\_381\_mlresult <opaque>)} if output by a program.


\note{Pairing operations.}
\label{note:pairing}
For efficiency reasons we split the pairing process into two parts:
the \texttt{millerLoop} and \texttt{finalVerify} functions.  We assume that we
have
\begin{itemize}
\item An intermediate multiplicative abelian group $\MlResult$;
$\denote{\mathtt{bls12\_381\_mulMlResult}}$
is the group multiplication operation in $\MlResult$.
\item A function (not necessarily itself a pairing) $e: G_1 \times
G_2 \rightarrow \MlResult$.
\item A cyclic group $\mu_r$ of order $r$.
\item An epimorphism $\psi: \MlResult \rightarrow \mu_r$ of groups such
that $\psi \circ e: G_1 \times G_2 \rightarrow \mu_r$ is a (nondegenerate,
bilinear) pairing.
\end{itemize}

\noindent We then define $\denote{\mathtt{millerLoop}} = e$ and
$\denote{\mathtt{finalVerify}} = \phi$, where
$$
\phi(a,b) = \begin{cases}
               \mathtt{true} & \text{if $\psi(ab^{-1}) = 1_{\mu_r}$} \\
               \mathtt{false} & \text{otherwise.}
            \end{cases}
$$
We do not mandate specific choices for $\MlResult, \mu_r, e$, and $\phi$, but a
plausible choice would be
\begin{itemize}
\item $\MlResult = \FF^*$
\item $e$ is the Miller loop associated with the optimal Ate pairing
for $E_1$ and $E_2$~\cite{Vercauteren}.
\item $\mu_r = \{x \in \FF^*: x^r=1\}$, the group of $r$th roots of unity in $\FF^*$.
(There are $r$ distinct $r$th roots of unity in $\FF^*$ because the embedding
degree of $E_1$ and $E_2$ with respect to $r$ is 12 (see~\cite[4.1]{Costello-pairings}).
\item $\psi(x) = x^{\frac{q-1}{r}}$.
\end{itemize}

\noindent The functions \texttt{millerLoop} and (especially) \texttt{finalVerify} are expected
to be very expensive, so their use should be kept to a minimum.  Fortunately
most current use cases do not require many uses of these functions.

%% \setlength{\LTleft}{-18mm} % Shift the table left a bit to centre it on the page
%% \begin{longtable}[H]{|l|p{5cm}|p{5cm}|c|c|}
%%     \hline
%%     \text{Function} & \text{Signature} & \text{Denotation} & \text{Can} & \text{Note} \\
%%     & & & Fail? & \\
%%     \hline
%%     \endfirsthead
%%     \hline
%%     \text{Function} & \text{Type} & \text{Denotation} & \text{Can} & \text{Note}\\
%%     & & & Fail? & \\
%%     \hline
%%     \endhead
%%     \hline
%%     \caption{Built-in Functions}
%%     % This caption goes on every page of the table except the last.  Ideally it
%%     % would appear only on the first page and all the rest would say
%%     % (continued). Unfortunately it doesn't seem to be easy to do that in a
%%     % longtable.
%%     \endfoot
%%     \caption[]{Future Built-in  Functions (continued)}
%%     \label{table:future-built-in-functions}
%%     \endlastfoot
%%     \TT{addInteger}               & $[\ty{integer}, \ty{integer}] \to \ty{integer}$   & $+$ &  & \\
%%     \TT{bls12\_381\_G1\_add}     & $[ \ty{bls12\_381\_G1\_element}, \ty{bls12\_381\_G1\_element} ] \to \ty{bls12\_381\_G1\_element}$ & x& y & x \\
%%     \TT{bls12\_381\_G1\_neg}     & $ [ \ty{bls12\_381\_G1\_element} ] \to \ty{bls12\_381\_G1\_element}$ & x & y & z
%%     \hline 
%% \end{longtable}

%% bls12\_381\_G1\_add                : [ bls12\_381\_G1\_element, bls12\_381\_G1\_element ] -> bls12\_381\_G1\_element
%% bls12\_381\_G1\_neg                : [ bls12\_381\_G1\_element ] -> bls12\_381\_G1\_element
%% bls12\_381\_G1\_scalarMul          : [ integer, bls12\_381\_G1\_element ] -> bls12\_381\_G1\_element
%% bls12\_381\_G1\_equal              : [ bls12\_381\_G1\_element, bls12\_381\_G1\_element ] -> bool
%% bls12\_381\_G1\_hashToGroup        : [ bytestring ] -> bls12\_381\_G1\_element
%% bls12\_381\_G1\_compress           : [ bls12\_381\_G1\_element ] -> bytestring
%% bls12\_381\_G1\_uncompress         : [ bytestring ] -> bls12\_381\_G1\_element
%% bls12\_381\_G2\_add                : [ bls12\_381\_G2\_element, bls12\_381\_G2\_element ] -> bls12\_381\_G2\_element
%% bls12\_381\_G2\_neg                : [ bls12\_381\_G2\_element ] -> bls12\_381\_G2\_element
%% bls12\_381\_G2\_scalarMul          : [ integer, bls12\_381\_G2\_element ] -> bls12\_381\_G2\_element
%% bls12\_381\_G2\_equal              : [ bls12\_381\_G2\_element, bls12\_381\_G2\_element ] -> bool
%% bls12\_381\_G2\_hashToGroup        : [ bytestring ] -> bls12\_381\_G2\_element
%% bls12\_381\_G2\_compress           : [ bls12\_381\_G2\_element ] -> bytestring
%% bls12\_381\_G2\_uncompress         : [ bytestring ] -> bls12\_381\_G2\_element
%% bls12\_381\_millerLoop            : [ bls12\_381\_G1\_element, bls12\_381\_G2\_element ] -> bls12\_381\_mlresult
%% bls12\_381\_mulMlResult           : [ bls12\_381\_mlresult, bls12\_381\_mlresult ] -> bls12\_381\_mlresult
%% bls12\_381\_finalVerify           : [ bls12\_381\_mlresult, bls12\_381\_mlresult ] -> bool


