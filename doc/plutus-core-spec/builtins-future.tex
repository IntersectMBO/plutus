\newcounter{notenumberC}
\renewcommand{\note}[1]{
  \bigskip
  \refstepcounter{notenumberC}
  \noindent\textbf{Note \thenotenumberC. #1}
}

\newpage

\section{Future Built-in Types and Functions}
\label{appendix:default-builtins-future}
A future release will add support for BLS12-381 elliptic curve pairing
operations.  This involves adding three new types and seventeen new built-in
functions.

\subsection{Built-in types}
\label{sec:future-built-in-types}
Tables~\ref{table:future-built-in-types} describes three new built-in
types.

\newcommand{\MlResult}{R}
\newcommand{\Fq}{\mathbb{F}_q}
\newcommand{\Fqq}{\mathbb{F}_{q^2}}
\newcommand{\FF}{\mathbb{F}_{q^{12}}}

\begin{table}[H]
  \centering
    \begin{tabular}{|l|p{2cm}|l|}
        \hline
        Type & Denotation & Concrete Syntax\\
        \hline
        $\ty{bls12\_381\_G1\_element}$ &   $G_1$ & \texttt{0x[0-9A-Fa-f]\{48\}}\\
        $\ty{bls12\_381\_G2\_element}$ &   $G_2$ & \texttt{0x[0-9A-Fa-f]\{96\}}\\
        $\ty{bls12\_381\_MlResult}$    &   $\MlResult$  &  None\\
        \hline
    \end{tabular}
    \caption{Atomic Types}
    \label{table:future-built-in-types}
\end{table}


\noindent $G_1$ and  $G_2$ are both cyclic groups of prime order $r$, where 
$$
r = \mathtt{0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001}
$$


\noindent The groups are all defined in terms of the finite field $\Fq$ where
\begin{align*}
q = \mathtt{0x}&\mathtt{1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf}\\
              &\mathtt{6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab}\\
\end{align*}

\noindent which is a 381-bit prime. The field $\Fq$ is isomorphic to $\Z_q$, the ring of
integers modulo $q$, and hence there is a natural epimorphism
$\pi:\Z \rightarrow \Fq$.  Given $x \in \Fq$, we denote by $\tilde{x}$ the
smallest non-negative integer $n$ with $\pi(n) = x$ and we will write the
integer $\tilde{x}$ to represent an element $x \in \Fq$.  We also make use of
the field $\Fqq = \Fq[x]/(x^2+1)$; we may regard $\Fqq$ as the set $\{a+bu:
a,b \in \Fq\}$ where $u^2=-1$.

\medskip\noindent There are elliptic curves $E_1$ defined over $\Fq$,

$$
E_1: y^2 = x^3 + 4
$$

\noindent and $E_2$ defined over $\Fqq$:
$$
E_2: y^2 = x^3 + 4(u+1)
$$

\noindent $E_1(\Fq)$ and  $E_2(\Fqq)$  are abelian groups under the
usual elliptic curve addition operations as described
in~\cite[III.2]{Silverman-Arithmetic-EC}.  $G_1$ is a subgroup of $E_1(\Fq)$ and
$G_2$ is a subgroup of $E_2(\Fqq)$; explicit generators for $G_1$ and $G_2$ are
given in~\cite[4.2.1]{IETF-pairing-friendly-curves}.  We denote the identity
element (the point at infinity) in $G_1$ by $\mathcal{O}_{G_1}$ and
that in $G_2$ by $\mathcal{O}_{G_2}$.

\bigskip
\noindent Values of the \texttt{bls12\_381\_MlResult} type are completely
opaque and can only be obtained as a result of \texttt{millerLoop} or by
multiplying two existing elements of type \texttt{bls12\_381\_MlResult}.  We
provide neither a serialisation format nor a concrete syntax for values of type:
such elements exist only ephemerally during computation.  We do not specify
$\MlResult$, the denotation of \texttt{bls12\_381\_MlResult}, precisely: our
only assumption is that it is an Abelian group. See Note~\ref{note:pairing} for
more on this.

\subsection{Built-in functions}
\label{sec:future-built-in-functions}

\newcommand{\hash}{\mathsf{hash}}
\newcommand{\compress}{\mathsf{compress}}
\newcommand{\uncompress}{\mathsf{uncompress}}

\setlength{\LTleft}{-18mm} % Shift the table left a bit to centre it on the page
\begin{longtable}[H]{|l|p{5cm}|p{5cm}|c|c|}
    \hline \text{Function} & \text{Signature} & \text{Denotation} & \text{Can}
    & \text{Note} \\ & & & Fail?
    & \\ \hline \endfirsthead \hline \text{Function} & \text{Type}
    & \text{Denotation} & \text{Can} & \text{Note}\\ & & & Fail?
    & \\ \hline \endhead \hline \caption{Built-in Functions}
    % This caption goes on every page of the table except the last.  Ideally it
    % would appear only on the first page and all the rest would say
    % (continued). Unfortunately it doesn't seem to be easy to do that in a
    % longtable.
    \endfoot
    \caption[]{Built-in Functions (continued)}
    \label{table:future-built-in-functions}
    \endlastfoot
%% G1
    \TT{bls12\_381\_G1\_add}  &
    $[ \ty{bls12\_381\_G1\_element}$,
      \text{\; $\ty{bls12\_381\_G1\_element} ]$}
      \text{\: $ \to \ty{bls12\_381\_G1\_element}$} & Group addition &  No & \\
    \TT{bls12\_381\_G1\_neg}  &
      $ [ \ty{bls12\_381\_G1\_element} ]$  \text{\;\; $\to \ty{bls12\_381\_G1\_element}$} & Group inverse  & No & \\
    \TT{bls12\_381\_G1\_scalarMul}  &
    $[ \ty{integer}$,
      \text{\; $\ty{bls12\_381\_G1\_element} ]$}
      \text{\: $ \to \ty{bls12\_381\_G1\_element}$} & $(n,a) \mapsto na$ &  No & \\
    \TT{bls12\_381\_G1\_equal}  &
    $[ \ty{bls12\_381\_G1\_element}$,
      \text{\; $\ty{bls12\_381\_G1\_element} ]$}
      \text{\: $ \to \ty{bool}$} & $=$ &  No & \\
    \TT{bls12\_381\_G1\_hashToGroup}  &
    $[ \ty{bytestring}, \ty{bytestring}]$
      \text{\: $ \to \ty{bls12\_381\_G1\_element}$} & $\hash_{G_1}$ &  Yes & \ref{note:hashing-into-group}\\
    \TT{bls12\_381\_G1\_compress}  &
    $[\ty{bls12\_381\_G1\_element}]$
      \text{\: $ \to \ty{bytestring}$} & $\compress_{G_1}$  &  No & \ref{note:group-compression}\\
    \TT{bls12\_381\_G1\_uncompress}  &
    $[ \ty{bytestring}]$
      \text{\: $ \to \ty{bls12\_381\_G1\_element}$} & $\uncompress_{G_1}$  &  Yes & \ref{note:group-compression}\\
    \hline 
%% G2
    \TT{bls12\_381\_G2\_add}  &
    $[ \ty{bls12\_381\_G2\_element}$,
      \text{\; $\ty{bls12\_381\_G2\_element} ]$}
      \text{\: $ \to \ty{bls12\_381\_G2\_element}$} & $(a,b) \mapsto a+b$ &  No & \\
    \TT{bls12\_381\_G2\_neg}  &
      $ [ \ty{bls12\_381\_G2\_element} ]$  \text{\;\; $\to \ty{bls12\_381\_G2\_element}$} & $a \mapsto -a$  & No & \\
    \TT{bls12\_381\_G2\_scalarMul}  &
    $[ \ty{integer}$,
      \text{\; $\ty{bls12\_381\_G2\_element} ]$}
      \text{\: $ \to \ty{bls12\_381\_G2\_element}$} & $(n,a) \mapsto na$ &  No & \\
    \TT{bls12\_381\_G2\_equal}  &
    $[ \ty{bls12\_381\_G2\_element}$,
      \text{\; $\ty{bls12\_381\_G2\_element} ]$}
      \text{\: $ \to \ty{bool}$} & $=$ &  No & \\
    \TT{bls12\_381\_G2\_hashToGroup}  &
    $[ \ty{bytestring}, \ty{bytestring}]$
      \text{\: $ \to \ty{bls12\_381\_G2\_element}$} & $\hash_{G_2}$  &  Yes & \ref{note:hashing-into-group}\\
    \TT{bls12\_381\_G2\_compress}  &
    $[\ty{bls12\_381\_G2\_element}]$
      \text{\: $ \to \ty{bytestring}$} & $\compress_{G_2}$  &  No & \ref{note:group-compression}\\
    \TT{bls12\_381\_G2\_uncompress}  &
    $[ \ty{bytestring}]$
      \text{\: $ \to \ty{bls12\_381\_G2\_element}$} & $\uncompress_{G_2}$  &  Yes & \ref{note:group-compression}\\
    \hline 
    \TT{bls12\_381\_millerLoop}  &
    $[ \ty{bls12\_381\_G1\_element}$,
      \text{\; $\ty{bls12\_381\_G2\_element} ]$}
    \text{\: $ \to \ty{\MlResult}$} & $e$ &  No & \ref{note:pairing}\\
    \TT{bls12\_381\_mulMlResult}  &
    $[ \ty{\MlResult}, \ty{\MlResult}] \to \ty{\MlResult}$ & Group multiplication & No & \ref{note:pairing}\\
    \TT{bls12\_381\_finalVerify}  &
    $[ \ty{\MlResult}, \ty{\MlResult}] \to \ty{bool}$ & $\phi$ & No & \ref{note:pairing}\\
    \hline
\end{longtable}

\note{Hashing into $G_1$ and $G_2$}
\label{note:hashing-into-group}

The denotations $\hash_{G_1}$ and $\hash_{G_2}$
of \texttt{bls12\_381\_G1\_hashToGroup} and
\texttt{bls12\_381\_G2\_hashToGroup} both take an arbitrary bytestring $b$ (the
\textit{message}) and a (possibly empty) bytestring of length at most 255 known as a \textit{domain
separation tag} (DST)~\cite[2.2.5]{IETF-hash-to-curve} and hash them to obtain a
point in $G_1$ or $G_2$ respectively.  The details of the hashing process are
described in~\cite{IETF-hash-to-curve} (see specifically Section 8.8), except
that
\textbf{we do not support DSTs of length greater than 255}: an attempt to use a
longer DST directly will cause an error.  If a longer DST is required then it
should be hashed to obtain a short DST as described
in~\cite[5.3.3]{IETF-hash-to-curve}, and then this should be supplied as the
second argument to the appropriate \texttt{hashToGroup} function.  Some hashing
implementations also allow a third argument (an ``augmentation string''), but we
do not support this since the same effect can be obtained by appending
(prepending?) the augmentation string to the message before hashing.

\note{Compression and uncompression for group elements} 
\label{note:group-compression}
Points in $G_1$ and $G_2$ are encoded as bytestrings in a ``compressed'' format
where only the $x$-coordinate of a point is encoded and some metadata is used to
indicate which of two possible $y$-coordinates the point has.  The encoding
format is based on the Zcash encoding for BLS12-381 points:
see~\cite{Zcash-serialisation} or~\cite[``Serialization'']{blst-library}.  In
detail,
\begin{itemize}

\item Given an element $x$ of $\Fq$, $\tilde{x}$ can be written as a 381-bit
binary number: $\tilde{x} = \Sigma_{i=0}^{380}b_i2^i$ with $b_i \in \{0,1\}$.  We
define $\mathsf{bits}(x)$ to be the string $b_{380}\cdots b_0$.

\item A nonzero element of $G_1$ can be written in the form $(x,y)$ with $x,y\in\Fq$,
and for every valid $x$ coordinate there are in fact two valid $y$ coordinates.

\item For $a = (x,y) \in G_1\backslash \mathcal{O}$ we define
$$
\compress_{G_1} (x,y) = \begin{cases}
\mathsf{1}\mathsf{0}\mathsf{1}\cdot\mathsf{bits}(x) & \text{if $y$ is the larger of the two possible $y$-coordinates}\\
\mathsf{1}\mathsf{0}\mathsf{0}\cdot\mathsf{bits}(x) & \text{otherwise}\\
\end{cases}
$$
\item We encode the identity element of $G_1$ using
$$
\compress{G_1}(\mathcal{O}_{G_1}) = \mathsf{1}\mathsf{1}\mathsf{0}\cdot\mathsf{0}^{381},
$$
\noindent where $\mathsf{0}^{381}$ denotes a string of 381 $\mathsf{0}$ bits.
Thus in all cases the encoding of an element of $G_1$ requires exactly 384 bits,
or 48 bytes.

Similarly, every non-identity element of $G_2$ can be written
in the form $(x,y)$ with $x,y \in \Fqq$.

$$
\compress_{G_2} (a+bu,y) = \begin{cases}
\mathsf{1}\mathsf{0}\mathsf{1}\cdot\mathsf{bits}(b)\cdot\mathsf{0}\mathsf{0}\mathsf{0}\cdot\mathsf{bits}(a)
& \text{if $y$ is the larger!!! of the two possible $y$-coordinates}\\
\mathsf{1}\mathsf{0}\mathsf{0}\cdot\mathsf{bits}(b)\cdot\mathsf{0}\mathsf{0}\mathsf{0}\cdot\mathsf{bits}(a) &
 \text{otherwise}\\
\end{cases}
$$
and
$$
\compress_{G_2}(\mathcal{O}_{G_2}) = \mathsf{1}\mathsf{1}\mathsf{0}\cdot\mathsf{0}^{765},
$$
The encoding of an element of $G_2$ requires exactly 786 bits, or 96 bytes.


\item $\Fq$ elements are encoded in big-endian form. They occupy 48 bytes in this form.
\item $\Fqq$ elements are encoded in big-endian form, meaning that the $\Fqq$ element $c_0 + c_1u$
  is represented by the $\Fq$ element $c_1$ followed by the $\Fq$ element $c_0$;
  elements of $\Fqq$ occupy 96 bytes in this form.
\item The zero element of $G$ is encoded
\item The most significant bit must always be set (indicating that we are using the Zcash compressed format).
\item The second most significant bit is set if and only if the encoding represents the zero
element of the group (the ``point at infinity'').  In this case all other bits
must be zero.
\item The third most significant bit is set if and only if the encoding does not represent the zero
element and its $y$-coordinate is the lexicographically larger of the two
associated with the encoded $x$-coordinate; if the bit is clear then it
indicates that the $y$-coordinate of the point is the smaller one.
\end{itemize}

The two $\uncompress$ functions are obtained by inverting the process above.
For $G_1$ a 48-byte bytestring $b$ is expected. If every bit of $b$ is zero
apart from the second most significant then $\uncompress_{G_1}(b)
= \mathcal{O}_{G_1}$.  Otherwise, it is checked that the first bit is set and
the second bit is clear, and then the final 381 bits are converted into an
element $x\in\Fq$ and it is checked whether $x^3+4$ has a square root in $\Fq$;
if so then a point $p=(x,y) \in E_1(\Fq)$ is obtained, where $y$ is the larger
square root of $x^3+4$ if the second bit of $b$ is set and the smaller square
root otherwise.  It is then checked whether $p$ lies in the subgroup $G_1$ and
if so we have $\uncompress_{G_1}(b)=p$.

\medskip
\noindent The $\uncompress_{G_2}$ function is defined similarly.

\medskip\noindent The uncompression process can fail in a number of ways:
\begin{itemize}
\item The encoding is malformed in some way; for example it has the wrong length or it does
not obey the conditions described above.
\item The encoded field element is not a square, so there is no point on the curve with that $x$-coordinate.
\item The encoded element is a square,  so that there is a point on the curve with that $x$ coordinate,
but the point does not lie in the relevant group.
\end{itemize}

\note{Pairing}
\label{note:pairing}
Also group operation on $\MlResult$, and mention embedding degree.

For efficiency reasons we split the pairing process into two parts:
the \texttt{millerLoop} and \texttt{finalVerify} functions.  We assume that we
have
\begin{itemize}
\item An intermediate multiplicative group $\MlResult$.
\item A cyclic group $\mu_r$ of order $r$.
\item A function (not necessarily itself a pairing) $e: G_1 \times
G_2 \rightarrow \MlResult$.
\item An epimorphism $\psi: \MlResult \rightarrow \mu_r$ of groups such
that $\psi \circ e: G_1 \times G_2 \rightarrow \mu_r$ is a (nondegenerate,
bilinear) pairing.
\end{itemize}

\noindent We then define $\denote{\mathtt{millerLoop}} = e$ and
$\denote{\mathtt{finalVerify}} = \phi$, where
$$
\phi(a,b) = \begin{cases}
               \mathtt{true} & \text{if $\psi(ab^{-1}) = 1_{\mu_r}$} \\
               \mathtt{false} & \text{otherwise.}
            \end{cases}
$$
We do not mandate specific choices for $\MlResult, \mu_r, e$, and $\phi$, but a
plausible choice would be
\begin{itemize}
\item $\MlResult = (\FF)^*$
\item $\mu_r = \{x \in (\FF)^*: x^r=1\}$, the group of $r$th roots of unity in $(\FF)^*$
\item $e$ is the Miller loop~\cite{Miller} associated with the optimal Ate pairing~\cite{Ate}
\item $\psi(x) = x^{\frac{q-1}{r}}$.
\end{itemize}

%% \setlength{\LTleft}{-18mm} % Shift the table left a bit to centre it on the page
%% \begin{longtable}[H]{|l|p{5cm}|p{5cm}|c|c|}
%%     \hline
%%     \text{Function} & \text{Signature} & \text{Denotation} & \text{Can} & \text{Note} \\
%%     & & & Fail? & \\
%%     \hline
%%     \endfirsthead
%%     \hline
%%     \text{Function} & \text{Type} & \text{Denotation} & \text{Can} & \text{Note}\\
%%     & & & Fail? & \\
%%     \hline
%%     \endhead
%%     \hline
%%     \caption{Built-in Functions}
%%     % This caption goes on every page of the table except the last.  Ideally it
%%     % would appear only on the first page and all the rest would say
%%     % (continued). Unfortunately it doesn't seem to be easy to do that in a
%%     % longtable.
%%     \endfoot
%%     \caption[]{Future Built-in  Functions (continued)}
%%     \label{table:future-built-in-functions}
%%     \endlastfoot
%%     \TT{addInteger}               & $[\ty{integer}, \ty{integer}] \to \ty{integer}$   & $+$ &  & \\
%%     \TT{bls12\_381\_G1\_add}     & $[ \ty{bls12\_381\_G1\_element}, \ty{bls12\_381\_G1\_element} ] \to \ty{bls12\_381\_G1\_element}$ & x& y & x \\
%%     \TT{bls12\_381\_G1\_neg}     & $ [ \ty{bls12\_381\_G1\_element} ] \to \ty{bls12\_381\_G1\_element}$ & x & y & z
%%     \hline 
%% \end{longtable}

%% bls12\_381\_G1\_add                : [ bls12\_381\_G1\_element, bls12\_381\_G1\_element ] -> bls12\_381\_G1\_element
%% bls12\_381\_G1\_neg                : [ bls12\_381\_G1\_element ] -> bls12\_381\_G1\_element
%% bls12\_381\_G1\_scalarMul          : [ integer, bls12\_381\_G1\_element ] -> bls12\_381\_G1\_element
%% bls12\_381\_G1\_equal              : [ bls12\_381\_G1\_element, bls12\_381\_G1\_element ] -> bool
%% bls12\_381\_G1\_hashToGroup        : [ bytestring ] -> bls12\_381\_G1\_element
%% bls12\_381\_G1\_compress           : [ bls12\_381\_G1\_element ] -> bytestring
%% bls12\_381\_G1\_uncompress         : [ bytestring ] -> bls12\_381\_G1\_element
%% bls12\_381\_G2\_add                : [ bls12\_381\_G2\_element, bls12\_381\_G2\_element ] -> bls12\_381\_G2\_element
%% bls12\_381\_G2\_neg                : [ bls12\_381\_G2\_element ] -> bls12\_381\_G2\_element
%% bls12\_381\_G2\_scalarMul          : [ integer, bls12\_381\_G2\_element ] -> bls12\_381\_G2\_element
%% bls12\_381\_G2\_equal              : [ bls12\_381\_G2\_element, bls12\_381\_G2\_element ] -> bool
%% bls12\_381\_G2\_hashToGroup        : [ bytestring ] -> bls12\_381\_G2\_element
%% bls12\_381\_G2\_compress           : [ bls12\_381\_G2\_element ] -> bytestring
%% bls12\_381\_G2\_uncompress         : [ bytestring ] -> bls12\_381\_G2\_element
%% bls12\_381\_millerLoop            : [ bls12\_381\_G1\_element, bls12\_381\_G2\_element ] -> bls12\_381\_mlresult
%% bls12\_381\_mulMlResult           : [ bls12\_381\_mlresult, bls12\_381\_mlresult ] -> bls12\_381\_mlresult
%% bls12\_381\_finalVerify           : [ bls12\_381\_mlresult, bls12\_381\_mlresult ] -> bool


