\newcounter{notenumberC}
\renewcommand{\note}[1]{
  \bigskip
  \refstepcounter{notenumberC}
  \noindent\textbf{Note \thenotenumberC. #1}
}

\newpage

\section{Future Built-in Types and Functions}
\label{appendix:default-builtins-future}
A future release will add support for BLS12-381 elliptic curve pairing
operations.  This involves adding three new types and seventeen new built-in
functions.

\subsection{Built-in types}
\label{sec:future-built-in-types}
Tables~\ref{table:future-built-in-types} describes three new built-in
types.

\newcommand{\Gone}{G_1}
\newcommand{\Gtwo}{G_2}
\newcommand{\MlResult}{R}

\newcommand{\Fq}{\mathbb{F}_q}
\newcommand{\Fqq}{\mathbb{F}_{q^2}}


\begin{table}[H]
  \centering
    \begin{tabular}{|l|p{6cm}|l|}
        \hline
        Type & Denotation & Concrete Syntax\\
        \hline
        \texttt{bls12\_381\_G1\_element} &   $\Gone$ & \texttt{0x[0-9A-Fa-f]\{96\}}\\
        \texttt{bls12\_381\_G2\_element} &   $\Gtwo$ & \texttt{0x[0-9A-Fa-f]\{96\}}\\
        \texttt{bls12\_381\_MlResult}    &   $\MlResult$  &  \\
        \hline
    \end{tabular}
    \caption{Atomic Types}
    \label{table:future-built-in-types}
\end{table}

We define some constants.  Our groups are all defined in terms of the  finite field $\Fq$ where
\begin{align*}
q = \mathtt{0x}&\mathtt{1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf}\\
              &\mathtt{6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab}\\
\end{align*}
which is a 381-bit prime.  The subgroup order is
$$
r = \mathtt{0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001}
$$

$$
E: y^2 = x^3 + 4
$$

$$
E': y^2 = x^3 + 4(u+1) \mbox{ where $u^2=-1$}
$$

These are abelian groups under the usual elliptic curve addition operations as defined in blah blah.

$\Fqq = \Fq[x]/(x^2+1)$; we may regard $\Fqq$ as the set $\{a+bu: a,b \in \Fq\}$ where $u^2=-1$.

$\Gone$ is the subgroup of $E(\Fq)$ generated by xxx and $\Gtwo$ is the subgroup of $E'(\Fqq)$ generated by yyy.




% Field modulus: q = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab  381 bits
% Subgroup size: r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001
% E: y^2 = x^3 + 4
% E': y^2 = x^3 + 4(u+1), u^2=-1
% Is it the Tate pairing?  It's probably the optimised Ate pairing, which
% should be the same as the reduced Tate pairing (maybe up to some endomorphism of G_T).
% CIP-0381 contains the serialisation of the generators.  Check those against the IETF document.


\subsection{Built-in functions}
\label{sec:future-built-in-functions}

\setlength{\LTleft}{-18mm} % Shift the table left a bit to centre it on the page
\begin{longtable}[H]{|l|p{5cm}|p{5cm}|c|c|}
    \hline
    \text{Function} & \text{Signature} & \text{Denotation} & \text{Can} & \text{Note} \\
    & & & Fail? & \\
    \hline
    \endfirsthead
    \hline
    \text{Function} & \text{Type} & \text{Denotation} & \text{Can} & \text{Note}\\
    & & & Fail? & \\
    \hline
    \endhead
    \hline
    \caption{Built-in Functions}
    % This caption goes on every page of the table except the last.  Ideally it
    % would appear only on the first page and all the rest would say
    % (continued). Unfortunately it doesn't seem to be easy to do that in a
    % longtable.
    \endfoot
    \caption[]{Built-in Functions (continued)}
    \label{table:future-built-in-functions}
    \endlastfoot
%% G1
    \TT{bls12\_381\_G1\_add}  &
    $[ \ty{bls12\_381\_G1\_element}$,
      \text{\; $\ty{bls12\_381\_G1\_element} ]$}
      \text{\: $ \to \ty{bls12\_381\_G1\_element}$} & Group addition &  No & \\
    \TT{bls12\_381\_G1\_neg}  &
      $ [ \ty{bls12\_381\_G1\_element} ]$  \text{\;\; $\to \ty{bls12\_381\_G1\_element}$} & Group inverse  & No & \\
    \TT{bls12\_381\_G1\_scalarMul}  &
    $[ \ty{integer}$,
      \text{\; $\ty{bls12\_381\_G1\_element} ]$}
      \text{\: $ \to \ty{bls12\_381\_G1\_element}$} & $(n,a) \mapsto na$ &  No & \\
    \TT{bls12\_381\_G1\_equal}  &
    $[ \ty{bls12\_381\_G1\_element}$,
      \text{\; $\ty{bls12\_381\_G1\_element} ]$}
      \text{\: $ \to \ty{bool}$} & $=$ &  No & \\
    \TT{bls12\_381\_G1\_hashToGroup}  &
    $[ \ty{bytestring}, \ty{bytestring}]$
      \text{\: $ \to \ty{bls12\_381\_G1\_element}$} & See note &  Yes? & \\
    \TT{bls12\_381\_G1\_compress}  &
    $[\ty{bls12\_381\_G1\_element}]$
      \text{\: $ \to \ty{bytestring}$} & See note  &  No & \\
    \TT{bls12\_381\_G1\_uncompress}  &
    $[ \ty{bytestring}]$
      \text{\: $ \to \ty{bls12\_381\_G1\_element}$} & See note &  Yes & \\
    \hline 
%% G2
    \TT{bls12\_381\_G2\_add}  &
    $[ \ty{bls12\_381\_G2\_element}$,
      \text{\; $\ty{bls12\_381\_G2\_element} ]$}
      \text{\: $ \to \ty{bls12\_381\_G2\_element}$} & $(a,b) \mapsto a+b$ &  No & \\
    \TT{bls12\_381\_G2\_neg}  &
      $ [ \ty{bls12\_381\_G2\_element} ]$  \text{\;\; $\to \ty{bls12\_381\_G2\_element}$} & $a \mapsto -a$  & No & \\
    \TT{bls12\_381\_G2\_scalarMul}  &
    $[ \ty{integer}$,
      \text{\; $\ty{bls12\_381\_G2\_element} ]$}
      \text{\: $ \to \ty{bls12\_381\_G2\_element}$} & $(n,a) \mapsto na$ &  No & \\
    \TT{bls12\_381\_G2\_equal}  &
    $[ \ty{bls12\_381\_G2\_element}$,
      \text{\; $\ty{bls12\_381\_G2\_element} ]$}
      \text{\: $ \to \ty{bool}$} & $=$ &  No & \\
    \TT{bls12\_381\_G2\_hashToGroup}  &
    $[ \ty{bytestring}, \ty{bytestring}]$
      \text{\: $ \to \ty{bls12\_381\_G2\_element}$} & $x$  &  Yes? & \\
    \TT{bls12\_381\_G2\_compress}  &
    $[\ty{bls12\_381\_G2\_element}]$
      \text{\: $ \to \ty{bytestring}$} & $x$  &  No & \\
    \TT{bls12\_381\_G2\_uncompress}  &
    $[ \ty{bytestring}]$
      \text{\: $ \to \ty{bls12\_381\_G2\_element}$} & $x$  &  Yes & \\
    \hline 
    \TT{bls12\_381\_millerLoop}  &
    $[ \ty{bls12\_381\_G1\_element}$,
      \text{\; $\ty{bls12\_381\_G2\_element} ]$}
    \text{\: $ \to \ty{\MlResult}$} & $ xxx $ &  No & \\
    \TT{bls12\_381\_mulMlResult}  &
    $[ \ty{\MlResult}, \ty{\MlResult}] \to \ty{\MlResult}$ & ? & No & \\
    \TT{bls12\_381\_finalVerify}  &
    $[ \ty{\MlResult}, \ty{\MlResult}] \to \ty{bool}$ & ? & No & \\
    \hline
\end{longtable}

%% \setlength{\LTleft}{-18mm} % Shift the table left a bit to centre it on the page
%% \begin{longtable}[H]{|l|p{5cm}|p{5cm}|c|c|}
%%     \hline
%%     \text{Function} & \text{Signature} & \text{Denotation} & \text{Can} & \text{Note} \\
%%     & & & Fail? & \\
%%     \hline
%%     \endfirsthead
%%     \hline
%%     \text{Function} & \text{Type} & \text{Denotation} & \text{Can} & \text{Note}\\
%%     & & & Fail? & \\
%%     \hline
%%     \endhead
%%     \hline
%%     \caption{Built-in Functions}
%%     % This caption goes on every page of the table except the last.  Ideally it
%%     % would appear only on the first page and all the rest would say
%%     % (continued). Unfortunately it doesn't seem to be easy to do that in a
%%     % longtable.
%%     \endfoot
%%     \caption[]{Future Built-in  Functions (continued)}
%%     \label{table:future-built-in-functions}
%%     \endlastfoot
%%     \TT{addInteger}               & $[\ty{integer}, \ty{integer}] \to \ty{integer}$   & $+$ &  & \\
%%     \TT{bls12\_381\_G1\_add}     & $[ \ty{bls12\_381\_G1\_element}, \ty{bls12\_381\_G1\_element} ] \to \ty{bls12\_381\_G1\_element}$ & x& y & x \\
%%     \TT{bls12\_381\_G1\_neg}     & $ [ \ty{bls12\_381\_G1\_element} ] \to \ty{bls12\_381\_G1\_element}$ & x & y & z
%%     \hline 
%% \end{longtable}

%% bls12\_381\_G1\_add                : [ bls12\_381\_G1\_element, bls12\_381\_G1\_element ] -> bls12\_381\_G1\_element
%% bls12\_381\_G1\_neg                : [ bls12\_381\_G1\_element ] -> bls12\_381\_G1\_element
%% bls12\_381\_G1\_scalarMul          : [ integer, bls12\_381\_G1\_element ] -> bls12\_381\_G1\_element
%% bls12\_381\_G1\_equal              : [ bls12\_381\_G1\_element, bls12\_381\_G1\_element ] -> bool
%% bls12\_381\_G1\_hashToGroup        : [ bytestring ] -> bls12\_381\_G1\_element
%% bls12\_381\_G1\_compress           : [ bls12\_381\_G1\_element ] -> bytestring
%% bls12\_381\_G1\_uncompress         : [ bytestring ] -> bls12\_381\_G1\_element
%% bls12\_381\_G2\_add                : [ bls12\_381\_G2\_element, bls12\_381\_G2\_element ] -> bls12\_381\_G2\_element
%% bls12\_381\_G2\_neg                : [ bls12\_381\_G2\_element ] -> bls12\_381\_G2\_element
%% bls12\_381\_G2\_scalarMul          : [ integer, bls12\_381\_G2\_element ] -> bls12\_381\_G2\_element
%% bls12\_381\_G2\_equal              : [ bls12\_381\_G2\_element, bls12\_381\_G2\_element ] -> bool
%% bls12\_381\_G2\_hashToGroup        : [ bytestring ] -> bls12\_381\_G2\_element
%% bls12\_381\_G2\_compress           : [ bls12\_381\_G2\_element ] -> bytestring
%% bls12\_381\_G2\_uncompress         : [ bytestring ] -> bls12\_381\_G2\_element
%% bls12\_381\_millerLoop            : [ bls12\_381\_G1\_element, bls12\_381\_G2\_element ] -> bls12\_381\_mlresult
%% bls12\_381\_mulMlResult           : [ bls12\_381\_mlresult, bls12\_381\_mlresult ] -> bls12\_381\_mlresult
%% bls12\_381\_finalVerify           : [ bls12\_381\_mlresult, bls12\_381\_mlresult ] -> bool


