\newcounter{notenumberC}
\renewcommand{\note}[1]{
  \bigskip
  \refstepcounter{notenumberC}
  \noindent\textbf{Note \thenotenumberC. #1}
}

\newpage

\section{Future Built-in Types and Functions}
\label{appendix:default-builtins-future}
A future release will add support for BLS12-381 elliptic curve pairing
operations.  This involves adding three new types and seventeen new built-in
functions.

\subsection{Built-in types}
\label{sec:future-built-in-types}
Tables~\ref{table:future-built-in-types} describes three new built-in
types.

\newcommand{\MlResult}{R}
\newcommand{\Fq}{\mathbb{F}_q}
\newcommand{\Fqq}{\mathbb{F}_{q^2}}
\newcommand{\FF}{\mathbb{F}_{q^{12}}}

\begin{table}[H]
  \centering
    \begin{tabular}{|l|p{6cm}|l|}
        \hline
        Type & Denotation & Concrete Syntax\\
        \hline
        \texttt{bls12\_381\_G1\_element} &   $G_1$ & \texttt{0x[0-9A-Fa-f]\{48\}}\\
        \texttt{bls12\_381\_G2\_element} &   $G_2$ & \texttt{0x[0-9A-Fa-f]\{96\}}\\
        \texttt{bls12\_381\_MlResult}    &   $\MlResult$  &  \\
        \hline
    \end{tabular}
    \caption{Atomic Types}
    \label{table:future-built-in-types}
\end{table}


We define some constants.  Our groups are all defined in terms of the  finite field $\Fq$ where
\begin{align*}
q = \mathtt{0x}&\mathtt{1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf}\\
              &\mathtt{6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab}\\
\end{align*}
which is a 381-bit prime.  The subgroup order is
$$
r = \mathtt{0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001}
$$

$$
E: y^2 = x^3 + 4
$$

$$
E': y^2 = x^3 + 4(u+1) \mbox{ where $u^2=-1$}
$$

These are abelian groups under the usual elliptic curve addition operations as
described in~\cite[III.2]{Silverman-Arithmetic-EC}.

$\Fqq = \Fq[x]/(x^2+1)$; we may regard $\Fqq$ as the set $\{a+bu: a,b \in \Fq\}$ where $u^2=-1$.

$G_1$ is the subgroup of $E(\Fq)$ generated by xxx and $G_2$ is the subgroup of $E'(\Fqq)$ generated by yyy.




% Field modulus: q = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab  381 bits
% Subgroup size: r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001
% E: y^2 = x^3 + 4
% E': y^2 = x^3 + 4(u+1), u^2=-1
% Is it the Tate pairing?  It's probably the optimised Ate pairing, which
% should be the same as the reduced Tate pairing (maybe up to some endomorphism of G_T).
% CIP-0381 contains the serialisation of the generators.  Check those against the IETF document.


\subsection{Built-in functions}
\label{sec:future-built-in-functions}

\setlength{\LTleft}{-18mm} % Shift the table left a bit to centre it on the page
\begin{longtable}[H]{|l|p{5cm}|p{5cm}|c|c|}
    \hline
    \text{Function} & \text{Signature} & \text{Denotation} & \text{Can} & \text{Note} \\
    & & & Fail? & \\
    \hline
    \endfirsthead
    \hline
    \text{Function} & \text{Type} & \text{Denotation} & \text{Can} & \text{Note}\\
    & & & Fail? & \\
    \hline
    \endhead
    \hline
    \caption{Built-in Functions}
    % This caption goes on every page of the table except the last.  Ideally it
    % would appear only on the first page and all the rest would say
    % (continued). Unfortunately it doesn't seem to be easy to do that in a
    % longtable.
    \endfoot
    \caption[]{Built-in Functions (continued)}
    \label{table:future-built-in-functions}
    \endlastfoot
%% G1
    \TT{bls12\_381\_G1\_add}  &
    $[ \ty{bls12\_381\_G1\_element}$,
      \text{\; $\ty{bls12\_381\_G1\_element} ]$}
      \text{\: $ \to \ty{bls12\_381\_G1\_element}$} & Group addition &  No & \\
    \TT{bls12\_381\_G1\_neg}  &
      $ [ \ty{bls12\_381\_G1\_element} ]$  \text{\;\; $\to \ty{bls12\_381\_G1\_element}$} & Group inverse  & No & \\
    \TT{bls12\_381\_G1\_scalarMul}  &
    $[ \ty{integer}$,
      \text{\; $\ty{bls12\_381\_G1\_element} ]$}
      \text{\: $ \to \ty{bls12\_381\_G1\_element}$} & $(n,a) \mapsto na$ &  No & \\
    \TT{bls12\_381\_G1\_equal}  &
    $[ \ty{bls12\_381\_G1\_element}$,
      \text{\; $\ty{bls12\_381\_G1\_element} ]$}
      \text{\: $ \to \ty{bool}$} & $=$ &  No & \\
    \TT{bls12\_381\_G1\_hashToGroup}  &
    $[ \ty{bytestring}, \ty{bytestring}]$
      \text{\: $ \to \ty{bls12\_381\_G1\_element}$} & See note &  Yes & \\
    \TT{bls12\_381\_G1\_compress}  &
    $[\ty{bls12\_381\_G1\_element}]$
      \text{\: $ \to \ty{bytestring}$} & See note  &  No & \\
    \TT{bls12\_381\_G1\_uncompress}  &
    $[ \ty{bytestring}]$
      \text{\: $ \to \ty{bls12\_381\_G1\_element}$} & See note &  Yes & \\
    \hline 
%% G2
    \TT{bls12\_381\_G2\_add}  &
    $[ \ty{bls12\_381\_G2\_element}$,
      \text{\; $\ty{bls12\_381\_G2\_element} ]$}
      \text{\: $ \to \ty{bls12\_381\_G2\_element}$} & $(a,b) \mapsto a+b$ &  No & \\
    \TT{bls12\_381\_G2\_neg}  &
      $ [ \ty{bls12\_381\_G2\_element} ]$  \text{\;\; $\to \ty{bls12\_381\_G2\_element}$} & $a \mapsto -a$  & No & \\
    \TT{bls12\_381\_G2\_scalarMul}  &
    $[ \ty{integer}$,
      \text{\; $\ty{bls12\_381\_G2\_element} ]$}
      \text{\: $ \to \ty{bls12\_381\_G2\_element}$} & $(n,a) \mapsto na$ &  No & \\
    \TT{bls12\_381\_G2\_equal}  &
    $[ \ty{bls12\_381\_G2\_element}$,
      \text{\; $\ty{bls12\_381\_G2\_element} ]$}
      \text{\: $ \to \ty{bool}$} & $=$ &  No & \\
    \TT{bls12\_381\_G2\_hashToGroup}  &
    $[ \ty{bytestring}, \ty{bytestring}]$
      \text{\: $ \to \ty{bls12\_381\_G2\_element}$} & $x$  &  Yes & \\
    \TT{bls12\_381\_G2\_compress}  &
    $[\ty{bls12\_381\_G2\_element}]$
      \text{\: $ \to \ty{bytestring}$} & $x$  &  No & \\
    \TT{bls12\_381\_G2\_uncompress}  &
    $[ \ty{bytestring}]$
      \text{\: $ \to \ty{bls12\_381\_G2\_element}$} & $x$  &  Yes & \\
    \hline 
    \TT{bls12\_381\_millerLoop}  &
    $[ \ty{bls12\_381\_G1\_element}$,
      \text{\; $\ty{bls12\_381\_G2\_element} ]$}
    \text{\: $ \to \ty{\MlResult}$} & $ xxx $ &  No & \\
    \TT{bls12\_381\_mulMlResult}  &
    $[ \ty{\MlResult}, \ty{\MlResult}] \to \ty{\MlResult}$ & ? & No & \\
    \TT{bls12\_381\_finalVerify}  &
    $[ \ty{\MlResult}, \ty{\MlResult}] \to \ty{bool}$ & ? & No & \\
    \hline
\end{longtable}

\subsection{Hashing}

The functions \texttt{bls12\_381\_G1\_hashToGroup} and
\texttt{bls12\_381\_G2\_hashToGroup} take an arbitrary bytestring $b$ (the
\textit{message}) and a (possibly empty) bytestring of length at most 255 known as a \textit{domain
separation tag} (DST)~\cite[2.2.5]{IETF-hash-to-curve} and hash them to obtain a
point in $G_1$ or $G_2$ respectively.  The details of the hashing process are
described in~\cite{IETF-hash-to-curve} (see specifically Section 8.8), except
that
\textbf{we do not support DSTs of length greater than 255}: an attempt to use a
longer DST directly will cause an error.  If a longer DST is required then it
should be hashed to obtain a short DST as described
in~\cite[5.3.3]{IETF-hash-to-curve}, and then this should be supplied as the
second argument to the appropriate \texttt{hashToGroup} function.  Some hashing
implementations also allow a third argument (an ``augmentation string''), but we
do not support this since the same effect can be obtained by appending
(prepending?) the augmentation string to the message before hashing.

\subsection{Compression}
Points in $G_1$ and $G_2$ are encoded as bytestrings in a ``compressed'' format
where only the $x$-coordinate of a point is encoded and some metadata is used to
indicate which of two possible $y$-coordinates the point has.  The encoding
format is based on the Zcash encoding for BLS12-381 points:
see~\cite{Zcash-serialisation} or~\cite[``Serialization'']{blst-library}.  In
detail,
\begin{itemize}

\item $\Fq$ elements are encoded in big-endian form. They occupy 48 bytes in this form.
\item $\Fqq$ elements are encoded in big-endian form, meaning that the $\Fqq$ element $c_0 + c_1u$
  is represented by the $\Fq$ element $c_1$ followed by the $\Fq$ element $c_0$; elements of $\Fqq$
  occupy 96 bytes in this form.
\item The zero element of $G$ is encoded
\item The most significant bit must always be set (indicating that we are using the Zcash compressed format).
\item The second most significant bit is set if and only if the encoding represents the zero
element of the group (the ``point at infinity'').  In this case all other bits
must be zero.
\item The third most significant bit is set if and only if the encoding does not represent the zero
element and its $y$-coordinate is the lexicographically larger of the two
associated with the encoded $x$-coordinate; if the bit is clear then it
indicates that the $y$-coordinate of the point is the smaller one.
\end{itemize}

Decoding can fail in a number of ways:
\begin{itemize}
\item The encoding is malformed in some way; for example it has the wrong length or it does
not obey the conditions described above.
\item The encoded field element is not a square, so there is no point on the curve with that $x$-coordinate.
\item The encoded element is a square,  so that there is a point on the curve with that $x$ coordindate,
but the point does not lie in the relevant group.
\end{itemize}

\subsection{Pairing}
Also group operation on $R$, and mention embedding degree.

For efficiency reasons we split the pairing process into two parts:
the \texttt{millerLoop} and \texttt{finalVerify} functions.  We assume that we
have an intermediate group $R$, a cyclic group $\mu_r$ of order $r$, a function
(not necessarily itself a pairing) $e: G_1 \times G_2 \rightarrow R$ and an
epimorphism $\phi: R \rightarrow \mu_r$ of groups such that $\phi \circ e:
G_1 \times G_2 \rightarrow \mu_r$ is a (nondegenerate, bilinear) pairing.  We
then define $\denote{\mathtt{millerLoop}} = e$ and
$\denote{\mathtt{finalVerify}} = \psi$, where
$$
\psi(a,b) = \begin{cases}
               \mathtt{true} & \text{if $\phi(ab^{-1}) = 1_{\mu_r}$} \\
               \mathtt{false} & \text{otherwise.}
            \end{cases}
$$
We do not mandate specific choices for $R, \mu_r, e$, and $\phi$, but a
plausible choice would be
\begin{itemize}
\item $R = (\FF)^*$
\item $\mu_r = \{x \in (\FF)^*: x^r=1\}$, the group of $r$th roots of unity in $(\FF)^*$
\item $e$ is the Miller loop~\cite{Miller} associated with the optimal Ate pairing~\cite{Ate}
\item $\phi(x) = x^{\frac{q-1}{r}}$.
\end{itemize}

\noindent Note also that the elements of $R$ are completely opaque and can only be
obtained as a result of \texttt{millerLoop} or by multiplying two existing
elements of $R$.  We provide neither a serialisation format nor a concrete
syntax for elements of $R$.

%% \setlength{\LTleft}{-18mm} % Shift the table left a bit to centre it on the page
%% \begin{longtable}[H]{|l|p{5cm}|p{5cm}|c|c|}
%%     \hline
%%     \text{Function} & \text{Signature} & \text{Denotation} & \text{Can} & \text{Note} \\
%%     & & & Fail? & \\
%%     \hline
%%     \endfirsthead
%%     \hline
%%     \text{Function} & \text{Type} & \text{Denotation} & \text{Can} & \text{Note}\\
%%     & & & Fail? & \\
%%     \hline
%%     \endhead
%%     \hline
%%     \caption{Built-in Functions}
%%     % This caption goes on every page of the table except the last.  Ideally it
%%     % would appear only on the first page and all the rest would say
%%     % (continued). Unfortunately it doesn't seem to be easy to do that in a
%%     % longtable.
%%     \endfoot
%%     \caption[]{Future Built-in  Functions (continued)}
%%     \label{table:future-built-in-functions}
%%     \endlastfoot
%%     \TT{addInteger}               & $[\ty{integer}, \ty{integer}] \to \ty{integer}$   & $+$ &  & \\
%%     \TT{bls12\_381\_G1\_add}     & $[ \ty{bls12\_381\_G1\_element}, \ty{bls12\_381\_G1\_element} ] \to \ty{bls12\_381\_G1\_element}$ & x& y & x \\
%%     \TT{bls12\_381\_G1\_neg}     & $ [ \ty{bls12\_381\_G1\_element} ] \to \ty{bls12\_381\_G1\_element}$ & x & y & z
%%     \hline 
%% \end{longtable}

%% bls12\_381\_G1\_add                : [ bls12\_381\_G1\_element, bls12\_381\_G1\_element ] -> bls12\_381\_G1\_element
%% bls12\_381\_G1\_neg                : [ bls12\_381\_G1\_element ] -> bls12\_381\_G1\_element
%% bls12\_381\_G1\_scalarMul          : [ integer, bls12\_381\_G1\_element ] -> bls12\_381\_G1\_element
%% bls12\_381\_G1\_equal              : [ bls12\_381\_G1\_element, bls12\_381\_G1\_element ] -> bool
%% bls12\_381\_G1\_hashToGroup        : [ bytestring ] -> bls12\_381\_G1\_element
%% bls12\_381\_G1\_compress           : [ bls12\_381\_G1\_element ] -> bytestring
%% bls12\_381\_G1\_uncompress         : [ bytestring ] -> bls12\_381\_G1\_element
%% bls12\_381\_G2\_add                : [ bls12\_381\_G2\_element, bls12\_381\_G2\_element ] -> bls12\_381\_G2\_element
%% bls12\_381\_G2\_neg                : [ bls12\_381\_G2\_element ] -> bls12\_381\_G2\_element
%% bls12\_381\_G2\_scalarMul          : [ integer, bls12\_381\_G2\_element ] -> bls12\_381\_G2\_element
%% bls12\_381\_G2\_equal              : [ bls12\_381\_G2\_element, bls12\_381\_G2\_element ] -> bool
%% bls12\_381\_G2\_hashToGroup        : [ bytestring ] -> bls12\_381\_G2\_element
%% bls12\_381\_G2\_compress           : [ bls12\_381\_G2\_element ] -> bytestring
%% bls12\_381\_G2\_uncompress         : [ bytestring ] -> bls12\_381\_G2\_element
%% bls12\_381\_millerLoop            : [ bls12\_381\_G1\_element, bls12\_381\_G2\_element ] -> bls12\_381\_mlresult
%% bls12\_381\_mulMlResult           : [ bls12\_381\_mlresult, bls12\_381\_mlresult ] -> bls12\_381\_mlresult
%% bls12\_381\_finalVerify           : [ bls12\_381\_mlresult, bls12\_381\_mlresult ] -> bool


