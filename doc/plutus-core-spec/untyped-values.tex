\subsection{Values in Plutus Core}
\label{sec:uplc-values}
The semantics of built-in functions in Plutus Core are obtained by instantiating
the sets $\Con{\tn}$ of constants of type $\tn$ (see
Section~\ref{sec:builtin-inputs}) to be the expressions of the form
\texttt{(con} $\tn$ $c$\texttt{)} and the set $\Inputs$ to be the set of Plutus
Core \textit{values}, terms which cannot immediately undergo any further
reduction, such as lambda terms and delayed terms.  Values also include partial
applications of built-in functions such as \texttt{[(builtin modInteger) (con
    integer 5)]}, which cannot perform any computation until a second integer
argument is supplied.  However, partial applications must also be
\textit{well-formed}, in the sense that applications of \texttt{force} must be
correctly interleaved with genuine arguments, and the arguments must themselves
be values.

We define syntactic classes $V$ of Plutus Core values and $A$ of partial builtin
applications simultaneously:

\begin{minipage}{\linewidth}
    \centering
    \[\begin{array}{lrcl}
        \textrm{Value}  & V   & ::= & \con{\tn}{c} \\
                        &     &     & \delay{M} \\
                        &     &     & \lamU{x}{M} \\
                        &     &     & \constr{i}{\repetition{V}} \\
                        &     &     & A
    \end{array}\]
    \captionof{figure}{Values in Plutus Core}
    \label{fig:untyped-cek-values}
\end{minipage}%
\nomenclature[F4]{$V$}{Plutus Core value}%
\nomenclature[F1]{$A$}{Well-formed partial built-in function application}

\medskip
\noindent Here $A$ is the class of well-formed partial applications, and to define
this we first define a class of possibly ill-formed iterated applications $\pba$ for
each built-in function $b \in \Fun$:

\begin{minipage}{\linewidth}
    \centering
  \[\begin{array}{lrl}
  \pba & ::= & \builtin{b}\\
       &     & \appU{\pba}{V}\\
       &    & \force{\pba}\\
    \end{array}\]
    \captionof{figure}{Partial built-in function application}
    \label{fig:partial-applications}
\end{minipage}%
\nomenclature[F2]{$\pba$}{Partial built-in function application (possibly ill-formed)}%
\nomenclature[F3]{$\pbas$}{Set of all  partial built-in function applications}

\medskip
\noindent We let $\pbas$ denote the set of terms generated by the grammar
in Figure~\ref{fig:partial-applications} and 
we define a function $\beta$ which extracts the name of the built-in
function occurring in a term in $\pbas$:
$$
 \begin{array}{ll}
 \beta(\builtin{b}) &= b\\
 \beta(\appU{\pba}{V}) & =\beta(\pba)\\
 \beta({\force{\pba}}) & =\beta(\pba)\\
\end{array}
$$%
\nomenclature[F5]{$\beta(\pba)$}{Function in partial builtin application $\pba$}

%% $$
%% \begin{array}{ll}
%%   \sat{\builtin{b}} &= []\\
%%   \sat{\appU{P}{V}} &= \sat{P}\snoc\type(V)\\
%%   \sat{\force{P}}   &= \sat{P}\snoc\fforce\\
%% \end{array}
%% $$

\noindent We also define a function $\pbasize{\cdot}$ which measures the size of
a term $\pba \in \pbas$:
$$
\begin{array}{ll}
\pbasize{\texttt{(builtin $b$)}} &= 0\\
\pbasize{\texttt{[$\pba$ $V$]}} &= 1+\pbasize{\pba}\\
\pbasize{\texttt{(force $\pba$)}} & = 1+\pbasize{\pba}
\end{array}
$$%
\nomenclature[F6]{$\pbasize{\pba}$}{Size of partial builtin application $\pba$}


%% \item Our built-in functions can take general members of $\Inputs$ as arguments
%%   as well as elements of the sets $\denote{\tn}$ and the symbol $\top$ is used
%%   to denote the type of elements of $\Inputs$. We use the symbol $\top$
%%   (which we assume does not appear in any other set we mention) to denote the
%%   type of non-constant elements of $\Inputs$ and write $\UniTop = \Uni \disj
%%   \{\top\}$ and $\UnihatTop = \Unihat \disj \{\top\}$.
%% \item We should be able to examine inputs (even during execution) to determine
%%   their types.  More precisely we assume that there is a function $\type:
%%   \Inputs \rightarrow \UniTop$ such that
%%   $$\type(x) =
%%   \begin{cases}
%%     \tn &\ \text{if } x \in \Con{\tn} \text{ for some } \tn \in \Uni\\
%%     \top &\text{otherwise}
%%   \end{cases}
%%   $$
%%   \noindent This is well defined because of our assumption that the sets $\Con{\tn}$ are disjoint.
%% \item We also define a partial order $\preceq$  on the set $\Uni^{\top}$ by
%%   $t_1 \preceq t_2$ if $t_1 = t_2$ or $t_2 = \top$.   


\paragraph{Well-formed partial applications.} A term $\pba \in \pbas$ is
an application of $b = \beta(\pba)$ to a number of values in $S$, interleaved
with applications of $\texttt{force}$.  We now define what it means for $\pba$
to be a \textit{well-formed partial application}.  Suppose that $\alpha(b) =
[\iota_1, \ldots, \iota_n]$. Firstly we require that $\pbasize{\pba} < n$, so
that $b$ is not fully applied; in this case we put
$\iota=\iota_{\pbasize{\pba}}$, the element of $b$'s signature which describes
what kind of ``argument'' $b$ currently expects.  The definition is completed by
induction on the structure of $\pba$:
\begin{enumerate}
\item $\pba=\mathtt{(builtin}\ b \mathtt{)}$ is always well-formed.
\item $\pba=\mathtt{[}\pba'\ V\mathtt{]}$ is well-formed if $\pba'$ is
  well-formed and $\iota \in \Unihash$ or $\iota \in \Var_*$ (equivalently, $\iota \notin \QVar$).
\item $\pba=\mathtt{(force}\ \pba'\mathtt{)}$ is well-formed if $\pba'$ is
  well-formed and $\iota \in \QVar$.
\end{enumerate}

\kwxm{Note that apart from type names all of this stuff is meta-notation that is
  need to describe the builtins machinery but isn't part of the language.}


\medskip
\noindent The definition of values in Figure~\ref{fig:untyped-cek-values} is now
completed by defining $A$ to be the syntactic class of well-formed
\textit{partial} built-in function applications:
$$
A = \{\pba \in \pbas: \pba \text{ is a well-formed partial application} \}.
$$

\noindent Note that this definition does not impose any requirements of type
correctness.  For example, with the types and functions defined in
Section~\ref{sec:default-builtins-1} the term $X =\texttt{[(builtin
    modInteger) (con string "blue")]}$ is a valid value which could be
treated like any other, for instance by being passed as an argument to a
\texttt{lam} expression.  However, the evaluation rules described in the next
section require that when a built-in function $b$ becomes \textit{fully} applied
the types of the arguments are checked against the signature of $b$ using the
relation $\approx$ and the function $\Eval$ defined in
Sections~\ref{sec:compatibility} and \ref{sec:eval}, so an error would arise if
the term $X$ were ever applied to another argument.
