\chapter{Serialising Plutus Core Terms and Programs Using the \texttt{flat} Format}
\label{appendix:flat-serialisation}
We use the \texttt{flat} format \cite{flat} to serialise Plutus Core
terms, and we regard this format as being the definitive concrete representation
of Plutus Core programs. For compactness we generally (and \textit{always} for
scripts on the blockchain) replace names with de Bruijn indices (see
Section~\ref{sec:grammar-notes}) in serialised programs.

We use bytestrings for serialisation, but it is convenient to define the
serialisation and deserialisation process in terms of strings of bits. Some
extra bits of padding are added at the end of the encoding of a program to
ensure that the number of bits in the output is a multiple of 8, and this allows
us to regard serialised programs as bytestrings in the obvious way.

See Section~\ref{sec:cardano-issues} for some restrictions on serialisation
specific to the Cardano blockchain.

\paragraph{Note: \texttt{flat} versus CBOR.}
Much of the Cardano codebase uses the CBOR format for serialisation; however, it
is important that serialised scripts not be too large. CBOR pays a price for
being a self-describing format. The size of the serialised terms is consistently
larger than a format that is not self-describing: benchmarks show that
\texttt{flat} encodings of Plutus Core scripts are smaller than CBOR encodings
by about 35\% (without using compression).



\section{Encoding and decoding}
Let $\Bits = \{\bits{0},\bits{1}\}^*$, the set of all finite sequences of
bits.  For brevity we write a sequence of bits in the form $b_{n-1} \cdots b_0$
instead of $[b_{n-1}, \ldots, b_0]$: thus $\bits{011001}$ instead of $[\bits{0},
  \bits{1},\bits{1},\bits{0},\bits{0},\bits{1}])$.  We denote the empty sequence
by $\epsilon$, and use $\length(s)$ to denote the length of a sequence of bits,
and $\cdot$ to denote concatenation (or prepending or appending a single bit to
a sequence of bits).%
\nomenclature[As]{$\Bits$}{The set of strings of bits}

\medskip
\noindent Similarly to the CBOR encoding for \texttt{data} described in
Appendix~\ref{appendix:data-cbor-encoding}, we will describe the flat encoding
by defining families of encoding functions (or \textit{encoders})
$$
\E_X : \Bits \times X \rightarrow \Bits
$$%
\nomenclature[HF]{$\E_X$}{Flat encoder}
and (partial) decoding functions (or \textit{decoders})
$$
\D_X : \Bits \rightharpoonup \Bits \times X
$$%
\nomenclature[HF]{$\D_X$}{Flat decoder}

\noindent for various sets $X$, such as the set $\Z$ of integers and the set of
all Plutus Core terms.  The encoding function $\E_X$ takes a sequence $s \in
\Bits$ and an element $x \in X$ and produces a new sequence of bits by appending
the encoding of $x$ to $s$, and the decoding function $\D_X$ takes a sequence of
bits, decodes some initial prefix of $s$ to a value $x \in X$, and returns the
remainder of $s$ together with $x$.


Encoding functions basically operate by decomposing an object into subobjects
and concatenating the encodings of the subobject; however it is sometimes
necessary to add some padding between subobjects in order to make sure that
parts of the output are aligned on byte boundaries, and for this reason (unlike
the CBOR encoding for \texttt{data}) all of our encoding functions have a first
argument containing all of the previous output, so that it can be examined to
determine how much alignment is required.

As in the case of CBOR, decoding functions are partial: they can fail if, for
instance, there is insufficient input, or if a decoded value is outside some
specified range.  To simplify notation we will mention any preconditions
separately, with the assumption that the decoder will fail if the preconditions
are not met; we also make a blanket assumption that all decoders fail if there
is not enough input for them to proceed.  Many of the definitions of decoders
construct objects by calling other decoders to obtain subobjects which are then
composed, and these are often introduced by a condition of the form ``if
$\D_X(s) = x$''.  Conditions like this should be read as implicitly saying that
if the decoder $\D_X$ fails then the whole decoding process fails.

\subsection{Padding}
The encoding functions mentioned above produce sequences of \textit{bits}, but
we sometimes need sequences of \textit{bytes}.  To this end we introduce a
functions $\pad: \Bits \rightarrow \Bits$ which adds a sequence of $\bits{0}$s
followed by a $\bits{1}$ to a sequence $s$ to get a sequence whose length is a
multiple of 8; if $s$ is a sequence such that $\length(s)$ is already a multiple of 8
then $\pad$ still adds an extra byte of padding; $\pad$ is used both for
internal alignment (for example, to make sure that the contents of a bytestring
are aligned on byte boundaries) and at the end of a complete encoding of a
Plutus Core program to to make the length a multiple of 8 bits.
Symbolically, 
$$
\pad(s)  = s \cdot \pp{k} \quad \text{if $\length(s) = 8n+k$ with $n,k \in \N$ and $0 \leq k \leq 7$}
$$
where
\begin{align*}
 \pp{0} &= \bits{00000001} \\
 \pp{1} &= \bits{0000001}  \\
 \pp{2} &= \bits{000001}   \\
 \pp{3} &= \bits{00001}    \\
 \pp{4} &= \bits{0001}     \\
 \pp{5} &= \bits{001}      \\
 \pp{6} &= \bits{01}       \\
 \pp{7} &= \bits{1}.
 \end{align*}

\noindent We also define a (partial) inverse function $\unpad: \Bits \rightharpoonup
\Bits$ which discards padding:
$$
  \unpad(q \cdot s) = s \quad \text{if $q = \pp{i}$ for some $i \in \{0,1,2,3,4,5,6,7\} $}.
$$

\noindent This can fail if the padding is not of the expected form or if the input is
the empty sequence $\epsilon$.

\section{Basic \texttt{flat} encodings}
\label{sec:basic-flat-encodings}
\subsection{Fixed-width natural numbers}
We often wish to encode and decode natural numbers which fit into some fixed
number of bits, and we do this simply by encoding them as their binary expansion
(most significant bit first), adding leading zeros if necessary.  More precisely
for $n \geq 1$ we define an encoder
$$
\E_n : \Bits \times \Nab{0}{2^{n-1}-1} \rightarrow \Bits
$$
by
$$
\E_n(s, \sum^{n-1}_{i=0}b_i2^i) = s \cdot b_{n-1} \cdots b_0 \quad \text{($b_i \in \{0,1\}$)}
$$
and a decoder
$$
\D_n : \Bits \rightharpoonup \Bits \times \Nab{0}{2^{n-1}-1}
$$
by
$$
\D_n(b_{n-1}\cdots{b_0} \cdot s)= (s,\sum^{n-1}_{i=0}b_i2^i).
$$ As in Appendix~\ref{appendix:data-cbor-encoding}, $\Nab{a}{b}$
denotes the closed interval of integers $\{n \in \Z : a \leq n \leq b\}$.  Note
that $n$ here is a variable (not a fixed label) so we are defining whole
families of encoders $\E_1, \E_2, \E_3, \ldots$ and and decoders $\D_1, \D_2,
\D_3\ldots$.


\subsection{Lists}
Suppose that we have a set $X$ for which we have defined an encoder $\E_X$ and a
decoder $\D_X$; we define an encoder $\Elist_X$ which encodes lists of elements
of $X$ by emitting the encodings of the elements of the list, each preceded by a
$\bits{1}$ bit, then emitting a $\bits{0}$ bit to mark the end of the list.
\begin{align*}
  \Elist_X(s,[]) &= s \cdot \bits{0} \\
  \Elist_X(s,[x_1, \ldots, x_n]) &= \Elist_X (s \cdot \bits{1} \cdot \E_X(x_1), [x_2, \ldots, x_n]).
\end{align*}

\noindent The corresponding decoder is given by
\begin{align*}
\Dlist_X(\bits{0} \cdot s) &= (s,[])\\
\Dlist_X(\bits{1} \cdot s) &= (s'', x \cdot l) \quad \text{if $D_X(s) = (s', x)$ and $\Dlist_X(s') = (s'', l).$}
\end{align*}

\subsection{Natural numbers}
We encode natural numbers by splitting their binary representations into
sequences of 7-bit blocks, then emitting these as a list with the \textbf{least
  significant block first}:

$$
\E_{\N} (s, \sum_{i=0}^{n-1}k_i2^{7i}) = \Elist_7(s, [k_0, \ldots, k_{n-1}])
$$
\noindent(where $k_i \in \Z$ and $0 \leq k_i \leq 127$).
\noindent The decoder is
$$
\D_{\N}(s) = (s', \sum_{i=0}^{n-1}k_i2^{7i}) \quad \text{if $\Dlist_7(s) = (s', [k_0, \ldots, k_{n-1}])$}.
$$

\subsection{Integers}
Signed integers are encoded by converting them to natural numbers using the
zigzag encoding ($0 \mapsto 0, -1 \mapsto 1, 1 \mapsto 2, -2 \mapsto 3, 2
\mapsto 4, \ldots$) and then encoding the result using $\E_{\N}$:
$$
\E_{\Z} (s, n) =
\begin{cases}
  \E_{\N}(s, 2n) & \text{if $n \geq 0$}\\
  \E_{\N}(s, -2n-1) & \text{if $n < 0$}.
\end{cases}
$$
The decoder is
$$
\D_{\Z}(s) =
\begin{cases}
  (s', \frac{n}{2}) & \text{if $n \equiv 0 \pmod 2$}\\
  (s', -\frac{n+1}{2}) & \text{if $n \equiv 1 \pmod 2$}
\end{cases} \quad\text{if $\D_{\N}(s) = (s', n)$}.
$$

\subsection{Bytestrings}  Bytestrings are encoded by dividing them into
nonempty blocks of up to 255 bytes and emitting each block in sequence.  Each
block is preceded by a single unsigned byte containing its length, and the end
of the encoding is marked by a zero-length block (so the empty bytestring is
encoded just as a zero-length block).  Before emitting a bytestring, the
preceding output is padded so that its length (in bits) is a multiple of 8; if
this is already the case a single padding byte is still added; this ensures that
contents of the bytestring are aligned to byte boundaries in the output.

Recall that $\B$ denotes the set of 8-bit bytes, $\{0,1, \ldots, 255\}$. For
specification purposes we may identify the set of bytestrings with the set
$\B^*$ of (possibly empty) lists of elements of $\B$.  We denote by $C$ the set
of \textit{bytestring chunks} of \textbf{nonempty} bytestrings of length at most
255: $C = \{[b_1, \ldots, b_n]: b_i \in \B, 1 \leq n \leq 255\}$, and define a
function $E_C: C \rightarrow \Bits$ by
$$
E_C ([b_1, \ldots, b_n]) = \E_8(n) \cdot \E_8(b_1) \cdot \cdots \cdot \E_8(b_n).
$$

\noindent
We define an encoder $\E_{C^*}$ for lists of chunks by 
$$
\E_{C^*} (s, [c_1, \ldots, c_n]) = s \cdot E_C(c_1) \cdot \cdots \cdot E_C(c_n) \cdot \bits{00000000}.
$$
\noindent Note that each $c_i$ is required to be nonempty but that we allow the
case $n = 0$, so that an empty list of chunks encodes as $\bits{00000000}$.

\medskip
\noindent To encode a bytestring we decompose it into a list $L$ of chunks and
then apply $\E_{C^*}$ to $L$.  However, there will usually be many ways to
decompose a given bytestring $a$ into chunks. For definiteness we recommend (but
do not demand) that $a$ is decomposed into a sequence of chunks of length 255
possibly followed by a smaller chunk.  Formally, suppose that $a = [a_1, \ldots,
  a_{255k+r}] \in \B^*\backslash\{\epsilon\}$ where $k \geq 0$ and $0 \leq r
\leq 254$.  We define the \textit{canonical 256-byte decomposition} $\tilde{a}$ of $a$ to
be
$$
\tilde{a} = [[a_1, \ldots, a_{255}],
  [a_{256}, \ldots, a_{510}],\ldots
  [a_{255(k-1)+1}, \ldots, a_{255k}]] \in C^*
$$
\noindent if $r=0$ and
$$
\tilde{a} = [[a_1, \ldots, a_{255}],
  [a_{256}, \ldots, a_{510}],\ldots
  [a_{255(k-1)+1}, \ldots, a_{255k}], [a_{255k+1}, \ldots, a_{255k+r}]] \in C^*
$$
\noindent if $r>0$.

\smallskip
\noindent For the empty bytestring we define
$$
\tilde{\epsilon} = [].
$$

\medskip
\noindent Given all of the above, we define the canonical encoding function
$\E_{\B^*}$ for bytestrings to be
$$
\E_{\B^*}(s, a) = E_{C^*}(\pad(s), \tilde{a}).
$$
\noindent Non-canonical encodings can be obtained by replacing $\tilde{a}$ with any
other decomposition of $a$ into nonempty chunks, and the decoder below will
accept these as well.

\bigskip

\noindent To define a decoder for bytestrings we first define a decoder
$\D_{C}$ for bytestring chunks:

$$
\D_{C}(s) = \D_C^{(n)}(s',[]) \quad \text{if $\D_8(s) = (s', n)$}
$$
where
$$
\D^{(n)}_C (s, l) =
\begin{cases}
  (s, l) & \text{if $n=0$}\\
  \D^{(n-1)}_C (s',l\cdot x)  & \text{if $n > 0$ and $\D_8(s) = (s',x)$.}
\end{cases}
$$
Now we define
$$
\D_{C^*}(s) =
\begin{cases}
  (s', []) & \text{if $D_C(s) = (s', [])$}\\
  (s'', x \cdot l) & \text{if $\D_C(s) = (s', x)$ with $x \ne []$ and $\D_{C^*}(s') = (s'', l)$}.
\end{cases}
$$
\noindent The notation is slightly misleading here: $\D_{C^*}$ does not
decode to a list of bytestring chunks, but to a single bytestring.  We
could alternatively decode to a list of bytestrings and then concatenate them
later, but this would have the same overall effect.

\medskip
\noindent Finally, we define the decoder for bytestrings by
$$
\D_{\B^*} (s) = \D_{C^*}(\unpad(s)).
$$

\subsection{Strings}
We have defined values of the \texttt{string} type to be sequences of Unicode
characters.  As mentioned earlier we do not specify any particular internal
representation of Unicode characters, but for serialisation we use the UTF-8
representation to convert between strings and bytestrings and then use the
bytestring encoder and decoder:

$$
\E_{\U^*}(s,u) = \E_{\B^*}(s,\utfeight(u))
$$

$$
\D_{\U^*}(s) = (s', \unutfeight(a)) \quad \text{if $\D_{\B^*}(s) = (s', a)$}
$$

\noindent
where $\utfeight$ and $\unutfeight$ are the UTF8 encoding and decoding functions
mentioned in Section~\ref{sec:default-builtins-1}. Recall that $\unutfeight$
is partial (not all bytestrings represent valid Unicode sequences), so
$\D_{\U^*}$ may fail if the input is invalid.


\section{Encoding and decoding Plutus Core}

\subsection{Programs}
A program is encoded by encoding the three components of the version number in
sequence then encoding the body, and possibly adding some padding to ensure that
the total number of bits in the output is a multiple of 8 (and hence the output
can be viewed as a bytestring).
$$
\Eprogram(\Prog{a}{b}{c}{t}) =
\pad(\Eterm(\E_{\N}(\E_{\N}(\E_{\N}(\epsilon, a), b), c), t)).
$$

\noindent The decoding process is the inverse of the encoding process: three
natural numbers are read to obtain the version number and then the body is
decoded.  After this we discard any padding in the remaining input and check
that all of the input has been consumed.
$$
\Dprogram(s) = \Prog{a}{b}{c}{t} \quad
\begin{cases}
  \text{ if }  &\D_{\N}(s) = (s', a)\\
  \text{ and } &\D_{\N}(s') = (s'', b)\\
  \text{ and } &\D_{\N}(s'') = (s''', c)\\
  \text{ and } &\Dterm(s''') = (r, t)\\
  \text{ and } &\unpad(r) = \epsilon.
\end{cases}
$$

\noindent 

\subsection{Terms}
Plutus Core terms are encoded by emitting a 4-bit tag identifying the type of
the term (see Table~\ref{table:term-tags}; recall that \texttt{[]} denotes
application) then emitting the encodings for any subterms.  We currently only
use ten of the sixteen available tags: the remainder are reserved for potential
future expansion.
\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|}
  \hline
  \Strut
  Term type & Binary & Decimal\\
  \hline
  \Strut
  Variable         & $\bits{0000}$  & 0 \\
  \texttt{delay}   & $\bits{0001}$  & 1 \\
  \texttt{lam}     & $\bits{0010}$ & 2 \\
  \texttt{[]}      & $\bits{0011}$  & 3 \\
  \texttt{const}   & $\bits{0100}$  & 4 \\
  \texttt{force}   & $\bits{0101}$   & 5 \\
  \texttt{error}   & $\bits{0110}$  & 6 \\
  \texttt{builtin} & $\bits{0111}$  & 7 \\
  \texttt{constr}  & $\bits{1000}$  & 8 \\
  \texttt{case}    & $\bits{1001}$  & 9 \\
  \hline
\end{tabular}
\caption{Term tags}
\label{table:term-tags}
\end{table}


\noindent The encoder for terms is given below: it refers to other encoders (for
names, types, and constants) which will be defined later.

\begin{alignat*}{2}
&  \Eterm(s,x)                 &&= \Ename(s \cdot \bits{0000},x) \\
&  \Eterm(s, \Delay{t})        &&=\Eterm(s \cdot \bits{0001}, t) \\
&  \Eterm(s, \Lam{x}{t})       &&= \Eterm(\Ebinder(s \cdot \bits{0010}, x), t) \\
&  \Eterm(s, \Apply{t_1}{t_2}) &&= \Eterm(\Eterm(s \cdot \bits{0011}, t_1), t_2)\\
&  \Eterm(s, \Const{tn}{c})    &&= \Econstant{tn}(\Etype(s \cdot \bits{0100}, \tn), c) \\
&  \Eterm(s, \Force{t})        &&= \Eterm(s \cdot \bits{0101}, t) \\
&  \Eterm(s, \Error)           &&= s \cdot \bits{0110} \\
&  \Eterm(s, \Builtin{b})      &&= \Ebuiltin(s \cdot \bits{0111}, b) \\
&  \Eterm(s, \Constr{i}{l})      &&= \Elist_{\mathsf{term}}(\E_{64}(s \cdot \bits{1000}, i), l) \\
&  \Eterm(s, \Kase{u}{l})      &&= \Elist_{\mathsf{term}}(\Eterm(s \cdot \bits{1001}, u), l)
\end{alignat*}

\noindent The decoder for terms is given below.  To simplify the definition we
use some pattern-matching syntax for inputs to decoders: for example the
argument $\bits{0101} \cdot s$ indicates that when the input is a string
beginning with $\bits{0101}$ the definition after the $=$ sign should be used
(and the remainder of the input is available in $s$ there).  If the input is not
long enough to permit the indicated decomposition then the decoder fails.  The
decoder also fails if the input begins with a prefix which is not listed; that
does not happen here, but does in some later decoders.

\begin{alignat*}{5}
  \Dterm(\bits{0000} \cdot s)  &= (s', x) &&\quad \text{if } \Dname(s) = (s', x) \\
  \Dterm(\bits{0001} \cdot s)  &= (s', \Delay{t})  &&\quad \text{if}\ \Dterm(s) = (s', t) \\
  \Dterm(\bits{0010} \cdot s)  &= (s'', \Lam{x}{t})  &&\quad \text{if}\ \Dbinder(s) = (s', x)
                                                           &&\ \text{and}\ \Dterm(s') = (s'', t) \\
  \Dterm(\bits{0011} \cdot s)  &= (s'', \Apply{t_1}{t_2}) &&\quad \text{if}\ \Dterm(s) = (s', t_1)
                                                  &&\ \text{and}\ \Dterm(s') = (s'', t_2) \\
  \Dterm(\bits{0100} \cdot s)  &= (s'', \Const{tn}{c}) &&\quad \text{if}\ \Dtype(s) = (s', \tn)
                                                           &&\ \text{and}\ \dConstant{\tn}(s') =(s'', c) \\
  \Dterm(\bits{0101} \cdot s)  &= (s', \Force{t})  &&\quad \text{if}\ \Dterm(s) = (s', t) \\
  \Dterm(\bits{0110} \cdot s)  &= (s, \Error)  && \\
  \Dterm(\bits{0111} \cdot s)  &= (s', b) &&\quad \text{if } \Dbuiltin(s) = (s', b) \\
  \Dterm(\bits{1000} \cdot s)  &= (s', \Constr{i}{l}) &&\quad \text{if } \D_{64}(s) = (s', i) &&\ \text{and}\ \Dlist_{\mathsf{term}}(s') = (s'', l)\\
  \Dterm(\bits{1001} \cdot s)  &= (s', \Kase{u}{l}) &&\quad \text{if } \Dterm(s) = (s', u) &&\ \text{and}\ \Dlist_{\mathsf{term}}(s') = (s'', l)
\end{alignat*}

\paragraph{NOTE.} The decoder $\Dterm$ should fail if we are decoding a program
with a version less than 1.1.0 and an input of the form $\bits{1000} \cdot s$ or
$\bits{1001} \cdot s$ is encountered.

\subsection{Built-in types}
Constants from built-in types are essentially encoded by emitting a sequence of
4-bit tags representing the constant's type and then emitting the encoding of
the constant itself.  However the encoding of types is somewhat complex because
it has to be able to deal with type operators such as $\ty{list}$ and
$\ty{pair}$.  The tags are given in Table~\ref{table:type-tags}: they include
tags for the basic types together with a tag for a type application operator.

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|}
  \hline
  \Strut
  Type & Binary  & Decimal \\
  \hline
  $\ty{integer}$                 & $\bits{0000}$ & 0  \\
  $\ty{bytestring}$              & $\bits{0001}$ & 1  \\
  $\ty{string}$                  & $\bits{0010}$ & 2  \\
  $\ty{unit}$                    & $\bits{0011}$ & 3  \\
  $\ty{bool}$                    & $\bits{0100}$ & 4  \\
  $\ty{list}$                    & $\bits{0101}$ & 5  \\
  $\ty{pair}$                    & $\bits{0110}$ & 6  \\
  (type application)             & $\bits{0111}$ & 7  \\
  $\ty{data}$                    & $\bits{1000}$ & 8  \\
  $\ty{bls12\_381\_G1\_element}$ & $\bits{1001}$ & 9  \\
  $\ty{bls12\_381\_G2\_element}$ & $\bits{1010}$ & 10 \\
  $\ty{bls12\_381\_MlResult}$    & $\bits{1011}$ & 11 \\
  \hline
\end{tabular}
\caption{Type tags}
\label{table:type-tags}
\end{table}


\newcommand\etype{\mathsf{e}_{\mathsf{type}}}
\newcommand\dtype{\mathsf{d}_{\mathsf{type}}}

\noindent We define auxiliary functions $\etype: \Uni \rightarrow \N^*$ and
$\dtype: \N^* \rightharpoonup \N^* \times \Uni$ ($\dtype$ is partial and $\Uni$
denotes the universe of types defined in Sections~\ref{sec:default-builtins-1},
\ref{sec:default-builtins-2}, and~\ref{sec:default-builtins-3}).

\begin{alignat*}{2}
  &\etype(\ty{integer})      &&= [0]  \\
  &\etype(\ty{bytestring})   &&= [1]  \\
  &\etype(\ty{string})       &&= [2]  \\
  &\etype(\ty{unit})         &&= [3]  \\
  &\etype(\ty{bool})         &&= [4]  \\
  &\etype(\listOf{t})        &&= [7,5] \cdot \etype(t) \\
  &\etype(\pairOf{t_1}{t_2}) &&= [7,7,6] \cdot \etype(t_1) \cdot \etype(t_2)\\
  &\etype(\ty{data})         &&= [8].
\end{alignat*}

\begin{alignat*}{3}
 &\dtype(0 \cdot l) &&= (l, \ty{integer})    \\
 &\dtype(1 \cdot l) &&= (l, \ty{bytestring}) \\
 &\dtype(2 \cdot l) &&= (l, \ty{string}))    \\
 &\dtype(3 \cdot l) &&= (l, \ty{unit})       \\
 &\dtype(4 \cdot l) &&= (l, \ty{bool})       \\
 &\dtype([7,5] \cdot l) &&= (l', \listOf{t}) &&\quad \text{if $\dtype(l) = (l', t)$}\\
 &\dtype([7,7,6] \cdot l) &&= (l'', \pairOf{t_1}{t_2}) 
  &&\ \begin{cases}
      \text{if} & \dtype(l) = (l', t_1)\\
      \text{and} & \dtype(l') = (l'', t_2)
    \end{cases}\\
  &\dtype(8 \cdot l) &&= (l, \ty{data}).
\end{alignat*}

\noindent The encoder and decoder for types is obtained by combining $\etype$
and $\dtype$ with $\Elist_4$ and $\Dlist_4$, the encoder and decoder for lists
of four-bit integers (see Section~\ref{sec:basic-flat-encodings}).

$$
\Etype(s,t) = \Elist_4 (s, \etype(t))
$$

$$
\Dtype(s) = (s', t) \quad \text{if $\Dlist_4(s) = (s', l)$ and $\dtype(l) = ([], t)$}.
$$

\subsection{Constants}
Values of built-in types can mostly be encoded quite simply by using encoders
already defined.  Note that the unit value \texttt{(con unit ())} does not have
an explicit encoding: the type has only one possible value, so there is no need
to use any space to serialise it.

The $\ty{data}$ type is encoded by converting to a bytestring using the CBOR
encoder $\eData$ described in Appendix~\ref{appendix:data-cbor-encoding} and
then using $\E_{\B^*}$.  The decoding process is the opposite of this: a
bytestring is obtained using $\D_{\B^*}$ and this is then decoded from CBOR
using $\dData$ to obtain a $\ty{data}$ object.

The $\ty{bls12\_381\_G1\_element}$ and $\ty{bls12\_381\_G2\_element}$ types are
serialised by converting to byestrings using the $\compress_{G_1}$ and
$\compress_{G_2}$ functions defined in
Section~\ref{sec:bls-builtins-4}, and decoding is similarly performed
via bytestrings using the $\uncompress$ functions.  \textbf{We do not provide
serialisation and deserialisation for constants of the
$\ty{bls12\_381\_mlresult}$ type}; we have specified a tag for this type, but if
that tag is encountered during deserialisation then deserialisation fails and
any subsequent input is ignored.


\begin{alignat*}{2}
  & \Econstant{\ty{integer}}(s,n)                  &&= \E_{\Z}(s, n) \\
  & \Econstant{\ty{bytestring}}(s,a)               &&= \E_{\B^*}(s, a) \\
  & \Econstant{\ty{string}}(s,t)                   &&= \E_{\U^*}(s, t) \\
  & \Econstant{\ty{unit}}(s,c)                     &&= s  \\
  & \Econstant{\ty{bool}}(s, \texttt{False})       &&= s \cdot \bits{0}\\
  & \Econstant{\ty{bool}}(s, \texttt{True})        &&= s \cdot \bits{1}\\
  & \Econstant{\listOf{\tn}}(s,l)                  &&= \Elist^{\tn}_{\mathsf{constant}}(s, l) \\
  & \Econstant{\pairOf{\tn_1}{\tn_2}}(s,(c_1,c_2))  &&= \Econstant{\tn_2}(\Econstant{\tn_1}(s, c_1), c_2)\\
  & \Econstant{\ty{data}}(s,d)                     &&= \E_{\B^*}(s, \eData(d))\\
  & \Econstant{\ty{bls12\_381\_G1\_element}}(s,e)  &&= \E_{\B^*}(s, \compress_{G_1}(e))\\
  & \Econstant{\ty{bls12\_381\_G2\_element}}(s,e)  &&= \E_{\B^*}(s, \compress_{G_2}(e)).
\end{alignat*}

\begin{alignat*}{3}
  &\dConstant{\ty{integer}}(s)              &&= \D_{\Z}(s) \\
  &\dConstant{\ty{bytestring}}(s)           &&= \D_{\B^*}(s) \\
  &\dConstant{\ty{string}}(s)               &&= \D_{\U^*}(s) \\
  &\dConstant{\ty{unit}}(s)                 &&= s  \\
  &\dConstant{\ty{bool}}(\bits{0} \cdot s)  &&= (s, \texttt{False}) \\
  &\dConstant{\ty{bool}}(\bits{1} \cdot s)  &&= (s, \texttt{True}) \\
  &\dConstant{\listOf{\tn}}(s)              &&= \Dlist^{\tn}_{\mathsf{constant}}(s, l) \\
  &\dConstant{\pairOf{\tn_1}{\tn_2}}(s)     &&= (s'', (c_1, c_2)) 
  && \begin{cases}
       \text{if}  & \dConstant{\tn_1}(s) = (s', c_1) \\
       \text{and} & \dConstant{\tn_2}(s') = (s'', c_2)
     \end{cases}\\
  &\dConstant{\ty{data}}(s)                  &&= (s', d) &&
                                           \text{if $\D_{\B*}(s) = (s', t)$
                                            and $\dData(t) = (t', d)$ for some $t'$}\\
  & \dConstant{\ty{bls12\_381\_G1\_element}}(s)  &&= (s',e) && \text{if $\D_{\B^*}(s) = (s',b)$ and $\uncompress_{G_1}(b)=e$}\\
  & \dConstant{\ty{bls12\_381\_G2\_element}}(s)  &&= (s',e) && \text{if $\D_{\B^*}(s) = (s',b)$ and $\uncompress_{G_2}(b)=e$}.
\end{alignat*}

\subsection{Built-in functions}
Built-in functions are represented by seven-bit integer tags and encoded and
decoded using $\E_7$ and $\D_7$.  The tags are specified in
Tables~\ref{table:builtin-tags-V1}, \ref{table:builtin-tags-V2}, and~\ref{table:builtin-tags-V3}.  We
assume that there are (partial) functions $\Tag$ and $\unTag$ which convert back
and forth between builtin names and their tags.

\begin{alignat*}{2}
  & \Ebuiltin(s,b) &&= \E_7(s, \Tag(b))\\
  & \Dbuiltin(s)   &&= (s', \unTag(n)) \quad \text{if $\D_7(s) = (s', n)$}.\\
\end{alignat*}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c||l|c|c|}
  \hline
  \Strut
  Builtin & Binary & Decimal & Builtin & Binary & Decimal \\
  \hline
   \TT{addInteger}               &    $\bits{0000000}$  &   0    &        \TT{ifThenElse}               &    $\bits{0011010}$  &  26 \\
   \TT{subtractInteger}          &    $\bits{0000001}$  &   1    &        \TT{chooseUnit}               &    $\bits{0011011}$  &  27 \\
   \TT{multiplyInteger}          &    $\bits{0000010}$  &   2    &        \TT{trace}                    &    $\bits{0011100}$  &  28 \\
   \TT{divideInteger}            &    $\bits{0000011}$  &   3    &        \TT{fstPair}                  &    $\bits{0011101}$  &  29 \\
   \TT{quotientInteger}          &    $\bits{0000100}$  &   4    &        \TT{sndPair}                  &    $\bits{0011110}$  &  30 \\
   \TT{remainderInteger}         &    $\bits{0000101}$  &   5    &        \TT{chooseList}               &    $\bits{0011111}$  &  31 \\
   \TT{modInteger}               &    $\bits{0000110}$  &   6    &        \TT{mkCons}                   &    $\bits{0100000}$  &  32 \\
   \TT{equalsInteger}            &    $\bits{0000111}$  &   7    &        \TT{headList}                 &    $\bits{0100001}$  &  33 \\
   \TT{lessThanInteger}          &    $\bits{0001000}$  &   8    &        \TT{tailList}                 &    $\bits{0100010}$  &  34 \\
   \TT{lessThanEqualsInteger}    &    $\bits{0001001}$  &   9    &        \TT{nullList}                 &    $\bits{0100011}$  &  35 \\
   \TT{appendByteString}         &    $\bits{0001010}$  &  10    &        \TT{chooseData}               &    $\bits{0100100}$  &  36 \\
   \TT{consByteString}           &    $\bits{0001011}$  &  11    &        \TT{constrData}               &    $\bits{0100101}$  &  37 \\
   \TT{sliceByteString}          &    $\bits{0001100}$  &  12    &        \TT{mapData}                  &    $\bits{0100110}$  &  38 \\
   \TT{lengthOfByteString}       &    $\bits{0001101}$  &  13    &        \TT{listData}                 &    $\bits{0100111}$  &  39 \\
   \TT{indexByteString}          &    $\bits{0001110}$  &  14    &        \TT{iData}                    &    $\bits{0101000}$  &  40 \\
   \TT{equalsByteString}         &    $\bits{0001111}$  &  15    &        \TT{bData}                    &    $\bits{0101001}$  &  41 \\
   \TT{lessThanByteString}       &    $\bits{0010000}$  &  16    &        \TT{unConstrData}             &    $\bits{0101010}$  &  42 \\
   \TT{lessThanEqualsByteString} &    $\bits{0010001}$  &  17    &        \TT{unMapData}                &    $\bits{0101011}$  &  43 \\
   \TT{sha2\_256}                &    $\bits{0010010}$  &  18    &        \TT{unListData}               &    $\bits{0101100}$  &  44 \\
   \TT{sha3\_256}                &    $\bits{0010011}$  &  19    &        \TT{unIData}                  &    $\bits{0101101}$  &  45 \\       
   \TT{blake2b\_256}             &    $\bits{0010100}$  &  20    &        \TT{unBData}                  &    $\bits{0101110}$  &  46 \\       
   \TT{verifyEd25519Signature}   &    $\bits{0010101}$  &  21    &        \TT{equalsData}               &    $\bits{0101111}$  &  47 \\       
   \TT{appendString}             &    $\bits{0010110}$  &  22    &        \TT{mkPairData}               &    $\bits{0110000}$  &  48 \\
   \TT{equalsString}             &    $\bits{0010111}$  &  23    &        \TT{mkNilData}                &    $\bits{0110001}$  &  49 \\
   \TT{encodeUtf8}               &    $\bits{0011000}$  &  24    &        \TT{mkNilPairData}            &    $\bits{0110010}$  &  50 \\
   \TT{decodeUtf8}               &    $\bits{0011001}$  &  25    & & & \\
\hline
\end{tabular}
\caption{Tags for PlutusV1 builtins}
\label{table:builtin-tags-V1}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|}
  \hline
  \Strut
  Builtin & Binary & Decimal\\
  \hline
 \TT{serialiseData}                   & $\bits{0110011}$  & 51 \\
 \TT{verifyEcdsaSecp256k1Signature}   & $\bits{0110100}$  & 52 \\
 \TT{verifySchnorrSecp256k1Signature} & $\bits{0110101}$  & 53 \\
\hline
\end{tabular}
\caption{Extra tags for PlutusV2 builtins}
\label{table:builtin-tags-V2}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|}
  \hline
  \Strut
  Builtin & Binary & Decimal\\
  \hline
    \TT{bls12\_381\_G1\_add}         & $\bits{0110110}$  & 54 \\
    \TT{bls12\_381\_G1\_neg}         & $\bits{0110111}$  & 55 \\
    \TT{bls12\_381\_G1\_scalarMul}   & $\bits{0111000}$  & 56 \\
    \TT{bls12\_381\_G1\_equal}       & $\bits{0111001}$  & 57 \\
    \TT{bls12\_381\_G1\_hashToGroup} & $\bits{0111010}$  & 58 \\
    \TT{bls12\_381\_G1\_compress}    & $\bits{0111011}$  & 59 \\
    \TT{bls12\_381\_G1\_uncompress}  & $\bits{0111100}$  & 60 \\
    \TT{bls12\_381\_G2\_add}         & $\bits{0111101}$  & 61 \\
    \TT{bls12\_381\_G2\_neg}         & $\bits{0111110}$  & 62 \\
    \TT{bls12\_381\_G2\_scalarMul}   & $\bits{0111111}$  & 63 \\
    \TT{bls12\_381\_G2\_equal}       & $\bits{1000000}$  & 64 \\
    \TT{bls12\_381\_G2\_hashToGroup} & $\bits{1000001}$  & 65 \\
    \TT{bls12\_381\_G2\_compress}    & $\bits{1000010}$  & 66 \\
    \TT{bls12\_381\_G2\_uncompress}  & $\bits{1000011}$  & 67 \\
    \TT{bls12\_381\_millerLoop}      & $\bits{1000100}$  & 68 \\
    \TT{bls12\_381\_mulMlResult}     & $\bits{1000101}$  & 69 \\
    \TT{bls12\_381\_finalVerify}     & $\bits{1000110}$  & 70 \\
    \TT{keccak\_256}                 & $\bits{1000111}$  & 71 \\
    \TT{blake2b\_224}                & $\bits{1001000}$  & 72 \\
\hline
\end{tabular}
\caption{Extra tags for future builtins}
\label{table:builtin-tags-V3}
\end{table}



\subsection{Variable names}
Variable names are encoded and decoded using the $\Ename$ and $\Dname$
functions, and variables bound in \texttt{lam} expressions are encoded and
decoded by the $\Ebinder$ and $\Dbinder$ functions.  

\paragraph{De Bruijn indices.}
We use serialised de Bruijn-indexed terms for script transmission because
this makes serialised scripts significantly smaller.  Recall from
Section~\ref{sec:grammar-notes} that when we want to use our syntax with de
Bruijn indices we replace names with natural numbers and the bound variable in a
\texttt{lam} expression with 0.  During serialisation the zero is ignored, and
during deserialisation no input is consumed and the index 0 is always returned:

$$
\Ebinder(s, n) = s
$$
$$
\Dbinder(s) = 0.
$$

\noindent For variables we always use indices which are greater than zero, and our
encoder and decoder for names are given by
$$
\Ename = \E_{\N}
$$
and
$$
\Dname (s) = (s', n) \quad \text{if $\D_{\N} = (s', n)$ and $n>0$}.
$$


\paragraph{Other types of name.}
One can serialise code involving other types of name by providing suitable
encoders and decoders for name.  For example, for textual names one could use
$\Ebinder = \Ename = \E_{\U^*}$ and $\Dbinder = \Dname = \D_{\U^*}$.  Depending
on the method used to represent variable names it may also be necessary to check
during deserialisation the more general requirement that variables are
well-scoped, but this problem will not arise if de Bruijn indices are used.

\section{Cardano-specific serialisation issues}
\label{sec:cardano-issues}
\subsection{Scope checking}
To execute a Plutus Core program on the blockchain it will be necessary to
deserialise it to some in-memory representation, and during or immediately after
deserialisation it should be checked that the body of the program is a closed
term (see the requirement in Section~\ref{sec:grammar-notes}); if this is not
the case then evaluation should fail immediately.

\subsection{CBOR wrapping}
Plutus Core programs are not stored on the Cardano chain directly as
\texttt{flat} bytestrings; for consistency with other objects used on the chain,
the \texttt{flat} bytestrings are in fact wrapped in a CBOR encoding.  This
should not concern most users, but we mention it here to avoid possible
confusion.


%% We could accept bytestrings split into blocks where the initial ones are all
%% exactly 64 bytes long: then the data would be interrupted by 0x40 ('@') every
%% 64 bytes.

\section{Example}
Consider the program
\begin{verbatim}
(program 5.0.2
 [
  [(builtin indexByteString)(con bytestring #1a5f783625ee8c)]
  (con integer 54321)
 ])
\end{verbatim}

\noindent Suppose this is stored in \texttt{index.uplc}.  We can convert it to
\texttt{flat} by running
\begin{verbatim}
$ cabal run exec uplc convert -- -i index.uplc --of flat -o index.flat
\end{verbatim}

\noindent The serialised program looks like this:

{\small
\begin{verbatim}
$ xxd -b index.flat
00000000: 00000101 00000000 00000010 00110011 01110001 11001001  ...3q.
00000006: 00010001 00000111 00011010 01011111 01111000 00110110  ..._x6
0000000c: 00100101 11101110 10001100 00000000 01001000 00111000  %...H8
00000012: 10110100 00000001 10000001
\end{verbatim}
}

\noindent Figure~\ref{fig:index-bytestring-example} shows how this encodes the
original program.  Sequences of bits are followed by explanatory comments and
lines beginning with \texttt{\#} provide further commentary on preceding bit
sequences.

\newcommand{\arrow}{$\rightarrow$}

% The \small below is just to make everything fit onto one page.  We could maybe
% remove it if the page breaks change.
\begin{figure}[H]
  \centering
  {\small  
        \begin{Verbatim}[commandchars=\\\{\}]
             00000101 : \textrm{Final integer chunk: \texttt{0000101} \arrow 5}
             00000000 : \textrm{Final integer chunk: \texttt{0000000} \arrow 0}
             00000010 : \textrm{Final integer chunk: \texttt{0000000} \arrow 2}
                      \# \textrm{Version: 5.0.2}
             0011     : \textrm{Term tag 3: apply}
             0011     : \textrm{Term tag 3: apply}
             0111     : \textrm{Term tag 7: builtin}
             0001110  : \textrm{Builtin tag 14}
                      \# builtin indexByteString
             0100     : \textrm{Term tag 4: constant}
             1        : \textrm{Start of type tag list}
             0001     : \textrm{Type tag 1}
             0        : \textrm{End of list}
                      \# \textrm{Type tags: [1] \arrow \texttt{bytestring}}
             001      : \textrm{Padding before bytestring}
             00000111 : \textrm{Bytestring chunk size: 7}
             00011010 : 0x1a
             01011111 : 0x5f
             01111000 : 0x78
             00110110 : 0x36
             00100101 : 0x25
             11101110 : 0xee
             10001100 : 0x8c
             00000000 : \textrm{Bytestring chunk size: 0 (end of list of chunks)}
                      \# con bytestring \#1a5f783625ee8c
             0100     : \textrm{Term tag 4: constant}
             1        : \textrm{Start of type tag list}
             0000     : \textrm{Type tag 0}
             0        : \textrm{End of list}
                      \# \textrm{Type tags: [0] \arrow \texttt{integer}}
             11100010 : \textrm{Integer chunk \texttt{1100010} (least significant)}
             11010000 : \textrm{Integer chunk \texttt{1010000}}
             00000110 : \textrm{Final integer chunk \texttt{0000110} (most significant)}
                      \# 0000110 \(\cons\) 1010000 \(\cons\) 1100010 \textrm{\arrow 108642 decimal}
                      \# \textrm{Zigzag encoding: 108642/2 \arrow +54321}
                      \# con integer 54321
             000001   : \textrm{Padding}
        \end{Verbatim}
        }
      \caption{\texttt{flat} encoding of \texttt{index.uplc}}
      \label{fig:index-bytestring-example}
  \end{figure}

