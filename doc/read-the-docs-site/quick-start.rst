.. _quick_start:

Quick Start
=================================

This guide gets you started on setting up the dev environment for a simple Cardano smart contract, with the on-chain validator written in Plutus Tx.
There are several other options for writing on-chain validators, such as `Aiken <https://aiken-lang.org/>`_ and `OpShin <https://github.com/OpShin/opshin>`_, and you can refer to their respective documentation for how to use them.

If you have any questions regarding this guide, open an issue in the `Plutus issue tracker <https://github.com/input-output-hk/plutus/issues>`_.

Writing the On-Chain Validator
-----------------------------------------------------------------

Prerequisites
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

GHC and Cabal should be installed in order to follow this guide.
Plutus Tx currently supports GHC v9.2.x and v9.6.x.
Cabal v3.8+ is recommended.

Additionally, some C libraries will need to be installed.
Plutus Tx depends on `cardano-base <https://github.com/input-output-hk/cardano-base>`_, which in turn depends on a few cryptographic C libraries, including ``libblst``, ``libsecp256k1``, and ``libsodium``.
Cabal is not designed to manage C dependencies, so you need to either install them yourself, or manage them using another tool (such as Nix).

If you are not using Nix, follow the instructions in the cardano-base repository to install these libraries (or install them in your own way if you like).

If you are, you can use plutus repository's dev shell: ::

  nix develop github:input-output-hk/plutus

The dev shell comes with not only the required C libraries, but also GHC and Cabal.

Create a New Cabal Package
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

First, make a new directory ``plutus-quickstart``: ::

  mkdir plutus-quickstart && cd $_

Then, create a new Cabal package that builds a library, using default settings: ::

  cabal init --lib --non-interactive

Declare Plutus Tx Dependencies
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Next, declare the following packages as dependencies: ``plutus-core``, ``plutus-ledger-api``, ``plutus-tx``, and ``plutus-tx-plugin``.
These packages aren't on Hackage (the default repository Cabal looks for packages from), but on the `CHaP <https://github.com/input-output-hk/cardano-haskell-packages>`_ repository.
We need to tell Cabal to look for packages from CHaP (in addition to Hackage).
To do so, make a ``cabal.project`` file, and follow the instructions in the CHaP repository to make Cabal aware of CHaP.
Then, add the following to your ``cabal.project``: ::

  packages:
    ./plutus-quickstart.cabal

Finally, add the aformentioned packages in the ``build-depends`` field in ``plutus-quickstart.cabal``: ::

  build-depends:
    , base
    , plutus-core
    , plutus-ledger-api
    , plutus-tx
    , plutus-tx-plugin

At this point, you should be able to build your project: ``cabal build plutus-quickstart`` should succeed.

Write the Validator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now we are ready to write the on-chain validator using Plutus Tx.
We showed and explained an auction validator in :ref:`simple_example`, and we'll reuse the same validator here.
Make a file named ``AuctionValidator.hs``, and copy the content over from `here <https://github.com/input-output-hk/plutus/blob/master/doc/read-the-docs-site/tutorials/AuctionValidator.hs>`_.
Add the following flag at the top of the file: ::

  {-# OPTIONS_GHC -fplugin-opt PlutusTx.Plugin:dump-uplc #-}

With this option, the compiled validator script - an Untyped Plutus Core (UPLC) program, will be written to a file.

Note that ``AuctionValidator.hs`` imports ``ScriptContext`` from ``PlutusLedgerApi.V2``, which means that the script created from it will be a PlutusV2 script.
PlutusV2 only supports Plutus Core v1.0.0 (currently the highest and default version is v1.1.0), which is why the ``target-version=1.0.0`` flag is needed.

By the way, the default module generated by ``cabal init``, i.e., ``MyLib.hs``, can be deleted since it is no longer needed.
In ``plutus-quickstart.cabal``, replace ``MyLib`` with ``AuctionValidator``.

Now, build it: ::

  cabal build plutus-quickstart

This should succeed, and write the serialised validator to a file, whose name is similar to ``AuctionValidator.uplc147232-0.flat`` (the digits are random and yours may differ).
Congratulations - you've successfully created a Plutus validator script.

Creating and Submitting Transactions using an Off-Chain Framework
-----------------------------------------------------------------

Once you have the validator, you can proceed with deploying and interacting with a smart contract that uses this validator.
To do so, you'll need the ability to perform operations like the following:

* Generating key pairs
* Quering available UTXOs that satisfy certain criteria and can be used as the input of a transaction
* Building transactions and calculating transaction fees
* Signing and submitting transactions

These can be done using low-level Cardano CLI commands or the Cardano API library functions.
A better way is to use high-level off-chain libraries and frameworks, such as:

* `Lucid <https://lucid.spacebudz.io/>`_, a JavaScript off-chain library for Cardano
* `Kuber <https://github.com/dQuadrant/kuber>`_, which provides a Haskell library and a JSON API for working with Cardano transactions
* `cardano-transaction-lib <https://github.com/Plutonomicon/cardano-transaction-lib>`_, a PureScript library for building Cardano transactions

These frameworks either consume compiled validators in serialised form (such as the one you just made), or depend on the Plutus Tx library and compile the on-chain code from source.
Refer to their respective documentation for more details about how to use them.

A good way to quickly deploy and test a smart contract is to do it on a public testnet, such as Preview.
Generate a key pair, go to the `faucet <https://docs.cardano.org/cardano-testnet/tools/faucet/>`_ for the testnet you are using to request some funds, submit a transaction to lock the funds in your smart contract validator script, and off you go to have all the fun with it.
Read :ref:`simple_example`, section *Life cycle of the auction smart contract*, if you need to understand how one can submit transactions to interact with the auction smart contract.

Interfacing between Plutus Tx and Off-Chain Frameworks
-----------------------------------------------------------------

At this time, interfacing between Plutus Tx and most off-chain frameworks (especially non-Haskell ones) isn't very well supported.
What this means is that you may run into inconveniences like these:

* The compiled valiator obtained via ``dump-uplc`` is a ``flat`` file, but some off-chain frameworks expect a Hex string, which must be obtained by first encoding the data in the ``flat`` file using CBOR, then Hex encode the CBOR data.
* The redeemer type is defined in Haskell (e.g., ``AuctionRedeemer`` in ``AuctionValidator.hs``), but needs to be redefined in another language when using a non-Haksell off-chain framework.
  For instance, when using Lucid, you'll need to define an object in JavaScript corresponding to ``AuctionRedeemer``, in order to construct your redeemer.

These inconveniences will be addressed once Plutus contract blueprint, as outlined in `CIP-0057 <https://developers.cardano.org/docs/governance/cardano-improvement-proposals/cip-0057/>`_, is adopted and implemented by us as well as the off-chain frameworks.
