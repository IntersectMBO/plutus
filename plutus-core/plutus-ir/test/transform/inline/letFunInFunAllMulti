{- 
The unconditional inlining optimization should not inline g nor idFun nor k (multiple occurrence).
k is fully applied so the optimization that does call site inlining of fully applied function should
inline k.

let 
  idFun :: Integer -> Integer
  idFun x = x
  g :: (Integer -> Integer) -> (Integer -> Integer)
  g y = idFun
  k :: (Integer -> Integer) -> (Integer -> Integer)
  k = g
in k idFun
 -}

(let
    (nonrec)
    (termbind
      (strict)
      (vardecl idFun (fun (con integer) (con integer)))
      (lam x (con integer) x)
    )
    (let
    (nonrec)
      (termbind
        (strict)
        (vardecl
          g
          (fun
            (fun (con integer) (con integer)) (fun (con integer) (con integer))
          )
        )
        (lam y (fun (con integer) (con integer)) idFun)
      )
      (let
      (nonrec)
        (termbind
          (strict)
          (vardecl
            k
            (fun
              (fun (con integer) (con integer)) (fun (con integer) (con integer))
            )
          )
          g
        )
        [ k idFun ]
      )
    )
)