{- 
funApp and idApp get inlined because they only occur once.
k should not get inlined by the unconditional inline optimization because it occurs more
than once. It should get inlined by the optimization that inlines fully applied functions because
it is fully applied.
k being inlined verifies that an over-applied function still gets inline.

let 
    idFun :: Integer -> Integer
    idFun y = y
    funApp :: (Integer -> Integer) -> (Integer -> Integer)
    funApp x = idFun
    k :: (Integer -> Integer) -> (Integer -> Integer)
    k = funApp
in k k 6
-}

(let
    (nonrec)
    (termbind
      (strict)
      (vardecl idFun (fun (con integer) (con integer)))
      (lam y (con integer) y)
    )
    (let
      (nonrec)
      (termbind
        (strict)
        (vardecl
          funApp
          (fun
            (fun (con integer) (con integer)) (fun (con integer) (con integer))
          )
        )
        (lam
          x
          (fun (con integer) (con integer))
          idFun
        )
      )
      (let
      (nonrec)
        (termbind
          (strict)
          (vardecl
            k
            (fun
              (fun (con integer) (con integer)) (fun (con integer) (con integer))
            )
          )
          funApp
        )
        
        [ [ k k ] (con integer 6) ]
      )
    )
)