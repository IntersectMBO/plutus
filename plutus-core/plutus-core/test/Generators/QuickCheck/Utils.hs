{-# LANGUAGE TypeApplications #-}

module Generators.QuickCheck.Utils where

import PlutusCore.Generators.QuickCheck.Utils

import Data.Coerce
import Test.Tasty
import Test.Tasty.QuickCheck

-- | Test that both 'multiSplit1' and 'multiSplit' produce a list such that 'concat'ing it gives
-- back the input.
test_multiSplitSound :: TestTree
test_multiSplitSound =
    testGroup "soundness" $ do
        (name, split) <-
            [ ("multiSplit1", coerce $ multiSplit1 @Int)
            , ("multiSplit", multiSplit 0.1)
            ]
        pure . testProperty name $ \(xs :: [Int]) ->
            withMaxSuccess 10000 . forAll (split xs) $ \aSplit ->
                xs === concat aSplit

-- | Show the distribution of lists generated by 'multiSplit' for a list of the given length.
test_listDistribution :: Int -> ([()] -> Gen [[()]]) -> Int -> TestTree
test_listDistribution numRuns split n =
    testProperty ("for a list of length " ++ show n) $
        withMaxSuccess numRuns . forAll (split $ replicate n ()) $ \aSplit ->
            label (show $ map length aSplit) True

test_multiSplitDistribution :: TestTree
test_multiSplitDistribution =
    testGroup "distribution of values generated by"
        [ testGroup "multiSplit1"
            [ test_listDistribution 10000 (coerce $ multiSplit1 @()) 1
            , test_listDistribution 10000 (coerce $ multiSplit1 @()) 2
            , test_listDistribution 10000 (coerce $ multiSplit1 @()) 3
            , test_listDistribution 10000 (coerce $ multiSplit1 @()) 4
            , test_listDistribution 10000 (coerce $ multiSplit1 @()) 5
            ]
        , testGroup "multiSplit"
            [ test_listDistribution 1000 (multiSplit 0.1) 1
            , test_listDistribution 1000 (multiSplit 0.05) 2
            , test_listDistribution 1000 (multiSplit 0.01) 3
            ]
        ]

test_utils :: TestTree
test_utils = testGroup "utils"
    [ test_multiSplitSound
    , test_multiSplitDistribution
    ]
