module Benchmarks.Values (
    makeBenchmarks,
) where

import Prelude

import Common

import PlutusCore (DefaultFun (InsertCoin, LookupCoin, UnValueData, ValueContains, ValueData))
import PlutusCore.Value (Value)
import PlutusCore.Value qualified as Value

import Control.Monad.Trans.Class (lift)
import Control.Monad.Trans.State.Strict (State, StateT, evalState, gets, modify)
import Criterion.Main (Benchmark)
import Data.ByteString (ByteString)
import Data.ByteString qualified as BS
import Data.Text qualified as Text
import Data.Text.Encoding (encodeUtf8)
import Data.Word (Word8)
import System.Random.Stateful (StateGenM, StatefulGen, StdGen, UniformRange (uniformRM),
                               runStateGenT_, uniformByteStringM)

makeBenchmarks :: StdGen -> [Benchmark]
makeBenchmarks gen =
    [ benchInsertCoin gen
    -- , benchUnionValue gen
    ]

newtype PolicyId = PolicyId ByteString
newtype TokenName = TokenName ByteString
newtype Amount = Amount Integer
type Counter = Integer

data GenState = GenState
    { policyIdCounter  :: Counter
    , tokenNameCounter :: Counter
    }

type BenchState = StateT StdGen (State GenState)

-- | An insertCoin benchmark is a concrete set of arguments we apply to the
-- InsertCoin builtin function to measure its runtime cost.
data InsertCoinBenchmark = InsertCoinBenchmark
    { icPolicyId  :: PolicyId
    , icTokenName :: TokenName
    , icAmount    :: Amount
    , icValue     :: Value
    }

icToRawTuple :: InsertCoinBenchmark -> (ByteString, ByteString, Integer, Value)
icToRawTuple (InsertCoinBenchmark (PolicyId p) (TokenName t) (Amount a) v) = (p, t, a, v)

benchInsertCoin :: StdGen -> Benchmark
benchInsertCoin gen =
    createFourTermBuiltinBenchElementwiseWithWrappers
        (id, id, id, id) -- TODO: use proper wrappers
        InsertCoin
        []
        (icToRawTuple <$> insertCoinBenchGen gen)

-- | Generate a set of benchmarks for the InsertCoin builtin function.
-- It includes the following scenarios:
--   1. Inserting into an empty Value.
--   2. Inserting a new TokenName into an existing PolicyId. Randomly extracting a PolicyId from the Value.
--   3. Inserting into an existing TokenName. Randomly extracting a (PolicyId, TokenName) pair from the Value.
--   4. Inserting a new PolicyId.
--   5. Deleting a TokenName by inserting a 0 amount. Randomly extracting a (PolicyId, TokenName) pair from the Value.
--   6. Deleting a PolicyId by inserting a 0 amount into its last TokenName. Should generate a Value with multiple such PolicyIds, and randomly picking which PolicyId to delete.
-- We're interested in the worst case performance, so we'll use the largest key values possible.
-- We should also run randomized benchmarks, where we insert random values into random Values.
-- We actually want to see how the performance scales with the size of the Value, so we should generate Values of varying sizes.
-- We want to make sure we are also hitting the worst case scenarios and various edge cases.
insertCoinBenchGen
    :: StdGen
    -> [InsertCoinBenchmark]
insertCoinBenchGen g = flip evalState (GenState 0 0) $ runStateGenT_ g $ \gen -> do
    policyId <- newPolicyId gen
    tokenName <- newTokenName gen
    amount <- uniformAmount gen
    let emptyValueBench = InsertCoinBenchmark policyId tokenName amount Value.empty
    pure [emptyValueBench]

-- | Generate a unique PolicyId on a uniform distribution. Note that the size of the
-- generated bytestring is going to be larger than Value.maxKeyLen, because we
-- append a counter integer to ensure uniqueness. This is acceptable for benchmarking
-- purposes, as we're interested in the worst-case performance.
newPolicyId :: StateGenM StdGen -> BenchState PolicyId
newPolicyId gen = do
    bs <- uniformByteStringM Value.maxKeyLen gen
    c <- lift $ gets policyIdCounter
    let newbs = BS.append bs (encodeUtf8 . Text.pack . show $ c)
    lift $ modify $ \s -> s { policyIdCounter = c + 1 }
    pure $ PolicyId newbs

-- | Generate a unique TokenName on a uniform distribution. Note that the size of the
-- generated bytestring is going to be larger than Value.maxKeyLen, because we
-- append a counter integer to ensure uniqueness. This is acceptable for benchmarking
-- purposes, as we're interested in the worst-case performance.
-- Actually, this wouldn't be acceptable if we were to measure based on the size of the
-- keys, because we would want to view how key size affects performance!
newTokenName :: StateGenM StdGen -> BenchState TokenName
newTokenName gen = do
    bs <- uniformByteStringM Value.maxKeyLen gen
    c <- lift $ gets tokenNameCounter
    let newbs = BS.append bs (encodeUtf8 . Text.pack . show $ c)
    lift $ modify $ \s -> s { tokenNameCounter = c + 1 }
    pure $ TokenName newbs

uniformAmount :: StateGenM StdGen -> BenchState Amount
uniformAmount gen =
    Amount <$> uniformRM (0, 100) gen -- TODO: tweak the range

newValue :: StateGenM StdGen -> BenchState Value
newValue gen = undefined
