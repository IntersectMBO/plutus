let
  data (Maybe :: * -> *) a | Maybe_match where
    Just : a -> Maybe a
    Nothing : Maybe a
  data Unit | Unit_match where
    Unit : Unit
  !traceError : all a. string -> a
    = /\a ->
        \(str : string) -> let !x : Unit = trace {Unit} str Unit in error {a}
in
\(d : data) ->
  case
    (all dead. unit)
    (let
      !tup : pair integer (list data)
        = unConstrData
            (headList
               {data}
               (tailList
                  {data}
                  (tailList
                     {data}
                     (sndPair {integer} {list data} (unConstrData d)))))
    in
    case
      (all dead. bool)
      (equalsInteger 1 (fstPair {integer} {list data} tup))
      [ (/\dead -> False)
      , (/\dead ->
           let
             !l : list data = sndPair {integer} {list data} tup
           in
           Maybe_match
             {data}
             (let
               !tup : pair integer (list data)
                 = unConstrData (headList {data} (tailList {data} l))
               !index : integer = fstPair {integer} {list data} tup
               !args : list data = sndPair {integer} {list data} tup
             in
             case
               (all dead. Maybe data)
               (equalsInteger 1 index)
               [ (/\dead ->
                    case
                      (all dead. Maybe data)
                      (equalsInteger 0 index)
                      [ (/\dead -> traceError {Maybe data} "PT1")
                      , (/\dead -> Just {data} (headList {data} args)) ]
                      {all dead. dead})
               , (/\dead -> Nothing {data}) ]
               {all dead. dead})
             {all dead. bool}
             (\(ds : data) -> /\dead -> True)
             (/\dead -> False)
             {all dead. dead}) ]
      {all dead. dead})
    [(/\dead -> traceError {unit} "PT5"), (/\dead -> ())]
    {all dead. dead}